R03- R语言进阶 杂项汇总


http://adv-r.had.co.nz/




========================================
怎么能休眠2s再执行？
----------------------------------------
1. 系统休眠几秒，用Sys.sleep 语句。
for(i in 1:3){
  print(i)
  Sys.sleep(2)
}




========================================
list完全可以作为R中的hash结构来使用
----------------------------------------
Lists are the only key-value mapping type provided in base R: there are no dictionaries or associative arrays.
list是R语言中包容性最强的数据对象，几乎可以容乃所有的其他数据类型。
我们可以在一个列表中储存不同的类型数据，还可以储存不同的长度数据，每一个插槽中都是一个向量（vector）。
但是基于list的hash效率很低。

更高效的是使用 environment 来定义key是字符串的hash变量。其中hash包和hashmap包就是这么做的，但是...
##########
1. 尝试 R 中的hash结构：hash包和hashmap包都报错
install.packages("hashmap")
library("hashmap")
help(hashmap)
#
mydict = hashmap( keys=c(1,2,3),values=c(10,20,30) )
#Error in (function (env, objName)  : 
#  argument to 'findVar' is not an environment
mydict[["a"]]
# 也找不到解决办法。。。



#
##########
2. 探索尝试 list 能否保存长度不同的数据类型?可以。

#创建
#初始化一个list
mydict1=list(a=c(1,2,3),h=c(0))
class(mydict1)

#后文每一步都需要检查效果，后文每句后面都省略该命令
#1.直接查看，或者2.用str查看list的数据结构
mydict1 
str(mydict1)


#拼接一个字符串作为key，并赋值和引用
mydict1[[paste0('c',1)]]=data.frame(a=c(1,2,3), b=c(10,20,30))
mydict1[[paste0('c',1)]] #引用

#增加一个key并赋值，在末尾
mydict1[['c']]=100

#修改：重新对value赋值
mydict1[['a']]=c(12,34)

#修改：在向量value中插入新元素
mydict1[["h"]]=c(mydict1[["h"]], 15)

#修改：#对这个key的value进行自增
mydict1[['c']]=mydict1[['c']]+2

#获得键列表
names(mydict1) 

#检测是否有某个键，可以用于hash的自增
key="c2"
key="c1"
if(key %in% names(mydict1)){
  print(mydict1[[key]])
}else{
  print("Not in")
}

#删除某个key
mydict1[["a"]]=NULL #好吧，a的键值对都被删除了


#可以用数字直接查找，说明是有序的，不是真正的hash结构
mydict1[[2]] 


refer:
1.R's Lists and its Detestable Dearth of Data-Structures
https://www.refsmmat.com/posts/2016-09-12-r-lists.html

2.Environments
http://adv-r.had.co.nz/Environments.html




========================================
R中拼接成的字符串做变量名，并赋值
----------------------------------------

assign( paste0("cell",1),100)
cell1

#但是怎么引用呢？
eval( 'a=paste0("cell",1)' ) #失败
#


========================================
如何用shiny部署R语言交互式网页小程序？
----------------------------------------

官方案例：http://shiny.rstudio.com/gallery/



1.安装
install.packages("shiny")


2.写代码
(1)看到网上大多给你扯ui.R+server.R，很少会提到global.R，笔者在自己实践的时候遇到的了global.R的使用问题，网上教程只能自己参悟了。

ui.R：搭框架，控件；
server.R：每个控件背后的算法代码；
global.R:server.R中，万一有很长的代码与调用很多其他packages就可以用global写一个函数集合，然后统一在server.R调用。

(2)在一个文件夹内写 ui.R 和 server.R。
格式如下：

# ui.R
library(shiny)
shinyUI(fluidPage(
	#
))
 
# server.R
library(shiny)
shinyServer(function(input, output) {
	#
})


(3)实例-界面：
# ui.R
library(shiny)

shinyUI(fluidPage(
  # Application title
  headerPanel("Hello Shiny!"),
  
  # 侧面控件 Sidebar with a slider input for number of observations
  sidebarPanel(
    #sliderInput是一个滑动的窗口。
    sliderInput("obs", 
                "Number of observations:", 
                min = 0, 
                max = 1000, 
                value = 500)
  ),
  
  # 右边 主控件(默认右边) Show a plot of the generated distribution
  mainPanel(
    plotOutput("distPlot")
  )

))


(4)实例-服务端：
# server.R
library(shiny)

shinyServer(function(input, output) {
  #数据来源都来自于ui.R，比如obs
  output$distPlot <- renderPlot({
    dist <- rnorm(input$obs)
    #server处理好的图才是返回给ui.R。譬如dist
    hist(dist)
  })
  
})



3.shiny的部署
runApp一下那个路径的文件夹就行了。

#
#####
#https://blog.csdn.net/sinat_26917383/article/details/53410370
library(shiny)
runApp("F://Temp/shiny")
#

refer
1. 中文教程：用R构建shiny应用程序：http://yanping.me/shiny-tutorial/#welcome
2. R powered web applications with Shiny (a tutorial and cheat sheet with 40 example apps) 
http://zevross.com/blog/2016/04/19/r-powered-web-applications-with-shiny-a-tutorial-and-cheat-sheet-with-40-example-apps/



========================================
画ROC曲线(ROCR包和pROC包)
----------------------------------------
AUC为ROC曲线下方的面积。一般AUC大于0.75就能够说明模型是比较合理的了。


1.
(1)library(ROCR)
data(ROCR.simple)
pred <- prediction(ROCR.simple$predictions, ROCR.simple$labels)
perf <- performance(pred,"tpr","fpr")
str(perf)

##AUC值,ROC曲线下面积为AUC，用来评价分类器的综合性能，该数值取0-1之间，越大越好。
#https://blog.csdn.net/Hellolijunshy/article/details/79991385
auc <- performance(pred,'auc');auc_value=auc@y.values[[1]]
auc_value=round(auc_value,2)
auc_value #0.84

plot(perf,colorize=TRUE,main=paste0('AUC=',auc_value))
abline(a=c(0,0),b=c(1,1),col="grey")


(2)#用ggplot2画图
plotdata=data.frame(
  x=unlist(perf@x.values),
  y=unlist(perf@y.values)
)
g=ggplot(plotdata, aes(x,y, color=x))+
  geom_path(size=1)+
  labs(x="False positive rate",y="True positive rate",title="ROC Curve")+
  scale_color_gradient(name="False positive rate", low="blue", high="red")+
  theme(plot.title=element_text(face="bold",size=10))
g
#



2.
library(pROC)
roc_curve=roc(pre_test$Y~probability)
str(roc_curve)
plot(1-roc_curve$specificities, roc_curve$sensitivities,type="o",
     xlab="1-specificities",ylab="sensitivities",main="ROC Curve")
abline(a=0,b=1,col="gray")
auc2=roc_curve$auc
text(0.5,0.4,paste("AUC: ", round(auc2, digits=2)), col="blue")
#


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

