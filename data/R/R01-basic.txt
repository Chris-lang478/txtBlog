R语言基础

程序设计的思想就是：复用==减少重复。
措施就是提取变化，封装不变。
实施方案就是：
	函数化 function
	面向对象化 OOP
	包 scope & environment
#


本文是基础部分，高级部分请参考
- OOP 专题: 函数 scope、environment
- R 原生可视化 专题: 
	表达式、数学公式与特殊符号
#




Rstudio环境配置：
1. Rstudio可以做到R版本的切换选择。
点击Tools->Global options,然后在R generals里选择R versions，就可以切换R版本。

2.





========================================
R语言资源: 从入门到精通
----------------------------------------
1.《R语言快速入门系列教程》
该手册博主编写，实战为主，包含大量生信相关案例。 
未公开发行，购买请发邮件咨询 jimmymall at 163 dot com


R官方文档： https://cran.r-project.org/manuals.html
R Tutorial：http://www.r-tutor.com/r-introduction/data-frame



2.R语言进阶教程
《高级R语言编程指南》, Hadley Wickham, 2016.
第一版 http://adv-r.had.co.nz/
第二版 https://adv-r.hadley.nz/





3.哈佛大学数据课程 http://tutorials.iq.harvard.edu
https://dss.iq.harvard.edu/blog/resources-learning-r

There are several excellent tutorials not listed on r-project.org. Some of these are listed below.
http://www.statmethods.net/
"Quick-R" aims to get you up and running in R quickly.

http://personality-project.org/r/r.guide.html
Notes on "Using R for psychological research".

http://r4ds.had.co.nz/
"R for Data Science" by R luminary Hadley Wickham. Includes a ggplot tutorial.

http://adv-r.had.co.nz/
Advanced R programming by Hadley Wickham.

http://rmarkdown.rstudio.com/lesson-1.html
A comprehensive RMarkdown tutorial.


4. 其他视频
https://www.imooc.com/learn/546


5.
HT Sequence Analysis with R and Bioconductor
http://manuals.bioinformatics.ucr.edu/home/ht-seq


Learn about Bioinformatics and Computational Tools for Biology
http://jura.wi.mit.edu/bio/education/





R语言镜像站
https://cran.rstudio.com/bin/windows/contrib/3.4/Cairo_1.5-9.zip
https://mirrors.tuna.tsinghua.edu.cn/bioconductor/packages/3.4/BiocViews.html#___Software
http://mirrors.ustc.edu.cn/bioc/3.4/BiocViews.html#___Software




========================================
运算符
----------------------------------------
1.
求助符：
	?mtcars #查看该数据集mtcats的帮助文档
	help()
	??ggplot2 #如果前两者不行
	find("fun") #得到名为“fun”函数所在的程序包，只在载入的包中找;
	args("fun") #得到名为“fun”函数的自变量列表.
	使用Rstudio时，光标停在函数上，按F1键
			按着ctrl，单击函数名，能打开函数的定义;
系统符号：
	> 命令或运算提示符
	+ 续行符
基本算数运算：
	加 +，	 减-，	乘*，	除/，	乘方^(或者**)，	求余数(取模)%%， x%/%y 整数除法
	57%%7 #1
	57%/%7 #8
赋值：
	= 或 <-
	->
	<<-
	assign(paste0("a",1),100) #a1=100
	get(paste0("a",1)) #100
逻辑运算符
	&&    与（优先计算第一个元素）
	||    或（优先计算第一个元素）

	&    与
	|    或
	!    非

	==   是否相等
	>    大于
	>=   大于等于
	<    小于
	<=    小于等于
三元表达式：类似js中的 a>b?a:b;
	ifelse(a>b, a, b)
数据类型查看
	class()
	str()
#


# &&和&的有什么差异呢？2个有优先性，在if中可以节省判断第二个的时间; 而在which()只能使用&。
a=1;if(4<3 & (a=a-1) ){print("No")};a #0
a=1;if(4<3 && (a=a-1) ){print("No")};a #1 计算第一个元素，false了就不在继续
#
a=1;if(4>3 | (a=a-1) ){print("Yes")};a # Yes, 0
a=1;if(4>3 || (a=a-1) ){print("Yes")};a # Yes, 1 #计算第一个元素，true了就不在继续
#





2.运算符“逻辑与”和“逻辑或”存在两种形式：
“&”和“|”作用在对象中的每一个元素上并且返回和比较次数相等长度的逻辑值；
“&&”和“||”只作用在对象的第一个元素上.

a1=c(1,2,3)
a2=c(0,-2,6)
a1 && a2 #[1] FALSE
a1 & a2 #[1] FALSE  TRUE  TRUE







========================================
 |-- 集合运算：交集intersect、并集union、找不同setdiff、判断相同setequal
----------------------------------------
在R语言进行数据分析时，经常需要找不同组间的相同和不同，那你应该掌握如下几个函数，让你事半功倍。


1. 子交并集

tips: 输出顺序时优先按照第一个参数中的顺序


(1) 交集intersect
两个向量的交集，集合可以是数字、字符串等

# 两个数值向量取交集
intersect(x=1:4, y = 2:6)
# [1] 2 3 4

# 两个字符向量取交集
intersect(x=letters[1:4], y = letters[2:6])
# [1] "b" "c" "d"

# 混合向量
intersect(x=c("a", "b", "c", 4), y = c("a", 2, 3, 4))
[1] "a" "4"



注意：取交集的输出，是按照元素在intersect第一个参数中出现的顺序输出的。
a1=c(10,5,4,3,2,100)
a2=c(-1,2,100,5)
intersect(a1, a2) #[1]   5   2 100
intersect(a2, a1) #[1]   2 100   5




(2) 并集union
求两个向量的并集，集合可以是任何数值类型

# 两个数值向量取并集
union(x=1:4, y = 2:6)
# [1] 1 2 3 4 5 6

# 两个字符向量取并集
union(x=letters[1:4], y = letters[2:6])
# [1] "a" "b" "c" "d" "e" "f"

# 混合向量
union(x=c("a", "b", "c", 4), y = c("a", 2, 3, 4))
[1] "a" "b" "c" "4" "2" "3"




(3) 找不同setdiff
求向量x与向量y中不同的元素(只取x中不同的元素) ，相当于是差集x-y

x = 1:4
y = 2:6
# 找x中不同于y的元素
setdiff(x, y)
# [1] 1
# 找y中不同于x的元素
setdiff(y, x)
# [1] 5 6




(4) 判断相同setequal
x = 1:4
y = 2:6
# 判断x与y是否相同，结果为假
setequal(x, y)
# [1] FALSE
# 找y与x是否相同，结果为假
setequal(y, x)
# [1] FALSE

# 只有完全相同的才返回TRUE
y = 1:4
setequal(x, y)
# [1] TRUE

setequal(c(1,2,3),c("1","2","3")) #[1] TRUE







2. 集合常见问题
(1)
# 2个集合，一个比另一个少了哪些?
set1=c('a', 'b','c','d')
set2=c('a', 'c','d')
#
for(tmp in set1){
  if(! (tmp %in% set2) ){
    print(tmp)
  }
}
# [1] "b"


精简版: setdiff(set1,set2) #[1] "b"



(2)







ref:
https://blog.csdn.net/woodcorpse/article/details/80494605








========================================
数据结构，及其查看
----------------------------------------
基本数据类型(4种)：数值（numeric）、字符（character）、逻辑值（logical）、复数型（complex）。
还有其他类型，如函数型、表达式、数据库连接等，但是一般不表示数据；
	由基本数据类型构成对象，对象包括向量、列表、矩阵、数组、数据框、时间序列等；
	- 向量是基础;

1.数据类型、结构、细节的查看 
str()
length() #只有一维的，获得长度
dim() #多维度的，获得维度

mode()
class()
attributes()
typeof()
names(mtcars) #返回mtcars中11个变量名；如果是list则返回其包含的变量名。就是$后面会出现的内容。

head(mtcars) 预览前几行
tail() 预览后几行

无论什么类型的数据，缺失数据总是用NA(Not Available的意思)来表示; 
R可以正确地表示无穷的数值，如用Inf和-Inf表示正负无穷大；
或者用NaN(Not a Number 的意思)表示不是数字的值.





2.数据类型的判断与转换
x="1"
is.character("1") #TRUE
is.numeric("1") #FALSE
is.logical(x)
is.complex(x) 

#转换类型
is.numeric(as.numeric("1")) #[1] TRUE

向量是否相等
all.equal(c(1,2),c(1,2)) #[1] TRUE
identical(c(1,2),c(1,2)) #[1] TRUE #精确相等




3.查看对象、删除对象
ls() #显示内存中的对象名字
ls(pat="m") #pattern(缩写为pat)实现只显示带有某个指定字符的对象名字
ls(pat="^m") #显示以m开头的对象名
ls(pattern = "^acc") #显示以acc开头的对象
ls.str( ) #显示内存中所有对象的详细信息

rm(x) #删除内存中的对象x
rm(x,y) #删除内存中的对象x和y
rm(list=ls()) #删除内存中的所有对象
rm(list=ls(pat="^m")) #删除对象中以字母m开头的对象










========================================
|-- 变量类型：向量vector、矩阵matrix、因子factor、列表list、数据框data.frame、类class
----------------------------------------
4.向量的建立
(1)常规示例
1) seq( )或“:” # 若向量(序列)具有较为简单的规律
	1:3 #1 2 3
	1:3+2 #3 4 5
	1:(3+2) # 1 2 3 4 5
	seq(1,10,by=2) #1 3 5 7 9 
	seq(1,2,length=5) #[1] 1.00 1.25 1.50 1.75 2.00 # 等价于seq(1,2,length.out=5)
	
	sequence(2:4) #[1] 1 2 1 2 3 1 2 3 4
	
2) rep( ) # 若向量(序列)具有较为复杂的规律
	rep(1:3,2) #1 2 3 1 2 3 #等价于 rep(1:3, times=2)
	rep(1:3,rep(1:3)) # 1 2 2 3 3 3
	rep(1:3, times = 2, each = 2) #1 1 2 2 3 3 1 1 2 2 3 3
	
3) c( ) # 若向量(序列)没有什么规律
	z <- x<-c(42,7)
	z # 42  7
	x # 42  7

4) scan( ) # 通过键盘逐个输入



############
# 向量的增删改查
############
arr=c("X","A", "B","C","D","Apple")
1)arr[-2] #删除第二个元素，就是"B"

2)删除某个值，比如"D"
index=grep( paste0("^D$"), arr)
arr2=arr[-index]
arr2 #[1] "X"     "A"     "B"     "C"     "Apple"

3)新增元素
arr3=c(arr, "Z") #末尾新增Z
arr4=c('0', arr) #开头新增0

4)查找某个值的位置，比如查找D的位置:
grep( paste0("^D$"), arr)
查不到则返回integer(0);






(2)因子型向量的建立
一个因子或因子向量不仅包括分类变量本身, 还包括变量不同的可能水平(即使它们在数据中不出现). 因子利用函数factor( )创建.
factor(x, levels = sort(unique(x), na.last = TRUE),labels = levels, exclude = NA, ordered = is.ordered(x))
参数说明：
	levels用来指定因子的水平（缺省值是向量x中不同的值；如果x中有levels中没有指定的值，则x中该值会被记作NA）；
	labels用来指定水平的名字（并显示出来）；
	exclude表示从向量x中剔除的水平值；
	ordered是一个逻辑型选项，用来指定银子的水平是否是有次序。
	这里x可以是数值型或字符型，这样对应的因子也就称为数值型因子或字符型因子。因此，因子的建立可以通过字符型向量或数值型向量来建立，且可以转化。
#


1).将字符型向量转换成因子
a=c("green", "blue", "green","yellow")
a1=factor(a)
a1 #或使用 str(a1) 或 attributes(a1)查看因子顺序
## [1] green  blue   green  yellow
## Levels: blue green yellow


因子默认是按照字母顺序排序的，这个实际情况很可能不一致。可以使用levels选项人为指定顺序。

#使用levels选项人为指定顺序
a2=factor(a, levels=c("green", "blue","yellow"))
a2
##[1] green  blue   green  yellow
##Levels: green blue yellow





2).将数值型向量转换成因子
b=c(1,2,3,1)
b1=factor(b)
b1
#[1] 1 2 3 1
#Levels: 1 2 3


为了对人类更友好，可以用labels为数值型贴上标签。此后显示的时候按标签设置显示：
> gender=factor(b, levels=c(1,2,3), labels=c("M","F","U") )
> gender
[1] M F U M
Levels: M F U # 男、女、不清楚。




3).将字符型因子转换为数值型因子
a2=a1;a2
## [1] green  blue   green  yellow
## Levels: blue green yellow

levels(a2)=c(1,2,3,4)
a2
## [1] 2 1 2 3 ## 因子4没有出现过
## Levels: 1 2 3 4

ff=factor(c("A","B","C"), labels=c(1,2,3));ff
## [1] 1 2 3
## Levels: 1 2 3




4).将数值型因子转换为字符型因子
b2=b1;b2  ## Levels: 1 2 3
levels(b2)=c("low","middle","high");b2  #Levels: low middle high

ff=factor(1:3, labels=c("A","B","C"));ff  #Levels: A B C

#注: 函数levels( )用来提取一个因子中可能的水平值
ff <- factor(c(2, 4), levels=2:5); ff
levels(ff)  #[1] "2" "3" "4" "5"




5).函数gl()能产生规则的因子序列. gl(k,n)，其中k是水平数, n是每个水平重复的次数. 
# 此函数有两个选项：length指定产生数据的个数, label指定每个水平因子的名字.
gl(3,5)
gl(3,5,length=30)
gl(2,6,label=c("Male","Female"))
#[1] Male   Male   Male   Male   Male   Male   Female Female Female Female Female Female
#Levels: Male Female




6)因子转为数字

把数据框中的因子变为数值: 把X000001.SH转变成数值类型，可以试试

先构建因子
DATA=data.frame(
	id=c(1,2,3,4,5),
	X000001.SH=c(1,2,1,1,2)
)
> DATA$X000001.SH=factor(DATA$X000001.SH)
> DATA$X000001.SH
## [1] 1 2 1 1 2
## Levels: 1 2
上述是因子。如何转为数值呢？

因子转数字1：
> rs=as.numeric(levels(DATA$X000001.SH))[DATA$X000001.SH];rs
## [1] 1 2 1 1 2
> str(rs)
## num [1:5] 1 2 1 1 2


因子转数字2：简单一行也能搞定。
> as.numeric(DATA$X000001.SH)
## [1] 1 2 1 1 2












(3)向量的截取，构建逻辑值截取。
x=10:50
x>45
x[x>45]
x[x %in% 1:15] #求交集 [1] 10 11 12 13 14 15

#按照某一列筛选
x=data.frame(
  a=c(1,2,3,4),
  b=c('a','b','c','d')
)

x[which(x$a>2),] #逻辑判断
#  a b
#3 3 c
#4 4 d

x$a %in% c(2,4,100) #在某个范围，返回逻辑值
x[x$a %in% c(2,4,100),] #
#  a b
#2 2 b
#4 4 d




(4)矩阵常用的函数
转置 t()
提取对角线元素 diag()
矩阵按行合并 rbind()，按列合并 cbind()

a2=matrix(1:6,2,3);a2
a2*a2 #矩阵的逐元乘积
a2 %*% t(a2) #矩阵的代数乘积


m<-matrix(1:12, nrow=3); m
apply(m, MARGIN=1, FUN=mean) # 求各行的均值
apply(m, MARGIN=2, FUN=mean) # 求各列的均值
scale(m, center=T, scale=T) #标准化

# 所谓中心化就是将数据减去均值后得到的，比如有一组数据(1,2,3,4,5,6,7)，它的均值是4，中心化后的数据为(-3，-2，-1，0，1，2，3)
# 而标准化则是在中心化后的数据基础上再除以数据的标准差
# 在R语言中可以通过scale函数直接进行数据的中心化和标准化：Scale(x,center,scale)
# 参数解释：x—即需要标准化的数据
#   center—表示是否进行中心化
#   scale—表示是否进行标准化
c1=c(1,2,3,4,5,6,7)
t( scale(c1,scale=F) ) #仅中心化 -3 -2 -1 0 1 2 3
c1.sd=sd(c1) #标准差
scale(c1,scale=F)/c1.sd == scale(c1)


#sweep(X, MARGIN, STATS, FUN) #表示从矩阵X中按MATGIN计算STATS，并从X中除去(sweep out).
#减去中位数:
m
#     [,1] [,2] [,3] [,4]
#[1,]    1    4    7   10
#[2,]    2    5    8   11
#[3,]    3    6    9   12

row.med <- apply(m, MARGIN=1, FUN=median); row.med
sweep(m, MARGIN=1, STATS=row.med, FUN='-') #
sweep(m, MARGIN=1, STATS=1:3, FUN='+') #按行分别加上1 2 3
#     [,1] [,2] [,3] [,4]
#[1,]    2    5    8   11
#[2,]    4    7   10   13
#[3,]    6    9   12   15



(5)数据框操作
head(Puromycin)
str(Puromycin)
dim(Puromycin)

#变量之间的关系可以通过成对数据散点图考查
pairs(Puromycin, panel = panel.smooth)

#使用xtabs( )函数由交叉分类因子产生一个列联表:
xtabs(~state + conc, data = Puromycin)
xtabs(~state, data = Puromycin)

#取子集
subset(Puromycin, state == "treated" & rate > 160)
subset(Puromycin, conc > mean(conc))


#添加新列的三种方法。iconc=1/conc
a=head(Puromycin);a
#方法1
a$iconc=1/a$conc;a
#方法2：使用with
a$iconc=with(a,1/conc);a
#方法3：用transform( )函数, 且可一次性定义多个变量
a=transform(a, iconc=1/conc, sqrtconc=sqrt(conc));a



========================================
|-- 检查 vector 是否有重复，并去重
----------------------------------------
> genelist[duplicated(genelist)]

如果有重复
genelist_new<-unique(genelist)  #去除重复




========================================
|-- list完全可以作为R中的hash结构来使用(太低效)
----------------------------------------
Lists are the only key-value mapping type provided in base R: there are no dictionaries or associative arrays.
list是R语言中包容性最强的数据对象，几乎可以容乃所有的其他数据类型。
我们可以在一个列表中储存不同的类型数据，还可以储存不同的长度数据，每一个插槽中都是一个向量（vector）。
但是基于list的hash效率很低。

更高效的是使用 environment 来定义key是字符串的hash变量。其中hash包和hashmap包就是这么做的，但是...
##########
1. 尝试 R 中的hash结构：hash包和hashmap包都报错
install.packages("hashmap")
library("hashmap")
help(hashmap)
#
mydict = hashmap( keys=c(1,2,3),values=c(10,20,30) )
#Error in (function (env, objName)  : 
#  argument to 'findVar' is not an environment
mydict[["a"]]
# 也找不到解决办法。。。



#
##########
2. 探索尝试 list 能否保存长度不同的数据类型?可以。

#创建
#初始化一个list
mydict1=list(a=c(1,2,3),h=c(0))
class(mydict1)

#后文每一步都需要检查效果，后文每句后面都省略该命令
#1.直接查看，或者2.用str查看list的数据结构
mydict1 
str(mydict1)


#拼接一个字符串作为key，并赋值和引用
mydict1[[paste0('c',1)]]=data.frame(a=c(1,2,3), b=c(10,20,30))
mydict1[[paste0('c',1)]] #引用

#增加一个key并赋值，在末尾
mydict1[['c']]=100

#修改：重新对value赋值
mydict1[['a']]=c(12,34)

#修改：在向量value中插入新元素
mydict1[["h"]]=c(mydict1[["h"]], 15)

#修改：#对这个key的value进行自增
mydict1[['c']]=mydict1[['c']]+2

#获得键列表
names(mydict1) 

#检测是否有某个键，可以用于hash的自增
key="c2"
key="c1"
if(key %in% names(mydict1)){
  print(mydict1[[key]])
}else{
  print("Not in")
}

#删除某个key
mydict1[["a"]]=NULL #好吧，a的键值对都被删除了


#可以用数字直接查找，说明是有序的，不是真正的hash结构
mydict1[[2]] 


refer:
1.R's Lists and its Detestable Dearth of Data-Structures
https://www.refsmmat.com/posts/2016-09-12-r-lists.html

2.Environments
http://adv-r.had.co.nz/Environments.html



========================================
|-- R中拼接成的字符串做变量名，并赋值
----------------------------------------

assign( paste0("cell",1),100)
cell1

#但是怎么引用呢？
eval( 'a=paste0("cell",1)' ) #失败
#

get("cell1") #成功
# 100



========================================
|-- 使用 structure 构建数据类型，能保存数据结构函数是dput()
----------------------------------------
踏破铁鞋无觅处，得来还是得多看书。


1. structure 定义结构
structure returns the given object with further attributes set.

attributes(x)
attributes(x) <- value


(1) 默认是定义矩阵
a1=structure(1:6, dim = 2:3)
a1
class(a1) #[1] "matrix"


(2) 还可以定义数据框
df <- structure(
  list(
    V1 = c(56, 123, 546, 26, 62, 6, NA, NA, NA, 15), 
    V2 = c(21, 231, 5, 5, 32, NA, 1, 231, 5, 200), 
    V3 = c(NA, NA, 24, 51, 53, 231, NA, 153, 6, 700), 
    V4 = c(2, 10, NA, 20, 56, 1, 1, 53, 40, 5000)
  ), 
 .Names = c("c1", "c2", "c3", "c4"), 
 row.names = c(NA, 10L), 
 class = "data.frame"
)
df
head(df)
#   c1  c2  c3 c4
#1  56  21  NA  2
#2 123 231  NA 10
#


(3) 也可以写成一行
refdf = structure(list(Start = c(1L, 25L, 60L), End = c(10L, 50L, 75L
)), .Names = c("Start", "End"), class = "data.frame", row.names = c(NA, 
-3L))
refdf
#  Start End
#1     1  10
#2    25  50
#3    60  75






2. 隆重推荐导出数据结构供重复使用的函数dput 

mydata <- data.frame('id'=c(10,12,3,4,5),'clazz'=c("a","b","c","d","e"))
mydata
#  id clazz
#1 10     a
#2 12     b
#3  3     c
#4  4     d
#5  5     e

dput(mydata)
#structure(list(id = c(10, 12, 3, 4, 5), clazz = structure(1:5, .Label = c("a", 
#"b", "c", "d", "e"), class = "factor")), class = "data.frame", row.names = c(NA, -5L))




ref:
https://r4ds.had.co.nz/introduction.html




========================================
|-- 获得元素在数组中的位置, 把一个(cell_type)字符串映射成另一个(color)字符串
----------------------------------------
#(1) find the index of a string in a array;
indexOf=function(value, arr){
    i=0
    for(item in arr){
        i=i+1
        if(value==item){
            return(i)
        }
    }
    return(-1)
}
indexOf('CD14+ Mono', c('B',   'CD14+ Mono',        'CD8 T')) # 2






#(2) get color list from cell type list
mapReplace=function(arr, mapList=NULL){
    if(is.null(mapList)){
        print('Get default color as no color input.')
        uniqItem=unique(arr);
        mapColorArr=rainbow(length(uniqItem)*1.2)
        for(i in 1:length(uniqItem) ){
            item=uniqItem[i]
            mapList[[item]]=mapColorArr[i]
        }
    }
    # map color from string;
    arrN=arr;
    for(key in names(mapList) ){
        value=mapList[[key]]
        arrN[which(arr==key)]=value
    }
    return(arrN)
}

colorDict=list(
    'B'=rainbow(20)[1],
    'CD14+ Mono'=rainbow(20)[2],
    'CD8 T'=rainbow(20)[3],
    'DC'=rainbow(20)[4],
    'FCGR3A+ Mono'=rainbow(20)[5],
    'Memory CD4 T'=rainbow(20)[6],
    'Naive CD4 T'=rainbow(20)[7],
    'NK'=rainbow(20)[8],
    'Platelet'=rainbow(20)[9]
)

mapReplace(pDat$celltype, colorDict)
#mapReplace(pDat$celltype)








========================================
控制结构（顺序、循环、条件）
----------------------------------------
#if, else, ifelse, switch:分支
#for, while, repeat, break, next:循环
#apply, lapply, sapply, tapply, sweep: 替代循环的函数
#
#function: 函数定义   source 调用文件
#call 函数调用
#.C   .Fortran 调用C或者Fortran子程序的动态链接库。Recall：递归调用；
#browser, debug, trace, traceback:程序调试：
#option:指定系统参数
#missing: 判断虚参是否对应实参
#nargs:参数个数   stop:终止函数执行
#eval(expr) 表达式计算
#system.time: 表达式计算计时
#menu: 选择菜单（字符列表菜单）
#





========================================
|-- 条件分支: if else, ifelse, switch
----------------------------------------
1.
##分支语句
x=1;
if(x == 1) 
    print(x)
else print("not 1");

##分支语句2
s=1;
if(s == 1) {
  print(s)
}else if(s==2){
  print(2)
}else{
  print("last else");
}


########
注意: R中执行if else报错：unexpected 'else' in "else"
多行(包括注释)语句必须使用{}包裹，

注意if else的结构写法，有以下三种，除此之外，会不识别else。
结构  1： if()  xx  else    yy   # 一行；
结构  2： if()  {xx} else  {yy}  
	或者 
	if(){
		xx
	}else    #此处不能两行写
		yy
结构3：
{
	if   
	else
}




2.
##分支语句switch
switch(statment, list) #首先判断条件的不同而执行不同的分支语句。
#首先执行statment，其返回值范围为1到list的长度; 然后switch语句执行list中包含的某一行语句，并将结果返回。

解释2:
switch(expr, list) #其中，expr为表达式，其值或为一个整数值或为一个字符串；list为一个列表。
运行机理：若expr的计算结果为整数，且值在1~length(list)之间时，则switch()函数返回列表相应位置的值。若expr的值超出范围，则没有返回值（老版本的R中返回NULL）。




#例1：第一个参数是n，就执行list的第n个语句片段。
(1)
xx=1
switch(xx,
        {print("A")},
        {print("B")},
       {print("C")});
#将打印A
xx也可以是布尔值，TRUE就是数字1，FALSE就是数字0；
(2)
switch(2,mean(1:10),rnorm(4))  #执行rnorm(4)
#由switch(x)来选择执行那个函数



# 例2: 如果第一个参数是字符串，则后面列表需要指定字符串的名字
you.like<-"fruit"
switch(you.like, drink="water", meat = "beef", fruit = "apple", vegetable="cabbage")
# [1] "apple"


###应用: 十分好用的switch()函数
for( i in c('b','a') ){
	rs=switch(i, a='aaa',b='bbb',c="ccc")
	print(rs)
}
#[1] "bbb"
#[1] "aaa"


#### 实例片段：根据不同的值，设置不同的条件。类似python中的字典的效果。
col=RColorBrewer::brewer.pal(n = 5,name = "Set2")
plot(density(DPAU[which( !is.na(DPAU[,1]) ),1]), col="white",
     xlab="DPAU", ylim=c(0, 0.07), main="DPAU distribution of all genes in each cell")
for(i in seq(1,ncol(DPAU))){
  cid=colnames(DPAU)[i]
  cellCycle=cellInfo[cid, 'cellCycle']
  color=switch(cellCycle,G1S=col[1], S=col[2], G2M=col[3], M=col[4], MG1=col[5])
  
  lines(density(DPAU[which( !is.na(DPAU[,i]) ),i]), col=color)
}



例3: 如果字符后是代码片段呢？
library(ggplot2)
g=ggplot(diamonds[1:1000,], aes(clarity, price, color=cut))
#
plotType='boxplot'
g2=switch(plotType, #这个返回值可要可不要
       boxplot=g+geom_boxplot(),
       jitter=g+geom_jitter(),
       violin=g+geom_violin()
)
g2 





========================================
|-- 循环: for, while, repeat
----------------------------------------
3.
#######################
#for循环语句(类似js)
#
for(name in expr1){
  expr2;
}
#name:循环变量；
#expr1:一个向量表达式，如1:10;
#expr2:一组表达式；

x=0;
for(i in 1:5){
  if(x==1) next; # 跳过，继续下一个循环数
  x=x+1;
  print(x);
  if(x==3) break;#终止循环语句
}


#for循环，演示cat函数的用法；
for(n in c(1,2,3,4,5)){
  x=rnorm(n);
  #print(x)
  cat(n,":",x,"\n");#输出函数
  #cat();
  #cat(n, ":",x,":", sum(x^2), "\n");
}
#循环中，next 结束本次循环，继续下一次循环；break 跳出循环；


#######################
#while循环语句(类似js)
while(condition){
  expr
}

x=0;
while(x<=5){
  x=x+1
  print(x)  
}



#######################
#repeat语句
repeat{
  expr
}

x=0;
repeat{
  if(x<=5){
    x=x+1;
    print(x);
  }else
    break;
}




ref:
https://blog.csdn.net/sinat_26917383/article/details/51191916






========================================
字符串
----------------------------------------
(1)获取字符串长度：nchar()能够获取字符串的长度，它也支持字符串向量操作。注意它和length()的结果是有区别的。
nchar(50); #2 字符串长度
length(50);#1 向量元素个数

(2)字符串粘合：paste()负责将若干个字符串相连结，返回成单独的字符串。其优点在于，就算有的处理对象不是字符型也能自动转为字符型。
paste0(a,b,c) 则能无缝连接字符串a和b和c。


> u=paste("hello world","R environment");u
[1] "hello world R environment"

> x=c("apple","google","microsoft","alibaba");x
[1] "apple"     "google"    "microsoft" "alibaba"  
> y=1:4
> y
[1] 1 2 3 4
> paste(x,y,sep='-')
[1] "apple-1"     "google-2"    "microsoft-3" "alibaba-4"  
> paste(x,y,sep='-',collapse='|')
[1] "apple-1|google-2|microsoft-3|alibaba-4"

> paste(x,y,sep=':',collapse=',') #输出json数据格式
[1] "apple:1,google:2,microsoft:3,alibaba:4" 


(3)字符串分割：strsplit()负责将字符串按照某种分割形式将其进行划分，它正是paste()的逆操作。
v=strsplit("this is a book."," ");v
[[1]]
[1] "this"  "is"    "a"     "book."

建议使用方式：
v=strsplit("this is a book."," ")[[1]];v
[1] "this"  "is"    "a"     "book."


> strsplit("This is Rstudio",'')[[1]];#分割成单字母
 [1] "T" "h" "i" "s" " " "i" "s" " " "R" "s" "t" "u" "d" "i" "o"

 
(4)字符串截取：substr()能对给定的字符串对象取出子集，其参数是子集所处的起始和终止位置。
Usage
	substr(x, start, stop)
	substring(text, first, last = 1000000L)
	substr(x, start, stop) <- value
	substring(text, first, last = 1000000L) <- value

> substr("abcdefg",0,4)
[1] "abcd"
> substr("abcdefg",1,4) #R语言中编号从1开始，与主流语言（C、java、php、Python）从0开始的惯例不同
[1] "abcd"
> substr("abcdefg",2,4)
[1] "bcd"

> substring("abcdefg",2)
[1] "bcdefg"


#首字母大写的函数
camelize=function(word){
  a1=toupper(substring(word,1,1));
  a2=substring(word,2);
  paste(a1,a2,sep="");
}
camelize('that')







(5)字符串替代：gsub(),sub().
gsub()负责搜索字符串的特定表达式，并用新的内容加以替代。sub()函数是类似的，但只替代第一个发现结果。
注：g是global全局的意思。


> x="this is a cat, I love cats."
> y=gsub("cat","dog",x)
> x
[1] "this is a cat, I love cats."
> y
[1] "this is a dog, I love dogs."
可见，原字符串并没有修改！只是返回新字符串。

> z=sub("cat","dog",x)
> x
[1] "this is a cat, I love cats."
> z
[1] "this is a dog, I love cats."#仅替换了第一个


(6)字符串匹配：grep()负责搜索给定字符串对象中特定表达式 ，并返回其位置索引。
grepl()函数与之类似，但其后面的"l"则意味着返回的将是逻辑值。
Usage
	grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
		 fixed = FALSE, useBytes = FALSE, invert = FALSE)

	grepl(pattern, x, ignore.case = FALSE, perl = FALSE,
		  fixed = FALSE, useBytes = FALSE)

	sub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
		fixed = FALSE, useBytes = FALSE)

	gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
		 fixed = FALSE, useBytes = FALSE)

	regexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
			fixed = FALSE, useBytes = FALSE)

	gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
			 fixed = FALSE, useBytes = FALSE)

	regexec(pattern, text, ignore.case = FALSE, perl = FALSE,
			fixed = FALSE, useBytes = FALSE)

#扫描文本
grep("the", scan("aa.txt", what="") );

#regexpr(pattern,x)#在字符串x中检索pattern，返回与pattern
#匹配的第一个子字符串的起始字符位置

regexpr("us","you_user_name_usa")
#返回首个与pattern匹配的字符串的其实位置

gregexpr("us","you_user_name_usa")
#返回所有与pattern匹配的字符串的其实位置


(7)大小写转化
text="This is China."
toupper(text)
tolower(text)
text #不影响原文

casefold(text,upper=FALSE) #转成小写
casefold(text,upper=TRUE) #转成大写
text #不影响原文

> DNA <- "AtGCtttACC" 
> tolower(DNA) 
[1] "atgctttacc" 
> toupper(DNA) 
[1] "ATGCTTTACC" 
> chartr("Tt", "Uu", DNA) 
[1] "AuGCuuuACC" 
> chartr("Tt", "UU", DNA) 
[1] "AUGCUUUACC" 



比如strtrim、strwrap、charmatch、match和pmatch等，甚至是 %in% 运算符都是可以使用的。R的在线帮助很全，自己看吧。


========================================
 |-- 正则表达式 Regular Expression
----------------------------------------
1.简介
正则表达式不是R的专属内容，所以用0作为起始编号，这里也只简单介绍，更详细的内容请查阅其他文章。
正则表达式是用于描述/匹配一个文本集合的表达式。

正则表达式具有神奇的功能，让你不得不用，并且每次用的时候都需要重新学习一遍。




2.细节
(1).  所有英文字母、数字和很多可显示的字符本身就是正则表达式，用于匹配它们自己。比如 'a' 就是匹配字母 'a' 的正则表达式

(2).  一些特殊的字符在正则表达式中不再用来描述它自身，它们在正则表达式中已经被“转义”，这些字符称为“元字符”。perl类型的正则表达式中被转义的字符有：. \ | ( ) [ ] { } ^ $ * + ?。被转义的字符已经有特殊的意义，如
    点号 . 表示任意字符；
    方括号表示选择方括号中的任意一个（如[a-z] 表示任意一个小写字符）；
    ^ 放在表达式开始出表示匹配文本开始位置，放在方括号内开始处表示非方括号内的任一字符；
    大括号表示前面的字符或表达式的重复次数；
    | 表示可选项，即 | 前后的表达式任选一个。

(3).  如果要在正则表达式中表示元字符本身，比如我就要在文本中查找问号‘?’， 那么就要使用引用符号（或称换码符号），一般是反斜杠 '\'。
需要注意的是，在R语言中得用两个反斜杠即 ‘\\’，如要匹配括号就要写成 ’\\(\\)‘

(4).  不同语言或应用程序（事实上很多规则都通用）定义了一些特殊的元字符用于表示某类字符，如 
    \d 表示数字0-9， \D 表示非数字，
    \s 表示空白字符（包括空格、制表符、换行符等），\S 表示非空白字符，
    \w 表示字（字母和数字），\W 表示非字，
    \< 和 \> 分别表示以空白字符开始和结束的文本。

(5).  正则表达式符号运算顺序：
    圆括号括起来的表达式最优先，
    然后是表示重复次数的操作（即：* + {} ），
    接下来是连接运算（其实就是几个字符放在一起，如abc），
    最后是表示可选项的运算（|）。

所以 'foot|bar' 可以匹配’foot‘或者’bar‘，但是 'foot|ba{2}r'匹配的是‘foot’或者‘baar’。

量词：  *表示{0,},		 +表示{1,},	?表示{0,1}.




3. 正则表达式语法规则
\ 转义字符
. 除了换行以外的任意字符
^ 放在句首，表示一行字符串的起始
$ 放在句尾，表示一行字符串的结束
* 零个或者多个之前的字符
+ 一个或者多个之前的字符
? 零个或者一个之前的字符
方括号[],代表可以匹配其中任何一个字符。而^在[]中代表“非”, -代表“之间”

– [qjk]:q,j,k中任意一个字符
– [^qjk]:非q,j,k的任意其它字符
– [a-z]:a至z中任意一个小写字符
– [^a-z]: 非任意一个a至z小写字符的其它字符(可以是大写字符)
– [a-zA-Z]:任意一个英文字母
– [a-z]+: 一个或者多个小写英文字母
| 或者
小括号()与花括号{}配合“|”使用

特别注意：保留字符都需要转义字符 \ 来转义表示

例如：
常用的特殊转义字符含义
  \n:换行符
  \t:tab
  \w:任意字母(包括下划线)或者数字 即 [a-zA-Z0-9_]
  \W:\w的反义 即[^a-zA-Z0-9_]
  \d:任意一个数字 即[0-9]
  \D:\d的反义 即[^0-9]
  \s:任意一个空格,比如space, tab, newline 等
  \S:\s的反义,任意一个非空格
  
正则表达式的常用函数
  grepl:返回一个逻辑值
  grep:返回匹配的id，
  agrep:返回匹配的id，
  
正则替换:sub和gsub， 两者的区别是前者仅替换一次，后者全局替换。

	regexpr:返回一个数字,1表示匹配,-1表示不匹配,以及两个属性,匹配 的长度和是否使用useBytes

	regexec:返回一个list,字符串中第一个匹配及其长度以及是否使用useBytes

	gregexpr:返回一个list, 每一个匹配及其长度以及是否使用useBytes
#


(2) 贪婪与非贪婪匹配
//js中的贪婪匹配与非贪婪匹配
var str = "abcabc92123abc"
str.match(/.*abc/) #默认是贪婪匹配 ["abcabc92123abc"]
str.match(/.*?abc/) #非贪婪匹配 ["abc"]

#########
#R语言基于正则表达式的获取
str = "abcabc92123abc"

gregexpr('.*abc',str)[[1]]  #默认是贪婪匹配
 # [1] 1
 # attr(,"match.length")
 # [1] 14
 # attr(,"index.type")
 # [1] "chars"
 # attr(,"useBytes")
 # [1] TRUE

gregexpr('.*?abc',str)[[1]] #加?后也是惰性
 # [1] 1 4 7
 # attr(,"match.length")
 # [1] 3 3 8
 # attr(,"index.type")
 # [1] "chars"
 # attr(,"useBytes")
 # [1] TRUE
没有竞争，就没有贪婪与否。所以想要实现非贪婪，需要后续有匹配任务。








4. 实例
查找 grep
例1： 查找PD开头的基因名字
genes=c("TP53","PDL1","PDL2","PTEN","pd1")
genes[grep("^PD",genes,ignore.case=T)]
## [1] "PDL1" "PDL2" "pd1"


替换 gsub
例2：替换_为-
cnames=c("Row-1","Row-2","Row-3");
gsub("Row-",'Cell_', cnames) #[1] "Cell_1" "Cell_2" "Cell_3"


在每一个元素中，sub只替换一次，而gsub则全部替换。
cnames2=c("R-ow-1","R-ow-2","R-ow-3");
gsub("-",'_', cnames2) #"R_ow_1" "R_ow_2" "R_ow_3"
sub("-",'_', cnames2) #"R_ow-1" "R_ow-2" "R_ow-3"




分割 strsplit
例3：将一串基因字符分割成单个的基因构成的数组：
inputUp="C4BPB, BASP1,VIM,    BEX3, EMP3, PRSS21";
geneUp=strsplit(inputUp,'[^a-zA-Z0-9]+')[[1]];
geneUp
#[1] "C4BPB"  "BASP1"  "VIM"    "BEX3"   "EMP3"   "PRSS21"





综合实例
例4：找到aatt开头、ggcc结尾的序列之间的序列。
my_find=function(startPattern,endPattern,x){
  #内函数1：获取开头位置
  i_start=function(pattern,x){
    bb=gregexpr(pattern,x,perl=TRUE);
    site=bb[[1]][1];
    start=attr(bb[[1]],"match.length") + site;
    return(start)
  }
  #内函数2：获取结尾位置
  i_end=function(pattern,x){
    bb=gregexpr(pattern,x,perl=TRUE);
    site=bb[[1]][1];
    return(site-1)
  }
  #获取开头和结尾
  a1=i_start(startPattern,x);
  a2=i_end(endPattern,x);
  #截取并返回开头和结尾
  return(substring(x,a1,a2));
}

aa ="aaatt123adsfasfa456ggccsdfa"
my_find('aatt','ggcc',aa); #adsfasfa





ref:
http://www.tuicool.com/articles/2IfEj2j


========================================
|-- 将一个分数的字符串数字转换成数值: eval(parse(text="1/2"))
----------------------------------------
https://bbs.pinggu.org/thread-4961503-1-1.html


很有趣的问题。
先说答案：eval(parse(text="1/2"))

解释：这个问题本质上是说，如何计算字符串形式的算式。那么，这样想就比较容易找答案了。
先把字符串表示成expression，即parse(text="1/2")；
然后计算，eval(parse(text="1/2"))









========================================
函数：R语言是函数式编程的
----------------------------------------
在R语言中采用函数式编程。需要对R的函数进行深入的学习。


函数=函数名+参数
exp(1)
参数还可以接收向量：
exp( c(1,2,3,4) )


自定义函数
fn=function(){
	return(xx);
}





2. 在函数内对参数进行验证，如果不是指定的值，则退出

  if( !(keyword %in% c('value1','value2')) ){
    stop("Error: keyword must in c('value1','value2')")
  }
#






refer:
https://www.douban.com/note/279077707/





========================================
|-- 一、R函数定义与调用，匿名函数与闭包
----------------------------------------
定义：
funcName=function(para[,para]){
	#many statements;
	return(something);
}

参数可以0到多个。
支持默认参数。

返回值可选，使用return则必须使用()，否则默认使用最后一个数字返回。

调用： 
funcName();#不带参数
funcName(1,2);#带参数


#函数本身也是是对象，可以查看其形参部分和函数体
formals(test)#查看形参列表
body(test)#查看函数体


#函数也可以不加{}
f1=function(x)x*2+3;
print( f1(2) )

#甚至这么写
f2=function(x)x
body(f2)=quote(x^3);#重新改写函数；
print( f2(3) )

#输入函数名，
page(nls) #查询函数代码；
edit(nls) #编辑函数代码；
#由于一些基本函数是C编写的，不能用上述方法查看和修改。



(1)函数声明与调用
func=function(){
	print("hello!")
}
func();

multi2=function(x,y){
	return(x*y);
}
multi2(5,6)#30


(2)允许函数嵌套。
add3=function(a,b,c){
	add2=function(x,y){
		return(x+y);
	}
	return(add2(add2(a,b),c))
}
add3(1,2,3) #6

(3)支持默认参数。
func1=function(x=10){
	print(x)
}

func1() #10
func1(25) #25

(4)默认返回最后一行表达式的值。
func2=function(){
	a=1
	b=2
	c=3
	c+a
}
func2() #4


(5)函数递归
累加
cumulate=function(n){
	if(n==1) return(1);
	return(n+cumulate(n-1))
}
cumulate(100);
[1] 5050

累乘(https://www.zhihu.com/question/43378587)
funr <- function(x) {
  return(ifelse(x>1, x*funr(x-1), x))
}
funr(5)
[1] 120



(10)返回函数的函数
outer=function(){
  x=2
  inc=function(increment){
    x=x+increment#并不能改变
    return(x)
  }
  inc; #返回函数
}

x=2
fn=outer()
fn(100) #102
fn(100) #102 #确实没有修改外函数中的x



(11)R语言版本的闭包：返回函数，并能私有的使用外函数的变量
(写过js的对闭包应该很熟悉)

x=1
outer=function(){
  x=2
  inc=function(increment){
    x<<-x+increment #能改变outer内的x值，因为 <<- 符号能穿透作用域，给上一层赋值。
    return(x)
  }
  get=function(){
    return(x)
  }
  set=function(a){
    x<<-a;
  }
  list(inc=inc,get=get,set=set);#返回函数列表
}
fns=outer()
fns2=outer() #两个闭包有着不同的环境，两个闭包中的变量不会共享。

str(fns)
fns$get() #2
fns$inc(100) #102
fns$get() #102
fns$set(-30)
fns$get() #-30
fns$inc(100) #70
fns$inc(100) #170
fns$get() #170
x #1
fns2$get() #2


2) 闭包，使用立即执行函数(function(){})()，节省代码。缺点：不能实例化多个实例了。
#立即执行函数
fns=(function(){
  x=10;
  get=function()x;
  set=function(a){
    x <<- a;
  }
  inc=function(i=1){
    x<<-x+i;
    x;
  }
  fns=list(get=get,set=set,inc=inc);
  return(fns);
})()
fns$get() #10
fns$set(0)
fns$inc(100) #100
fns$inc(10) #110
fns$inc() #111
fns$get() #111


3) 更精简的，函数内直接定义一个list，由于是最后一条语句，直接返回该list
fns=(function(){
  x=10;
  list(
    get=function()x,
    set=function(a){
      x <<- a;
    },
    inc=function(i=1){
      x<<-x+i;
      x;
    }
  )
})()

使用该方法，可以仿写类了。返回的就是一个类名。



4) 直接使用立即执行函数，不污染函数外的变量空间
rm(a,b)
a=10
(function(){ # 立即执行的匿名函数，就像不存在过。
    a=1;
    b=2
    print(a) #1
    print(b) #2
})()
print(a) #10
print(b) #not found




refer:
1. 《高级R语言编程指南》, Hadley Wickham, 2016.
2. R语言学习1：R中的匿名函数、闭包与函数工厂 https://blog.csdn.net/hdyshr/article/details/82744681



========================================
|-- 二、变量的作用域
----------------------------------------
1.内函数可以取出外函数的变量
a=c(1,2);
fun0=function(){
  print(a);
}
fun0() #1 2
R语言采用的是Lexical Scoping(词法作用域)。词法作用域，又称静态作用域，即变量定义后的作用域是不变的。

函数里碰到一个变量时，如果在函数里有定义或者调用的时候给了定义，就用这个定义（这个和dynamic scoping一样）；
否则就到定义函数的环境里（不是被调用的环境）找，有定义的话就用那个定义（这个和dynamic scoping 不一样）；
实在找不到了才会给出error。

实例1：
x=1
fa=function(){
  x=2
  fi=function(){
    print(x)
  }
  x=3
  fi()
}

x=100
fa() 
#3

实例2：
f=function(x){
	g=function(y){
		y+z;
	}
	z=4;
	x+g(x)
}
z=10;
f(3)

我的结果是：
f(3)=3+g(3)=3+(3+z)=3+(3+4)=10


实例3：如果去掉函数内部的z赋值呢？
f=function(x){
	g=function(y){
		y+z;
	}
	x+g(x)
}
z=10;
f(3)
我的结果：
f(3)=3+g(3)=3+(3+z)=3+(3+10)=16 



2.但是内函数不能修改外函数的变量
a=c(1,2);
fun=function(){
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    b=c(b,100)
    a=c(b,200)
    print(a) #[1]   1   2   3   4 100 200 #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1  2  3  4 10
  #并没有改变
}

fun()
print(a) #[1] 1 2 #毫不影响

#a就属于全局变量；b就是局部变量；

顶层的a并没有改变，即使看起来在fun()中被修改了。只有fun()中局部变量a发生了改变。
实际上，局部变量a与相应的全局变量a共享一个内存地址，直到局部变量的数值发生了变化。
这种情况下，会分配给局部变量a新的内存地址。




3.再次尝试
a=c(1,2);
fun=function(){
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    b=c(b,100)
    #对上一个层次环境中的变量进行写操作 超级赋值符号<<-
    a<<-c(b,200) #这样就可以突破一层作用域，改变上层变量
    print(a) #[1]   3   4   5 100 200
    #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1   2   3   4 100 200
}

fun()
print(a) #[1] 1 2 #依旧毫不影响



4.想改变最外层的a怎么办？
在fun函数内使用一次<<-符号。
a=c(1,2);
fun=function(){
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    b=c(b,100)
    #对上一个层次环境中的变量进行写操作 超级赋值符号<<-
    a<<-c(b,200) #这样就可以突破一层作用域，改变上层变量
    print(a) #[1]   3   4   5 100 200
    #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1   2   3   4 100 200
  a<<-a #再次穿透一层作用域
}

fun()
print(a) #[1]    2   3   4 100 200 #也受到了影响






##
More: 更多关于函数scope和环境environment部分请参考 R/R-OOP;


========================================
|-- 三、自定义二元运算符: "%myname%"=function(){}
----------------------------------------
#以为%开始和结束，函数的参数和返回值都是某种数据类型

"%myname%"=function(a,b)return(a^b)
2%myname%10   #1024






========================================
|-- R语言的函数中的特殊参数"..."
----------------------------------------
1. ...参数是一种特殊的参数，表明一些可以传递给另一个函数的参数。
常用于当你需要扩展另一个函数，而你又不想复制原函数的整个参数列表时。

如下例，你希望修改plot()函数中的个别参数，而其他参数保持不变，将其应用于一个新定义的函数中myplot()：
myplot <- function(x, y, type = "l", ...) {
    plot(x, y, type = type, ...) ## Pass '...' to 'plot' function
}


更拗口的一个说法: “...”用来引用从被调用函数传递下来的参数。当所有匹配“...”的参数来自特定的类或者特定类的子类，为这些函数定义的方法会被选择和调用。
fun1 <- function(data, data.frame, graph=TRUE, limit=20, ...) {
  [omitted statements]
  if (graph)
    par(pch="*", ...)
  [more omissions]
}





(2)获取这些参数

当一个函数需要引用“...”中的成分时，表达式列表list(...）将获取所有这样的参数，返回的是一个命名列表。

例
x = function(a){2*a}
y = function(a, b){a+b}
#定义新函数，用到旧函数
z = function(c, ...){
  args = list(...)
  return(x(args$a) + y(args$a, args$b) +c)
}
z(c = 2, b = 2, a =2 ) #2*2+(2+2)+2=10




2.在泛型函数（generic function）中，...还有另一种用法，它的作用是根据数据类型使用合适的方法

泛型函数是一个函数族，其中的每个函数都有相似的功能，但是适用于某个特定的类。
> mean
standardGeneric for "mean" defined from package "base"

function (x, ...) 
standardGeneric("mean")
<environment: 0x0000000003049880>
Methods may be defined for arguments: x
Use  showMethods("mean")  for currently available ones.




3. 还有一种情况下，...参数必须使用：
那就是，当传递到函数的参数数量不能事先确定的时候。

比如paste()函数，他的作用是将一连串字符串连接起来，然后新建一个字符串或向量，所以无法预知参数个数：
> args(paste)
function (..., sep = " ", collapse = NULL) 
NULL


还有cat()函数，它的功能是和paste相似，也是连接字符串。
> args(cat)
function (..., file = "", sep = " ", fill = FALSE, labels = NULL, 
    append = FALSE) 
NULL


注意：任何出现在...之后的参数列表必须明确的给出名称。而且不能够部分匹配或位置匹配。
比如，paste() 指定参数后，后面的分隔符sep参数必须使用完整形式，不能省略。
paste('a','b',sep=":") #"a:b"
paste('a','b',":") #"a b :" 不符合预期。






refer:
https://blog.csdn.net/Intelligebce/article/details/83958973





========================================
 |-- R语言中do.call()的用法
----------------------------------------
简单参数设置就能搞定的事情，是不会用到do.call的。

某些情况下，你知道某个函数接受参数的明确个数，但是太多了，你懒，所以用do.call；但更多的情况是你迫不得已，必须用它。

虽然R语言有类型很丰富的数据结构，但是很多时候数据结构比较复杂，那么基本就会用到list这种结构的数据类型。但是list对象很难以文本的形式导出，因此需要一个函数能快速将复杂的list结构扁平化成dataframe。这里要介绍的就是do.call函数。


do.call 构造并执行来自字符串名称或直接函数调用来的函数, 并将其传递给它的参数列表。参数列表 即 list, 所以 do.call 针对的就是 list。




?do.call
## Description
## do.call constructs and executes a function call from a name or a function and a list of arguments to be passed to it.
## Usage
## do.call(what, args, quote = FALSE, envir = parent.frame())
what可以是一个函数也可以是一个 字符串形式的函数名称(eg. kmeans or ‘kmeans’). 
args 供函数调用的参数设置，这些参数都将被 what 识别并调用. 
quote 逻辑值, 是否引用参数. 
envir 评估函数调用时所处的环境. 对于what是字符串形式函数名称且对应的参数都是符号或者引用的表达式时会非常有用.





1.例1
aa 		<- 	data.frame(matrix(1:25, ncol = 5), matrix(4:28, ncol = 5), matrix(21:45, ncol=5))
aa
aa_sum 	<- 	do.call(sum,aa);aa_sum #[1] 1550
aa_bind <-	do.call(cbind,aa);aa_bind #拿出来每列，按照列合并，所以和aa一模一样，不过是"matrix"
#

bb 		<- 	list(matrix(1:25, ncol = 5), matrix(4:28, ncol = 5), matrix(21:45, ncol=5))
bb
bb_sum 	<- 	do.call(sum,bb);bb_sum #[1] 1550
bb_bind <-	do.call(cbind,bb);bb_bind #把list的每一个元素拿出来，列之间合并，变宽了。

#list和data.frame都是可以的
#do.call(fn, list) 是告诉list一个函数fn，然后list里的所有元素来执行这个函数。
# 不过一定要拿下，这是晋级的方法
# https://www.douban.com/note/589741782/



例2：生成数据框
x1 = 1:10
x2 = 11:20
x3 = 21:30
data.frame(x1,x2,x3) #返回三列构成的数据框
# 基本等价于
do.call("data.frame",list(x1,x2,x3)) #把list中每个元素拿出来，给函数data.frame(理论上传无限参数)
# https://www.jianshu.com/p/078071c12e77



例3：定义复数
complex(imag=1:3)
# 等价于
do.call("complex", list(imag = 1:3))



例4：用kmeans给每一行元素贴一个标签
set.seed(100)
t1=do.call('kmeans',list(x=iris[,1:4],centers=3))
t1$cluster
# 等价于
set.seed(100)
t2=kmeans(x=iris[,1:4],centers=3)
t2$cluster



例5：画列之间的相关系数热图
library(corrplot)
do.call('corrplot.mixed',list(cor(iris[,1:4])))



2.简单的讲，do.call 的功能就是执行一个函数，而这个函数的参数呢，放在一个list里面, 是list的每个子元素。
> tmp <- data.frame('letter'=letters[1:8],number=seq(1:8), 'value' = c('+','-'))
> tmp
  letter number value
1      a      1     +
2      b      2     -
3      c      3     +
4      d      4     -
5      e      5     +
6      f      6     -
7      g      7     +
8      h      8     -
> tmp[[1]]
[1] a b c d e f g h
Levels: a b c d e f g h
> tmp[[2]]
[1] 1 2 3 4 5 6 7 8
> tmp[[3]]
[1] + - + - + - + -
Levels: - +
> do.call('paste', c(tmp, sep=""))
[1] "a1+" "b2-" "c3+" "d4-" "e5+" "f6-" "g7+" "h8-"
#
这里的tmp使用data.frame函数创建的，其实它本质上还是一个list，这里分别用[[]]符号显示他的2个元素，可以看到do.call函数把tmp的3个元素（3个向量）作为paste函数的参数。这个例子我们也可以这样写：

> paste(tmp[[1]],tmp[[2]],tmp[[3]], sep = "")
[1] "a1+" "b2-" "c3+" "d4-" "e5+" "f6-" "g7+" "h8-"

但是：为什么这样不行呢？
> do.call('paste', list(tmp,sep="") ) 
[1] "1:8"                       "1:8"                       "c(2, 1, 2, 1, 2, 1, 2, 1)"





3.例: 使用list()单独设置函数的参数列表，然后再用do.call("pheatmap", hm.parameters )的形式执行。
plotCycle <- function  ( phaseCorsMatrix ) {
    library("pheatmap")
    library("RColorBrewer")
    breaks <- seq ( -1 , 1 , length.out = 31 )
    heatColors <- rev (brewer.pal ( 9, 'RdBu'))
    heatColors <-colorRampPalette(heatColors)
    colorPallete <- heatColors((length ( breaks ) - 1 ))
    
    # create heatmap
    hm.parameters <- list(phaseCorsMatrix,
    color = colorPallete,
    breaks = breaks,
    cellwidth = NA, cellheight = NA, scale = "none",
    treeheight_row = 50,
    kmeans_k = NA,
    show_rownames = T, show_colnames = F,
    main = "",
    clustering_method = "average",
    cluster_rows = FALSE, cluster_cols = FALSE,
    clustering_distance_rows = "euclidean",
    clustering_distance_cols = NA ,
    legend = T , annotation_legend = F )
    
    do.call("pheatmap", hm.parameters )
}


4.例










refer:
https://bbs.pinggu.org/thread-3802000-1-1.html











========================================
文件I/O
----------------------------------------

0. 本文件内读取示例数据
(1)
Input =("
        Distance    Trill  No.trill
        10m        16     8
        100m        3    18
        ")
Matriz = as.matrix(read.table(textConnection(Input),
                              header=TRUE,
                              row.names=1))
Matriz
#     Trill No.trill
#10m     16        8
#100m     3       18




#(2)更简洁的写法：
# 直接在程序中嵌入数据
mydatatxt="
age gender
1 M
2 F
3 F
"
mydata=read.table(text=mydatatxt, header=T) # text设置了，file就要留空。
mydata
#  age gender
#1   1      M
#2   2      F
#3   3      F


以上适合小数据及，大型数据集还是要从文件读取。







1.一次全部读入内存：

(1)读入数据框：
fileName="D:/coding/Java/CCDS.20160908.txt";
#a=read.table(choose.files(),sep = '\t',stringsAsFactors = F,header = T)# 选择你下的CCDs文件
a=read.table(fileName,sep = '\t',stringsAsFactors = F,header = T)# 选择你下的CCDs文件

newdata <- read.csv(file = "data.csv", row.names=1, stringsAsFactors = F, sep = ",")

教训：一定要加入 stringsAsFactors = F，否则数据可能会异常。


(2)读入一列基因名字:
geneList2=readLines("geneList2.txt")

R认为短横线-是无效的，所以如果读入的列名中包含了-，它会默认将其替换为. ，目的是确保能及时检验是否出现重复的列名。





2.R语言逐行读取并处理大文件最好逐行读取。  

用R语言作分析时，有时候需要逐行处理非常大文件，各种教材中推荐的read.table 和scan都是一次性读入内存，如果文件有好几个Gb大小，一般电脑肯定吃不消。其实R中可以逐行读取的行数，这里示例一个函数，作为备忘：

con <- file("e:/data.txt", "r")
line=readLines(con,n=1)
while( length(line) != 0 ) {
     print(line)
     line=readLines(con,n=1)
}
close(con)

如果需要将一行的文字劈成多段，再进行处理，可以用strsplit函数，除此之外，还有一些常用的字符串处理函数，记录如下：
substr(),nchar(), grep(), regexpr(), sub(), gsub()


这样在异常时可能不能及时关闭资源，有博文建议如下方式写：
http://stackoverflow.com/questions/6304073/warning-closing-unused-connection-n

getCommentary <- function(filepath) {
    con <- file(filepath) 
    on.exit(close(con)) #这样，不管函数因为什么原因结束，都会关闭该资源链接。
    Commentary <-readLines(con)
    Commentary
}

getCommentary("foo.txt")






3.数据对象从内存-硬盘之间读写
str(ttr.varSD)
## List of 4 ...

内存写入硬盘：
save(ttr.varSD, file='ttr.varSD.RDS')

硬盘读入到内存：
aa=readRDS('ttr.varSD.RDS')


(2) 把id写入文件，一个id一行，不要行列标题
write.table(rownames(tmp),file="xx.Right.cellID",
            quote=F,row.names = F,col.names = F)
#
write.csv(data, file = "data.csv")



4.读取外部函数源码文件：source("xx.R")





========================================
|-- 大型脚本的组织架构 (我自己的R工具包)
----------------------------------------
1. 文件结构 
projectName/
 |-script/
 |-src/
 |-result/
 |-data/
#
原始数据放到data/中，设置为可读不可写。

结果放到result中，关键词加日期命名文件夹。

代码放到 script中，函数定义放到 src中。



2. 带个格式化
(1)在 script/ 中写代码 
# Project Name: xx
# Aim: get correlation
# email: jimmymall at 163 dot com 
# Version: v0.0.1
# 
setwd("xx/result/") #这里用绝对路径，后面都尽可能用相对路径。
getwd()

source("../src/base/tool.df.R")







(2) src/base 中写常用函数，及测试，要有详细的文档


########################
# src/base/tool.df.R 
########################
# aim: tools to deal with data frame, to df, or from df;
# version:



########################
# src/base/tool.color.R 
########################
# add alpha to color hex;
addAlpha=function(hex, alpha='33'){
  paste0(substr(hex,1,7),alpha)
}



更详尽的实现请移步: https://github.com/DawnEve/bioToolKit





========================================
|-- 读文件时的技巧: 防止字符变因子
----------------------------------------
1.
options(stringsAsFactors=FALSE)


字符型数据读入时自动转换为因子，因子是R中的变量，它只能取有限的几个不同值，将数据保存为因子可确保模型函数能够正确处理。But当变量作为简单字符串使用时可能出错。要想防止转换为因子：
1.令参数stringAsFactors=FALSE,防止导入的数据任何的因子转换。
2.更改系统选项options(stringsAsFactors=FALSE)
3.指定抑制转换的列：as.is=参数。通过一个索引向量指定，或者一个逻辑向量，需要转换的列取值FALSE,不需要转换的列取值TRUE。

data5<-read.csv('item.csv',stringAsFactors=FALSE)


2. 如果数据集中含有中文，直接导入很有可能不识别中文，这时加上参数fileEncoding='utf-8'
read.csv('data.csv',fileEncoding='utf-8')





ref:
https://www.cnblogs.com/zhangduo/p/4440314.html












========================================
|-- 读取 excel 文件
----------------------------------------
1. xlsx

(1) 安装
装Java: 百度吧。

装包:
install.packages('xlsx')




(2) 使用
library(xlsx)
dat <- read.xlsx("data.xlsx", sheetName = "Sheet1", encoding = 'UTF-8')

一个标准的数据读取如上所示，下面将几个常用的参数：

"data.xlsx"：表示读取数据的名称。
sheetName：表示读取表中表的名称，通常第一个就是Sheet1。
encoding：这个在读取中文数据的时候是一定要加上的，不然读取数据会出现乱码。

sheetIndex：表示读取文件中第几个表，sheetIndex = 1表示读取文件中第一个表。需要特别注意：当文件中我们的表明为中文字时，不能使用类似sheetName = "表1"进行读取，即使加上encoding = 'UTF-8'也会出现读取错误，这时就需要使用sheetIndex来进行读取。

###







ref:
https://www.r-bloggers.com/read-excel-files-from-r/







========================================
时间 Time
----------------------------------------
1. 获取时间
> now=Sys.time();now
[1] "2020-04-17 10:52:38 CST"
> as.numeric(now)
[1] 1587091959
> str(now)
 POSIXct[1:1], format: "2020-04-17 10:52:38"
#



## 在循环中显示进度条和耗时
start=as.numeric(Sys.time())
for(i in 1:100){
  if(i%%10==0){
    print(paste(i, '; Elapse', round(as.numeric(Sys.time())-start,2), 'seconds'))
  }
  
  # time consuming task
  Sys.sleep(0.05)
}






2. 时间字符串变时间戳
#包装成函数形式
timeString2stamp=function(timeStr){
  #as.numeric(as.POSIXlt("2020-04-13 23:00:00 CST"));
  as.numeric(as.POSIXlt( paste0('2020-',timeStr,":00:00 CST") ));
}
timeString2stamp('04-13 23') #[1] 1586790000



3. 时间戳变日期格式
> as.Date(as.POSIXct(1587322649, origin="1970-01-01"))
[1] "2020-04-19"

完整形式: //为什么日期不一样，上面是19日，下面是20日？
as.POSIXct(1587322649, origin="1970-01-01")
[1] "2020-04-20 02:57:29 CST"



ref:
https://www.cnblogs.com/shalijiang/p/4523863.html















========================================
查看R环境中的变量 ls()、ls.str()
----------------------------------------
1.你希望知道目前工作空间中存在哪些已定义的变量和函数。
> ls()
[1] "a"  "fn" "x"  "y" 


(2) 则通过设定选项pattern(可简写为pat) 来筛选变量:
ls(pattern = "x")
ls(pat = "^m") #支持正则表达式






2.如果你除了变量名称以外还想对变量有更多的了解，那么你可以使用ls.str函数，该函数会返回变量的一些其他信息：
> ls.str()
a :  num [1:6] 0 48 48 100 150 250
fn : function (x, y)  
x :  num [1:1000, 1:30] -0.877 -0.746 1.376 0.238 0.109 ...
y :  num [1:1000, 1:2] 1.7688 0.5453 0.0449 0.8503 0.6149 ...

ls.str函数之所以写为ls.str，原因在于其功能既显示了所有变量的名称，又对所有变量使用了str函数。


(2)选项pattern在这里同样适用。
M <- data.frame(n1=c(1,2), n2=c(20,30), m=c('A','B'))
ls.str(pat = "M")


(3) 按照mode显示现有数据

> ls.str(mode = "function") 
fn : function (x, y)

> ls.str(mode = "list") 
M : 'data.frame':	2 obs. of  3 variables:
 $ n1: num  1 2
 $ n2: num  20 30
 $ m : Factor w/ 2 levels "A","B": 1 2
#






3. ls函数不会显示以点（.）开头的变量名，以点开头的变量一般作为隐藏变量不为用户所知（这一输出规定来源于UNIX系统）。在R软件中，可以通过将ls.str函数中的all.names参数设定为TRUE，强制列出所有变量：
> ls(all.names=TRUE)
[1] ".hidvar"      ".Random.seed" "a"            "fn"           "x"            "y" 


> ls.str(all.names=TRUE)
.hidvar :  num 10
.Random.seed :  int [1:626] 10403 427 1930864435 1259062582 -539819294 -2087501084 1001909850 -1788871087 1372516555 1104797631 ...
a :  num [1:6] 0 48 48 100 150 250
fn : function (x, y)  
x :  num [1:1000, 1:30] -0.877 -0.746 1.376 0.238 0.109 ...
y :  num [1:1000, 1:2] 1.7688 0.5453 0.0449 0.8503 0.6149 ...







========================================
可重复性研究
----------------------------------------
1.用shiny+Rmarkdown写Assignment报告，在文档中使用shiny，既装逼又实用。
2.做数据分析研究时用shiny+dashboard+dygraph开发一个可交互的数据分析应用。方便进行探索性的数据分析，可以选择变量，可以拖动时间轴，可以放大缩小时间范围或者数值y的范围，观察数据更方便。
（https://www.zhihu.com/question/35224925）


shinny 教程见 专题: R web shinny框架





========================================
R高级教程: What They Forgot to Teach You About R
----------------------------------------
https://rstats.wtf/


1. 复杂对象
(1)
library(here)

saveRDS(my_precious, here("results", "my_precious.rds")) #保存对象
my_precious <- readRDS(here("results", "my_precious.rds")) #读取对象



(2) 使用相对路径
library(ggplot2)
library(here)

df <- read.delim(here("data", "raw_foofy_data.csv"))
p <- ggplot(df, aes(x, y)) + geom_point()
ggsave(here("figs", "foofy_scatterplot.png"))





========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

