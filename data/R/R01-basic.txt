R语言基础

程序设计的思想就是：复用==减少重复。
措施就是提取变化，封装不变。
实施方案就是：函数化 function，面向对象化 OOP


Rstudio环境配置：
1. Rstudio可以做到R版本的切换选择。
点击Tools->Global options,然后在R generals里选择R versions，就可以切换R版本。

2.




========================================
R语言资源: 从入门到精通
----------------------------------------
1.《R语言快速入门系列教程》  
http://agetouch.blog.163.com/blog/static/22853509020161026101219690/

R官方文档： https://cran.r-project.org/manuals.html
R Tutorial：http://www.r-tutor.com/r-introduction/data-frame



2.R语言进阶教程
《高级R语言编程指南》, Hadley Wickham, 2016.
第一版 http://adv-r.had.co.nz/
第二版 https://adv-r.hadley.nz/





3.哈佛大学数据课程 http://tutorials.iq.harvard.edu
https://dss.iq.harvard.edu/blog/resources-learning-r

There are several excellent tutorials not listed on r-project.org. Some of these are listed below.
http://www.statmethods.net/
"Quick-R" aims to get you up and running in R quickly.

http://personality-project.org/r/r.guide.html
Notes on "Using R for psychological research".

http://r4ds.had.co.nz/
"R for Data Science" by R luminary Hadley Wickham. Includes a ggplot tutorial.

http://adv-r.had.co.nz/
Advanced R programming by Hadley Wickham.

http://rmarkdown.rstudio.com/lesson-1.html
A comprehensive RMarkdown tutorial.




R语言镜像站
https://cran.rstudio.com/bin/windows/contrib/3.4/Cairo_1.5-9.zip
https://mirrors.tuna.tsinghua.edu.cn/bioconductor/packages/3.4/BiocViews.html#___Software
http://mirrors.ustc.edu.cn/bioc/3.4/BiocViews.html#___Software




========================================
运算符
----------------------------------------
1.
求助符：
	?mtcars #查看该数据集mtcats的帮助文档
	help()
	??ggplot2 #如果前两者不行
	find("fun") #得到名为“fun”函数所在的程序包，只在载入的包中找;
	args("fun") #得到名为“fun”函数的自变量列表.
	使用Rstudio时，光标停在函数上，按F1键
系统符号：
	> 命令或运算提示符
	+ 续行符
基本算数运算：
	加 +，	 减-，	乘*，	除/，	乘方^(或者**)，	求余数(取模)%%， x%/%y 整数除法
	57%%7 #1
	57%/%7 #8
赋值：
	= 或 <-
	->
	<<-
	assign(paste0("a",1),100) #a1=100
逻辑运算符
	&&    与（优先计算第一个元素）
	||    或（优先计算第一个元素）

	&    与
	|    或
	!    非

	==   是否相等
	>    大于
	>=   大于等于
	<    小于
	<=    小于等于
三元表达式：类似js中的 a>b?a:b;
	ifelse(a>b, a, b)
	


2.运算符“逻辑与”和“逻辑或”存在两种形式：
“&”和“|”作用在对象中的每一个元素上并且返回和比较次数相等长度的逻辑值；
“&&”和“||”只作用在对象的第一个元素上.

a1=c(1,2,3)
a2=c(0,-2,6)
a1 && a2 #[1] FALSE
a1 & a2 #[1] FALSE  TRUE  TRUE







========================================
 |-- 集合运算：交集intersect、并集union、找不同setdiff、判断相同setequal
----------------------------------------
子交并集 https://blog.csdn.net/woodcorpse/article/details/80494605

(1) 交集intersect
两个向量的交集，集合可以是数字、字符串等

# 两个数值向量取交集
intersect(x=1:4, y = 2:6)
# [1] 2 3 4

# 两个字符向量取交集
intersect(x=letters[1:4], y = letters[2:6])
# [1] "b" "c" "d"

# 混合向量
intersect(x=c("a", "b", "c", 4), y = c("a", 2, 3, 4))
[1] "a" "4"




(2) 并集union
求两个向量的并集，集合可以是任何数值类型

# 两个数值向量取并集
union(x=1:4, y = 2:6)
# [1] 1 2 3 4 5 6

# 两个字符向量取并集
union(x=letters[1:4], y = letters[2:6])
# [1] "a" "b" "c" "d" "e" "f"

# 混合向量
union(x=c("a", "b", "c", 4), y = c("a", 2, 3, 4))
[1] "a" "b" "c" "4" "2" "3"




(3) 找不同setdiff
求向量x与向量y中不同的元素(只取x中不同的元素) ，相当于是差集x-y

x = 1:4
y = 2:6
# 找x中不同于y的元素
setdiff(x, y)
# [1] 1
# 找y中不同于x的元素
setdiff(y, x)
# [1] 5 6



(4) 判断相同setequal
x = 1:4
y = 2:6
# 判断x与y是否相同，结果为假
setequal(x, y)
# [1] FALSE
# 找y与x是否相同，结果为假
setequal(y, x)
# [1] FALSE

# 只有完全相同的才返回TRUE
y = 1:4
setequal(x, y)
# [1] TRUE

setequal(c(1,2,3),c("1","2","3")) #[1] TRUE







refer:
http://agetouch.blog.163.com/blog/static/228535090201452664648639/
http://agetouch.blog.163.com/blog/static/22853509020146422428798/








========================================
数据结构，及其查看
----------------------------------------
基本数据类型(4种)：数值（numeric）、字符（character）、逻辑值（logical）、复数型（complex）。
还有其他类型，如函数型、表达式、数据库连接等，但是一般不表示数据；
	由基本数据类型构成对象，对象包括向量、列表、矩阵、数组、数据框、时间序列等；
	- 向量是基础;

1.数据类型、结构、细节的查看 
str()
length() #只有一维的，获得长度
dim() #多维度的，获得维度

mode()
class()
attributes()
typeof()
names(mtcars) #返回mtcars中11个变量名；如果是list则返回其包含的变量名。就是$后面会出现的内容。

head(mtcars) 预览前几行
tail() 预览后几行

无论什么类型的数据，缺失数据总是用NA(Not Available的意思)来表示; 
R可以正确地表示无穷的数值，如用Inf和-Inf表示正负无穷大；
或者用NaN(Not a Number 的意思)表示不是数字的值.





2.数据类型的判断与转换
x="1"
is.character("1") #TRUE
is.numeric("1") #FALSE
is.logical(x)
is.complex(x) 

#转换类型
is.numeric(as.numeric("1")) #[1] TRUE

向量是否相等
all.equal(c(1,2),c(1,2)) #[1] TRUE
identical(c(1,2),c(1,2)) #[1] TRUE #精确相等




3.查看对象、删除对象
ls() #显示内存中的对象名字
ls(pat="m") #pattern(缩写为pat)实现只显示带有某个指定字符的对象名字
ls(pat="^m") #显示以m开头的对象名
ls(pattern = "^acc") #显示以acc开头的对象
ls.str( ) #显示内存中所有对象的详细信息

rm(x) #删除内存中的对象x
rm(x,y) #删除内存中的对象x和y
rm(list=ls()) #删除内存中的所有对象
rm(list=ls(pat="^m")) #删除对象中以字母m开头的对象










========================================
|-- 变量类型：向量vector、矩阵matrix、因子factor、列表list、数据框data.frame、类class
----------------------------------------
4.向量的建立
(1)常规示例
1) seq( )或“:” # 若向量(序列)具有较为简单的规律
	1:3 #1 2 3
	1:3+2 #3 4 5
	1:(3+2) # 1 2 3 4 5
	seq(1,10,by=2) #1 3 5 7 9 
	seq(1,2,length=5) #[1] 1.00 1.25 1.50 1.75 2.00 # 等价于seq(1,2,length.out=5)
	
	sequence(2:4) #[1] 1 2 1 2 3 1 2 3 4
	
2) rep( ) # 若向量(序列)具有较为复杂的规律
	rep(1:3,2) #1 2 3 1 2 3 #等价于 rep(1:3, times=2)
	rep(1:3,rep(1:3)) # 1 2 2 3 3 3
	rep(1:3, times = 2, each = 2) #1 1 2 2 3 3 1 1 2 2 3 3
	
3) c( ) # 若向量(序列)没有什么规律
	z <- x<-c(42,7)
	z # 42  7
	x # 42  7

4) scan( ) # 通过键盘逐个输入











(2)因子型向量的建立
一个因子或因子向量不仅包括分类变量本身, 还包括变量不同的可能水平(即使它们在数据中不出现). 因子利用函数factor( )创建.
factor(x, levels = sort(unique(x), na.last = TRUE),labels = levels, exclude = NA, ordered = is.ordered(x))
参数说明：
	levels用来指定因子的水平（缺省值是向量x中不同的值；如果x中有levels中没有指定的值，则x中该值会被记作NA）；
	labels用来指定水平的名字（并显示出来）；
	exclude表示从向量x中剔除的水平值；
	ordered是一个逻辑型选项，用来指定银子的水平是否是有次序。
	这里x可以是数值型或字符型，这样对应的因子也就称为数值型因子或字符型因子。因此，因子的建立可以通过字符型向量或数值型向量来建立，且可以转化。
#


1).将字符型向量转换成因子
a=c("green", "blue", "green","yellow")
a1=factor(a)
a1 #或使用 str(a1) 或 attributes(a1)查看因子顺序
## [1] green  blue   green  yellow
## Levels: blue green yellow


因子默认是按照字母顺序排序的，这个实际情况很可能不一致。可以使用levels选项人为指定顺序。

#使用levels选项人为指定顺序
a2=factor(a, levels=c("green", "blue","yellow"))
a2
##[1] green  blue   green  yellow
##Levels: green blue yellow





2).将数值型向量转换成因子
b=c(1,2,3,1)
b1=factor(b)
b1
#[1] 1 2 3 1
#Levels: 1 2 3


为了对人类更友好，可以用labels为数值型贴上标签。此后显示的时候按标签设置显示：
> gender=factor(b, levels=c(1,2,3), labels=c("M","F","U") )
> gender
[1] M F U M
Levels: M F U # 男、女、不清楚。




3).将字符型因子转换为数值型因子
a2=a1;a2
## [1] green  blue   green  yellow
## Levels: blue green yellow

levels(a2)=c(1,2,3,4)
a2
## [1] 2 1 2 3 ## 因子4没有出现过
## Levels: 1 2 3 4

ff=factor(c("A","B","C"), labels=c(1,2,3));ff
## [1] 1 2 3
## Levels: 1 2 3




4).将数值型因子转换为字符型因子
b2=b1;b2  ## Levels: 1 2 3
levels(b2)=c("low","middle","high");b2  #Levels: low middle high

ff=factor(1:3, labels=c("A","B","C"));ff  #Levels: A B C

#注: 函数levels( )用来提取一个因子中可能的水平值
ff <- factor(c(2, 4), levels=2:5); ff
levels(ff)  #[1] "2" "3" "4" "5"




5).函数gl()能产生规则的因子序列. gl(k,n)，其中k是水平数, n是每个水平重复的次数. 
# 此函数有两个选项：length指定产生数据的个数, label指定每个水平因子的名字.
gl(3,5)
gl(3,5,length=30)
gl(2,6,label=c("Male","Female"))
#[1] Male   Male   Male   Male   Male   Male   Female Female Female Female Female Female
#Levels: Male Female




6)因子转为数字

把数据框中的因子变为数值: 把X000001.SH转变成数值类型，可以试试

先构建因子
DATA=data.frame(
	id=c(1,2,3,4,5),
	X000001.SH=c(1,2,1,1,2)
)
> DATA$X000001.SH=factor(DATA$X000001.SH)
> DATA$X000001.SH
## [1] 1 2 1 1 2
## Levels: 1 2
上述是因子。如何转为数值呢？

因子转数字1：
> rs=as.numeric(levels(DATA$X000001.SH))[DATA$X000001.SH];rs
## [1] 1 2 1 1 2
> str(rs)
## num [1:5] 1 2 1 1 2


因子转数字2：简单一行也能搞定。
> as.numeric(DATA$X000001.SH)
## [1] 1 2 1 1 2












(3)向量的截取，构建逻辑值截取。
x=10:50
x>45
x[x>45]
x[x %in% 1:15] #求交集 [1] 10 11 12 13 14 15

#按照某一列筛选
x=data.frame(
  a=c(1,2,3,4),
  b=c('a','b','c','d')
)

x[which(x$a>2),] #逻辑判断
#  a b
#3 3 c
#4 4 d

x$a %in% c(2,4,100) #在某个范围，返回逻辑值
x[x$a %in% c(2,4,100),] #
#  a b
#2 2 b
#4 4 d




(4)矩阵常用的函数
转置 t()
提取对角线元素 diag()
矩阵按行合并 rbind()，按列合并 cbind()

a2=matrix(1:6,2,3);a2
a2*a2 #矩阵的逐元乘积
a2 %*% t(a2) #矩阵的代数乘积


m<-matrix(1:12, nrow=3); m
apply(m, MARGIN=1, FUN=mean) # 求各行的均值
apply(m, MARGIN=2, FUN=mean) # 求各列的均值
scale(m, center=T, scale=T) #标准化

# 所谓中心化就是将数据减去均值后得到的，比如有一组数据(1,2,3,4,5,6,7)，它的均值是4，中心化后的数据为(-3，-2，-1，0，1，2，3)
# 而标准化则是在中心化后的数据基础上再除以数据的标准差
# 在R语言中可以通过scale函数直接进行数据的中心化和标准化：Scale(x,center,scale)
# 参数解释：x—即需要标准化的数据
#   center—表示是否进行中心化
#   scale—表示是否进行标准化
c1=c(1,2,3,4,5,6,7)
t( scale(c1,scale=F) ) #仅中心化 -3 -2 -1 0 1 2 3
c1.sd=sd(c1) #标准差
scale(c1,scale=F)/c1.sd == scale(c1)


#sweep(X, MARGIN, STATS, FUN) #表示从矩阵X中按MATGIN计算STATS，并从X中除去(sweep out).
#减去中位数:
m
#     [,1] [,2] [,3] [,4]
#[1,]    1    4    7   10
#[2,]    2    5    8   11
#[3,]    3    6    9   12

row.med <- apply(m, MARGIN=1, FUN=median); row.med
sweep(m, MARGIN=1, STATS=row.med, FUN='-') #
sweep(m, MARGIN=1, STATS=1:3, FUN='+') #按行分别加上1 2 3
#     [,1] [,2] [,3] [,4]
#[1,]    2    5    8   11
#[2,]    4    7   10   13
#[3,]    6    9   12   15



(5)数据框操作
head(Puromycin)
str(Puromycin)
dim(Puromycin)

#变量之间的关系可以通过成对数据散点图考查
pairs(Puromycin, panel = panel.smooth)

#使用xtabs( )函数由交叉分类因子产生一个列联表:
xtabs(~state + conc, data = Puromycin)
xtabs(~state, data = Puromycin)

#取子集
subset(Puromycin, state == "treated" & rate > 160)
subset(Puromycin, conc > mean(conc))


#添加新列的三种方法。iconc=1/conc
a=head(Puromycin);a
#方法1
a$iconc=1/a$conc;a
#方法2：使用with
a$iconc=with(a,1/conc);a
#方法3：用transform( )函数, 且可一次性定义多个变量
a=transform(a, iconc=1/conc, sqrtconc=sqrt(conc));a



========================================
|-- 检查 vector 是否有重复，并去重
----------------------------------------
> genelist[duplicated(genelist)]

如果有重复
genelist_new<-unique(genelist)  #去除重复




========================================
|-- list完全可以作为R中的hash结构来使用(太低效)
----------------------------------------
Lists are the only key-value mapping type provided in base R: there are no dictionaries or associative arrays.
list是R语言中包容性最强的数据对象，几乎可以容乃所有的其他数据类型。
我们可以在一个列表中储存不同的类型数据，还可以储存不同的长度数据，每一个插槽中都是一个向量（vector）。
但是基于list的hash效率很低。

更高效的是使用 environment 来定义key是字符串的hash变量。其中hash包和hashmap包就是这么做的，但是...
##########
1. 尝试 R 中的hash结构：hash包和hashmap包都报错
install.packages("hashmap")
library("hashmap")
help(hashmap)
#
mydict = hashmap( keys=c(1,2,3),values=c(10,20,30) )
#Error in (function (env, objName)  : 
#  argument to 'findVar' is not an environment
mydict[["a"]]
# 也找不到解决办法。。。



#
##########
2. 探索尝试 list 能否保存长度不同的数据类型?可以。

#创建
#初始化一个list
mydict1=list(a=c(1,2,3),h=c(0))
class(mydict1)

#后文每一步都需要检查效果，后文每句后面都省略该命令
#1.直接查看，或者2.用str查看list的数据结构
mydict1 
str(mydict1)


#拼接一个字符串作为key，并赋值和引用
mydict1[[paste0('c',1)]]=data.frame(a=c(1,2,3), b=c(10,20,30))
mydict1[[paste0('c',1)]] #引用

#增加一个key并赋值，在末尾
mydict1[['c']]=100

#修改：重新对value赋值
mydict1[['a']]=c(12,34)

#修改：在向量value中插入新元素
mydict1[["h"]]=c(mydict1[["h"]], 15)

#修改：#对这个key的value进行自增
mydict1[['c']]=mydict1[['c']]+2

#获得键列表
names(mydict1) 

#检测是否有某个键，可以用于hash的自增
key="c2"
key="c1"
if(key %in% names(mydict1)){
  print(mydict1[[key]])
}else{
  print("Not in")
}

#删除某个key
mydict1[["a"]]=NULL #好吧，a的键值对都被删除了


#可以用数字直接查找，说明是有序的，不是真正的hash结构
mydict1[[2]] 


refer:
1.R's Lists and its Detestable Dearth of Data-Structures
https://www.refsmmat.com/posts/2016-09-12-r-lists.html

2.Environments
http://adv-r.had.co.nz/Environments.html



========================================
|-- R中拼接成的字符串做变量名，并赋值
----------------------------------------

assign( paste0("cell",1),100)
cell1

#但是怎么引用呢？
eval( 'a=paste0("cell",1)' ) #失败
#





========================================
控制结构（顺序、循环、条件）
----------------------------------------
#if, else, ifelse, switch:分支
#for, while, repeat, break, next:循环
#apply, lapply, sapply, tapply, sweep: 替代循环的函数
#
#function: 函数定义   source 调用文件
#call 函数调用
#.C   .Fortran 调用C或者Fortran子程序的动态链接库。Recall：递归调用；
#browser, debug, trace, traceback:程序调试：
#option:指定系统参数
#missing: 判断虚参是否对应实参
#nargs:参数个数   stop:终止函数执行
#eval(expr) 表达式计算
#system.time: 表达式计算计时
#menu: 选择菜单（字符列表菜单）
#

##分支语句
x=1;
if(x == 1) 
    print(x)
else print("not 1");

##分支语句2
s=1;
if(s == 1) {
  print(s)
}else if(s==2){
  print(2)
}else{
  print("last else");
}


##分支语句3switch
switch(statment, list) #首先判断条件的不同而执行不同的分支语句。
#首先执行statment，其返回值范围为1到list的长度。
#switch语句执行list中包含的语句，并将结果返回。
#例子：
case=TRUE;#TRUE==1
switch(case,
        {print("A")},
        {print("B")},
       {print("C")});
#将打印A

1>0#TRUE
1>2#FALSE
print(TRUE==1) #TRUE
print(FALSE==0)#TRUE
#经检验，TRUE就是数字1，FALSE就是数字0；


#######################
#for循环语句(类似js)
#
for(name in expr1){
  expr2;
}
#name:循环变量；
#expr1:一个向量表达式，如1:10;
#expr2:一组表达式；

x=0;
for(i in 1:5){
  x=x+1;
  print(x);
  if(x==3) break;#终止语句
}


#for循环，演示cat函数的用法；
for(n in c(1,2,3,4,5)){
  x=rnorm(n);
  #print(x)
  cat(n,":",x,"\n");#输出函数
  #cat();
  #cat(n, ":",x,":", sum(x^2), "\n");
}
#循环中，next 结束本次循环，继续下一次循环；break 跳出循环；


#######################
#while循环语句(类似js)
while(condition){
  expr
}

x=0;
while(x<=5){
  x=x+1
  print(x)  
}



#######################
#repeat语句
repeat{
  expr
}

x=0;
repeat{
  if(x<=5){
    x=x+1;
    print(x);
  }else
    break;
}









========================================
字符串
----------------------------------------
(1)获取字符串长度：nchar()能够获取字符串的长度，它也支持字符串向量操作。注意它和length()的结果是有区别的。
nchar(50); #2 字符串长度
length(50);#1 向量元素个数

(2)字符串粘合：paste()负责将若干个字符串相连结，返回成单独的字符串。其优点在于，就算有的处理对象不是字符型也能自动转为字符型。
paste0(a,b,c) 则能无缝连接字符串a和b和c。


> u=paste("hello world","R environment");u
[1] "hello world R environment"

> x=c("apple","google","microsoft","alibaba");x
[1] "apple"     "google"    "microsoft" "alibaba"  
> y=1:4
> y
[1] 1 2 3 4
> paste(x,y,sep='-')
[1] "apple-1"     "google-2"    "microsoft-3" "alibaba-4"  
> paste(x,y,sep='-',collapse='|')
[1] "apple-1|google-2|microsoft-3|alibaba-4"

> paste(x,y,sep=':',collapse=',') #输出json数据格式
[1] "apple:1,google:2,microsoft:3,alibaba:4" 


(3)字符串分割：strsplit()负责将字符串按照某种分割形式将其进行划分，它正是paste()的逆操作。
v=strsplit("this is a book."," ");v
[[1]]
[1] "this"  "is"    "a"     "book."

建议使用方式：
v=strsplit("this is a book."," ")[[1]];v
[1] "this"  "is"    "a"     "book."


> strsplit("This is Rstudio",'')[[1]];#分割成单字母
 [1] "T" "h" "i" "s" " " "i" "s" " " "R" "s" "t" "u" "d" "i" "o"

 
(4)字符串截取：substr()能对给定的字符串对象取出子集，其参数是子集所处的起始和终止位置。
Usage
	substr(x, start, stop)
	substring(text, first, last = 1000000L)
	substr(x, start, stop) <- value
	substring(text, first, last = 1000000L) <- value

> substr("abcdefg",0,4)
[1] "abcd"
> substr("abcdefg",1,4) #R语言中编号从1开始，与主流语言（C、java、php、Python）从0开始的惯例不同
[1] "abcd"
> substr("abcdefg",2,4)
[1] "bcd"

> substring("abcdefg",2)
[1] "bcdefg"


#首字母大写的函数
camelize=function(word){
  a1=toupper(substring(word,1,1));
  a2=substring(word,2);
  paste(a1,a2,sep="");
}
camelize('that')


refer:http://agetouch.blog.163.com/blog/static/22853509020146925220656/




(5)字符串替代：gsub(),sub().
gsub()负责搜索字符串的特定表达式，并用新的内容加以替代。sub()函数是类似的，但只替代第一个发现结果。
注：g是global全局的意思。


> x="this is a cat, I love cats."
> y=gsub("cat","dog",x)
> x
[1] "this is a cat, I love cats."
> y
[1] "this is a dog, I love dogs."
可见，原字符串并没有修改！只是返回新字符串。

> z=sub("cat","dog",x)
> x
[1] "this is a cat, I love cats."
> z
[1] "this is a dog, I love cats."#仅替换了第一个


(6)字符串匹配：grep()负责搜索给定字符串对象中特定表达式 ，并返回其位置索引。
grepl()函数与之类似，但其后面的"l"则意味着返回的将是逻辑值。
Usage
	grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
		 fixed = FALSE, useBytes = FALSE, invert = FALSE)

	grepl(pattern, x, ignore.case = FALSE, perl = FALSE,
		  fixed = FALSE, useBytes = FALSE)

	sub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
		fixed = FALSE, useBytes = FALSE)

	gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
		 fixed = FALSE, useBytes = FALSE)

	regexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
			fixed = FALSE, useBytes = FALSE)

	gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
			 fixed = FALSE, useBytes = FALSE)

	regexec(pattern, text, ignore.case = FALSE, perl = FALSE,
			fixed = FALSE, useBytes = FALSE)

#扫描文本
grep("the", scan("aa.txt", what="") );

#regexpr(pattern,x)#在字符串x中检索pattern，返回与pattern
#匹配的第一个子字符串的起始字符位置

regexpr("us","you_user_name_usa")
#返回首个与pattern匹配的字符串的其实位置

gregexpr("us","you_user_name_usa")
#返回所有与pattern匹配的字符串的其实位置


(7)大小写转化
text="This is China."
toupper(text)
tolower(text)
text #不影响原文

casefold(text,upper=FALSE) #转成小写
casefold(text,upper=TRUE) #转成大写
text #不影响原文

> DNA <- "AtGCtttACC" 
> tolower(DNA) 
[1] "atgctttacc" 
> toupper(DNA) 
[1] "ATGCTTTACC" 
> chartr("Tt", "Uu", DNA) 
[1] "AuGCuuuACC" 
> chartr("Tt", "UU", DNA) 
[1] "AUGCUUUACC" 





========================================
 |-- 正则表达式 Regular Expression
----------------------------------------
正则表达式具有神奇的功能，让你不得不用，并且每次用的时候都需要从新学习一遍。

量词：  *表示{0,},		 +表示{1,},	?表示{0,1}.

正则表达式语法规则
\ 转义字符
. 除了换行以外的任意字符
^ 放在句首，表示一行字符串的起始
$ 放在句尾，表示一行字符串的结束
* 零个或者多个之前的字符
+ 一个或者多个之前的字符
? 零个或者一个之前的字符
方括号[],代表可以匹配其中任何一个字符。而^在[]中代表“非”, -代表“之间”

– [qjk]:q,j,k中任意一个字符
– [^qjk]:非q,j,k的任意其它字符
– [a-z]:a至z中任意一个小写字符
– [^a-z]: 非任意一个a至z小写字符的其它字符(可以是大写字符)
– [a-zA-Z]:任意一个英文字母
– [a-z]+: 一个或者多个小写英文字母
| 或者
小括号()与花括号{}配合“|”使用

特别注意：保留字符都需要转义字符 \ 来转义表示

例如：
常用的特殊转义字符含义
  \n:换行符
  \t:tab
  \w:任意字母(包括下划线)或者数字 即 [a-zA-Z0-9_]
  \W:\w的反义 即[^a-zA-Z0-9_]
  \d:任意一个数字 即[0-9]
  \D:\d的反义 即[^0-9]
  \s:任意一个空格,比如space, tab, newline 等
  \S:\s的反义,任意一个非空格
  
     正则表达式的常用函数
  grepl:返回一个逻辑值
  grep:返回匹配的id，
  agrep:返回匹配的id，
  
  正则替换:sub和gsub， 两者的区别是前者仅替换一次，后者全局替换。

	regexpr:返回一个数字,1表示匹配,-1表示不匹配,以及两个属性,匹配 的长度和是否使用useBytes

	regexec:返回一个list,字符串中第一个匹配及其长度以及是否使用useBytes

	gregexpr:返回一个list, 每一个匹配及其长度以及是否使用useBytes
#


查找 grep
例1： 查找PD开头的基因名字
genes=c("TP53","PDL1","PDL2","PTEN","pd1")
genes[grep("^PD",genes,ignore.case=T)]
## [1] "PDL1" "PDL2" "pd1"


替换 gsub
例2：替换_为-
cnames=c("Row-1","Row-2","Row-3");
gsub("Row-",'Cell_', cnames) #[1] "Cell_1" "Cell_2" "Cell_3"


在每一个元素中，sub只替换一次，而gsub则全部替换。
cnames2=c("R-ow-1","R-ow-2","R-ow-3");
gsub("-",'_', cnames2) #"R_ow_1" "R_ow_2" "R_ow_3"
sub("-",'_', cnames2) #"R_ow-1" "R_ow-2" "R_ow-3"




分割 strsplit
例3：将一串基因字符分割成单个的基因构成的数组：
inputUp="C4BPB, BASP1,VIM,    BEX3, EMP3, PRSS21";
geneUp=strsplit(inputUp,'[^a-zA-Z0-9]+')[[1]];
geneUp
#[1] "C4BPB"  "BASP1"  "VIM"    "BEX3"   "EMP3"   "PRSS21"




http://www.tuicool.com/articles/2IfEj2j


========================================
|-- 将一个分数的字符串数字转换成数值: eval(parse(text="1/2"))
----------------------------------------
https://bbs.pinggu.org/thread-4961503-1-1.html


很有趣的问题。
先说答案：eval(parse(text="1/2"))

解释：这个问题本质上是说，如何计算字符串形式的算式。那么，这样想就比较容易找答案了。
先把字符串表示成expression，即parse(text="1/2")；
然后计算，eval(parse(text="1/2"))







========================================
函数：R语言是函数式编程的
----------------------------------------
在R语言中采用函数式编程。需要对R的函数进行深入的学习。


函数=函数名+参数
exp(1)
参数还可以接收向量：
exp( c(1,2,3,4) )

自定义函数
fn=function(){
	return(xx);
}


refer:
https://www.douban.com/note/279077707/
http://agetouch.blog.163.com/blog/static/22853509020146422625878/





========================================
|-- 一、R函数定义与调用，匿名函数与闭包
----------------------------------------
定义：
funcName=function(para[,para]){
	#many statements;
	return(something);
}

参数可以0到多个。
支持默认参数。

返回值可选，使用return则必须使用()，否则默认使用最后一个数字返回。

调用： 
funcName();#不带参数
funcName(1,2);#带参数


#函数本身也是是对象，可以查看其形参部分和函数体
formals(test)#查看形参列表
body(test)#查看函数体


#函数也可以不加{}
f1=function(x)x*2+3;
print( f1(2) )

#甚至这么写
f2=function(x)x
body(f2)=quote(x^3);#重新改写函数；
print( f2(3) )

#输入函数名，
page(nls) #查询函数代码；
edit(nls) #编辑函数代码；
#由于一些基本函数是C编写的，不能用上述方法查看和修改。



(1)函数声明与调用
func=function(){
	print("hello!")
}
func();

multi2=function(x,y){
	return(x*y);
}
multi2(5,6)#30


(2)允许函数嵌套。
add3=function(a,b,c){
	add2=function(x,y){
		return(x+y);
	}
	return(add2(add2(a,b),c))
}
add3(1,2,3) #6

(3)支持默认参数。
func1=function(x=10){
	print(x)
}

func1() #10
func1(25) #25

(4)默认返回最后一行表达式的值。
func2=function(){
	a=1
	b=2
	c=3
	c+a
}
func2() #4


(5)函数递归
累加
cumulate=function(n){
	if(n==1) return(1);
	return(n+cumulate(n-1))
}
cumulate(100);
[1] 5050

累乘(https://www.zhihu.com/question/43378587)
funr <- function(x) {
  return(ifelse(x>1, x*funr(x-1), x))
}
funr(5)
[1] 120



(10)返回函数的函数
outer=function(){
  x=2
  inc=function(increment){
    x=x+increment#并不能改变
    return(x)
  }
  inc; #返回函数
}

x=2
fn=outer()
fn(100) #102
fn(100) #102 #确实没有修改外函数中的x



(11)R语言版本的闭包：返回函数，并能私有的使用外函数的变量
(写过js的对闭包应该很熟悉)

x=1
outer=function(){
  x=2
  inc=function(increment){
    x<<-x+increment #能改变outer内的x值，因为 <<- 符号能穿透作用域，给上一层赋值。
    return(x)
  }
  get=function(){
    return(x)
  }
  set=function(a){
    x<<-a;
  }
  list(inc=inc,get=get,set=set);#返回函数列表
}
fns=outer()
fns2=outer() #两个闭包有着不同的环境，两个闭包中的变量不会共享。

str(fns)
fns$get() #2
fns$inc(100) #102
fns$get() #102
fns$set(-30)
fns$get() #-30
fns$inc(100) #70
fns$inc(100) #170
fns$get() #170
x #1
fns2$get() #2


2) 闭包，使用立即执行函数(function(){})()，节省代码。缺点：不能实例化多个实例了。
#立即执行函数
fns=(function(){
  x=10;
  get=function()x;
  set=function(a){
    x <<- a;
  }
  inc=function(i=1){
    x<<-x+i;
    x;
  }
  fns=list(get=get,set=set,inc=inc);
  return(fns);
})()
fns$get() #10
fns$set(0)
fns$inc(100) #100
fns$inc(10) #110
fns$inc() #111
fns$get() #111


3) 更精简的，函数内直接定义一个list，由于是最后一条语句，直接返回该list
fns=(function(){
  x=10;
  list(
    get=function()x,
    set=function(a){
      x <<- a;
    },
    inc=function(i=1){
      x<<-x+i;
      x;
    }
  )
})()

使用该方法，可以仿写类了。返回的就是一个类名。


refer:
1. 《高级R语言编程指南》, Hadley Wickham, 2016.
2. R语言学习1：R中的匿名函数、闭包与函数工厂 https://blog.csdn.net/hdyshr/article/details/82744681



========================================
|-- 二、变量的作用域, environment([fnName])
----------------------------------------
1.内函数可以取出外函数的变量
a=c(1,2);
fun0=function(){
  print(a);
}
fun0() #1 2
R语言采用的是Lexical Scoping(词法作用域)。词法作用域，又称静态作用域，即变量定义后的作用域是不变的。

函数里碰到一个变量时，如果在函数里有定义或者调用的时候给了定义，就用这个定义（这个和dynamic scoping一样）；
否则就到定义函数的环境里（不是被调用的环境）找，有定义的话就用那个定义（这个和dynamic scoping 不一样）；
实在找不到了才会给出error。

实例1：
x=1
fa=function(){
  x=2
  fi=function(){
    print(x)
  }
  x=3
  fi()
}

x=100
fa() 
#3

实例2：
f=function(x){
	g=function(y){
		y+z;
	}
	z=4;
	x+g(x)
}
z=10;
f(3)

我的结果是：
f(3)=3+g(3)=3+(3+z)=3+(3+4)=10


实例3：如果去掉函数内部的z赋值呢？
f=function(x){
	g=function(y){
		y+z;
	}
	x+g(x)
}
z=10;
f(3)
我的结果：
f(3)=3+g(3)=3+(3+z)=3+(3+10)=16 



2.但是内函数不能修改外函数的变量
a=c(1,2);
fun=function(){
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    b=c(b,100)
    a=c(b,200)
    print(a) #[1]   1   2   3   4 100 200 #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1  2  3  4 10
  #并没有改变
}

fun()
print(a) #[1] 1 2 #毫不影响

#a就属于全局变量；b就是局部变量；

顶层的a并没有改变，即使看起来在fun()中被修改了。只有fun()中局部变量a发生了改变。
实际上，局部变量a与相应的全局变量a共享一个内存地址，直到局部变量的数值发生了变化。
这种情况下，会分配给局部变量a新的内存地址。




3.再次尝试
a=c(1,2);
fun=function(){
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    b=c(b,100)
    #对上一个层次环境中的变量进行写操作 超级赋值符号<<-
    a<<-c(b,200) #这样就可以突破一层作用域，改变上层变量
    print(a) #[1]   3   4   5 100 200
    #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1   2   3   4 100 200
}

fun()
print(a) #[1] 1 2 #依旧毫不影响



4.想改变最外层的a怎么办？
在fun函数内使用一次<<-符号。
a=c(1,2);
fun=function(){
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    b=c(b,100)
    #对上一个层次环境中的变量进行写操作 超级赋值符号<<-
    a<<-c(b,200) #这样就可以突破一层作用域，改变上层变量
    print(a) #[1]   3   4   5 100 200
    #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1   2   3   4 100 200
  a<<-a #再次穿透一层作用域
}

fun()
print(a) #[1]    2   3   4 100 200 #也受到了影响



5.如果就是想在inner中修改最顶层作用域变量呢？
可以使用assign()向顶层赋值
a=c(1,2);
fun=function(){
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    b=c(b,100)
    a<<-c(b,200) #这样就可以突破一层作用域，改变上层变量
    
    #向顶层赋值函数assign()
    assign("a", a, pos=.GlobalEnv);#向顶层赋值
    
    print(a) #[1]   3   4   5 100 200
    #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1   2   3   4 100 200
}

fun()
print(a) # 1   2   3   4 100 200




6.这个作用域在R中怎么看？environment()
a=c(1,2);
print(environment()) #<environment: R_GlobalEnv>
fun=function(){
  print(environment()) #<environment: 0x000000001a8de318>
  b=c(a,3,4);
  a=c(b,10)
  inner=function(){
    print(environment()) #<environment: 0x000000001a8dd1b0>
    b=c(b,100)
    a<<-c(b,200) #这样就可以突破一层作用域，改变上层变量
    
    #向顶层赋值函数assign()
    assign("a", a, pos=.GlobalEnv);#向顶层赋值
    
    print(a) #[1]   3   4   5 100 200
    #内函数改变，仅在内函数有效
  }
  inner();
  print(a) #[1]  1   2   3   4 100 200
}

fun()
print(a)



7.本地有变量，想引用外部作用域中的变量怎么办？
a=c(1,2);
print(environment()) #<environment: R_GlobalEnv>
fun=function(){
  a=c(3,4);
  b=c(10,20);
  print(environment()) #<environment: 0x000000001aa14938>

  inner=function(){
    a=c(5,6);
    print(environment()) #<environment: 0x000000001aa13798>
    print(a) #[1] 5 6
    
    print(ls()) #输出当前局部变量名。 [1] "a"
    print(ls(envir=parent.frame(n=1)))#输出向上一个框架的局部变量名。[1] "a"     "b"     "inner"
	#ls.str()可以获得更多信息。
    #调整n则向上渗透。
    print(ls(envir=parent.frame(n=2)))#又向外渗透一层"a"   "fun"
  }
  inner()
}

fun()

只能看到，还是没取到，怎么取出外部变量值呢？
##############################
f1=function(){
  print(is.environment(.GlobalEnv));#[1] TRUE
  print(environment()) #<environment: 0x000000001b93be70>
}

outer=function(){
  f2=function(){
    print(is.environment(environment())); #[1] TRUE
    print(environment()) #<environment: 0x000000001b92cc18>
  }
  inner=function(){
    f1()
    print(environment(f2)) #<environment: 0x000000001b93d0f0> 这个打印的是f2的环境
    f2()
  }
  
  inner();
}

outer()
能打印出来变量、函数所处的环境hash，则应该也能取出来。很有启发性。

受到“R环境和变量作用域的问题  http://blog.csdn.net/thoixy/article/details/40503765”启发：
##############################
//下面终于取出来环境变量了
a=c(1)
f1=function(){
  print(a) #1
  #print(is.environment(.GlobalEnv));
  #print(environment())
}

outer=function(){
  a=c(200)
  f2=function(){
    print(a) #200
    #print(is.environment(environment()));
    #print(environment())
  }
  inner=function(){
    print(a) #2
    a=c(3)
    f1()
    ee=(environment(f2)) #获取f2的环境
    print(a) #3
    print(ee$a) #200  #从f2的环境中获取变量a
    
    e1=environment(f1);
    print(e1) #<environment: R_GlobalEnv>
    print( e1$a  ); #1
    f2()
  }
  
  inner();
}

outer()

注意，通过环境变量取出来的值是所在环境的变量，而不是环境内的变量。
所以遇到函数（要当成普通变量），要找并列的上下文，而不是找函数内部。

R如何理解变量和环境的Lexical Scoping Rule  http://blog.csdn.net/stat_elliott/article/details/45166481



8.小结
►关于全局变量
    R语言中全局变量的使用比想象中的要多。R语言自身内部大量使用了全局变量，物理上其C语言代码还是R例程，对于这点你也许会感到惊讶。例如，超赋值运算符<<-用于许多R语言函数中(尽管通常只对上一级环境层次中的变量进行写操作)。线程化(Threaded)代码和GPU代码倾向于大量使用全局变量，这为并行对象提供了主要的通信途径。两者均用于编写高性能程序。
 
►关于“闭包”
    R语言中“闭包”包含了函数的参数、函数体以及调用时的环境。有一种编程方法是用闭包包括环境，这种编程方法使用的特性也叫做“闭包”。
    闭包包含了一个可创建局部变量的函数，并创建另一个函数可以访问该变量。



	
	
========================================
|-- 三、自定义二元运算符: "%myname%"=function(){}
----------------------------------------
#以为%开始和结束，函数的参数和返回值都是某种数据类型

"%myname%"=function(a,b)return(a^b)
2%myname%10   #1024






========================================
|-- R语言的函数中的特殊参数"..."
----------------------------------------
1. ...参数是一种特殊的参数，表明一些可以传递给另一个函数的参数。
常用于当你需要扩展另一个函数，而你又不想复制原函数的整个参数列表时。

如下例，你希望修改plot()函数中的个别参数，而其他参数保持不变，将其应用于一个新定义的函数中myplot()：
myplot <- function(x, y, type = "l", ...) {
    plot(x, y, type = type, ...) ## Pass '...' to 'plot' function
}


更拗口的一个说法: “...”用来引用从被调用函数传递下来的参数。当所有匹配“...”的参数来自特定的类或者特定类的子类，为这些函数定义的方法会被选择和调用。
fun1 <- function(data, data.frame, graph=TRUE, limit=20, ...) {
  [omitted statements]
  if (graph)
    par(pch="*", ...)
  [more omissions]
}





(2)获取这些参数

当一个函数需要引用“...”中的成分时，表达式列表list(...）将获取所有这样的参数，返回的是一个命名列表。

例
x = function(a){2*a}
y = function(a, b){a+b}
#定义新函数，用到旧函数
z = function(c, ...){
  args = list(...)
  return(x(args$a) + y(args$a, args$b) +c)
}
z(c = 2, b = 2, a =2 ) #2*2+(2+2)+2=10




2.在泛型函数（generic function）中，...还有另一种用法，它的作用是根据数据类型使用合适的方法

泛型函数是一个函数族，其中的每个函数都有相似的功能，但是适用于某个特定的类。
> mean
standardGeneric for "mean" defined from package "base"

function (x, ...) 
standardGeneric("mean")
<environment: 0x0000000003049880>
Methods may be defined for arguments: x
Use  showMethods("mean")  for currently available ones.




3. 还有一种情况下，...参数必须使用：
那就是，当传递到函数的参数数量不能事先确定的时候。

比如paste()函数，他的作用是将一连串字符串连接起来，然后新建一个字符串或向量，所以无法预知参数个数：
> args(paste)
function (..., sep = " ", collapse = NULL) 
NULL


还有cat()函数，它的功能是和paste相似，也是连接字符串。
> args(cat)
function (..., file = "", sep = " ", fill = FALSE, labels = NULL, 
    append = FALSE) 
NULL


注意：任何出现在...之后的参数列表必须明确的给出名称。而且不能够部分匹配或位置匹配。
比如，paste() 指定参数后，后面的分隔符sep参数必须使用完整形式，不能省略。
paste('a','b',sep=":") #"a:b"
paste('a','b',":") #"a b :" 不符合预期。






refer:
https://blog.csdn.net/Intelligebce/article/details/83958973



========================================
 |-- 函数的调试debug 和性能分析 system.time()
----------------------------------------

一、函数的调试 debug
1.手动添加 print(xx)， 随时查看变量，判断出错位置。
缺点：比较繁琐，特别是程序较长的时候。

2.使用R的调试工具。
(1) debug(f)函数可以把函数f()设置成调试状态，意味着每次调用f()都会进入这一状态。
取消这一状态需调用 undebug(f)。
在2.10版本之后，可以使用 debugonce()代替，仅检查漏洞一次。


(2)程序调试工具还能跟踪运行步骤，进而加深对程序处理过程的理解

#递归的原理：将x类型的原始问题降级为一个或划分为若干个更小的同类型问题，然后对每个较小问题调用f()函数自身，直到达到终止条件，再将各个小问题的结果向上返回并整理来解决问题。

#递归算法排序
qs=function(x){
  if(length(x)<=1) return(x)
  pivot=x[1]
  therest=x[-1]
  sv1=therest[therest<pivot]
  sv2=therest[therest>=pivot]
  sv1=qs(sv1)
  sv2=qs(sv2)
  return(c(sv1,pivot,sv2))
}
a=c(8,7,20,9,45,3)
qs(a)
# [1]  3  7  8  9 20 45

#使用调试工具，跟踪代码
#trace code
debugonce(qs)
qs(a)
然后回车查看下一步，或者输入变量回车，查看当前变量的值。




二、性能优化
https://www.zhihu.com/question/23589055
1.跟踪运行的时间
add=function(a,b){
	return(a+b)
}

方法1：
time1=Sys.time();
add(1,2);
time2=Sys.time();
print(paste("消耗时间",time2-time1));


方法2：【推荐】
system.time(add(1,2))
用户user 系统system 流逝elapsed 
0.10 0.00 0.09 


三个数字分别表示 
user:消耗在应用程序（非操作系统部分）执行的时间；
system: 低层操作系统执行（如磁盘读写等）部分的时间；
elapsed:是经过的总时间（可以认为是前两者的总和）。
一般优化时主要关注user时间。





2.避免使用for循环，优先使用向量化操作

x=runif(1e6)
y=runif(1e6)

#向量化
system.time(z<-x+y) #这里不能使用=，否则会被认为是传入的参数而报错
# 用户 系统 流逝 
# 0.01 0.00 0.02 

#for循环
z=vector(length=1e6)
system.time(for(i in 1:length(x)) z[i]=x[i]+y[i])
# 用户 系统 流逝 
# 0.13 0.00 0.12 #为什么elapse比user还小呢？不清楚


可见，向量化0.01s运行速度远远高于for循环的0.13s。

当然，速度的提升是以更多内存消耗为代价的。时间和空间的权衡经常无法避免。






========================================
 |-- R语言中do.call()的用法
----------------------------------------
简单参数设置就能搞定的事情，是不会用到do.call的。

某些情况下，你知道某个函数接受参数的明确个数，但是太多了，你懒，所以用do.call；但更多的情况是你迫不得已，必须用它。

虽然R语言有类型很丰富的数据结构，但是很多时候数据结构比较复杂，那么基本就会用到list这种结构的数据类型。但是list对象很难以文本的形式导出，因此需要一个函数能快速将复杂的list结构扁平化成dataframe。这里要介绍的就是do.call函数。


do.call 构造并执行来自字符串名称或直接函数调用来的函数, 并将其传递给它的参数列表。参数列表 即 list, 所以 do.call 针对的就是 list。




?do.call
## Description
## do.call constructs and executes a function call from a name or a function and a list of arguments to be passed to it.
## Usage
## do.call(what, args, quote = FALSE, envir = parent.frame())
what可以是一个函数也可以是一个 字符串形式的函数名称(eg. kmeans or ‘kmeans’). 
args 供函数调用的参数设置，这些参数都将被 what 识别并调用. 
quote 逻辑值, 是否引用参数. 
envir 评估函数调用时所处的环境. 对于what是字符串形式函数名称且对应的参数都是符号或者引用的表达式时会非常有用.





1.例1
aa 		<- 	data.frame(matrix(1:25, ncol = 5), matrix(4:28, ncol = 5), matrix(21:45, ncol=5))
aa
aa_sum 	<- 	do.call(sum,aa);aa_sum #[1] 1550
aa_bind <-	do.call(cbind,aa);aa_bind #拿出来每列，按照列合并，所以和aa一模一样，不过是"matrix"
#

bb 		<- 	list(matrix(1:25, ncol = 5), matrix(4:28, ncol = 5), matrix(21:45, ncol=5))
bb
bb_sum 	<- 	do.call(sum,bb);bb_sum #[1] 1550
bb_bind <-	do.call(cbind,bb);bb_bind #把list的每一个元素拿出来，列之间合并，变宽了。

#list和data.frame都是可以的
#do.call(fn, list) 是告诉list一个函数fn，然后list里的所有元素来执行这个函数。
# 不过一定要拿下，这是晋级的方法
# https://www.douban.com/note/589741782/



例2：生成数据框
x1 = 1:10
x2 = 11:20
x3 = 21:30
data.frame(x1,x2,x3) #返回三列构成的数据框
# 基本等价于
do.call("data.frame",list(x1,x2,x3)) #把list中每个元素拿出来，给函数data.frame(理论上传无限参数)
# https://www.jianshu.com/p/078071c12e77



例3：定义复数
complex(imag=1:3)
# 等价于
do.call("complex", list(imag = 1:3))



例4：用kmeans给每一行元素贴一个标签
set.seed(100)
t1=do.call('kmeans',list(x=iris[,1:4],centers=3))
t1$cluster
# 等价于
set.seed(100)
t2=kmeans(x=iris[,1:4],centers=3)
t2$cluster



例5：画列之间的相关系数热图
library(corrplot)
do.call('corrplot.mixed',list(cor(iris[,1:4])))



2.简单的讲，do.call 的功能就是执行一个函数，而这个函数的参数呢，放在一个list里面, 是list的每个子元素。
> tmp <- data.frame('letter'=letters[1:8],number=seq(1:8), 'value' = c('+','-'))
> tmp
  letter number value
1      a      1     +
2      b      2     -
3      c      3     +
4      d      4     -
5      e      5     +
6      f      6     -
7      g      7     +
8      h      8     -
> tmp[[1]]
[1] a b c d e f g h
Levels: a b c d e f g h
> tmp[[2]]
[1] 1 2 3 4 5 6 7 8
> tmp[[3]]
[1] + - + - + - + -
Levels: - +
> do.call('paste', c(tmp, sep=""))
[1] "a1+" "b2-" "c3+" "d4-" "e5+" "f6-" "g7+" "h8-"
#
这里的tmp使用data.frame函数创建的，其实它本质上还是一个list，这里分别用[[]]符号显示他的2个元素，可以看到do.call函数把tmp的3个元素（3个向量）作为paste函数的参数。这个例子我们也可以这样写：

> paste(tmp[[1]],tmp[[2]],tmp[[3]], sep = "")
[1] "a1+" "b2-" "c3+" "d4-" "e5+" "f6-" "g7+" "h8-"

但是：为什么这样不行呢？
> do.call('paste', list(tmp,sep="") ) 
[1] "1:8"                       "1:8"                       "c(2, 1, 2, 1, 2, 1, 2, 1)"





3.例: 使用list()单独设置函数的参数列表，然后再用do.call("pheatmap", hm.parameters )的形式执行。
plotCycle <- function  ( phaseCorsMatrix ) {
    library("pheatmap")
    library("RColorBrewer")
    breaks <- seq ( -1 , 1 , length.out = 31 )
    heatColors <- rev (brewer.pal ( 9, 'RdBu'))
    heatColors <-colorRampPalette(heatColors)
    colorPallete <- heatColors((length ( breaks ) - 1 ))
    
    # create heatmap
    hm.parameters <- list(phaseCorsMatrix,
    color = colorPallete,
    breaks = breaks,
    cellwidth = NA, cellheight = NA, scale = "none",
    treeheight_row = 50,
    kmeans_k = NA,
    show_rownames = T, show_colnames = F,
    main = "",
    clustering_method = "average",
    cluster_rows = FALSE, cluster_cols = FALSE,
    clustering_distance_rows = "euclidean",
    clustering_distance_cols = NA ,
    legend = T , annotation_legend = F )
    
    do.call("pheatmap", hm.parameters )
}


4.例










refer:
https://bbs.pinggu.org/thread-3802000-1-1.html




========================================
|-- 调试函数 stop('sth')
----------------------------------------
相当于断言

fn2=function(x=2){
  print('line1')
  if(x<0){
    stop( paste('Stoped here: x should be greater than 0; but x=',x) )
  }
  print('line2')
}
fn2(10)
fn2(-1)




========================================
 |-- 高阶函数: apply家族函数
----------------------------------------
高阶函数就是操作函数的函数。可能参数是函数，也可能返回函数。具有一定的抽象性。

#apply, lapply, sapply, tapply, sweep: 替代循环的函数

1.apply函数
作用：Apply Functions Over Array Margins对阵列行或者列使用函数
用法：apply(X, MARGIN, FUN, ...)

(1)按行求和:apply第二个参数为1
a=array(c(1,2,3,4,5,6),c(2,3))
a
#[,1] [,2] [,3]
#[1,]    1    3    5
#[2,]    2    4    6

#一行代码搞定
apply(a,1,sum) #[1]  9 12

#fn内用循环实现的话
rs=apply(a,1,function(data){ #1是按行传入。
  sum=0
  for (i in data) {
    sum =sum+i
  }
  print(sum)
  return(sum)
})

print(rs) #[1]  9 12 结果是个数组



(2)按列求和:apply第二个参数为2
a=array(c(1,2,3,4,5,6),c(2,3))
a
#[,1] [,2] [,3]
#[1,]    1    3    5
#[2,]    2    4    6

#一行代码搞定
apply(a,2,sum) #[1]  3  7 11

#fn内用循环实现的话
rs=apply(a,2,function(data){ #2是按列传入。
  sum=0
  for (i in data) {
    sum =sum+i
  }
  print(sum)
  return(sum)
})

print(rs) #[1]  3  7 11 结果是个数组
str(rs)  #num [1:3] 3 7 11






2.lapply函数
作用：Apply a Function over a List or Vector 对列表或者向量使用函数
用法：lapply(X, FUN, ...) X表示一个向量或者表达式对象，其余对象将被通过as.list强制转换为list

b=list(x=1:10,y=exp(-3:3),z=c(TRUE,FALSE));b
#$x
#[1]  1  2  3  4  5  6  7  8  9 10

#$y
#[1]  0.04978707  0.13533528  0.36787944  1.00000000  2.71828183  7.38905610 20.08553692

#$z
#[1]  TRUE FALSE

rs=lapply(b,mean)

print(rs)
str(rs)
#List of 3
# $ x: num 5.5
# $ y: num 4.54
# $ z: num 0.5






3.sapply函数
描述：Apply a Function over a List or Vector 对列表或者向量使用函数
用法：sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)

这是一个用户友好版本，是lapply函数的包装版。该函数返回值为向量、矩阵，如果simplify="array"，且合适的情况下，将会通过simplify2array()函数转换为阵列。sapply(x, f, simplify=FALSE, USE.NAMES=FALSE)返回的值与lapply(x,f)是一致的。

USE.NAMES逻辑值，如果为TRUE，且x没有被命名，则对x进行命名。

a=array(c(1,2,3,4,5,6),c(2,3))
a

b=list(x=1:10,y=exp(-3:3),z=c(TRUE,FALSE));b

rs=sapply(b,function(data){
  print(data)
})

print(rs)
str(rs)



4.sweep主要用于array的一些分类计算，而apply更多的是矩阵计算，data.frame也行。array是高于2维的数据


http://blog.csdn.net/yitianguxingjian/article/details/51820758


========================================
|-- split() 函数： Divide into Groups and Reassemble
----------------------------------------
Divide into Groups and Reassemble | 重新组合

函数split()可以按照分组因子，把向量，矩阵和数据框进行适当的分组。它的返回值是一个列表，代表分组变量每个水平的观测。这个列表可以使用sapply(),lappy()进行处理（apply – combine步骤），得到问题的最终结果。

只是分组，既可以对向量分组，也可以对数据框分组

Usage
split(x, f, drop = FALSE, ...)
## Default S3 method:
split(x, f, drop = FALSE, sep = ".", lex.order = FALSE, ...)

split(x, f, drop = FALSE, ...) <- value
unsplit(value, f, drop = FALSE)

参数
x: 一个待分组的向量或者data frame
f: 函数，一个factor或者list（如果list中元素交互作用于分组中），以此为规则将x分组
drop: 逻辑值，如果f中的某一个level没有用上则被弃用
value: 一个储存向量的list，其形式类似于分组完成之后返回的那个list



例1：
> d <- data.frame(gender=c("M","M","F","M","F","F"),age=c(47,59,21,32,33,24),income=c(55000,88000,32450,76500,123000,45650), over25=rep(c(1,1,0), times=2))
> d
  gender age income over25
1      M  47  55000      1
2      M  59  88000      1
3      F  21  32450      0
4      M  32  76500      1
5      F  33 123000      1
6      F  24  45650      0

> split(d$income, list(d$gender,d$over25)) #将income按照gender、over25分组
$`F.0`
[1] 32450 45650
$M.0
numeric(0)
$F.1
[1] 123000
$M.1
[1] 55000 88000 76500


然后配合 apply 家族函数求每组的mean
> lapply(split(d$income, list(d$gender,d$over25)),mean)
$F.0
[1] 39050

$M.0
[1] NaN

$F.1
[1] 123000

$M.1
[1] 73166.67





例2：
> split(1:10, 2)
$`2`
 [1]  1  2  3  4  5  6  7  8  9 10

> split(1:10, 1:2) #分成2组
$`1`
[1] 1 3 5 7 9

$`2`
[1]  2  4  6  8 10

> split(1:10, 1:5) #分成5组
$`1`
[1] 1 6

$`2`
[1] 2 7

$`3`
[1] 3 8

$`4`
[1] 4 9

$`5`
[1]  5 10




========================================
|-- R语言数据整合- aggregate() 将数据进行分组（按行）然后每组做统计，有点类似sql语言中的group by
----------------------------------------

1.
## S3 method for class 'data.frame'
aggregate(x, by, FUN, ..., simplify = TRUE, drop = TRUE)
## x：待折叠的数据 by:统计标量   FUN 折叠计算  

例
> aggregate(diamonds,by=list(cutType=diamonds$cut), FUN=mean) #by 必须是list
##     cutType     carat cut color clarity    depth    table    price        x        y        z
## 1      Fair 1.0461366  NA    NA      NA 64.04168 59.05379 4358.758 6.246894 6.182652 3.982770
## 2      Good 0.8491847  NA    NA      NA 62.36588 58.69464 3928.864 5.838785 5.850744 3.639507
## 3 Very Good 0.8063814  NA    NA      NA 61.81828 57.95615 3981.760 5.740696 5.770026 3.559801
## 4   Premium 0.8919549  NA    NA      NA 61.26467 58.74610 4584.258 5.973887 5.944879 3.647124
## 5     Ideal 0.7028370  NA    NA      NA 61.70940 55.95167 3457.542 5.507451 5.520080 3.401448





2.
## S3 method for class 'formula'
aggregate(formula, data, FUN, ...,
          subset, na.action = na.omit)
## 第一个参数也可以输入表达式

例
> aggregate(price~cut,diamonds, FUN=mean)
        cut    price
1      Fair 4358.758
2      Good 3928.864
3 Very Good 3981.760
4   Premium 4584.258
5     Ideal 3457.542






========================================
 |-- 数据拟合函数
----------------------------------------

1.非线性拟合 nls()函数
x=1:12;x
y1=c(7098.00, 7498,7848,8254,8761,8801.12,8951.32,9325.03,9680.90,10200,11000,12360.74)
plot(y1~x, col="red")

fit1=nls(y1~a*b^x, start=list(a=1,b=2))
lines(seq(1,12,by=0.1), predict(fit1, data.frame(x=seq(1,12,by=0.1))), col="#0096ff", lty="dotted" )
#end








========================================
R语言面向对象(OOP)初步: S3, S4 类
----------------------------------------
R的面向对象编程是基于泛型函数(generic function)的，而不是基于类层次结构。

假设之前读者已经对封装、继承、多态等OOP比较熟悉，只是对R语言的OOP不熟悉。
如果不知道OOP基础，请自定百度并学习Java的OOP介绍部分。

R语言简介1-4：函数与面向对象初步
http://agetouch.blog.163.com/blog/static/22853509020146422625878/
R语言简介1-6：面向对象OOP
http://agetouch.blog.163.com/blog/static/228535090201651975827664/


更多内容，请看本博客的R OOP专题。


========================================
文件I/O
----------------------------------------

0. 本文件内读取示例数据
(1)
Input =("
        Distance    Trill  No.trill
        10m        16     8
        100m        3    18
        ")
Matriz = as.matrix(read.table(textConnection(Input),
                              header=TRUE,
                              row.names=1))
Matriz
#     Trill No.trill
#10m     16        8
#100m     3       18




#(2)更简洁的写法：
# 直接在程序中嵌入数据
mydatatxt="
age gender
1 M
2 F
3 F
"
mydata=read.table(text=mydatatxt, header=T) # text设置了，file就要留空。
mydata
#  age gender
#1   1      M
#2   2      F
#3   3      F


以上适合小数据及，大型数据集还是要从文件读取。







1.一次全部读入内存：

(1)读入数据框：
fileName="D:/coding/Java/CCDS.20160908.txt";
#a=read.table(choose.files(),sep = '\t',stringsAsFactors = F,header = T)# 选择你下的CCDs文件
a=read.table(fileName,sep = '\t',stringsAsFactors = F,header = T)# 选择你下的CCDs文件


(2)读入一列基因名字:
geneList2=readLines("geneList2.txt")



R认为短横线-是无效的，所以如果读入的列名中包含了-，它会默认将其替换为. ，目的是确保能及时检验是否出现重复的列名。






2.R语言逐行读取并处理大文件最好逐行读取。  

用R语言作分析时，有时候需要逐行处理非常大文件，各种教材中推荐的read.table 和scan都是一次性读入内存，如果文件有好几个Gb大小，一般电脑肯定吃不消。其实R中可以逐行读取的行数，这里示例一个函数，作为备忘：

con <- file("e:/data.txt", "r")
line=readLines(con,n=1)
while( length(line) != 0 ) {
     print(line)
     line=readLines(con,n=1)
}
close(con)

如果需要将一行的文字劈成多段，再进行处理，可以用strsplit函数，除此之外，还有一些常用的字符串处理函数，记录如下：
substr(),nchar(), grep(), regexpr(), sub(), gsub()


这样在异常时可能不能及时关闭资源，有博文建议如下方式写：
http://stackoverflow.com/questions/6304073/warning-closing-unused-connection-n

getCommentary <- function(filepath) {
    con <- file(filepath) 
    on.exit(close(con)) #这样，不管函数因为什么原因结束，都会关闭该资源链接。
    Commentary <-readLines(con)
    Commentary
}

getCommentary("foo.txt")






3.数据对象从内存-硬盘之间读写
str(ttr.varSD)
## List of 4 ...

内存写入硬盘：
save(ttr.varSD, file='ttr.varSD.RDS')

硬盘读入到内存：
aa=readRDS('ttr.varSD.RDS')


(2) 把id写入文件，一个id一行，不要行列标题
write.table(rownames(tmp),file="xx.Right.cellID",
            quote=F,row.names = F,col.names = F)




4.读取外部函数源码文件：source("xx.R")










========================================
********** 第二部分：统计学 （前4章） **********
----------------------------------------
略。详情看单列笔记。






========================================
********** 第三部分：画图 ********** 
----------------------------------------
略。详情看单列笔记。





========================================
********** 第四部分：包 ********** 
----------------------------------------

1.选择使用哪个镜像：
setRepositories()



2. 查看当前加载的包
(.packages()) 

## To see the list of currently loaded packages use
search() #相比上句少了几个



(2) 卸除已加载的包
如卸除RMySQL包
>detach('package:RMySQL')


注意是卸除，不是卸载，也就是说不是把包从R运行环境中彻底删除，只是不希望该包被加载使用。

在包使用函数冲突，检验函数依赖时比较有用。


>detach('package:ggplot2')
在升级该包时，不能是加载状态，如果不想重启Rstudio，就可以先卸除该包，再执行安装命令，安装新包。




3. 如何查看R语言package中自带哪些数据集以及各个数据集的描述？
(1) 查看R内置数据集
data()
## Data sets in package ‘datasets’:
...

(2)查看包中的数据集
print(data(package='具体的package名'))
例如：
print(data(package='fda'))
通过上述命令，就可知道具体的package中包含的datasets。

(3)对于某个特定的数据集，我们可通过命令
?数据集名称
来进一步了解数据集，如对于fda包中的数据集CanadianWeather，可用?CanadianWeather 查看该数据集的详细描述。




4. 查看R包的引用路径
> .libPaths() 
## [1] "/home/wangjl/R/x86_64-pc-linux-gnu-library/3.4"
## [2] "/usr/local/lib/R/site-library"                 
## [3] "/usr/lib/R/site-library"                       
## [4] "/usr/lib/R/library" 











========================================
如何获得R包的全部函数名字？
----------------------------------------
1. library(help = datasets) # Get the list of functions in the package
library(help = ggplot2) 
#自动打开新标签，向下滚动，找到 索引。

或只看索引
x <- library(help = ggplot2)
x$info[[2]]



2. ls("package:datasets") will list all the objects in the package
只看base基础包函数名可以 ls("package:base")



3. List Objects and their Structure
>library(ggplot2)
#Need help? Try Stackoverflow: https://stackoverflow.com/tags/ggplot2.
> lsf.str("package:ggplot2") #List Objects and their Structure



4. help(package="程序包名") #打开web帮主页
help(package="ggplot2")
help(package="pasilla")



5. If you want all exported functions (i.e. functions accessible via ::), then getNamespaceExports(pkgName) will do the trick.

If you want all functions in the package, including the ones accessible via :::, you can do ls(getNamespace(pkgName)).

getNamespaceExports('ggplot2')




refer:
https://stackoverflow.com/questions/20535247/seeking-functions-in-an-r-package









========================================
R操作mysql数据库
----------------------------------------

1. 把mysql连接信息写到文件中。
$ cat /home/wangjl/pylib/con_mysql.R
library(DBI)
library(RMySQL)
con<-dbConnect(MySQL(),user='root', password='123456',dbname='wang',host='y.biomooc.com',
               port=7070, DBMsencoding='utf8')
dbSendQuery(con,'SET NAMES utf8;') #读取防乱码
query<-dbSendQuery(con,'alter database wang character set utf8;') #写入防乱码
#
#query<-dbSendQuery(con,'select cid, cellType from cell_c1 where cellType="HeLa_sync"')
#data=fetch(query, n=-1);
#data




2. 把数据查询写成函数
#R语言的数据库链接
rm(con)
getDF_fromDB=function(sql){
  source('/home/wangjl/pylib/con_mysql.R')
  query<-dbSendQuery(con, sql );
  data=fetch(query, n=-1);
  #
  print(dim(data))
  print(head(data))
  return(data)
}



# 获取编码基因，和非编码基因
sql=paste0('select distinct gene_name,gene_type from feature_gene;');
geneNames=getDF_fromDB(sql)
# [1] 58692     2
#   gene_name      gene_type
# 1    TSPAN6 protein_coding
# 2      TNMD protein_coding
# 3      DPM1 protein_coding
# 4     SCYL3 protein_coding





========================================
|-- R通过ODBC连接数据库(win)
----------------------------------------
以下的实验环境是在windows7-64操作系统下进行
1、下载（mySQL-connector-odbc-5.3.7-win64.msi）
     下载地址：http://dev.mysql.com/downloads/connector/odbc (8.2 MB) 
2、安装Mysql的RODBC：mysql-connector-odbc-5.3.2-win64.msi
3、配置datasource

(1)找到C:\Windows\System32\odbcad32.exe
(2)左侧点击 添加 ，选择MySQL ODBC ANSI Driver/或 unicode，点击完成；
(3)填写表格，名字(填写mysqlodbc或自定义，下文R的odbcConnect第一个参数要用)建议用无空格的英文，描述随便写，填写mysql用户名和密码，选择数据库，点击OK。
(4)回到ODBC数据源管理器，选择mysqlodbc，点击确定。

4.R软件访问mysql数据库
(1)安装及加载RODBC
install.packages("RODBC")
library(RODBC)

(2) 与mysql建立连接
channel=odbcConnect("mysqlodbc", uid="root", pwd="")

（3）查询该数据库下都有哪些数据库表

> sqlTables(channel)
  TABLE_CAT TABLE_SCHEM   TABLE_NAME TABLE_TYPE REMARKS
1      test                       aa      TABLE        
2      test              first_table      TABLE        
3      test             second_table      TABLE        
4      test                 students      TABLE 
5      test                 orders      TABLE   

（4）查询某个表中的数据返回给数据框
> orders=sqlFetch(channel,"orders")
> orders
 order_id order_name order_unit order_quantity order_price order_note order_time
1 1  2500ml95%酒精  桶  17 12  NA 1464

（5）条件查询
orders2=sqlQuery(channel,"select order_name,order_price from orders order by order_id desc");

（6）将数据框中的数据保存到数据库表中
USArrests #这是R的默认内置数据，是一个数据框

数据框的首列没有列名，所以在保存之前需要指定列名
sqlSave(channel, USArrests, rownames = "state", addPK = TRUE)

cmd打开数据库查看test库，多了usarrests表，里面正是数据框中的内容。可见数据框能正确的保存到mysql数据库中去了

添加一条数据
rs3=sqlQuery(channel,"insert into usarrests(state,murder,assault,urbanpop,rape)values('noplace',0,0,0,0)");
发现数据已经在了。

（7）在R软件将刚才添加到mysql数据库中的表删除掉
sqlDrop(channel,"usarrests")

（8）关闭连接资源
odbcClose(channel)

（9）通过RODBC进行数据存取的主要函数
函数名字	函数描述
odbcConnect(dsn,uid="",pwd="")  #建立并打开连接
sqlFetch(channel,sqtable) #从数据库读取数据表，并返回一个数据框对象
sqlQuery(channel,query) #想数据库提交一个sql查询，并返回结果（'data.frame'格式）
sqlSave(channel,mydf,tablename=sqtable,append=FALSE) #将一个数据框写入或更新(append=True)到数据库
sqlDrop(channel,sqtable) #从数据库删除一个表
sqlClear(channel,sqltable) #删除表中内容
sqlTable(channel) #返回数据库中表的信息
sqlColumns(chanel,sqltable) #返回数据库表sqltable列的信息
close(channel) #关闭连接

操作步骤：
建立DSN
打开连接
数据操作
关闭连接 


实例1
#加载包
library(RODBC)

#创建连接
channel<-odbcConnect("BITEST",uid="dw",psw="dw")

#执行查询
org1<-sqlFetch(channel,'DIM.DIM_ORGANIZATION') #这是oracle数据库
org2<-sqlQuery(channel,"select * from DIM.DIM_ORGANIZATION")

#关闭连接
odbcClose(channel)

#使用数据
head(org1)
head(org2)



实例2 通过RODBC将数据写入oracle

library(RODBC)
channel<-odbcConnect("BITEST",uid="dw",psw="dw")
#创建数据，待写入对象
mydata<-sqlQuery(channel,'select * from DIM.DIM_ORGANIZATION')

#写入数据库，并读取结果
sqlSave(channel,mydata,"NEW_TABLE_NAME", append=FALSE)
mydata2=sqlQuery(channel,'select * from NEW_TABLE_NAME')

#更新数据库，并读取结果
sqlSave(channel,mydata,"NEW_TABLE_NAME", append=TRUE)
mydata3=sqlQuery(channel,'select * from NEW_TABLE_NAME')

#删除刚刚建立的数据表NEW_TABLE_NAME
sqlDrop(channel,"NEW_TABLE_NAME")
odbcClose(channel)

#查看执行结果
head(mydata,n=30)
head(mydata2,n=30)
head(mydata3,n=30)


refer:
http://wenku.baidu.com/link?url=PtNUOCT66CzajvN_uM_4FaCloQffW8HzaE1PMlOg3UqyXwpZNbT3DC1URy-tsLqQRIeW_DJhxBsS06QsY99OjKSq_BV7--vj1zWhtga7k1_
http://blog.csdn.net/hongweigg/article/details/49779943
http://www.dataguru.cn/thread-289411-1-1.html





========================================
|-- R通过RMySQL包操作mysql数据库(linux)
----------------------------------------
test: 2019.10
mysql on docker ubuntu1806;
Rstudio on centOS7


1.Rmysql库安装
注意: Rmysql库依赖DBI库

install.packages("DBI")
install.packages("RMySQL") 或 install.packages('RMySQL',type='source')

查看已安装的包：
.packages(all.available=TRUE)

至此安装完毕,如果中间过程还出问题,可能底层C++环境欠缺
参考:https://www.jianshu.com/p/d57355c57876






2.
另外R连接mysql会出现中文乱码变问号情况，查到COS上一个贴子，解决方案如下：
在MySQL的配置文件/etc/mysql/my.cnf中[client]标签下加default-character-set=utf8 

这个我试了，总是报错。我用的docker版的mysql，是这个原因吗？
后面避免读写中文乱码，使用的是sql语句。

library(DBI)
library(RMySQL)
con<-dbConnect(MySQL(),user='root', password='123456',dbname='wang',host='y.biomooc.com',
               port=7070, DBMsencoding='utf8')
dbSendQuery(con,'SET NAMES utf8;') #读取防中文乱码
query<-dbSendQuery(con,'alter database wang character set utf8;') #写入防中文乱码
#
query<-dbSendQuery(con,'select * from fruits;')
data=fetch(query);
data #获得数据框





3. 在R中使用RMySQL
library(DBI)
library(RMySQL)
#help(package="RMySQL") #查看说明文档

##连接数据库
con<-dbConnect(MySQL(),user='root', password='123456',dbname='wang',host='y.biomooc.com',port=7070, DBMsencoding='utf8')
## 连接linux本地的mysql不需要输入host，默认port=3306。

##关闭数据库
## dbDisconnect(con) 




(1)查询：dbSendQuery的使用 
dbSendQuery返回的MySQLResult类型，而dbGetQuery直接返回数据框data.frame

dbSendQuery(con,'SET NAMES utf8') #先执行这一句，防止中文显示乱码


#i) 用sql语句查询，获得数据框，直接获得查询结果 
dbGetQuery(con, "SELECT * FROM fruits limit 3")



#ii) 用sql语句查询，获得数据框，两步法获取查询结果
res <- dbSendQuery(con, "SELECT *FROM fruits")#获取前2条数据，n=-1时是获取所有数据  
data <- dbFetch(res, n=2) #再获取余下几条数据
data
data <- dbFetch(res, n=-1) #取余下所有数据
data

dbClearResult(res)#清除查询结果

#dbDisconnect(con)#断开连接  




#iii) 用R函数，读整个数据表  
tb=dbReadTable(con,"result")
tb
##   name subject score
## 1 张三    数学    90
## 2 张三    语文    50
## 3 张三    地理    40
## 4 李四    语文    55
## 5 李四    政治    45
## 6 王五    政治    30




(2)查看状态
> summary(con) #获取连接信息
<MySQLConnection:0,0>
  User:   root 
  Host:   y.biomooc.com 
  Dbname: wang 
  Connection type: y.biomooc.com via TCP/IP 

Results:
<MySQLResult:0,0,0>
  Statement: select * from cell_c1 limit 3; 
  Has completed? yes 
  Affected rows: -1 
  Rows fetched: 3 
NULL


dbGetInfo(con) #获取连接信息
dbListTables(con) #查看database下所有表格




ii) 防止中文乱码
mysql> show variables like "char%";
+------------ -------------+------------ ---------------+
| Variable_name            | Value                      |
+----------- --------------+------------- --------------+
| character_set_client     | utf8                       |
| character_set_connection | utf8                       |
| character_set_database   | latin1                     | #改为utf8写入才能避免R写入中文时乱码
| character_set_filesystem | binary                     |
| character_set_results    | utf8                       |
| character_set_server     | latin1                     |
| character_set_system     | utf8                       |
| character_sets_dir       | /usr/share/mysql/charsets/ |
+----------- --------------+---------- -----------------+
8 rows in set (0.01 sec)

#防止写入中文时乱码
dbSendQuery(con,'alter database wang character set utf8;') #数据库改为utf8，否则写入会中文乱码

#查询字符集
query<-dbSendQuery(con,'show variables like "char%";')
df=fetch(query) #返回值是数据框






(3)写数据库表: 创建新表，写入 
#dbWriteTable(conn, "tablename", data) #写表

#写表，把fruits写入水果数据表"fruits"
fruits <-data.frame(id=1:5,name=c("苹果","香蕉","梨子","玉米","西瓜"),price=c(8.8,4.98,7.8,6,2.1),status=c("无","打折","无","售罄","批发"))  
dbListTables(con)
dbWriteTable(con,"fruits",fruits,row.names=F, fileEncoding="utf-8")  #写入中文乱码！编码一致就正常了
dbListTables(con)


#使用sql查询
query<-dbSendQuery(con,'select * from fruits limit 3;')
data<-fetch(query)

#追加数据表，是否覆盖
#new_info <- data.frame(user_id=6:7,user_name=c("小明","小红"),score = c(82,74))
#dbWriteTable(conn,"student_info ",new_info, append=T,row.names=F) #追加数据
#dbWriteTable(conn," student_info ",testB,overwrite=T,row.names=F)#覆盖数据

new_info <- data.frame(id=6:7,name=c("水果1","水果2"),price = c(8.2,7.4),status=c("打折","批发"))
dbWriteTable(con,"fruits",new_info,append=T,row.names=F) #追加数据
dbWriteTable(con,"fruits",new_info,overwrite=T,row.names=F)#覆盖数据：以前的数据被清空，现在只有这个新增的数据了



(4)删除表
dbRemoveTable(con, "fruits")



(5)其他方法
summary(con) #连接信息

dbGetInfo(con)

dbListTables(con) #列出所有的表

dbExistsTable(con,'table_name')#是否存在表

dbListResults(con) #列出所有的结果

dbClearResult(res) #清除结果






附录：
1. SQL语句语句特点：先全局选择，再局部选择
Select * from sale where year=2010 and ...


2.where后面可以接很多，有比较运算符，算数运算符，逻辑运算符。
- 比较运算符号：=(等于，不是双引号)；!=（不等于）；>，<，>=，<=
- 算数运算符：*，/，+，-
- 逻辑运算符：&&(and,与)， ||（or，或） ，!（,not非）




refer:
https://blog.csdn.net/sinat_26917383/article/details/51601539




========================================
|-- R操作sqlite
----------------------------------------
1. sqlite的优点就是既有数据库的sql操作灵活性（和mysql很类似），又有文件的存放便捷性(不需要连接数据库等操作)。
缺点是只适用于小数据集。

(1) 实例1
# install.packages("RSQLite")
library(RSQLite)

#连接表，所有结果保存到一个文件中
db = dbConnect(SQLite(), dbname="~/web/docs/your-db.sqlite")

#之后和mysql操作一样了。

# 创建表
dbSendQuery(conn=db,
   "CREATE TABLE SSGB_obs
   (Date DATETIME,
   Station TEXT,
   Snowline TEXT,
   PRIMARY KEY (Date, Station))
")

# List tables in your database
dbListTables(db)
 
# List columns in a table
dbListFields(db, "SSGB_obs")


#导入一批csv文件到db表：雪线的数据
# List files
f = list.files("./csv/clean/")
# Read csvs
# Format for database
# Write to database
for (i in f){
  x = read.table(paste0("./csv/clean/", i), sep ="|", stringsAsFactors=F)
  for (j in names(x[-1])){
    Date = x[-1,1]
    Station = x[1,j]
    Snowline = x[-1,j]
    data = cbind.data.frame(Date,Station,Snowline)
    dbWriteTable(conn=db, name="SSGB_obs", data, append=T, row.names=F)
  }
}

# 读出数据，得到的是数据框
x = dbGetQuery(db, "
   SELECT * FROM SSGB_obs
")






(2) 实例2
library(RSQLite)
sqlite    <- dbDriver("SQLite")
con <- dbConnect(sqlite,"hg19_bioconductor.sqlite") # makes a new file

#写入数据到db
suppressMessages(library(org.Hs.eg.db))
kegg2ID=toTable(org.Hs.egPATH)
#[1] "gene_id" "path_id"
dbWriteTable(con,'keggID2geneID',kegg2ID,row.name=F,overwrite=T)

#读出db
x = dbGetQuery(con, "
   SELECT * FROM keggID2geneID
")
class(x) #[1] "data.frame"
head(x)

dbDisconnect(con) #关闭连接

# 查文件大小
system("ls -l hg19_bioconductor.sqlite", show=TRUE)
# -rw-r--r--. 1 wangjl jinwf 290816 Nov 23 21:19 hg19_bioconductor.sqlite














ref:
一个R语言package：https://cran.r-project.org/web/packages/RSQLite/RSQLite.pdf
参考：https://scottishsnow.wordpress.com/2014/08/14/writing-to-a-database-r-and-sqlite/
示例代码：http://faculty.washington.edu/kenrice/sisg-adv/exampleSQLite.R










========================================
dplyr包与Mysql数据库 //todo
----------------------------------------




========================================
可重复性研究
----------------------------------------
1.用shiny+Rmarkdown写Assignment报告，在文档中使用shiny，既装逼又实用。
2.做数据分析研究时用shiny+dashboard+dygraph开发一个可交互的数据分析应用。方便进行探索性的数据分析，可以选择变量，可以拖动时间轴，可以放大缩小时间范围或者数值y的范围，观察数据更方便。
（https://www.zhihu.com/question/35224925）



========================================
历史
----------------------------------------
《数据分析简史》 https://www.douban.com/note/496070836/


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

