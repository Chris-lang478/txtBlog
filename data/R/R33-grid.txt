grid 包简介：随心所欲的布局神器

主要内容：
	grid 来生成图形输出
	图形窗口的布局
	grid 函数来创建和操作图形对象




========================================
grid包简介
----------------------------------------
R 中主要存在两种绘图系统：
- base R 传统图像系统
- grid 图像系统
传统的图像系统是由 graphics 包所提供的一系列函数组成，grid 系统是 grid 包提供的

grid 包是一个底层的绘图系统，提供的都是底层的绘图函数，没有用于绘制复杂图形的高级函数。
像 ggplot2 和 lattice 两个顶层的绘图包都是基于 grid 系统的，所以，了解 grid 包对于理解 ggplot2 的顶层函数的工作方式是很有帮助的
同时，也可以使用 grid 包来灵活地控制图形的外观和布局

grid包能画图，还能控制布局。


1. 官方资料
https://www.stat.auckland.ac.nz/~paul/grid/grid.html

Grid is an add-on package for the R language and environment for statistical computing and graphics. It provides a set of graphical functions which support a great deal of flexibility in the layout of graphics.

lattice 是基于 grid 的。

- type vignette() 


(2)
https://www.stat.auckland.ac.nz/~paul/RGraphics/rgraphics.html
https://www.stat.auckland.ac.nz/~paul/RG2e/

- Part II of my forthcoming book R Graphics will contain the most comprehensive description of grid (in a single document) to date.  
	* https://www.stat.auckland.ac.nz/~paul/RGraphics/rgraphics.html


- gridBase 包 能整个grid包和base包的图片。


(3) pdf/html 书
http://jse.amstat.org/v18n3/zhou.pdf
https://stat.ethz.ch/R-manual/R-patched/library/grid/doc/viewports.pdf
https://stat.ethz.ch/R-manual/R-patched/library/grid/html/00Index.html


(4) 神仙级的解释
R 数据可视化 —— grid 系统（一） https://zhuanlan.zhihu.com/p/370904286
R 数据可视化 —— grid 系统（二） https://zhuanlan.zhihu.com/p/371124820





========================================
grid包的绘图功能
----------------------------------------
1. grid 提供了一些函数用于绘制简单的图形

(1)基本上 base 有的在grid中都有对应。

# 文字
grid.text(label = "Let's us begin!")

# 圆圈
grid.circle(x=0.5, y=0.5, r=0.2) #默认是相对单位，0-1之间。

grid.circle(
  x=seq(0.1, 0.9, length=100),
  y=0.5 + 0.4*sin(seq(0, 2*pi, length=100)),
  r=abs(0.1*cos(seq(0, 2*pi, length=100)))
)



(2) 每一个功能还有对应的 生成对象 形式。

比如 grid.text() 函数的 声称对象 形式是 textGrob() 函数。

#
grid.rect() - creates a rectangle grob and draws it.
grid.circle() - creates a circle grob and draws it.
grid.polygon() - creates a polygon grob and draws it.
grid.text() - creates a text grob and draws it.
grid.lines() - creates a line segment and draws it.
#
rectGrob() - creates a rectangle grob but does not draw it.
circleGrob() - creates a circle grob but does not draw it.
polygonGrob() - creates a polygon grob but does not draw it.
textGrob() - creates a text grob but does not draw it.
linesGrob() - creates a line segment grob but does not draw it.
#
If we want to draw one of these grobs, we could use the grid.draw() function. 

画图函数 / 生成对象的函数: 功能
grid.move.to / moveToGrob: 设置当前位置
grid.line.to / lineToGrob: 绘制一条从当前位置到指定位置的线并
grid.line /linesGrob: 绘制直线
grid.segments/ segmentsGrob: 绘制线段
grid.rect/rectGrob: 在指定位置绘制矩形
grid.circle/circleGrob: 根据位置和半径绘制圆圈
grid.polygon/ polygonGrob: 根据顶点绘制多边形
grid.text/textGrob: 在指定位置和角度绘制文本
grid.arrows/ arrowsGrob: 绘制带箭头的线
grid.points/ pointsGrob: 绘制散点
grid.xaxis/xaxisGrob: 绘制x轴
grid.yaxis/yaxisGrob: 绘制y轴



# 例1: 画出 grid 对象
library(grid)

grid.newpage()
obj.text=textGrob("good")
grid.draw(obj.text)

tg <- textGrob('Title', y=0.7, gp = gpar(fontsize = 13, fontface = 'bold'));tg
sg <- textGrob('Subtitle', gp = gpar(fontsize = 10, col="red"));sg

grid.newpage()
grid.draw(tg)
grid.draw(sg)


# 或画到指定的视窗中
grid.newpage()
vp <- viewport(x=0.4,y=0.7,width=0.5,height=0.4) #默认是相对center
pushViewport(vp)
grid.rect()
grid.draw(obj.text)






# 例2: 修改grid对象
We can modify a grob by using the functions grid.edit() and editGrob(). 
We demonstrate this in the following example.

# First we construct a .1×.1 rectangle grob centered at (.5,.5) and called gr. We do not draw it yet.
gr <- rectGrob(width=0.1,height=0.1, name="gr")
# x= 0.5, y=0.5 by default.

# Now, we can use editGrob to make a copy of this rectangle, which will be put in a different place, centered at (.2,.6):
gr1 <- editGrob(gr, vp=viewport(x=0.2, y=0.6), name="gr1")

# Then we draw the copy using:
grid.newpage()
grid.draw(gr1)

# and we can create a 2nd rectangle, gr2, centered it at (.7,.75), and red color
gr2 <- editGrob(gr, vp=viewport(x=0.7, y=0.75), name="gr2", gp=gpar(col="red"))
grid.draw(gr2)

# We can create a third rectangle, gr3 centered at(.5,.4), rotate 30 degree, bold line
gr3 <- editGrob(gr, vp=viewport(x=0.5, y=0.4, angle =30), name="gr3", 
                gp=gpar(lwd=3, lty=2))
grid.draw(gr3)








(3) grid包的所有函数
一共212多个。
> rs=ls("package:grid");
> length(rs) #共212个

其中 带有 grid.前缀的有 68个，大多是可以直接画图的。
> rs[grep("grid.", rs)]
 [1] "grid.abline"          "grid.add"             "grid.arrows"          "grid.bezier"          "grid.cap"            
 [6] "grid.circle"          "grid.clip"            "grid.collection"      "grid.convert"         "grid.convertHeight"  
[11] "grid.convertWidth"    "grid.convertX"        "grid.convertY"        "grid.copy"            "grid.curve"          
[16] "grid.delay"           "grid.display.list"    "grid.DLapply"         "grid.draw"            "grid.edit"           
[21] "grid.force"           "grid.frame"           "grid.function"        "grid.gedit"           "grid.get"            
[26] "grid.gget"            "grid.grab"            "grid.grabExpr"        "grid.gremove"         "grid.grep"           
[31] "grid.grill"           "grid.grob"            "grid.layout"          "grid.legend"          "grid.line.to"        
[36] "grid.lines"           "grid.locator"         "grid.ls"              "grid.move.to"         "grid.multipanel"     
[41] "grid.newpage"         "grid.null"            "grid.pack"            "grid.panel"           "grid.path"           
[46] "grid.place"           "grid.plot.and.legend" "grid.points"          "grid.polygon"         "grid.polyline"       
[51] "grid.pretty"          "grid.raster"          "grid.record"          "grid.rect"            "grid.refresh"        
[56] "grid.remove"          "grid.reorder"         "grid.revert"          "grid.roundrect"       "grid.segments"       
[61] "grid.set"             "grid.show.layout"     "grid.show.viewport"   "grid.strip"           "grid.text"           
[66] "grid.xaxis"           "grid.xspline"         "grid.yaxis" 
> rs1=rs[grep("^grid.", rs, invert = T)]; length(rs1) #剩下144


而带有 Grob 后缀的有36个，都是生成作图对象。
> rs1[grep("Grob$", rs1)]
 [1] "addGrob"       "arrowsGrob"    "bezierGrob"    "circleGrob"    "clipGrob"      "curveGrob"     "delayGrob"     "editGrob"     
 [9] "forceGrob"     "frameGrob"     "functionGrob"  "getGrob"       "legendGrob"    "linesGrob"     "lineToGrob"    "moveToGrob"   
[17] "nullGrob"      "packGrob"      "pathGrob"      "placeGrob"     "pointsGrob"    "polygonGrob"   "polylineGrob"  "rasterGrob"   
[25] "recordGrob"    "rectGrob"      "removeGrob"    "reorderGrob"   "roundrectGrob" "segmentsGrob"  "setGrob"       "showGrob"     
[33] "textGrob"      "xaxisGrob"     "xsplineGrob"   "yaxisGrob"
> rs1=rs1[grep("[Gg]rob", rs1, invert = T)]; length(rs1)  #剩下95个



单位函数 10 个
> rs1[grep("unit", rs1)]
> rs1[grep("unit", rs1, ignore.case = T)]
 [1] "convertUnit" "is.unit"     "unit"        "unit.c"      "unit.length" "unit.pmax"   "unit.pmin"   "unit.psum"   "unit.rep"   
[10] "unitType"
> rs1=rs1[grep("unit", rs1, invert = T,  ignore.case = T)]; length(rs1)  #剩下85个


viewport 函数 13个
> rs1[grep("[Vv]iewport$", rs1)]
[1] "current.viewport" "dataViewport"     "downViewport"     "editViewport"     "plotViewport"     "pop.viewport"     "popViewport"     
[8] "push.viewport"    "pushViewport"     "seekViewport"     "showViewport"     "upViewport"       "viewport" 
> rs1=rs1[grep("[Vv]iewport$", rs1, invert = T)]; length(rs1)  #剩下72个

> rs1
 [1] "absolute.size"       "applyEdit"           "applyEdits"          "arcCurvature"        "arrow"               "ascentDetails"      
 [7] "bezierPoints"        "calcStringMetric"    "childNames"          "convertHeight"       "convertNative"       "convertWidth"       
[13] "convertX"            "convertY"            "current.parent"      "current.rotation"    "current.transform"   "current.vpPath"     
[19] "current.vpTree"      "depth"               "descentDetails"      "deviceDim"           "deviceLoc"           "draw.details"       
[25] "drawDetails"         "editDetails"         "emptyCoords"         "engine.display.list" "explode"             "gEdit"              
[31] "gEditList"           "get.gpar"            "getNames"            "gList"               "gpar"                "gPath"              
[37] "gTree"               "heightDetails"       "isEmptyCoords"       "layout.heights"      "layout.torture"      "layout.widths"      
[43] "layoutRegion"        "linearGradient"      "makeContent"         "makeContext"         "nestedListing"       "pathListing"        
[49] "pattern"             "postDrawDetails"     "preDrawDetails"      "radialGradient"      "resolveHJust"        "resolveRasterSize"  
[55] "resolveVJust"        "setChildren"         "stringAscent"        "stringDescent"       "stringHeight"        "stringWidth"        
[61] "valid.just"          "validDetails"        "viewport.layout"     "viewport.transform"  "vpList"              "vpPath"             
[67] "vpStack"             "vpTree"              "widthDetails"        "xDetails"            "xsplinePoints"       "yDetails" 






========================================
|-- 坐标系统: unit对象
----------------------------------------
在grid包中，unit对象用于表示：长度和单位。
grid 的坐标系统是用来确定数值的单位，同样的数值在不同的单位中表示不同的大小，看起来叫单位系统应该会更恰当些。

1. 坐标系统的单位
unit对象: 用unit对象表示长度的大小和单位：
unit(x, units, data=NULL)
参数注释：
	x：数值向量
	units：单位向量


坐标系统：描述
native: 位置和大小相对于当前 viewport 的x、y轴的范围
npc: 定义当前 viewport 的左下角(0,0)，右上角(1,1)
snpc: 位置和大小被表示为当前 vewport 的宽度和高度中更小的值的比例
inches: 英寸，(0,0)表示 viewport 的左下角
cm: 厘米
mm: 毫米 
points: 点，每英寸相当于 72.27 个点
bigpts: 大点，每英寸相当于72个大点
picas: 1 pica 相当于12个点
dida: 1157 个 dida 相当于 1238 个点
cicero: 1 cicero 相当于 12 个 dida
scaledpts: 相当于一个点的 65536 分之一
char: 相当于字体大小为单位(由 fontsize 和 cex 确定)
lines: 相当于以线条高度为单位(由 fontsize, cex, lineheight 确定)
strwidth, strheight: 相当于以字符串的宽高为单位(由 fontsize, cex, fontfamily, fontface 确定)
grobwidth, grobheight: 以给定图形对象的宽高位单位。


(1)使用 unit 函数来设置不同的系统
> unit(1, "cm")
[1] 1cm
> unit(1:4, "mm")
[1] 1mm 2mm 3mm 4mm
> unit(1:4, c("npc", "mm", "native", "lines"))
[1] 1npc    2mm     3native 4lines 



(2) 坐标系统之间的运算将会以表达式的方式返回
> unit(1:4, "mm")[1] - unit(1:4, "mm")[4]
[1] -3mm
> unit(1, "npc") - unit(1:4, "mm")
[1] sum(1npc, -1mm) sum(1npc, -2mm) sum(1npc, -3mm) sum(1npc, -4mm)
> max(unit(1:4, c("npc", "mm", "native", "lines")))
[1] max(1npc, 2mm, 3native, 4lines)



(3) 对于字符串及对象长度坐标系统
> unit(1, "strwidth", "some text")
[1] 1strwidth
> unit(1, "grobwidth", textGrob("some text"))
[1] 1grobwidth

有对应的简便函数可以使用
> stringHeight("some text")
[1] 1strheight
> grobHeight(textGrob("some text"))
[1] 1grobheight



(4) 可以使用 convertWidth 和 convertHeight 实现单位之间的转换
> convertHeight(unit(1, "cm"), "mm")
[1] 10mm
> convertHeight(unit(1, "dida"), "points")
[1] 1.07000864304235points
> convertHeight(unit(1, "cicero"), "points")
[1] 12.8401037165082points
> convertHeight(unit(1, "cicero"), "dida")
[1] 12dida
> convertHeight(unit(1, "points"), "scaledpts")
[1] 65536scaledpts
> convertWidth(stringWidth("some text"), "lines")
[1] 3.61246744791667lines
> convertWidth(stringWidth("some text"), "inches")
[1] 0.722493489583333inches


(5) 对于一个图形对象，如果修改了图形对象属性，则对应的大小也会改变
> grid.text("some text", name="tgrob")
> convertWidth(grobWidth("tgrob"), "inches")
[1] 0.722493489583333inches
# 修改图形对象的 fontsize 属性
> grid.edit("tgrob", gp=gpar(fontsize=18))
> convertWidth(grobWidth("tgrob"), "inches")
[1] 1.083740234375inches


(6) 我们可以使用不同的单位系统来绘制一个矩形
grid.rect(
  x=unit(0.5, "npc"), 
  y=unit(1, "inches"),
  width=stringWidth("very snug"), 
  height=unit(10, "lines"), 
  just=c("left", "bottom")
)








========================================
|-- 设置 图形参数: gpar()对象
----------------------------------------
grid包使用gpar对象用于设置 图形参数。


1. 所有的图形原语函数都有一个 gp(graphical parameters) 参数，用来接收一个 gpar 对象，该对象包含一些图形参数用于控制图像的输出

(1) gpar 对象可以使用 gpar() 函数来生成，例如
> gpar(col="red", lty="dashed")
$col
[1] "red"

$lty
[1] "dashed"


(2) 这些图形参数包括
参数: 描述 
	col: 线条、文本、矩形边框等的颜色
	fill: 矩形、圆形、多边形的填充色
	gamma: 颜色的 gamma 校正值
	alpha: 不透明度。越大越不透明: 0完全透明，1完全不透明
	lwd: 线条宽度
	lex: 线条扩展乘子
	lty: 线条类型
	lineend: 线段点类型：round, butt, square 
	linejoin: 线连接点类型: round, mitre, bevel 
	linemitre: 线条斜率限制
	cex: fontsize 的扩展乘子
	fontsize: 字体大小(points)
	fontface: 字体样式(bold, italic/oblique, plain, bold.italic 或整数1-4)
	fontfamily: 字体家族
	lineheight: 线高

用gapr对象表示图形参数：
	col: Colour for lines and borders.
	fill: Colour for filling rectangles, polygons, ...
	alpha: Alpha channel for transparency
	lty: Line type
	lwd: Line width
	lex: Multiplier applied to line width
	lineend: Line end style (round, butt, square)
	linejoin: Line join style (round, mitre, bevel)
	linemitre: Line mitre limit (number greater than 1)
	fontsize: The size of text (in points)
	cex: Multiplier applied to fontsize
	fontfamily: The font family
	fontface: The font face (bold, italic, ...)
	lineheight: The height of a line as a multiple of the size of text
	font: Font face (alias for fontface; for backward compatibility)




(3) 使用 get.gpar 可以获取当前图形参数的值，如果未指定要获取的参数，将会返回所有的参数值
> get.gpar(c("lty", "fill"))
$lty
[1] "solid"

$fill
[1] "white"


(4) 因此，我们可以在绘制图像时，传递 gp 参数来设置图像参数
grid.newpage()
grid.rect(
  x=0.66, 
  height=0.7, 
  width=0.2,
  gp=gpar(fill="blue")
)

grid.rect(
  x=0.33, 
  height=0.7, 
  width=0.2
)

# alpha 不透明度，越大越不透明
grid.rect(x=0.4, y=0.8, height=0.2, width=0.9, gp=gpar(fill="red", alpha=0.8))
grid.rect(x=0.4, y=0.2, height=0.2, width=0.9, gp=gpar(fill="red", alpha=0.2))



(5) 在 grid 中，cex 参数是累积的，也就是说当前的 cex 值等于当前设置的值乘上之前的 cex 值
例如
pushViewport(viewport(gp=gpar(cex=0.5)))
grid.text("How small do you think?", gp=gpar(cex=0.5))
# 在一个 viewport 中设置了 cex = 0.5，之后的文本又设置了 cex = 0.5，最后文本的大小就是 0.5*0.5 = 0.25

alpha 参数与 cex 类似，也是累积的


(6) 传入向量
注意: 这些图形参数都可以接受一个向量值，比如，你可以将一个颜色向量传递给 col 或 fill 参数，如果向量的长度小于绘制的图形的个数，则参数会进行循环赋值

如，我们绘制 100 个圆形，但是只传递了一个长度为 50 的颜色向量给 col 参数

grid.newpage()
grid.circle(
  x = seq(0.1, 0.9, length=100),
  y = 0.5 + 0.4*sin(seq(0, 2*pi, length=100)),
  r = 0.01, #abs(0.1*cos(seq(0, 2*pi, length=100))),
  gp = gpar(col=rainbow(50))
)


(7) 对于多边形 grid.polygon() 函数，有一个 id 参数可以将多边形的点进行分组，如果某一分组点中包含 NA 值，则又会将在 NA 处将点分为两组

grid.newpage()
# 设置均等分的角度，并删除最后一个角度
angle <- seq(0, 2*pi, length=11)[-11]

grid.polygon(
  x = 0.25 + 0.2*cos(angle), 
  y = 0.5 + 0.3*sin(angle),
  id = rep(1:2, c(7, 3)),
  gp = gpar(
    fill=c("grey", "white")
    )
  )

# 将其中一个角度设置为 NA
angle[4] <- NA

grid.polygon(
  x = 0.75 + 0.2*cos(angle), 
  y = 0.5 + 0.3*sin(angle),
  id = rep(1:2, c(7, 3)),
  gp = gpar(
    fill=c("grey", "white")
    )
  )

从图中可以看出，本来根据 id 值分为两组，第一组为灰色填充，第二组为白色填充。
但是在添加 NA 之后，在 NA 处将 id 为 1 的分组又一分为二，但是填充色还是灰色，并不是接续白色
















========================================
grid 的布局功能
----------------------------------------
2. grid中文翻译为网格，可将其解释为画布分割，通过设定相应的参数，从而可以任意的摆放图形

(1) 常用函数：
	grid.newpage() 创建新的画布
	grid.layout() 分割画布，使用参数widths和heights指定分割比例 ,从上到下，从左到右排列
	viewport() 在画布中创建视窗
	grid.show.viewport() 在画布中展示视窗
	grid.show.layout() 展示分割的画布
	pushViewport() 将新建的viewport推出去，即将工作区域切换到新的viewport
	popViewport() 将当前的viewport删除，其父viewport作为新的工作区域, 子viewport中的绘制的图形不会被删除
	downViewport() 导航到子viewport，并作为工作区域，原viewport不会删除
	upViewport() 导航到父viewport，父viewport变为工作区域, 原viewport不会被删除
	seekViewport() 导航到name参数所在的viewport,并作为工作区域
	grid.text() 输出文本标签,坐标只与画布有关，与viewport无关


画一个ggplot2图，然后执行
current.vpTree() #查看树状结构
# 好可怕！半屏幕的输出！说明 ggplot2 底层全是grid的视口！连坐标轴都是。


(2) 语法：
viewport(x = unit(0.5, "npc"), y = unit(0.5, "npc"), 
         width = unit(1, "npc"), height = unit(1, "npc"), 
         default.units = "npc", 
         just = "centre", 
         gp = gpar(), 
         clip = "inherit", 
         xscale = c(0, 1), yscale = c(0, 1), 
         angle = 0, 
         layout = NULL, 
         layout.pos.row = NULL, layout.pos.col = NULL, name = NULL) 

grid.layout(nrow = 1, ncol = 1, 
            widths = unit(rep_len(1, ncol), "null"), 
            heights = unit(rep_len(1, nrow), "null"), 
            default.units = "null", 
            respect = FALSE, 
            just="centre")


(3) 参数解释
(viewport 视口，有的翻译为视窗。)

name：此视口(viewport)的名字，用于搜索和定位
x,y 为起点坐标，默认是矩形视窗中心坐标，为0 - 1的数字，表示占newpage的比例
	x：绘图区域相对页面左下角原点的x坐标，默认单位为npc，Normalised Parent Coordinates，含义是归一化的父区域坐标
	y：绘图区域相对页面左下角原点的y坐标
width, height 为矩形视窗的长宽，同样是占newpage的比例

default.units：默认单位为npc (Normalised Parent Coordinates)，含义是规范化化的父区域坐标
angle 把视口逆时针旋转的角度，从-360到360,正数表示逆时针旋转，负数表示顺时针旋转
just 表示指定视窗起点位置，默认“centre”, 还可以设置左下角c(“left”, “buttom”), 右上角c(“right”, “top”) 等
	x和y所指的位置，默认为矩形中心位置

layout 布局(grid.layout)对象，用于将当前的viewport拆分为子区域
layout.pos.row，layout.pos.col：子区域在父布局中的行位置和列位置
nrow 表示将该区域拆分为几行
ncol 表示将该区域拆分为几列
widths 表示每个子区域的宽度,向量长度等于ncol
heights 表示每个子区域的高度，向量长度等于nrow
gp = gpar() 表示传递其它参数，如: col/fill颜色,lty线型, lwd线宽, fontsize文本尺寸, fontfamily字体, fontface字型等， 可以通过?gpar查询
	gpar对象，用于设置图形参数；

clip：裁剪区域，有效值是“on”，“inherit”或“off”，指示剪裁到视口范围内，从父视口继承剪裁区域，或者完全关闭剪裁。 为了后向兼容性，逻辑值TRUE对应于“on”，而FALSE对应于“inherit”
xscale，yscale：两个数值元素的向量，用于表示坐标轴的最小值和最大值。




(4) 什么是 viewport?
通常使用 grid.newpage() 函数来新建一个空白画布
在画布中，又可以定义很多个独立的矩形绘图窗口，在每个矩形窗口中都可以绘制任意你想要绘制的内容，这样的窗口就是 viewport

有了viewport这个工具，我们就可以很灵活的在图形中画出任意区域分割的子图了。
例1: viewport是绘图的基础，创建一个viewport
vp = viewport(x = 0.5, y = 0.5, width = 0.5, height = 0.25, angle=45)

通过函数grid.show.viewport()查看创建的视口：
grid.show.viewport(viewport(x=0.6, y=0.6, width=unit(1, "inches"), height=unit(1, "inches"), angle=30))

height和width是矩形的长和宽，x和y是视口中心点（也就是，矩形的几何中心点）距离x坐标抽和y坐标轴的距离




默认情况下，整个画布就是一个 viewport，如果新增一个 viewport，那么默认会继承所有默认的图形参数值。

例2: 使用 viewport() 函数来新建一个 viewport，并接受位置参数(x 和 y) 和大小参数(width 和 height)，以及对齐方式(just)
> vp2=viewport(
   x = unit(0.4, "npc"), 
   y = unit(1, "cm"),
   width = stringWidth("very very snug indeed"), 
   height = unit(6, "lines"), 
   just = c("left", "bottom")
)
> vp2
# viewport[GRID.VP.4] 
viewport() 函数返回的是一个 viewport 对象，但其实你会发现，什么东西都没有画出来

> grid.show.viewport(vp2)





(5) 基于viewport绘制图形
library(grid)

# 使用grid包绘图时，首先要创建一个空的画布：
grid.newpage()

#在画布中创建viewport对象：
vp = viewport(x = 0.5, y = 0.5, width = 0.5, height = 0.25, angle=45)

#此时，画布中是空的，需要把viewport推到画布中：
pushViewport(vp)

#viewport是绘图的区域，也就是说，基于viewport绘制图形，在视口规定的范围内作图，例如，向视口中绘制矩形。
grid.rect() #默认情况下grid.rect画出viewport的边界。



(6) 可视化 viewport 
labelvp <- function(name, col="gray", tcol="white", clipOff=TRUE) {
  seekViewport(name)
  if (clipOff)
    pushViewport(viewport(clip="off"))
  grid.rect(gp=gpar(col=col, lwd=5, fill=NA))
  grid.rect(x=0, y=1, width=unit(1, "strwidth", name) + unit(2, "mm"),
            height=unit(1, "line"), just=c("left", "top"),
            gp=gpar(fill=col, col=NA))
  grid.text(name, x=unit(1, "mm"), y=unit(1, "npc") - unit(1, "mm"),
            just=c("left", "top"), gp=gpar(col=tcol))
  upViewport(0)
}

vplay <- grid.layout(3, 3, 
                     respect=rbind(c(0, 0, 0), 
                                   c(0, 1, 0), 
                                   c(0, 0, 0)))

pushViewport(viewport(width=0.95, height=0.95))
grid.rect(gp=gpar(col="light gray"))
pushViewport(viewport(layout=vplay))

pushViewport(viewport(layout.pos.col=2, name="col2"))
upViewport()
pushViewport(viewport(layout.pos.row=2, name="row2"))

labelvp("col2", "black")
labelvp("row2")












========================================
|-- viewport 树与 viewport 的切换
----------------------------------------
1. grid可以创建多个viewport，所有的viewport组织成一棵树。
任何一个时刻，有一个当前viewport对象，初始状态下为树的根节点viewport。
grid提供了一套函数用于管理viewport对象。


grid包为每一个画布维护了一个由viewport构成的树，树的根节点是由系统创建的，名字是ROOT的viewport，每一个节点都是一个viewport。活跃viewport是树的当前位置，在树中是唯一的，用户只能向活跃viewport中绘图，所有的操作都是基于活跃viewport。viewport()函数用于创建viewport，而一个viewport只有被push到viewport树中，才能在其区域中绘图。


(1)通过5个函数实现对viewport树的遍历和更新：

使用pushViewport()可以将指定的viewport插入到当前viewport的子节点中，同时当前viewport对象移动为刚刚插入的viewport；
使用popViewport()可以删除当前viewport，同时当前viewport改为刚刚删除的viewport的父节点；
使用upViewport()当前viewport移动到父节点；
使用downViewport()当前viewport移动到指定name的子节点；
使用seekViewport()在整棵树范围内搜索指定name的viewport，将其设置为当前viewport。

注意：当向树中push一个viewport时，如果树中存在一个级别（level）相同，名字相同的viewport，那么push操作会把该viewport替换掉。


(2) 查看当前的viewport树结构：
current.vpTree()


例如，下面我们连续push三个viewport到一个图形中。
绘制的图形依次嵌套，这说明，每push一次，原活跃viewport都变成父节点，把当前的veiwport作为子viewport：
grid.newpage()
colors=c("red", "green", "blue")
xvec=c(0.3,0.4,0.5)
for(i in 1:3){
  vp=viewport(x=xvec[i], y=0.5, 
              width=0.4, height=0.4,
              gp=gpar(col=colors[i])
  )
  pushViewport(vp)
  grid.rect()
}

current.vpTree() #查看树状结构
# viewport[ROOT]->(viewport[GRID.VP.4]->(viewport[GRID.VP.5]->(viewport[GRID.VP.6]))) 




(3) pushViewport() 函数可以将一个 viewport 对象 push 到图像设备中
实例: 新建一个带旋转角度的视口，然后在里面添加文字
grid.newpage()
grid.text(
  "top-left corner", 
  x=unit(1, "mm"),
  y=unit(1, "npc") - unit(1, "mm"),
  just=c("left", "top")
)

# 新建一个视口：旋转30度
pushViewport(
  viewport(
    width=0.8, 
    height=0.5, 
    angle=30,
    name="vp1"
    )
)
grid.rect() #视口边框

# 添加文字，角度和视口一致
grid.text(
  "top-left corner", 
  x = unit(1, "mm"),
  y = unit(1, "npc") - unit(1, "mm"),
  just = c("left", "top")
)

# 如果继续旋转， 则是相对于当前视口的
pushViewport( viewport(width=0.8, height=0.5, angle=30, name="vp2") )
grid.rect(gp=gpar(col="red", lty=2, fill="#FFFFFF00")) #设置填充色为全透明的
grid.text(
  "top-left corner", 
  x = unit(1, "mm"),
  y = unit(1, "npc") - unit(1, "mm"),
  just = c("left", "top"),
  gp=gpar(col="red")
)


(4) popViewport() 函数：删除当前视口，并返回到其上一层
每次 push 一个 viewport 之后，都会将该 viewport 作为当前活动的窗口，如果要回滚到之前的 viewport，可以使用 popViewport() 函数，该函数会将当前活动窗口删除

popViewport()

grid.text(
  "bottom-right corner",
  x=unit(1, "npc") - unit(1, "mm"),
  y=unit(1, "mm"), 
  just=c("right", "bottom")
)

从图片中可以看到，活动窗口已经切换到第二个 viewport，并将文本绘制在其右下角

查看当前 视口树，发现 vp2已经被删:
> current.vpTree()
viewport[ROOT]->(viewport[vp1]) 


popViewport() 还可接受一个参数 n，用于指定需要 pop 几个 viewport。默认 n = 1，传递更大的值可以跳转到更上层的 viewport，如果设置为 0 则会返回到最外层图形设备上。



(5) 另一个更改活动窗口的方法是，使用 upViewport() 和 downViewport() 函数。
upViewport() 函数与 popViewport() 类似，不同之处在于，upViewport() 函数不会删除当前活动 viewport。
这样，在重新访问之前的 viewport 时，不用再 push 一遍，而且能够提升访问的速度。

重新访问 viewport 使用的是 downViewport() 函数，通过 name 参数来选择指定的 viewport

# 切换到最外层
upViewport()
# 在右下角添加文本
grid.text(
  "bottom-right corner",
  x=unit(1, "npc") - unit(1, "mm"),
  y=unit(1, "mm"), 
  just=c("right", "bottom")
  )
# 返回 vp1
downViewport("vp1")
# 添加外侧框线
grid.rect(
  width=unit(1, "npc") + unit(2, "mm"), 
  height=unit(1, "npc") + unit(2, "mm"),
  gp = gpar(fill = NA)
)

如果想要访问 vp2 会报错，不存在该 viewport

> downViewport("vp2")
Error in grid.Call.graphics(C_downviewport, name$name, strict) : 
  Viewport 'vp2' was not found


(6) 还可以直接使用 seekViewport() 函数来切换到指定名称的 viewport.






========================================
|-- viewport 的裁剪(clip)
----------------------------------------
2. 裁剪 viewport
我们可以将图形限制在当前 viewport 之内，如果绘制的图形大小超过了当前 viewport 则不会显示，我们可以使用 clip 参数

该参数接受三个值：
	on：输出的图形必须保持在当前 viewport 内，超出的部分会被裁剪
	inherit：继承上一个 viewport 的 clip 值
	off：不会被裁剪


grid.newpage()
# 在画布中心添加一个 viewport，并设置允许剪切
pushViewport(viewport(w=.5, h=.5, clip="on"))
# 添加矩形框和线条很粗的圆形
grid.rect(
  gp = gpar(fill = "#8dd3c7")
  )
grid.circle(
  r = .7, 
  gp = gpar(
    lwd = 20,
    col = "#fdb462"
    )
)

# 在当前 viewport 中添加一个 viewport，继承方式
pushViewport(viewport(clip="inherit"))
# 添加线条更细一点的圆形
grid.circle(
  r = .7, 
  gp = gpar(
    lwd = 10, 
    col = "#80b1d3",
    fill = NA)
)
# 关闭裁剪
pushViewport(viewport(clip="off"))
# 显示整个圆形
grid.circle(
  r=.7,
  gp = gpar(
    fill = NA,
    col = "#fb8072"
  )
)
# 只有最后一个圆显示出了全部，前面两个圆形只显示在 viewport 内的部分





========================================
|-- viewport 的3种排列: vpList /vpStack /vpTree
----------------------------------------
1. viewport 的排布方式有三种：
	vpList：viewport 列表，以平行的方式排列各 viewport
	vpStack：以堆叠的方式排列，俗称套娃，与使用 pushViewport 功能相似
	vpTree：以树的方式排列，一个根节点可以有任意个子节点

例如，我们新建三个 viewport
vp1 <- viewport(name="A")
vp2 <- viewport(name="B")
vp3 <- viewport(name="C")

(1) vpList 平行方式
然后，我们以列表的方式将这些 viewport push 到图形设备中
grid.newpage()
pushViewport(vpList(vp1, vp2, vp3))

可以使用 current.vpTree 函数来查看当前的 viewport 排列树
> current.vpTree()
viewport[ROOT]->(viewport[A], viewport[B], viewport[C]) 
可以看到，这三个 viewport 是并列的关系


(2) 我们再看看以堆叠(vpStack)的方式放置
> grid.newpage()
> pushViewport(vpStack(vp1, vp2, vp3))
> current.vpTree()
viewport[ROOT]->(viewport[A]->(viewport[B]->(viewport[C]))) 

可以看到，根节点是整个画布，画布的子节点是 A，A 的子节点是 B，B 的子节点是 C，这就是堆叠的方式，一个套一个


(3) 树形排列
> grid.newpage()
> pushViewport(vpTree(vp1, vpList(vp2, vp3)))
> current.vpTree()
viewport[ROOT]->(viewport[A]->(viewport[B], viewport[C]))

根节点是整个画布，然后是子节点 A，A 的子节点是 B、C


(4) 根据父节点找子节点
我们知道，画布中的所有 viewport 是以树的方式存储的，那么我们就可以根据 viewport 的父节点来定位某一个 viewport

例如，我们想查找名称 C 的 viewport，其父节点为 B，再上层父节点为 A，则可以使用 vpPath 函数来构造检索路径
> vpPath("A", "B", "C")
A::B::C 
同时也可以消除同名 viewport 的干扰






========================================
|-- 将 viewport 作为图形原语(grid绘图命令)的参数
----------------------------------------
1.每个原语函数都有一个 vp 参数

例如，在一个 viewport 中绘制文本
vp1 <- viewport(width=0.5, height=0.5, name="vp1")
pushViewport(vp1)

grid.text("Text drawn in a viewport")
popViewport()

也可以下面的代码代替，将文本绘制到指定的 viewport 中
grid.text("Text drawn in a viewport", vp=vp1)





========================================
|-- viewport 的图形参数 gp=gpar(col="red")
----------------------------------------
viewport 也有一个 gp 参数，用来设置图形属性，设置的值将会作为 viewport 中所有的图形对象的默认值

grid.newpage()
pushViewport(
  viewport(
    gp = gpar(fill="grey")
    )
  )

grid.rect( x = 0.33, height = 0.7, width = 0.2  )
grid.rect( x = 0.66, height = 0.7, width = 0.2, gp = gpar(fill="black") )
popViewport()





========================================
|-- viewport 行列布局 viewport(layout=grid.layout(...)) 
----------------------------------------
viewport 的 layout 参数可以用来设置布局，将 viewport 区域分割成不同的行和列，行之间可以有不同的高度，列之间可以有不同的宽度。

1. viewport 还支持行列布局，前面提到viewport函数，还有几个参数我们还没涉及：
	layout：grid.layout对象，用于将当前viewport拆分为子区域
	layout.pos.row：创建的viewport在父节点layout的行位置
	layout.pos.col：创建的viewport在父节点layout的列位置

grid.layout(nrow = 1, ncol = 1,
    widths = unit(rep_len(1, ncol), "null"), heights = unit(rep_len(1, nrow), "null"),
    default.units = "null", respect = FALSE, just="centre")

我们来看一下grid.layout()的参数：
	nrow, ncol：布局分为多少个行和列，每一个行和列构成的单元叫做分区（subdivision）
	widths，heights：每一个分区的宽和高
		widths：每个子区域的宽度，向量长度等于ncol
		heights：每个子区域的高度，向量长度等于nrow
	default.units：默认单位
	respect：逻辑值，如果为true，指定行高度和列宽度都遵守。
	just：指定对齐方式，有效的值是："left", "right", "centre", "center", "bottom", 和 "top".


(1) grid 布局使用 grid.layout() 函数来构造，例如
grid.newpage()

vplay <- grid.layout(
  nrow = 3, 
  ncol = 3, 
  respect=rbind(
    c(0, 0, 0),
    c(0, 1, 0),
    c(0, 0, 0))
  )

我们构造了一个 3 行 3 列的布局，中间的位置是一个正方形
构造了布局之后，就可以添加到 viewport 中了
pushViewport(viewport(layout=vplay))



(2) 我们可以使用 layout.pos.col 和 layout.pos.row 参数来指定 viewport 放置的位置
# 新建一个 viewport 并放置在第二列
pushViewport(
  viewport(
    layout.pos.col = 2, 
    name = "col2")
  )
grid.rect(
  gp = gpar(
    lwd = 10,
    col = "black",
    fill = NA
  ))
grid.text(
  label = "col2",
  x = unit(1, "mm"),
  y = unit(1, "npc") - unit(1, "mm"),
  just = c("left", "top")
  )

upViewport()

# 新建一个 viewport 并放置在第二行
pushViewport(
  viewport(
    layout.pos.row = 2, 
    name = "row2")
  )

grid.rect(
  gp = gpar(
    lwd = 10,
    col = "grey",
    fill = NA
  ))
grid.text(
  x = unit(1, "mm"),
  y = unit(1, "npc") - unit(1, "mm"),
  label = "row2",
  just = c("left", "top")
)



(3) 也可以使用 unit 来设置行列的高度和宽度，例如

unitlay <- grid.layout(
  nrow = 3, 
  ncol = 3, 
  widths = unit(
    c(1, 1, 2),
    c("inches", "null", "null")
  ),
  heights = unit(
    c(3, 1, 1),
    c("lines", "null", "null"))
  )

我们定义了一个 3 行 3 列的布局，
- 列宽通过 widths 分配，即第一列宽度为 1 inches，剩下的两列的宽度的占比为 1:2
- 行高通过 heights 分配，第一行为 3 个 lines 单位，剩下的两行高度为 1:1

布局应该是这样子的
grid.show.layout(unitlay)



(4) grid 布局也可以嵌套

假设我们有这样一个，1 行 2 列的 viewport
gridfun <- function() { 
  # 1*2 的布局
  pushViewport(viewport(layout=grid.layout(1, 2))) 
  
  # 第一行第一列的 viewport
  pushViewport(viewport(layout.pos.col=1)) 
  # 绘制矩形和文本
  grid.rect(gp = gpar(fill = "#80b1d3")) 
  grid.text("black")
  grid.text("&", x=1)
  popViewport()
  
  # 第一行第二列的 viewport
  pushViewport(viewport(layout.pos.col=2, clip="on"))
  grid.rect(gp=gpar(fill="#fb8072"))
  grid.text("white", gp=gpar(col="white"))
  grid.text("&", x=0, gp=gpar(col="white"))
  
  popViewport(2)
}
# view
grid.newpage()
gridfun()



新建一个 5 行 5 列的 viewport
grid.newpage()
pushViewport(
  viewport(
    layout = grid.layout(
      nrow = 5, 
      ncol = 5, 
      widths=unit(
        c(5, 1, 5, 2, 5), 
        c("mm", "null", "mm", "null", "mm")),
      heights=unit(
        c(5, 1, 5, 2, 5), 
        c("mm", "null", "mm", "null", "mm"))
      )
    )
  )

然后，分别在 2 行 2 列和 4 行 4 列 中放置一个刚定义的 viewport
pushViewport(
  viewport(
    layout.pos.col=2, 
    layout.pos.row=2)
  )
gridfun()
popViewport()

pushViewport(
  viewport(
    layout.pos.col=4, 
    layout.pos.row=4)
  )
gridfun()
popViewport(2)






2. 模仿R base的绘图区创建一个布局并绘图
(1) 九宫格布局
layout = grid.layout(nrow=3, ncol=3,
                   widths=unit(c(5, 1, 2), c("lines", "null", "lines")),
                   heights=unit(c(5, 1, 4), c("lines", "null", "lines")))

top.vp = viewport(layout=layout, name="top")
grid.show.layout(layout)


(2) 为边距命名
创建一系列的viewport，占用布局的各个分区，由于没有push任何viewport，因此画布中没有绘制任何图形。
在为每个视口命名时，使用统一的格式：margin+数值。

margin1 = viewport(layout.pos.col = 2, layout.pos.row = 3, name = "margin1") #(3,2)
margin2 = viewport(layout.pos.col = 1, layout.pos.row = 2, name = "margin2") #(2,1)
margin3 = viewport(layout.pos.col = 2, layout.pos.row = 1, name = "margin3") #(1,2)
margin4 = viewport(layout.pos.col = 3, layout.pos.row = 2, name = "margin4") #(2,3)
plot = viewport(layout.pos.col = 2, layout.pos.row = 2, name = "plot")       #(2,2)

# 其他四个都是 top.vp 的子元素
splot <- vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot))
pushViewport(splot)


# grid.show.viewport(margin1)

R用数字来表示位置，数值代表的含义是：1=Buttom，2=Left，3=Top，4=Right，视口被布局分割的分区如下图所示：
grid.show.viewport(top.vp) # ?? //todo



(3) 创建 viewport 树
使用vpList()把视口排列成一个树形结构，并把top.vp作为视图的父节点，把所有其他视口作为子节点，使用vpTree()创建一个viewport树：
> splot = vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot))

把整个viewport树push到活跃视口中，这样，在绘图区域中，我们可以在不同的散点视口中绘制图形。
> pushViewport(splot)

在把整个树push到活跃视口之后，就可以在不同的区域内绘制图形，使用seekViewport()函数按照视口名称切换到指定的视口，并把当前视口激活。
seekViewport("plot")
grid.xaxis()
grid.yaxis()
grid.rect()
grid.points(x, y)


完整代码如下: 创建布局，并画散点图，在边距添加坐标轴。
library(grid)
layout = grid.layout(nrow=3, ncol=3,
                      widths=unit(c(5, 1, 2), c("lines", "null", "lines")),
                      heights=unit(c(5, 1, 4), c("lines", "null", "lines")))
#grid.show.layout(layout)

top.vp =viewport(layout=layout,name="top")
#grid.show.viewport(top.vp)

x = runif(10)
y = runif(10)
xscale = extendrange(x)
yscale = extendrange(y)

margin1 = viewport(layout.pos.col = 2, layout.pos.row = 3, name = "margin1")
margin2 = viewport(layout.pos.col = 1, layout.pos.row = 2, name = "margin2")
margin3 = viewport(layout.pos.col = 2, layout.pos.row = 1, name = "margin3")
margin4 = viewport(layout.pos.col = 3, layout.pos.row = 2, name = "margin4")
plot = viewport(layout.pos.col = 2, layout.pos.row = 2, name = "plot",xscale = xscale, yscale = yscale)

splot = vpTree(top.vp, vpList(margin1, margin2, margin3, margin4, plot))
#grid.show.viewport(splot)



grid.newpage()
pushViewport(splot)

seekViewport("plot")
grid.xaxis()
grid.yaxis()
grid.rect()
grid.points(x, y,pch=20)

seekViewport("margin1")
grid.text("Random X", y = unit(1, "lines"))

seekViewport("margin2")
grid.text("Random Y", x = unit(1, "lines"), rot = 90)


# 回到顶层
upViewport(0)

# 顶部添加标题
seekViewport("margin3")
grid.text("The user adds a title!", gp = gpar(fontsize = 20))













========================================
grid 函数来创建和操作图形对象
----------------------------------------
1. 控制图像输出
我们可以使用图形原语来绘制图形输出，并返回一个图形对象(grobs)，例如

library(RColorBrewer)
grid.newpage()
grid.circle(
  name = "circles",
  x = seq(0.1, 0.9, length = 40),
  y = 0.5 + 0.4 * sin(seq(0, 2 * pi, length = 40)),
  r = abs(0.1 * cos(seq(0, 2 * pi, length = 40))),
  gp = gpar(col = brewer.pal(8, "Set2"))
)
# 这段代码将会绘制一串圆形
# 同时也会生成一个 circle grob，该对象保存了当前绘制的这些圆形的信息



(2) 怎么查看该对象？
grid 保留了一个显示列表，用于记录当前画布中的所有的 viewport 和 grobs。因此，grid.circle() 函数构造的对象也会保存在显示列表中，意味着我们可以根据对象的名称 circles 来获取、修改该对象

使用 grid.get() 函数，可以获取该 circle 对象的拷贝

> grid.get("circles") #就是创建时的 name 属性
circle[circles]


(3) 修改该对象 
使用 grid.edit() 可以用来修改该 circle 对象的图像属性

grid.edit(
  "circles",
  gp = gpar(
    col = brewer.pal(10, "RdBu")
    )
  )
# 修改颜色属性之后，会直接显示在图形输出中


(4) 删除对象 
还可以使用 grid.remove() 函数，从显示列表中删除图形对象的输出

grid.remove("circles")
# 画布一片空白，什么也没有





2. 标准的函数及参数
控制 grobs 的函数包括：

输出函数/对象函数: 描述 
grid.get()/ getGrob(): 返回一个或多个 grobs 的拷贝
grid.edit()/editGrob(): 修改一个或多个 grobs 
grid.add()/addGrob(): 添加一个或多个 grobs 
grid.remove()/removeGrob(): 删除一个或多个 grobs 
grid.set()/setGrob(): 替换一个或多个 grobs 

# 只要我们知道了 grobs 的名称，就可以对其获取、修改或删除
# 而 getNames() 函数，可以帮助我们获取当前图形中所有 grobs 的名称

(1) 所有图像输出函数的第一个参数都是图像对象的名称
# 我们绘制了 8 个同心圆，并根据奇偶顺序将 circle grob 命名为 circle.odd 和 circle.even
grid.newpage()
suffix <- c("even", "odd")

for (i in 1:8)
  grid.circle(
    name = paste0("circle.", suffix[i %% 2 + 1]),
    r = (9 - i) / 20,
    gp = gpar(
      col = NA, 
      fill = grey(i / 10)
      )
  )


(2) 修改对象
然后，我们可以使用 grid.edit() 函数，修改所有名为 circle.odd 的 grobs 的颜色
# 如果 global = TRUE，则会返回显示列表中所有匹配的对象，例如
grid.edit(
  "circle.odd", 
  gp = gpar(
    fill = brewer.pal(4, "Set3")[4]),
  global = TRUE #返回所有匹配的对象
)


# 如果参数 grep = TRUE，可以接受正则表达式对象名称
或者，用正则表达式来匹配带有 even 的 grob
grid.edit(
  "even", 
  gp = gpar(
    col = "#80b1d3", 
    fill = "#fdb462"
    ),
  grep=TRUE, #使用正则表达式
  global=TRUE
)




========================================
|-- grob 排布结构(gList, gTree) 与子对象的获取
----------------------------------------
1. grob 的排布结果包括：
	gList：包含多个 grobs 的 list
	gTree：grobs 的树形结构，即一个 grob 中包含其他的 grob

例如，对于 xaxis grob

grid.newpage()
pushViewport(viewport(y = 0.5, height = 0.5, width = 0.5))
grid.rect()
pushViewport(viewport(y = 0.5, height = 0.5, width = 0.5))

grid.xaxis(name="axis1", at=1:4/5)


(1) 会包含有多个子 grob，如线条，文本等
> childNames(grid.get("axis1"))
[1] "major"  "ticks"  "labels"

# 如果把 xaxis grob 看作为一棵树的根，那么它包含三个子 grob。
其中 major 和 ticks 是 lines grob，labels 为 text grob。

(2) 其中 at 参数设置了轴刻度，我们可以使用 grid.edit 来修改
grid.edit("axis1", at=1:3/4)

(3) 那想要修改 labels 的格式，怎么办？即如何访问一个对象的子对象呢？

可以使用 gPath(grob path) 函数，类似于 vpPath，可以使用父节点名称加子节点名称来访问
> grid.edit(gPath("axis1", "labels"), rot=45)

或者，也可以使用 axis1::labels 方式来访问
> grid.edit( "axis1::labels", rot=-45)


注意：grobs 的搜索是深度优先，也就是说，如果在显示列表中遍历到了一个 gTree grob，且未找到匹配项，则会对该 grob 执行深度优先遍历



(4) 这种 gTree 结构对象，也包含 gp 和 vp 参数。

在父节点上设置对应的 gp 参数值，会作为默认值传递给子对象。例如
> grid.xaxis(gp=gpar(col="grey"))

也可以将一个 viewport 直接作为参数值传递
> grid.xaxis(vp=viewport(y=0.75, height=0.5))








========================================
|-- 图形对象
----------------------------------------
1. 在前面的章节中，我们介绍的都是如何使用函数直接生成图形输出并返回图形对象（grob）
在这一节，我们将介绍如果创建 grob，但不绘制图形，通过对 grob 创建及修改，并在最后使用 grid.draw() 函数来绘制出图形。

(1) 每个能产生图形输出和图形对象的 grid 函数都有一个对应的只创建图形对象，没有图形输出的函数
例如，grid.circle() 对应于 circleGrob()，grid.edit() 对应于 editGrob()，在前面的函数表中都有列出

例如
grid.newpage()
pushViewport(viewport(width = 0.5, height = 0.5))
# 创建 x 轴对象
ag <- xaxisGrob(at=1:4/5)
# 修改对象，将标签的字体变为斜体、紫色、大字体
ag <- editGrob(ag, "labels", gp=gpar(fontface="italic", col="purple", cex=1.2))
# 绘图
grid.draw(ag)




(2) 我们可以将不同的 grob 组合在一起，生成一个复杂的图形。比如
grid.newpage()

# 我们构建一个名为 boxedText 的 gTree 对象，包含其子对象包括一个文本和一个矩形
tg <- textGrob("sample text")
rg <- rectGrob(
  width = 1.2*grobWidth(tg),
  height = 1.5*grobHeight(tg)
)
boxedText <- gTree(
  children = gList(rg, tg)
)

# 我们直接可以绘制组合对象
grid.draw(boxedText)





(3) 而对该对象的图形属性的修改，会反映到具体的子对象中

# 修改颜色
grid.draw(
  editGrob(
    boxedText, 
    gp=gpar(col="skyblue")
    )
)


# 指定 viewport
grid.draw(
  editGrob(
    boxedText, 
    vp = viewport(angle=45), #旋转角度
    gp = gpar(fontsize=18, col="red")
    )
)





========================================
|-- 捕获输出 的对象：grid.grab()
----------------------------------------
在上面的例子中，我们先构建了一个组合对象，然后绘制该对象
还可以反着来，先绘制图形对象，然后对它们进行组合。

1. 使用 grid.grab() 函数，可以获取当前画布中所有输出的图形对象，并以 gTree 的形式返回

例如，我们使用 ggplot2 绘制一个直方图，并获取所有图形对象
library(ggplot2)
ggplot(mpg) + geom_histogram(aes(displ, fill = class), bins = 10, position = "dodge")
histTree <- grid.grab()


(2) 然后，你可以尝试运行下面的代码，重绘该对象
grid.newpage()
grid.draw(histTree)


(3) 或者指定一个视口，画在画布上半部分：
grid.newpage()
vp1=viewport(x=0, y=1, width=1, height=0.5, just=c("left", "top"))
pushViewport(vp1)
grid.draw(histTree)


(4) 测试一下这个ggplot2对象有多少视口
> histTree
gTree[GRID.gTree.113] 
> current.vpTree()
viewport[ROOT]->(viewport[GRID.VP.7]->(viewport[GRID.VP.8]), viewport[GR...密密麻麻十几行

> childNames(histTree)
[1] "layout"
> childNames(grid.get("ROOT"))
Error in childNames(grid.get("ROOT")) : 
  it is only valid to get 'children' from a "gTree"




(5) 也可以使用 grid.grabExpr 来获取表达式的输出图形对象
grid.grabExpr(
  print(
    ggplot(mpg) + 
      geom_histogram(
        aes(displ, fill = class), 
        bins = 10, 
        position = "dodge")
    )
  )
# gTree[GRID.gTree.208] 





========================================
|-- 图形对象的放置：grid.frame/grid.pack/grid.place/placeGrob
----------------------------------------
1. 假设我们有一个复杂图形

# 文本对象
label <- textGrob(
  "A\nPlot\nLabel ",
  x = 0, 
  just = "left"
)

x <- seq(0.1, 0.9, length=50)
y <- runif(50, 0.1, 0.9)

# gTree 结构图形对象，包括矩形、线图、点图
gplot <- gTree(
  children = gList(
    rectGrob(
      gp = gpar(
        col = "grey60",
        fill = "#cbd5e8",
        alpha = 0.3)
    ),
    linesGrob(
      x, 
      y,
      gp = gpar(
        col = "#33a02c"
      )),
    pointsGrob(
      x, y, 
      pch = 16, 
      size = unit(5, "mm"),
      gp = gpar(
        col = "#fb8072"
      ))
  ),
  vp = viewport(
    width = unit(1, "npc") - unit(5, "mm"),
    height = unit(1, "npc") - unit(5, "mm")
  )
)


(1) 我们可以使用上一章节提到的布局方法，将该图像设计为 1 行 2 列的布局

layout <- grid.layout(
  nrow = 1, 
  ncol = 2, 
  widths = unit(
    c(1, 1), 
    c("null", "grobwidth"), 
    list(NULL, label)
    )
  )

然后将图形绘制到指定位置中
grid.newpage()
pushViewport(viewport(layout=layout))
pushViewport(viewport(layout.pos.col=2))
grid.draw(label)
popViewport()

pushViewport(viewport(layout.pos.col=1))
grid.draw(gplot)
popViewport(2)


(2) 但其实，grid 提供了更简便的函数用于放置 grobs

grid.frame() 函数创建一个没有子对象的 gTree，可以使用 grid.pack() 向其中添加子对象，同时确保为每个子对象保留足够的绘图空间

上面的代码可以改写成

grid.newpage()

# 新建一个空 frame
grid.frame(name="frame1")
# 放置 gplot 对象，在这一阶段，gplot 会占据整个 frame
grid.pack("frame1", gplot)
# 在 frame 的右边放置 label 对象
grid.pack("frame1", label, side="right")


# 这种动态的方式很简便，但是也带来了时间上的花费，随着需要放置的对象越来越多，速度会越来越慢。


(3) 另一种替代的方式是，先定义一个布局，然后再放置对象
grid.newpage()
grid.frame(name="frame1", layout=layout)

grid.place("frame1", gplot, col=1)
grid.place("frame1", label, col=2)


(4) 安静模式
在上面两个例子中，每次放置一个 grob 都会更新一遍图形输出。所以，一个更好的方式是，在安静模式下创建一个 frame，然后放置 grobs。

安静模式，即使用对象函数 frameGrob() 和 placeGrob()/packGrob 创建 frame、放置 grobs，但是不会输出图形，只有在所有设置完成之后，使用 grid.draw 一次性绘制

grid.newpage()

# 创建 frame
fg <- frameGrob(layout=layout)
# 添加 grob
fg <- placeGrob(fg, gplot, col=1)
fg <- placeGrob(fg, label, col=2)
# 一次性绘制
grid.draw(fg)








========================================
与 ggplot2 对象的交互与操作
----------------------------------------




========================================
|-- 使用 grid 拼接 ggplot2 对象
----------------------------------------
1. 我们之前拼接 grid 对象，是新建视口，并打印图形。
优点和缺点是要手动计算每个视口的位置，更灵活了，但是也更不自动化了。

实例: 带边缘分布的散点图
# step1: prepare ggplot charts
library(ggplot2)
library(grid)
p.hist.len <- ggplot(iris) + geom_histogram(aes(x=Sepal.Length))
p.hist.wid <- ggplot(iris) + geom_histogram(aes(x=Sepal.Width)) + coord_flip()
p.scatter <- ggplot(iris) + geom_point(aes(x=Sepal.Length, y=Sepal.Width))

# step2: 直接按百分比创建视口，然后画图
# top left panel
grid.newpage()
vp.len <- viewport(x=0, y=0.66, width=0.66, height=0.34, just=c("left", "bottom"))
pushViewport(vp.len)
print(p.hist.len, newpage=F)
upViewport() # 返回父节点

# bottom right panel
vp.wid <- viewport(x=0.66, y=0, width=0.34, height=0.66, just=c("left", "bottom"))
pushViewport(vp.wid)
print(p.hist.wid, newpage=F)
upViewport()

# bottom left panel
vp.scatter <- viewport(x=0, y=0, width=0.66, height=0.66, just=c("left", "bottom"))
pushViewport(vp.scatter)
print(p.scatter, newpage=F)
upViewport()





2. 使用 layout 布局，把 ggplot2 图形逐个打印到视口中
利用布局在同一个画布中绘制多个图形的另外一种方法是使用print()函数，代码摘抄于《R统计绘图（2）：grid布局》。

我们来演示下这种方法生成前言统计图形的过程：

step1，创建多个图形
library(ggplot2)
# prepare ggplot charts
p.hist.len = ggplot(iris) + geom_histogram(aes(x=Sepal.Length))
p.hist.wid = ggplot(iris) + geom_histogram(aes(x=Sepal.Width)) + coord_flip()
p.scatter = ggplot(iris) + geom_point(aes(x=Sepal.Length, y=Sepal.Width))

step2，创建布局，分割视口，并push当前视口
library(grid)
grid.newpage()
pushViewport(viewport(layout = grid.layout(3, 3)))

step3，把图形输出到布局的不同区域中
print(p.scatter, vp=viewport(layout.pos.row=2:3, layout.pos.col=1:2))
print(p.hist.len, vp=viewport(layout.pos.row=1, layout.pos.col=1:2))
print(p.hist.wid, vp=viewport(layout.pos.row=2:3, layout.pos.col=3))










ref: 
https://blog.csdn.net/albh81462/article/details/101662498
https://segmentfault.com/a/1190000007955532



========================================
|-- ggplot2设置坐标轴范围：用grid包在图中加入自定义要素 //todo
----------------------------------------
1. 需求： 有3张数据来源完全不同，theme什么的一大堆设置都调好的ggplot，把这三张图拼起来，然后共用一个x跟y轴，让他们变成一张图。

https://blog.csdn.net/weixin_39617685/article/details/109920035














========================================
grid包 实例
----------------------------------------
3. 实例

(1) 空白画布，一个倾斜的矩形。
library(ggplot2)
library(grid)

grid.newpage() # 创建一个空白画布
vp1 <-viewport(x =0.5, y =0.5, width =0.5, height =0.25, angle =45) # 设定视窗大小
grid.show.viewport(vp1) # 查看在画布中的的视窗，自动上色，方便观察



library(grid)
grid.show.viewport(
	viewport(x=0.6, y=0.6, width=unit(1, "inches"), height=unit(1, "inches"), angle=30)
)




# 画一个圆
library(grid)
grid.newpage() # 创建一个空白画布

vp <- viewport(width=0.9,height=0.9)
pushViewport(vp)
# a rectangle (with dashed lines) on the border of the viewport:
grid.rect(gp=gpar(lty="dashed"))
# a circle centered at (.6,.4) with radius .3:
grid.circle(x=0.6, y=0.4, r=0.3)





(2) 一个空画布，添加多个 viewport

有了viewport这个工具，我们就可以很灵活的在图形中画出任意区域分割的子图了。


library(ggplot2)
library(grid)

#library(showtext) 
#YaHei <-windowsFont("微软雅黑")
#font_add("YaHei", regular ="msyh.ttc", bold ="msyhbd.ttc")
# 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体
#showtext_auto() #### 父viewport

grid.newpage() #新建一个page

#1) 新建一个viewport，起点为左下角，
vp1 <-viewport(x =0, y =0.2, w =0.9, h =0.8, just =c("left", "bottom")) 
pushViewport(vp1) # 推出vp1
grid.rect(gp =gpar(col ="red")) # 新建一个矩形,gp=gpar()表示设置图形参数

grid.text("vp1_1", x =0.8, y =0.2, gp =gpar(col ="red", fontfamily ="YaHei", fontsize =15)) # 新建一个文本,输出到vp1


#2) 新建一个viewport，起点为左下角，
vp2 <-viewport(x =0, y =0.2, w =0.9, h =0.8, just =c("left", "bottom")) 
pushViewport(name =vp2) # 将工作区域设置到vp2

# 新建一个矩形,gp=gpar()表示设置图形参数
grid.rect(x =0.1, y =0.2, width =0.9, height =0.7, just =c("left", "bottom"), gp =gpar(col ="blue", lty ="dashed"))

# 新建一个文本,输出到vp2
grid.text("vp2_1", x =0.8, y =0.3, gp =gpar(col ="blue", fontfamily ="YaHei", fontsize =15))


#3) 新建一个viewport
vp3 <-viewport(x =0.1, y =0.2, width =0.9, height =0.7, just =c("left", "bottom"))
pushViewport(vp3)
grid.rect(x =0.1, y =0.2, width =0.7, height =0.7, just =c("left", "bottom"), gp =gpar(col ="orange", lty ="twodash", lwd =2))

# 新建一个矩形,gp=gpar()表示设置图形参数
grid.text("vp3_1", x =0.6, y =0.4, gp =gpar(col ="orange", fontfamily ="YaHei", fontsize =15)) # 新建一个文本,输出到vp2




(3) layout参数

library(ggplot2)
library(grid)

grid.newpage() 

# 设置分割的宽度和长度比例
g1 <-grid.layout(nrow =3, ncol =2, widths =c(2, 3), heights =c(2, 1, 3)) 

grid.show.layout(l =g1)



























========================================
子母图 //todo
----------------------------------------

子母图，主要是形成局部放大的效果，既可以从整体上对比，又兼顾特别小的数据组，或特别密的数据点可以查看，而没有必要单独做2张图







========================================
|-- 综合例子
----------------------------------------

(4) 上下两块，下面分左右两部分。
library(ggplot2)
library(grid)

#library(showtext) 
#YaHei <-windowsFont("微软雅黑")
#font_add("YaHei", regular ="msyh.ttc", bold ="msyhbd.ttc") # 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体
#showtext_auto() 

# 准备三个ggplot对象
plot.iris <-ggplot(iris, aes(Sepal.Length, Sepal.Width)) +
  geom_point() +
  facet_grid(cols =vars(Species)) # 按Species列分面

plot.mpg <-ggplot(mpg, aes(x =cty, y =hwy, colour =factor(cyl))) +
  geom_point(size =2.5) +
  labs(title ="dot plot") 

plot.diamonds <-ggplot(diamonds, aes(clarity, fill =cut)) +
  geom_bar() +
  theme(axis.text.x =element_text(angle =70, vjust =0.5)) +labs(title ="bar plot")

# 新建画布
grid.newpage()

layout_1<-grid.layout(nrow =3, ncol =2, widths =c(1, 1), heights =c(1, 4, 5)) # 分成上下2*3共6个版块，最上面版块显示标题

pushViewport(viewport(layout =layout_1)) # 推出分成6个版块的视窗

print(plot.iris, vp =viewport(layout.pos.row =2, layout.pos.col =c(1, 2))) # 在中间一行子视窗中画plot.iris
print(plot.mpg, vp =viewport(layout.pos.row =3, layout.pos.col =1)) # 在左下角子视窗中画plot.mpg
print(plot.diamonds, vp =viewport(layout.pos.row =3, layout.pos.col =2)) #在右下角子视窗中画plot.diamonds
grid.text("This is title", x =0.5, y =0.95, gp =gpar(col ="orange", fontfamily ="YaHei", fontsize =15)) #增加画布标题






(5) grid 拼接蝴蝶图
library(ggplot2)
library(grid)
library(dplyr)

#library(showtext)
#library(Cairo) 
#YaHei <-windowsFont("微软雅黑")
#font_add("YaHei",regular ="msyh.ttc", bold ="msyhbd.ttc") # 右键字体，然后点击属性，regular指定常规, bold表示指定粗体字体
#CairoPNG(file ="E:/R_input&output/images_output/蝴蝶图_exercing.png", width =1200, height =700)
#showtext_begin()

#生成图形所需数据集：
mydata<-data.frame(id=1:14,
                   A=c(5.0,14.7,2.5,8.5,5.1,6.9,7.7,6.8,4.4,4.9,5.3,1.0,0.9,7.8),
                   B=c(31.3,24.7,17.8,17.2,15.3,14.3,13.9,13.9,12.4,10.0,6.5,4.2,2.5,0.9),
                   Label=c("Website","Customer & Employee Referral","Webinar",
                           "Facebook/Twitter/Other Social","Marketting & Advertising","Paid Serch","Other",
                           "Sales generated","Tradeshows","Parter","Linkedin","Events","Lead list","Emial Campaign")) 

p1<-ggplot(mydata) +# 绘制右侧的柱形图
  geom_hline(yintercept=mean(mydata$A),linetype=2,size=.25,colour="grey")+
  geom_bar(aes(x=id,y=A),stat="identity",fill="#E2BB1E",colour=NA)+
  ylim(-5.5,16)+
  scale_x_reverse()+
  geom_text(aes(x=id,y=-4,label=Label),vjust=.5)+
  geom_text(aes(x=id,y=A+.75,label=paste0(A,"%")),size=4.5,family="YaHei",fontface="bold")+
  coord_flip()+
  theme_void() 
p1 

p2<-ggplot(mydata)+# 绘制左侧柱形图, 左侧图没有横坐标刻度标签
  geom_hline(yintercept=-mean(mydata$B),linetype=2,size=.25,colour="grey")+
  geom_bar(aes(x=id,y=-B),stat="identity",fill="#C44E4C",colour=NA)+
  # y=-B,绘制的图形在另一侧
  ylim(-40,0)+scale_x_reverse()+
  geom_text(aes(x=id,y=-B-1.75,label=paste0(B,"%")),size=4.5,family="YaHei",fontface="bold")+
  coord_flip()+
  theme_void()
p2

# 图形拼接
grid.newpage() # 新建画布
layout_1<-grid.layout(nrow =2, ncol =2, widths =c(2, 3), heights =c(1, 9)) # 分成2*2共4个版块
pushViewport(viewport(layout =layout_1)) # 推出分为4个版块的视窗
print(p1, vp =viewport(layout.pos.row =2, layout.pos.col =2)) # 将p1输出到右下角
print(p2, vp =viewport(layout.pos.row =2, layout.pos.col =1)) # 将p2输出到左下角

# 添加主标题和分标题
grid.text(label="main Title",x =0.5,y =0.97,gp=gpar(col="cyan",fontsize=15,fontfamily="YaHei",draw=TRUE,just ="centre"))
grid.text(label="left Title", x =0.15,y =0.94,gp=gpar(col="blue",fontsize=10,fontfamily="YaHei",draw=TRUE,just =c("left", "top")))
grid.text(label="right Title",x =0.85,y =0.94,gp=gpar(col="blue",fontsize=10,fontfamily="YaHei",draw=TRUE,just =c("right", "top")))
#showtext_end()
#dev.off()


========================================
改造：包装、升级
----------------------------------------
(4) 画一个椭圆

# From gCurve we generate a function called grid.mirror, which draws the mirror image of a curve.
"ellipse" <- function (w=1/10, h, angle, xrange = c(0, 1),
                       yrange = c(0,1), default.units = "native",
                       vp = viewport(xscale = xrange, yscale = yrange, height=h, width=w,
                                     angle=angle), gp1 = NULL, gp2 = NULL, name = NULL) {
  
  grid.mirror(0.5 + sqrt(0.5^2 - (0.5 - x)^2), 0, 1,
              default.units = default.units,
              return = FALSE, vp = vp, gp1 = gp1, gp2 = gp2, name = name)
}

vp <- viewport(width=0.9,height=0.9)
pushViewport(vp)
grid.rect(gp=gpar(lty="dashed"))
ellipse(h=0.5, angle=30)






========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

