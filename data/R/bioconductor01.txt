R包与bioconductor


常用语句：
if (!requireNamespace("BiocManager", quietly = TRUE)){
    install.packages("BiocManager")
}
BiocManager::install("ggplot2")




R程序官网：http://www.r-project.org/
bioconductor可用包：https://bioconductor.org/packages/3.3/bioc/
manual:http://compbio.mit.edu/cummeRbund/manual_2_0.html
ggplot2:http://ggplot2.org/  http://ggplot2.tidyverse.org/reference/

更好的流程是： 
ubuntu1604安装好，直接apt安装r-base，之后安装bioconductor，顺便提前apt安装xml和curl库。




========================================
R 包通用、常用操作
----------------------------------------
函数.libPaths()能够显示库所在的位置，
函数library()则可以显示库中有哪些包，
命令search()可以知道哪些包已加载并可使用。



1.选择使用哪个镜像：
setRepositories()



2. 查看当前加载的包
(.packages()) 

## To see the list of currently loaded packages use
search() #相比上句少了几个



(2) 卸除已加载的包
如卸除RMySQL包
>detach('package:RMySQL')


注意是卸除，不是卸载，也就是说不是把包从R运行环境中彻底删除，只是不希望该包被加载使用。

在包使用函数冲突，检验函数依赖时比较有用。


>detach('package:ggplot2')
在升级该包时，不能是加载状态，如果不想重启Rstudio，就可以先卸除该包，再执行安装命令，安装新包。


(3) 查看已安装包的版本号
packageVersion("SingleR") #‘1.1.6’


(4) 查看 BiocManager 是否有警告
BiocManager::valid() #诊断
BiocManager::valid()$out_of_date # 过时的包

如果升级，使用空命令
BiocManager::install() #升级 all





========================================
|-- R包的安装位置，查询和设置
----------------------------------------
1. 查询包的安装位置

> Sys.getenv("LD_LIBRARY_PATH") #这是动态链接库
[1] "/usr/local/lib/R/lib::/lib:/usr/local/lib:/usr/lib/x86_64-linux-gnu:/usr/lib/jvm/java-11-openjdk-amd64/lib/server"


> Sys.getenv() #获取全部配置参数

# R_LIBS_SITE             /usr/local/lib/R/site-library:/usr/lib/R/site-library:/usr/lib/R/library ##内置的包 R3.6


> Sys.getenv("R_LIBS") 
[1] "/usr/local/lib/R/site-library: #找到了刚安装的 ggplot2
/usr/local/lib/R/library" ##内置的包 R4.0: base, stats4, class, 





2. 用户自定义安装包路径：.libPaths()

(1) 全新安装的R
> .libPaths() # 包的查找路径
# [1] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"


> Sys.getenv("R_LIBS_USER")  #用户自定义安装的包
[1] "~/R/x86_64-pc-linux-gnu-library/4.0" #不存在这个路径

# 新建这个路径
$ mkdir -p /home/rstudio/R/x86_64-pc-linux-gnu-library/4.0
$ ls /home/rstudio/R/x86_64-pc-linux-gnu-library/4.0


重启R(Rstudio 菜单 Session - quit session)，再次查询
> .libPaths() # 包的查找路径
[1] "/usr/local/lib/R/site-library"                  
[2] "/usr/local/lib/R/library"                       
[3] "/home/rstudio/R/x86_64-pc-linux-gnu-library/4.0"





(2) 如果新建文件 ~/.Rprofile 
$ cat ~/.Rprofile 
.libPaths("/home/rstudio/R/x86_64-pc-linux-gnu-library/4.0")

重启R(Rstudio 菜单 Session - quit session)，再次查询
> .libPaths() # 包的查找路径
[1] "/home/rstudio/R/x86_64-pc-linux-gnu-library/4.0"
[2] "/usr/local/lib/R/site-library"                  
[3] "/usr/local/lib/R/library"

发现这个自定义路径跑到了最前面。

这时，安装包的文件就自动跑到了下面。









========================================
|-- 如何查看R语言package中自带哪些数据集以及各个数据集的描述？
----------------------------------------

1.如何知道一个包内的函数名字列表？
help(package="packagename")

假设包的名字叫abc，里面某一个函数叫def:可以用  library(help=abc)  看这个包里有什么函数，数据集等。
调用这个包可以用  library(abc)  。
如果要看函数如何用，可以  ?def，这样会出来函数的帮助文件。
如果要看具体函数的代码，很多情况直接输入  def  是不行的，因为R是面向对象的程序语言，可以先用methods(def)看这个函数有什么“方法”。

比如sspir这个包，想看里面的kfilter函数的代码，可以用library(sspir)加载这个包，然后methods(kfilter)，下面会出来结果：kfilter.SS和kfilter.ssm。然后你直接输入kfilter.SS就出来具体代码了。

http://bbs.pinggu.org/thread-1556305-1-1.html



(1) 查看R内置数据集
data()
## Data sets in package ‘datasets’:
...

(2)查看包中的数据集
print(data(package='具体的package名'))
例如：
print(data(package='fda'))
通过上述命令，就可知道具体的package中包含的datasets。

载入包中的数据，通过
print(data(package='glmnet')) #显示该包中的所有数据集
data('CoxExample') #载入数据


(3)对于某个特定的数据集，我们可通过命令
?数据集名称
来进一步了解数据集，如对于fda包中的数据集CanadianWeather，可用?CanadianWeather 查看该数据集的详细描述。












========================================
|-- 如何获得R包的全部（所有）函数名字？
----------------------------------------
1. library(help = datasets) # Get the list of functions in the package
library(help = ggplot2) 
#自动打开新标签，向下滚动，找到 索引 Index。
# +.gg                    Add components to a plot
# CoordSf                 Visualise sf objects
# aes                     Construct aesthetic mappings


或只看索引
x <- library(help = ggplot2)
x$info[[2]]




2. ls("package:datasets") will list all the objects in the package
只看base基础包函数名可以 ls("package:base")

> ls("package:ggplot2")
#  [1] "%+%"        "%+replace%"     "aes"                      
#  [4] "aes_"       "aes_all"        "aes_auto" 




3. List Objects and their Structure
> library(ggplot2)
#Need help? Try Stackoverflow: https://stackoverflow.com/tags/ggplot2.

> lsf.str("package:ggplot2") #List Objects and their Structure
# %+% : function (e1, e2)  
# %+replace% : function (e1, e2)  
# aes : function (x, y, ...)  


# 查看所有的变量名（含函数名）
> ls(envir=as.environment("package:ggplot2"))
#  [1] "%+%"                       "%+replace%"                "aes"                      
#  [4] "aes_"                      "aes_all"                   "aes_auto"                 
#  [7] "aes_q"                     "aes_string"                "after_scale"   





4. help(package="程序包名") #打开web帮主页
help(package="ggplot2")
help(package="pasilla")



5. If you want all exported functions (i.e. functions accessible via ::), then getNamespaceExports(pkgName) will do the trick.
> getNamespaceExports('ggplot2')
  [1] "draw_key_vpath"            "StatDensity2dFilled"       "find_panel"               
  [4] "stat_density2d_filled"     "stat_count"                "scale_fill_date"
#


(2)
If you want all functions in the package, including the ones accessible via :::, you can do ls(getNamespace(pkgName)).

> ls(getNamespace("ggplot2"))
  [1] "[.mapped_discrete"                "[.uneval"                        
  [3] "[[.ggproto"                       "[[<-.uneval"                     
  [5] "[<-.mapped_discrete"              "[<-.uneval"                      
  [7] "%+%"                              "%+replace%"                      
  [9] "%||%"                             "%|W|%" 
#



refer:
https://stackoverflow.com/questions/20535247/seeking-functions-in-an-r-package






========================================
安装R包的几种方法(Install Bioconductor Packages)
----------------------------------------
新版R包安装函数有变化：
To install this package, start R (version "3.6") and enter:

if (!requireNamespace("BiocManager", quietly = TRUE)){
    install.packages("BiocManager")
}
BiocManager::install("pasilla")



#从github安装包
https://github.com/twitter/AnomalyDetection:
library(devtools)
install_github("twitter/AnomalyDetection")


#常规安装bioconductor包
source('https://bioconductor.org/biocLite.R');
biocLite('glmnet')


#指定本地包名
install.packages(path_to_file, repos = NULL, type="source")
install.packages("E:\matrixStats_0.51.0.tar.gz", repos = NULL, type="source")

#指定包的镜像
install.packages("RJSONIO", repos = "http://www.omegahat.org/R", type="source")

#直接命令行安装R包
D:\Program Files\R\R-3.3.2\bin\x64>Rcmd INSTALL E:\xx_1.0.1.tar.gz
R CMD build --binary RJSONIO_0.2-3.tar.gz






####

http://www.bioconductor.org/install/#install-bioconductor-packages
http://www.bioconductor.org/packages/release/bioc/html/cummeRbund.html
http://compbio.mit.edu/cummeRbund/


## try http:// if https:// URLs are not supported
> source("https://bioconductor.org/biocLite.R")
> biocLite() #推荐先安装默认组件 
> biocLite('cummeRbund') #再具体安装某一个

BioC_mirror: https://bioconductor.org
Using Bioconductor 3.3 (BiocInstaller 1.22.3), R 3.3.1 (2016-06-21).
Installing package(s) ‘cummeRbund’
also installing the dependencies ‘httpuv’, ‘xtable’, ‘htmltools’, ‘shiny’, ‘jsonlite’, ‘mime’, ‘curl’, ‘openssl’, ‘R6’, ‘lambda.r’, ‘futile.options’, ‘Matrix’, ‘chron’, ‘interactiveDisplayBase’, ‘httr’, ‘colorspace’, ‘futile.logger’, ‘snow’, ‘survival’, ‘Formula’, ‘cluster’, ‘rpart’, ‘nnet’, ‘acepack’, ‘foreign’, ‘gridExtra’, ‘data.table’, ‘AnnotationHub’, ‘dichromat’, ‘munsell’, ‘labeling’, ‘stringi’, ‘magrittr’, ‘bitops’, ‘BiocParallel’, ‘SummarizedExperiment’, ‘Hmisc’, ‘VariantAnnotation’, ‘ensembldb’, ‘DBI’, ‘digest’, ‘gtable’, ‘MASS’, ‘scales’, ‘stringr’, ‘Rcpp’, ‘GenomicRanges’, ‘XML’, ‘IRanges’, ‘XVector’, ‘GenomeInfoDb’, ‘Biostrings’, ‘zlibbioc’, ‘RCurl’, ‘Rsamtools’, ‘GenomicAlignments’, ‘lattice’, ‘RColorBrewer’, ‘biomaRt’, ‘AnnotationDbi’, ‘GenomicFeatures’, ‘BSgenome’, ‘biovizBase’, ‘latticeExtra’, ‘matrixStats’, ‘BiocGenerics’, ‘RSQLite’, ‘ggplot2’, ‘reshape2’, ‘fastcluster’, ‘rtracklayer’, ‘Gviz’, ‘plyr’, ‘S4Vectors’, ‘Biobase’

如果下载失败，及时手动下载补充安装包：
位置：/tmp/Rtemptxxxx/downloaded_packages （使用root权限）
链接类型：https://cran.r-project.org/src/contrib/Formula_1.2-1.tar.gz
需要找一个靠谱的cran源。

安装后这些包的位置：
/usr/local/lib/R/site-library/


教训：使用R3.3.1版本安装出现更多警告！使用R3.2正常安装。
The downloaded source packages are in
	‘/tmp/RtmpFiZMVb/downloaded_packages’
There were 29 warnings (use warnings() to see them)
> warnings()
Warning messages:
1: In install.packages(pkgs = doing, lib = lib, ...) :
  installation of package ‘cluster’ had non-zero exit status
2: In install.packages(pkgs = doing, lib = lib, ...) :
  installation of package ‘acepack’ had non-zero exit status
3: In install.packages(pkgs = doing, lib = lib, ...) :
  installation of package ‘munsell’ had non-zero exit status
4: In install.packages(pkgs = doing, lib = lib, ...) :
  installation of package ‘htmltools’ had non-zero exit status
...
29: In install.packages(pkgs = doing, lib = lib, ...) :
  installation of package ‘cummeRbund’ had non-zero exit status
> 

  
安装好后，可以使用" .packages(all. available=TRUE) "在R中查看已安装的程序包。




查看该包的详细文档：
> browseVignettes("cummeRbund")




========================================
|-- 没有root 权限下 R安装包方法
----------------------------------------

1. 查看R包的引用路径
> .libPaths() 
## [1] "/home/wangjl/R/x86_64-pc-linux-gnu-library/3.4"
## [2] "/usr/local/lib/R/site-library"                 
## [3] "/usr/lib/R/site-library"                       
## [4] "/usr/lib/R/library" 



2.如果想指定目录，可以在自己的home目录下，创建一个名称为 .Rprofile 的文件；
文件内容修改成： 
R_LIBS_USER="your lib path"

例如：
R_LIBS_USER="/home/BBQ100/R_lib"

重新打开1个R，然后再去查看.libPaths() ，是否添加成功。
如果没有成功

用以下方法：
在 ~/.bashrc 中设置
export R_LIBS_USER=/your/path

直接安装









========================================
|-- 提速安装：换BioConductor镜像
----------------------------------------
1.在中国大陆使用默认的bioconductor可能下载速度特别慢，可以使用中国科技大学、清华大学或者日本的镜像。

## 查看当前的安装源
biocinstallRepos()

## 用chooseBioCmirror()换BioConductor镜像
chooseBioCmirror()
setRepositories()



 
 

refer:
http://www.bioconductor.org/about/mirrors/
https://bioc.ism.ac.jp/
中科大(镜像好像坏了) http://mirrors.ustc.edu.cn/
清华大学bioconductor镜像：https://mirrors.tuna.tsinghua.edu.cn/

http://bioconductor.org/packages/3.3/bioc/manuals/BiocInstaller/man/BiocInstaller.pdf





######
# 过时或已不能访问:
######
2).[推荐]## The usage of biocLite() is also possible:
source("https://bioc.ism.ac.jp/biocLite.R")
biocLite("WGCNA")

3. 直接指定镜像
source("http://bioconductor.org/biocLite.R")
#指定一个离你最近的国内镜像
options(BioC_mirror="http://mirrors.ustc.edu.cn/bioc/")
biocLite("包名")




 
========================================
如何将R和RStudio中界面的语言转变成英文
----------------------------------------
找到R程序的etc文件夹中Rconsole，以管理员身份打开记事本，用记事本开Rconsole。 
找到“ language =  ”一行，将其改为 "language = en" 。保存即可。

http://mito.air-nifty.com/mitoakiyoshiblog/2011/01/how-to-change-l.html
http://blog.sciencenet.cn/blog-526092-686410.html




========================================
与测序相关的conductor包：
----------------------------------------
 Sequencing (347)
	 ChIPSeq (61)
	 DNASeq (10)
	 ExomeSeq (6)
	 HiC (7)
	 MethylSeq (15)
	 Microbiome (9)
	 miRNA (9)
	 RiboSeq (4)
	 RIPSeq (2)
	 RNASeq (130)
	 TargetedResequencing (5)
	 WholeGenome (15)


========================================
|-- Bioconductor, SingleCellExperiment and scater
----------------------------------------
1.推荐新手和老手使用良好开发和维护的Bioconductor方法和类。
https://www.bioconductor.org/developers/how-to/commonMethodsAndClasses/


2.SingleCellExperiment (SCE)
是一个处理单细胞实验的S4类，包括专门针对每个细胞的存储和检索spike-in信息、降维、ize factors，以及常规对基因和文库的方法。

(1)实际上，可以用构造器创建该类的对象。

library(SingleCellExperiment)
counts <- matrix(rpois(100, lambda = 10), ncol=10, nrow=10)
rownames(counts) <- paste("gene", 1:10, sep = "")
colnames(counts) <- paste("cell", 1:10, sep = "")
sce <- SingleCellExperiment(
    assays = list(counts = counts),
    rowData = data.frame(gene_names = paste("gene_name", 1:10, sep = "")),
    colData = data.frame(cell_names = paste("cell_name", 1:10, sep = ""))
)
sce


(2)作者建议如下命名：
 - counts: Raw count data, e.g., number of reads or transcripts for a particular gene.
 - normcounts: Normalized values on the same scale as the original counts. For example, counts divided by cell-specific size factors that are centred at unity.
 - logcounts: Log-transformed counts or count-like values. In most cases, this will be defined as log-transformed normcounts, e.g., using log base 2 and a pseudo-count of 1.
 - cpm: Counts-per-million. This is the read count for each gene in each cell, divided by the library size of each cell in millions.
 - tpm: Transcripts-per-million. This is the number of transcripts for each gene in each cell, divided by the total number of transcripts in that cell (in millions).

从counts 转换为 normcounts ：
normcounts(sce) <- log2(counts(sce) + 1)
sce

查看
dim(normcounts(sce)) #维度
head(normcounts(sce)) #前几行



3. scater package-Single-cell analysis toolkit for gene expression data in R
(1)scater is a R package for single-cell RNA-seq analysis (McCarthy et al. 2017)
该包包含很多有用的方法，做质控、可视化、前处理。

http://bioconductor.org/packages/release/bioc/html/scater.html
A collection of tools for doing various analyses of single-cell RNA-seq gene expression data, with a focus on quality control.
包含很多scRNAseq数据分析方法，焦点是质控。

scater的特色功能是：
 - Automated computation of QC metrics 自动化QC特性。
 - Transcript quantification from read data with pseudo-alignment 转录定量。
 - Data format standardisation 数据格式标准化。
 - Rich visualizations for exploratory analysis 丰富可视化来探索分析。
 - Seamless integration into the Bioconductor universe 和Bioconductor宇宙无缝连接。
 - Simple normalisation methods 简单的归一化方法。

强烈建议所有scRNAseq分析都使用scater。

(2)scater可以对你的mapping and alignment之后的表达矩阵做质控、过滤、标准化。
老版本scater使用SCESet类，而新版本使用SingleCellExperiment 类。功能不变。如下图：
http://hemberg-lab.github.io/scRNA.seq.course/figures/scater_qc_workflow.png

前处理、质控：从raw RNAseq read到可以做下游分析的clean、tidy dataset，。








========================================
R操作mysql数据库
----------------------------------------

1. 把mysql连接信息写到文件中。
$ cat /home/wangjl/pylib/con_mysql.R
library(DBI)
library(RMySQL)
con<-dbConnect(MySQL(),user='root', password='123456',dbname='wang',host='y.biomooc.com',
               port=7070, DBMsencoding='utf8')
dbSendQuery(con,'SET NAMES utf8;') #读取防乱码
query<-dbSendQuery(con,'alter database wang character set utf8;') #写入防乱码
#
#query<-dbSendQuery(con,'select cid, cellType from cell_c1 where cellType="HeLa_sync"')
#data=fetch(query, n=-1);
#data




2. 把数据查询写成函数
#R语言的数据库链接
rm(con)
getDF_fromDB=function(sql){
  source('/home/wangjl/pylib/con_mysql.R')
  query<-dbSendQuery(con, sql );
  data=fetch(query, n=-1);
  #
  print(dim(data))
  print(head(data))
  return(data)
}



# 获取编码基因，和非编码基因
sql=paste0('select distinct gene_name,gene_type from feature_gene;');
geneNames=getDF_fromDB(sql)
# [1] 58692     2
#   gene_name      gene_type
# 1    TSPAN6 protein_coding
# 2      TNMD protein_coding
# 3      DPM1 protein_coding
# 4     SCYL3 protein_coding





========================================
|-- R通过ODBC连接数据库(win)
----------------------------------------
以下的实验环境是在windows7-64操作系统下进行
1、下载（mySQL-connector-odbc-5.3.7-win64.msi）
     下载地址：http://dev.mysql.com/downloads/connector/odbc (8.2 MB) 
2、安装Mysql的RODBC：mysql-connector-odbc-5.3.2-win64.msi
3、配置datasource

(1)找到C:\Windows\System32\odbcad32.exe
(2)左侧点击 添加 ，选择MySQL ODBC ANSI Driver/或 unicode，点击完成；
(3)填写表格，名字(填写mysqlodbc或自定义，下文R的odbcConnect第一个参数要用)建议用无空格的英文，描述随便写，填写mysql用户名和密码，选择数据库，点击OK。
(4)回到ODBC数据源管理器，选择mysqlodbc，点击确定。

4.R软件访问mysql数据库
(1)安装及加载RODBC
install.packages("RODBC")
library(RODBC)

(2) 与mysql建立连接
channel=odbcConnect("mysqlodbc", uid="root", pwd="")

（3）查询该数据库下都有哪些数据库表

> sqlTables(channel)
  TABLE_CAT TABLE_SCHEM   TABLE_NAME TABLE_TYPE REMARKS
1      test                       aa      TABLE        
2      test              first_table      TABLE        
3      test             second_table      TABLE        
4      test                 students      TABLE 
5      test                 orders      TABLE   

（4）查询某个表中的数据返回给数据框
> orders=sqlFetch(channel,"orders")
> orders
 order_id order_name order_unit order_quantity order_price order_note order_time
1 1  2500ml95%酒精  桶  17 12  NA 1464

（5）条件查询
orders2=sqlQuery(channel,"select order_name,order_price from orders order by order_id desc");

（6）将数据框中的数据保存到数据库表中
USArrests #这是R的默认内置数据，是一个数据框

数据框的首列没有列名，所以在保存之前需要指定列名
sqlSave(channel, USArrests, rownames = "state", addPK = TRUE)

cmd打开数据库查看test库，多了usarrests表，里面正是数据框中的内容。可见数据框能正确的保存到mysql数据库中去了

添加一条数据
rs3=sqlQuery(channel,"insert into usarrests(state,murder,assault,urbanpop,rape)values('noplace',0,0,0,0)");
发现数据已经在了。

（7）在R软件将刚才添加到mysql数据库中的表删除掉
sqlDrop(channel,"usarrests")

（8）关闭连接资源
odbcClose(channel)

（9）通过RODBC进行数据存取的主要函数
函数名字	函数描述
odbcConnect(dsn,uid="",pwd="")  #建立并打开连接
sqlFetch(channel,sqtable) #从数据库读取数据表，并返回一个数据框对象
sqlQuery(channel,query) #想数据库提交一个sql查询，并返回结果（'data.frame'格式）
sqlSave(channel,mydf,tablename=sqtable,append=FALSE) #将一个数据框写入或更新(append=True)到数据库
sqlDrop(channel,sqtable) #从数据库删除一个表
sqlClear(channel,sqltable) #删除表中内容
sqlTable(channel) #返回数据库中表的信息
sqlColumns(chanel,sqltable) #返回数据库表sqltable列的信息
close(channel) #关闭连接

操作步骤：
建立DSN
打开连接
数据操作
关闭连接 


实例1
#加载包
library(RODBC)

#创建连接
channel<-odbcConnect("BITEST",uid="dw",psw="dw")

#执行查询
org1<-sqlFetch(channel,'DIM.DIM_ORGANIZATION') #这是oracle数据库
org2<-sqlQuery(channel,"select * from DIM.DIM_ORGANIZATION")

#关闭连接
odbcClose(channel)

#使用数据
head(org1)
head(org2)



实例2 通过RODBC将数据写入oracle

library(RODBC)
channel<-odbcConnect("BITEST",uid="dw",psw="dw")
#创建数据，待写入对象
mydata<-sqlQuery(channel,'select * from DIM.DIM_ORGANIZATION')

#写入数据库，并读取结果
sqlSave(channel,mydata,"NEW_TABLE_NAME", append=FALSE)
mydata2=sqlQuery(channel,'select * from NEW_TABLE_NAME')

#更新数据库，并读取结果
sqlSave(channel,mydata,"NEW_TABLE_NAME", append=TRUE)
mydata3=sqlQuery(channel,'select * from NEW_TABLE_NAME')

#删除刚刚建立的数据表NEW_TABLE_NAME
sqlDrop(channel,"NEW_TABLE_NAME")
odbcClose(channel)

#查看执行结果
head(mydata,n=30)
head(mydata2,n=30)
head(mydata3,n=30)


refer:
http://wenku.baidu.com/link?url=PtNUOCT66CzajvN_uM_4FaCloQffW8HzaE1PMlOg3UqyXwpZNbT3DC1URy-tsLqQRIeW_DJhxBsS06QsY99OjKSq_BV7--vj1zWhtga7k1_
http://blog.csdn.net/hongweigg/article/details/49779943
http://www.dataguru.cn/thread-289411-1-1.html





========================================
|-- R通过RMySQL包操作mysql数据库(linux)
----------------------------------------
test: 2019.10
mysql on docker ubuntu1806;
Rstudio on centOS7


1.Rmysql库安装
注意: Rmysql库依赖DBI库

install.packages("DBI")
install.packages("RMySQL") 或 install.packages('RMySQL',type='source')

查看已安装的包：
.packages(all.available=TRUE)

至此安装完毕,如果中间过程还出问题,可能底层C++环境欠缺
参考:https://www.jianshu.com/p/d57355c57876






2.
另外R连接mysql会出现中文乱码变问号情况，查到COS上一个贴子，解决方案如下：
在MySQL的配置文件/etc/mysql/my.cnf中[client]标签下加default-character-set=utf8 

这个我试了，总是报错。我用的docker版的mysql，是这个原因吗？
后面避免读写中文乱码，使用的是sql语句。

library(DBI)
library(RMySQL)
con<-dbConnect(MySQL(),user='root', password='123456',dbname='wang',host='y.biomooc.com',
               port=7070, DBMsencoding='utf8')
dbSendQuery(con,'SET NAMES utf8;') #读取防中文乱码
query<-dbSendQuery(con,'alter database wang character set utf8;') #写入防中文乱码
#
query<-dbSendQuery(con,'select * from fruits;')
data=fetch(query);
data #获得数据框





3. 在R中使用RMySQL
library(DBI)
library(RMySQL)
#help(package="RMySQL") #查看说明文档

##连接数据库
con<-dbConnect(MySQL(),user='root', password='123456',dbname='wang',host='y.biomooc.com',port=7070, DBMsencoding='utf8')
## 连接linux本地的mysql不需要输入host，默认port=3306。

##关闭数据库
## dbDisconnect(con) 




(1)查询：dbSendQuery的使用 
dbSendQuery返回的MySQLResult类型，而dbGetQuery直接返回数据框data.frame

dbSendQuery(con,'SET NAMES utf8') #先执行这一句，防止中文显示乱码


#i) 用sql语句查询，获得数据框，直接获得查询结果 
dbGetQuery(con, "SELECT * FROM fruits limit 3")



#ii) 用sql语句查询，获得数据框，两步法获取查询结果
res <- dbSendQuery(con, "SELECT *FROM fruits")#获取前2条数据，n=-1时是获取所有数据  
data <- dbFetch(res, n=2) #再获取余下几条数据
data
data <- dbFetch(res, n=-1) #取余下所有数据
data

dbClearResult(res)#清除查询结果

#dbDisconnect(con)#断开连接  




#iii) 用R函数，读整个数据表  
tb=dbReadTable(con,"result")
tb
##   name subject score
## 1 张三    数学    90
## 2 张三    语文    50
## 3 张三    地理    40
## 4 李四    语文    55
## 5 李四    政治    45
## 6 王五    政治    30




(2)查看状态
> summary(con) #获取连接信息
<MySQLConnection:0,0>
  User:   root 
  Host:   y.biomooc.com 
  Dbname: wang 
  Connection type: y.biomooc.com via TCP/IP 

Results:
<MySQLResult:0,0,0>
  Statement: select * from cell_c1 limit 3; 
  Has completed? yes 
  Affected rows: -1 
  Rows fetched: 3 
NULL


dbGetInfo(con) #获取连接信息
dbListTables(con) #查看database下所有表格




ii) 防止中文乱码
mysql> show variables like "char%";
+------------ -------------+------------ ---------------+
| Variable_name            | Value                      |
+----------- --------------+------------- --------------+
| character_set_client     | utf8                       |
| character_set_connection | utf8                       |
| character_set_database   | latin1                     | #改为utf8写入才能避免R写入中文时乱码
| character_set_filesystem | binary                     |
| character_set_results    | utf8                       |
| character_set_server     | latin1                     |
| character_set_system     | utf8                       |
| character_sets_dir       | /usr/share/mysql/charsets/ |
+----------- --------------+---------- -----------------+
8 rows in set (0.01 sec)

#防止写入中文时乱码
dbSendQuery(con,'alter database wang character set utf8;') #数据库改为utf8，否则写入会中文乱码

#查询字符集
query<-dbSendQuery(con,'show variables like "char%";')
df=fetch(query) #返回值是数据框






(3)写数据库表: 创建新表，写入 
#dbWriteTable(conn, "tablename", data) #写表

#写表，把fruits写入水果数据表"fruits"
fruits <-data.frame(id=1:5,name=c("苹果","香蕉","梨子","玉米","西瓜"),price=c(8.8,4.98,7.8,6,2.1),status=c("无","打折","无","售罄","批发"))  
dbListTables(con)
dbWriteTable(con,"fruits",fruits,row.names=F, fileEncoding="utf-8")  #写入中文乱码！编码一致就正常了
dbListTables(con)


#使用sql查询
query<-dbSendQuery(con,'select * from fruits limit 3;')
data<-fetch(query)

#追加数据表，是否覆盖
#new_info <- data.frame(user_id=6:7,user_name=c("小明","小红"),score = c(82,74))
#dbWriteTable(conn,"student_info ",new_info, append=T,row.names=F) #追加数据
#dbWriteTable(conn," student_info ",testB,overwrite=T,row.names=F)#覆盖数据

new_info <- data.frame(id=6:7,name=c("水果1","水果2"),price = c(8.2,7.4),status=c("打折","批发"))
dbWriteTable(con,"fruits",new_info,append=T,row.names=F) #追加数据
dbWriteTable(con,"fruits",new_info,overwrite=T,row.names=F)#覆盖数据：以前的数据被清空，现在只有这个新增的数据了



(4)删除表
dbRemoveTable(con, "fruits")



(5)其他方法
summary(con) #连接信息

dbGetInfo(con)

dbListTables(con) #列出所有的表

dbExistsTable(con,'table_name')#是否存在表

dbListResults(con) #列出所有的结果

dbClearResult(res) #清除结果






附录：
1. SQL语句语句特点：先全局选择，再局部选择
Select * from sale where year=2010 and ...


2.where后面可以接很多，有比较运算符，算数运算符，逻辑运算符。
- 比较运算符号：=(等于，不是双引号)；!=（不等于）；>，<，>=，<=
- 算数运算符：*，/，+，-
- 逻辑运算符：&&(and,与)， ||（or，或） ，!（,not非）




refer:
https://blog.csdn.net/sinat_26917383/article/details/51601539




========================================
|-- R操作sqlite
----------------------------------------
1. sqlite的优点就是既有数据库的sql操作灵活性（和mysql很类似），又有文件的存放便捷性(不需要连接数据库等操作)。
缺点是只适用于小数据集。

(1) 实例1
# install.packages("RSQLite")
library(RSQLite)

#连接表，所有结果保存到一个文件中
db = dbConnect(SQLite(), dbname="~/web/docs/your-db.sqlite")

#之后和mysql操作一样了。

# 创建表
dbSendQuery(conn=db,
   "CREATE TABLE SSGB_obs
   (Date DATETIME,
   Station TEXT,
   Snowline TEXT,
   PRIMARY KEY (Date, Station))
")

# List tables in your database
dbListTables(db)
 
# List columns in a table
dbListFields(db, "SSGB_obs")


#导入一批csv文件到db表：雪线的数据
# List files
f = list.files("./csv/clean/")
# Read csvs
# Format for database
# Write to database
for (i in f){
  x = read.table(paste0("./csv/clean/", i), sep ="|", stringsAsFactors=F)
  for (j in names(x[-1])){
    Date = x[-1,1]
    Station = x[1,j]
    Snowline = x[-1,j]
    data = cbind.data.frame(Date,Station,Snowline)
    dbWriteTable(conn=db, name="SSGB_obs", data, append=T, row.names=F)
  }
}

# 读出数据，得到的是数据框
x = dbGetQuery(db, "
   SELECT * FROM SSGB_obs
")






(2) 实例2
library(RSQLite)
sqlite    <- dbDriver("SQLite")
con <- dbConnect(sqlite,"hg19_bioconductor.sqlite") # makes a new file

#写入数据到db
suppressMessages(library(org.Hs.eg.db))
kegg2ID=toTable(org.Hs.egPATH)
#[1] "gene_id" "path_id"
dbWriteTable(con,'keggID2geneID',kegg2ID,row.name=F,overwrite=T)

#读出db
x = dbGetQuery(con, "
   SELECT * FROM keggID2geneID
")
class(x) #[1] "data.frame"
head(x)

dbDisconnect(con) #关闭连接

# 查文件大小
system("ls -l hg19_bioconductor.sqlite", show=TRUE)
# -rw-r--r--. 1 wangjl jinwf 290816 Nov 23 21:19 hg19_bioconductor.sqlite














ref:
一个R语言package：https://cran.r-project.org/web/packages/RSQLite/RSQLite.pdf
参考：https://scottishsnow.wordpress.com/2014/08/14/writing-to-a-database-r-and-sqlite/
示例代码：http://faculty.washington.edu/kenrice/sisg-adv/exampleSQLite.R










========================================
dplyr包与Mysql数据库 //todo
----------------------------------------




========================================
R包画各种热图 - 高分文章必备漂亮的大热图
----------------------------------------
比较好的配色方案： https://www.plob.org/article/10156.html





========================================
|-- R基本函数image画热图
----------------------------------------
1.使用R基本函数image画热图
https://www.jianshu.com/p/c17a7c92b7fe

# 产生样本数据
m <- data.frame(
  rep1 = sample(1:20),
  rep2 = sample(1:20)
)

# 写一个绘图函数
draw_image <- function(data, label = FALSE) {
	# 设定绘图参数
	breaks.frequency <- seq(from=min(data), to=max(data), length.out=10)
	myColors <- colorRampPalette(c("white", "#2874A6"))

	# 产生图片
	image(1:nrow(data), 1:ncol(data), as.matrix(data),  breaks=breaks.frequency,      col=myColors(length(breaks.frequency)-1), axes = F, cex = 1.5, xlab = "", ylab = "")

	# 自定义axis
	axis(2, 1:ncol(data), colnames(data), cex.axis=2.5)
	axis(1, 1:nrow(data), rownames(mxdata), cex.axis=2.5)

	# 自定义文本
	if (label) {
		for (x in 1:nrow(data)) {
			for (y in 1:ncol(data))  {
				text(x, y, data[x, y], cex = 2)
			}
		}
	}
}
# 绘制图形
draw_image(data, FALSE)



################
#如果想添加图例：
################

# 绘制图形
CairoPDF(file="heatmap2.pdf",width=7,height=3.5)
#1.图下面留空
par(mai=c(1,1,0.5,0.5))
#画图
draw_image(m, T,mycolor) #改造成自定义颜色，
#2.图例
legend(x=1,y=-0,border = "black",lty=0,
       legend=c("<=0.001", "0.001~0.01", "0.01~0.05", ">0.05"),
       fill=MyCOLOR,
       xpd=T, #要设置xpd=T才能在图外画图例
       ncol=4,#ncol几列
       bty="n"
       ) 
dev.off()




========================================
|-- pheatmap包画各种热图 (附录: 全部参数列表)
----------------------------------------
https://www.jianshu.com/p/1c55ea64ff3f

顶部分类条
添加分类间隔gap




难题1: 颜色条精细控制
(1)使用pheatmap包画热图： 画列注释、图例自定义颜色和0的位置
Q: 在数据不scale时，颜色设为蓝，白，红，图例会显示最小值最大值的范围，有没有办法实现0点为白色，>0为红色，<0为蓝色？
A: 可以通过breaks和color参数进行设置的


#使用raw
#tmp=br5@raw.data[c(s.genes.2,g2m.genes.2),]
#使用标准化后的
tmp=br5@scale.data[c(s.genes.2,g2m.genes.2),]
tmp=tmp[,sort(colnames(tmp))]
#data.frame(Type=tmp.type)
tmp.type=data.frame( Type=substr(colnames(tmp),1,4) );
rownames(tmp.type) = colnames(tmp)
head(tmp.type)

###
#查看cell cycle基因对细胞分类的效果
#breaks
bk <- c(seq(-6,-0.1,by=0.01),seq(0,6,by=0.01)) #[-2, 6]
CairoPDF(file="06-3-heatmap-nonS-sync.pdf",width=8,height=10)
pheatmap(tmp, border=FALSE, 
         cluster_cols = F,
         #scale="row",
         annotation_col=tmp.type,
         #color
         color = c(colorRampPalette(colors = c("blue","white"))(length(bk)/2),colorRampPalette(colors = c("white","red"))(length(bk)/2)),
         legend_breaks=seq(-6,6,2),
         breaks=bk
         )
dev.off()





难题2: 保存总是不流畅，或者被覆盖
library(pheatmap)
library(Cairo)
drawHM01=function(output='',keyword=''){
  pHM=pheatmap( as.matrix(iris[,1:4]), 
                clustering_method = 'ward.D2', na_col = 'grey',
                show_rownames=F,show_colnames=F,
                border=FALSE)
  CairoPDF( paste0(output, keyword, '04_heatmap_cycleGene.pdf'), width=4.5, height=4.5)
  #fig1
  clust_ward <- hclust( dist(iris[,1:4]) , method = 'ward.D2')
  plot(clust_ward)
  rect.hclust(clust_ward, k = 3, border =c("#E41E25", "#FBD800", "#208A41") )
  #fig2
  grid.newpage()
  print(pHM)
  dev.off()
  print('draw end: ')
  return(pHM)
}
p1=drawHM01()

library(ggplot2)
# 还可以这样保存
ggsave(p1,filename = "04_pheatmap.pdf",width=4.5,height=4.5)

print(p1) #这样显示图片

class(p1) #"pheatmap"
str(p1) #特别长











1.构建测试数据集
test = matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
head(test[,1:6])
##          Test1      Test2    Test3      Test4    Test5       Test6
## Gene1 4.064973  0.7535271 3.024070 -2.1294440 4.407945 -0.35677097
## Gene2 2.360043  1.6974946 3.273425 -2.3341406 3.839523  0.16982944
## Gene3 3.253465 -0.9011582 1.716257 -0.2294471 4.636610 -0.24520382
## Gene4 4.070226 -0.6191941 3.734437  1.9348314 4.426825 -0.17730957
## Gene5 3.821414  0.5584876 1.871479 -0.2784607 2.633761  0.01332901
## Gene6 3.012469  0.1738285 3.652423 -2.0083435 4.124951 -0.67899611

# 默认绘图
pheatmap(test)

(2) 归一化
# scale = "row"参数对行进行归一化
pheatmap(test, scale = "row")


(3) 聚类方式
# clustering_method参数设定不同聚类方法，默认为"complete",可以设定为'ward', 'ward.D', 'ward.D2', 'single', 'complete', 'average', 'mcquitty', 'median' or 'centroid'
pheatmap(test,scale = "row", clustering_method = "average")

# clustering_distance_rows = "correlation"参数设定行聚类距离方法为Pearson corralation，默认为欧氏距离"euclidean"
pheatmap(test, scale = "row", clustering_distance_rows = "correlation")

# cluster_row = FALSE参数设定不对行进行聚类
pheatmap(test, cluster_row = FALSE)


(4) 色彩
# color参数自定义颜色
pheatmap(test, color = colorRampPalette(c("navy", "white", "firebrick3"))(50))



(5) 图例控制
# legend_breaks参数设定图例显示范围，legend_labels参数添加图例标签
pheatmap(test, legend_breaks = c(1:5), legend_labels = c("1.0","2.0","3.0","4.0","5.0"))


# legend = FALSE参数去掉图例
pheatmap(test, legend = FALSE)



(6) 每个最小方格的边框
# border_color参数设定每个热图格子的边框色
pheatmap(test, border_color = "red")

# border=FALSE参数去掉边框线
pheatmap(test, border=FALSE)










2. 顶部添加分类条

# 构建列注释信息
annotation_col = data.frame(
  CellType = factor(rep(c("CT1", "CT2"), 5)), 
  Time = 1:5
)
rownames(annotation_col) = paste("Test", 1:10, sep = "")
head(annotation_col)
##       CellType Time
## Test1      CT1    1
## Test2      CT2    2
## Test3      CT1    3
## Test4      CT2    4
## Test5      CT1    5
## Test6      CT2    1



# 构建行注释信息
annotation_row = data.frame(
  GeneClass = factor(rep(c("Path1", "Path2", "Path3"), c(10, 4, 6)))
)
rownames(annotation_row) = paste("Gene", 1:20, sep = "")
head(annotation_row)
##       GeneClass
## Gene1     Path1
## Gene2     Path1
## Gene3     Path1
## Gene4     Path1
## Gene5     Path1
## Gene6     Path1



# annotation_col参数添加列注释信息
pheatmap(test, annotation_col = annotation_col)


# annotation_legend = FALSE参数去掉注释图例
pheatmap(test, annotation_col = annotation_col, annotation_legend = FALSE)

(2)
# annotation_col和annotation_row参数同时添加行和列的注释信息
pheatmap(test, annotation_row = annotation_row, annotation_col = annotation_col)



(3)
# 自定注释信息的颜色列表
ann_colors = list(
  Time = c("white", "firebrick"),
  CellType = c(CT1 = "#1B9E77", CT2 = "#D95F02"),
  GeneClass = c(Path1 = "#7570B3", Path2 = "#E7298A", Path3 = "#66A61E")
)
head(ann_colors)
## $Time
## [1] "white"     "firebrick"
## 
## $CellType
##       CT1       CT2 
## "#1B9E77" "#D95F02" 
## 
## $GeneClass
##     Path1     Path2     Path3 
## "#7570B3" "#E7298A" "#66A61E"

# annotation_colors设定注释信息的颜色
pheatmap(test, annotation_col = annotation_col, annotation_colors = ann_colors, main = "Title")

pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row, 
         annotation_colors = ann_colors)

pheatmap(test, annotation_col = annotation_col, annotation_colors = ann_colors[2]) 










3. 添加分类间隔gap

(1)
# gaps_row = c(10, 14)参数在第10和14行处添加gap, 要求对行不进行聚类
pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, gaps_row = c(10, 14))

(2)
# cutree_col = 2参数将列按聚类树的结果分成两部分, 要求对列进行聚类
pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, gaps_row = c(10, 14),
         cutree_col = 2)

(3)
# 对行和列都不聚类，自定义划分行和列的gap
pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, cluster_cols = FALSE, 
         gaps_row = c(6, 10, 14), gaps_col = c(2, 5, 8))
#






4. 外观控制：行名显示、自定义行名、格子里的数字、格子宽度高度、标题
(1)
# show_rownames和show_colnames参数设定是否显示行名和列名
pheatmap(test,show_rownames=F,show_colnames=F)


# 自定义行的标签名
labels_row = c("", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
               "", "", "Il10", "Il15", "Il1b")
# labels_row参数添加行标签
pheatmap(test, annotation_col = annotation_col, labels_row = labels_row)



(2) 格子里显示数字
# display_numbers = TRUE参数设定在每个热图格子中显示相应的数值，number_color参数设置数值字体的颜色
pheatmap(test, display_numbers = TRUE,number_color = "blue")


(3)
# number_format = "%.1e"参数设定数值的显示格式
pheatmap(test, display_numbers = TRUE, number_format = "%.1e")



(4)
# 自定义数值的显示方式
pheatmap(test, display_numbers = matrix(ifelse(test < 0.05, "*", ""), nrow(test)))


(5)
# cellwidth和cellheight参数设定每个热图格子的宽度和高度，main参数添加主标题
pheatmap(test, cellwidth = 15, cellheight = 12, main = "Example heatmap")







5. 设定聚类方式
(1)
# 自定义聚类的距离方法
drows = dist(test, method = "minkowski")
dcols = dist(t(test), method = "minkowski")
# clustering_distance_rows和clustering_distance_cols参数设定行和列的聚类距离方法
pheatmap(test, clustering_distance_rows = drows, clustering_distance_cols = dcols)



(2)
# treeheight_row和treeheight_col参数设定行和列聚类树的高度，默认为50
pheatmap(test, treeheight_row = 30, treeheight_col = 50)







6. 输出
(1)
# fontsize参数设定标签字体大小，filename参数设定图片保存名称
pheatmap(test, cellwidth = 15, cellheight = 12, fontsize = 8, filename = "test.pdf")


(2)将热图结果按聚类后的顺序输出
aa=pheatmap(test,scale="row")  #热图，归一化，并聚类

# 简要查看热图对象的信息
summary(aa)
##          Length Class  Mode   
## tree_row 7      hclust list   
## tree_col 7      hclust list   
## kmeans   1      -none- logical
## gtable   6      gtable list


order_row = aa$tree_row$order  #记录热图的行排序
order_col = aa$tree_col$order    #记录热图的列排序
datat = data.frame(test[order_row,order_col])   # 按照热图的顺序，重新排原始数据
datat = data.frame(rownames(datat),datat,check.names =F)  # 将行名加到表格数据中
colnames(datat)[1] = "geneid" 
write.table(datat,file="reorder.txt",row.names=FALSE,quote = FALSE,sep='\t')  #输出结果，按照热图中的顺序








### 附录 
mat
数组矩阵（要绘制热图的数据源，保证数据是numeric类型）
color
热图的颜色选择
默认：colorRampPalette(rev(brewer.pal(n = 7, name ="RdYlBu")))(100)

break
用来定义数值和颜色的对应关系。可以将特定颜色和特定数值关联，如果NA则自动进行计算。如果颜色超过值的范围，超过阈值的会使用和阈值一样的颜色。
默认：NA

border_color
热图的单位元素的描边颜色，NA表示不描边
默认：“gray60”

cellwidth
热图单位元素（cell）的宽度，NA表示依据窗口自动调整
默认：NA
cellheight同

scale
数值标准（scale）化，可以是“row“,”column“,”none“
默认：“none”

cluster_rows
用布尔值来判定行元素是不是应该被clustered or clust object。
默认：TRUE
同理，cluster_cols决定是否应该把列clust

clustering_distance_rows
计算类间距的方式，
默认：“euclidean”（欧式距离）
clustering_distance_cols同理

clustering_method
cluster的途径方法（method）
默认：“complete”

clustering_callback
默认：identity2

cutree_rows
如果使用了对行的集群，则可以指定集群个数（基于hclust），如果未使用对行集群则忽略
默认：NA
cutree_col同理

treeheight_row
行集群树的高度
默认：(50point)

legend
图例是否显示
默认：TRUE

legend_breaks
图例是否断点标注
默认：NA

legend_labels
图例的标题
默认：NA

annotation_row
是否对行进行分类注释
默认：NA
annotation_col同理

annotation(废弃)
deprecated parameter that currently sets the annotation_col if it is missing
默认：NA

annotation_colors
指定注释条的颜色。
默认：NA

annotation_legend
布尔值表示是否显示注释条的图例
默认：TRUE

annotation_names_row
布尔值表示是否在图例上显示注释名称
默认：TRUE
annotation_names_col同理

drop_levels
是否在图例显示unused levels
默认：TRUE

shown_rownames
是否显示行名
默认：T
shown_colnames
是否显示列名
默认：T

main
图表主标题
默认：NA

fondsize
图表字体大小
默认：10

fontsize_row
行标题的字号
默认：fondsize
fontsize_col同上

angle_col
列标签的角度，可以选择0，45，270，315

display_numbers
是否在单位元素（cell）内显示数字
默认：F

number_format
显示在cell内的数字格式，例如%.2代表两位小数%.1e表示指数形式...参见C语言printf函数格式
默认：%.2f

fontsize_number
限制在Cell内的数字大小
默认：0.8*fontsize

gaps_row
当行未进行集群分析时，指示再哪里查处gap空隙
默认：NULL
gaps_col同理

labels_row
使用行标签代替行名
默认：NULL
labels_col同理

filename
保存的路径和文件名。支持png、pdf、tiff、bmp、jpeg
NA

height
输出的图片都高度，单位：inches
默认：NA
width同理

silent
不要画出图像（在gtable导出适用）
FALSE

na_col
对NA值对应的cell填充特定颜色
默认："#DDDDDD",...








========================================
|-- ComplexHeatmap包画热图
----------------------------------------
官方文档： https://jokergoo.github.io/ComplexHeatmap-reference/book/a-single-heatmap.html



1.要求画热图：
(1).有三个数据文件，每个都是这样的7行9列：
2-HG	Citrate	Fumarate	lsocitrate	Lactate	maltate	Succinate	Age	Gender
Any cancer	0.001	0.001	0.25	0.001	0.25	0.001	0.25	0.001	0.25
Breast cancer	0.1	0.1	0.002525	0.1	0.002525	0.1	0.002525	0.1	0.002525
Thyroid cancer	0.023	0.023	0.001452	0.023	0.001452	0.023	0.001452	0.023	0.001452
Second malignant neoplasms(SMNS)	0.00255	0.00255	0.0236	0.00255	0.0236	0.00255	0.0236	0.00255	0.0236
Neurodevelopmental disorders	0.001548	0.001548	0.03564	0.001548	0.03564	0.001548	0.03564	0.001548	0.03564
Marcrocephaly	0.05426	0.05426	0.0254	0.05426	0.0254	0.05426	0.0254	0.05426	0.0254
Lhermitte-Duclos disease	0.0263	0.0263	0.09878	0.0263	0.09878	0.0263	0.09878	0.0263	0.09878

三个文件rbind拼接，同时在最左侧显示数据来源。
文件之间显示分割线。

(2)行列名字标注到热图的left和top;
(3)共用一个图例，显示到右侧。






2. 代码：
library(ComplexHeatmap)
library(circlize)
setwd("/home/wangjl/web/docs/docs")


see=function(df){
  print(dim(df))
  print(df[1:3,])
}

#read data
mat1=read.table("self_made_data.txt",sep="\t",header=T,row.names=1)
mat2=read.table("self_made_data2.txt",sep="\t",header=T,row.names=1)
mat3=read.table("self_made_data3.txt",sep="\t",header=T,row.names=1)
see(mat1) #7 9
#
mat=rbind(mat1,mat2,mat3)
see(mat) #21 9
#
rt = as.matrix(mat)
is.matrix(rt)
#colors = structure(circlize::rand_color(7), names = c("1", "2", "3", "4","5","6","7"))
colors = colorRamp2(c(-0.4,-0.01,0,0.01,0.5),
                    c("blue", "light blue","white","orange", "brown"))
p1 <- Heatmap(rt, 
              col = colors,
              show_heatmap_legend = T, name = "p-value", #显示图例，图例标题
              cluster_rows = FALSE, cluster_columns = FALSE,#不聚类行和列
              #
              rect_gp = gpar(col="white",lwd=1), #每个最小方框的描边
              #width = unit(10, "cm"), height = unit(10, "cm"), #尺寸自动好了
              #
              row_names_side = "left",column_names_side = "top",#xy坐标显示位置
              #
              #row_title = expression(PTEN^MUT/SDH^WT), #添加左侧标题，只有一个
              row_split = c( rep("A",7),rep("B",7),rep("C",7) ), #添加左侧标题3个，表明来源
              #row_split = c( rep(expression(PTEN^MUT/SDH^WT),7), #显示表达式会报错
              #               rep(expression(PTEN^WT/SDH^MUT),7),
              #               rep(expression(PTEN^WT/SDH^WT),7) )
              #为row标注(y轴刻度)设置不同的颜色和字号
              row_title_gp = gpar(col = c("green", "orange", "purple"), font =c(20,20) ),
              row_names_gp = gpar(col = c("green", "orange", "purple"), fontsize = c(10, 10, 10)),
			  
			  row_gap = unit(5, "mm") #三个文件之间的距离
);p1
library(Cairo)
CairoPDF(file='test3.pdf',width=8,height=5)
p1
dev.off()

## end


refer:
https://www.jianshu.com/p/d8b8f7acf47c
用ComplexHeatmap复现一张热图 https://www.jianshu.com/p/2fdf721cff58





========================================
韦恩图绘制 venn图: VennDiagram 包
----------------------------------------
# 经典的2类交集韦恩图，顶上标标签，圆圈标数字个数，面积成比例
library (VennDiagram)
#grid.newpage()
venn.plot <- draw.pairwise.venn(393, 269, 94, c("BC", "HeLa"), 
                                fill = c('#F81082', '#619CFF'),  col = "transparent",
                                cex = 2.5,cat.cex=2.5,alpha = 0.50,
                                main="Cycle related genes", #不显示
                                
                                cat.pos = c(-30, 10), #angle of text, dgree=0 means top of cycle
                                cat.dist = 0.05,   #distance of text to border, can be negative
                                
                                cat.col = c('#F81082', '#619CFF'), margin=0.3, scaled = T);
#


1.VennDiagram包
#安装VennDiagram包
#install.packages("VennDiagram")
> library (VennDiagram)


(1)情况1: 知道集合大小、重叠区域大小
#install.packages("VennDiagram")
library (VennDiagram)

#1) 两个部分
#重叠区域大小按比例
venn.plot <- draw.pairwise.venn(100, 70, 30, c("First", "Second"));
grid.draw(venn.plot);
#不按比例
grid.newpage()
venn.plot <- draw.pairwise.venn(100, 70, 30, c("First", "Second"), scaled = FALSE);
grid.draw(venn.plot);


#3) 更多参数
grid.newpage()
venn.plot <- draw.pairwise.venn(
  area1 = 100,  #区域1的数
  area2 = 70,   #区域2的数
  cross.area = 60,  #交叉数
  category = c("First", "Second"),#分类名称
  fill = c("blue", "red"),#区域填充颜色
  lty = "blank",  #区域边框线类型
  cex = 2,        #区域内部数字的字体大小
  cat.cex = 2,    #分类名称字体大小
  cat.pos = c(285, 105), #分类名称在圆的位置，默认正上方，通过角度进行调整
  cat.dist = 0.09,   #分类名称距离边的距离（可以为负数）
  cat.just = list(c(-1, -1), c(1, 1)),  #分类名称的位置
  ext.pos = 30,  #线的角度 默认是正上方12点位置
  ext.dist = -0.05,   #外部线的距离
  ext.length = 0.85,  #外部线长度
  ext.line.lwd = 2,  #外部线的宽度
  ext.line.lty = "dashed"   #外部线为虚线
);
grid.draw(venn.plot); #再画一次，颜色更深


#3)三个数据集
# A more complicated diagram
grid.newpage()
venn.plot <- draw.triple.venn(
  area1 = 65,
  area2 = 75,
  area3 = 85,
  n12 = 35,
  n23 = 15,
  n13 = 25,
  n123 = 5,
  category = c("First", "Second", "Third"),
  fill = c("blue", "red", "green"),
  lty = "blank",
  cex = 2,
  cat.cex = 2,
  scaled=F,
  cat.col = c("blue", "red", "green")
);

# Writing to file
tiff(filename = "Triple_Venn_diagram.tiff", compression = "lzw");  #保存图片
#pdf(file = "Triple_Venn_diagram.pdf", width=5,height=5)
grid.draw(venn.plot);#画图展示
dev.off(); 



#4)四个数据集：花瓣形
# Reference four-set diagram
grid.newpage()
venn.plot <- draw.quad.venn(
  area1 = 72,
  area2 = 86,
  area3 = 50,
  area4 = 52,
  n12 = 44,
  n13 = 27,
  n14 = 32,
  n23 = 38,
  n24 = 32,
  n34 = 20,
  n123 = 18,
  n124 = 17,
  n134 = 11,
  n234 = 13,
  n1234 = 6,
  category = c("First", "Second", "Third", "Fourth"),
  fill = c("orange", "red", "green", "blue"),
  lty = "dashed",
  cex = 2,
  cat.cex = 2,
  cat.col = c("orange", "red", "green", "blue")
);
grid.draw(venn.plot);#画图展示



#5)五个数据集：
# Reference five-set diagram
grid.newpage()
venn.plot1 <- draw.quintuple.venn(
  area1 = 301,
  area2 = 321,
  area3 = 311,
  area4 = 321,
  area5 = 301,
  n12 = 188,
  n13 = 191,
  n14 = 184,
  n15 = 177,
  n23 = 194,
  n24 = 197,
  n25 = 190,
  n34 = 190,
  n35 = 173,
  n45 = 186,
  n123 = 112,
  n124 = 108,
  n125 = 108,
  n134 = 111,
  n135 = 104,
  n145 = 104,
  n234 = 111,
  n235 = 107,
  n245 = 110,
  n345 = 100,
  n1234 = 61,
  n1235 = 60,
  n1245 = 59,
  n1345 = 58,
  n2345 = 57,
  n12345 = 31,
  category = c("A", "B", "C", "D", "E"),
  fill = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  cat.col = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  cat.cex = 2,
  margin = 0.05,
  cex = c(1.5, 1.5, 1.5, 1.5, 1.5, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8,
          1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 1, 1, 1, 1, 1.5),
  ind = TRUE
);
grid.draw(venn.plot1);#画图展示







##############
# (2)情况2: 知道集合内容，还没统计集合大小、重叠区域
##############

#1) 两数据集
venn.plot <- venn.diagram(
  x = list(
    "A" = 1:100,
    "B" = 96:140
  ),
  filename = "Venn_22set_complex.png",imagetype='png',
  col = "transparent",
  fill = c("red", "green"),
  cex = 2.5,
  cat.cex = 2.5,
  rotation.degree = 0,
  main = "Complex Venn Diagram",
  main.cex = 2,
  sub.cex = 1,
  alpha = 0.50
);


##2) 三个数据集
A <- sample(1:1000, 400, replace = FALSE);
B <- sample(1:1000, 600, replace = FALSE);
C <- sample(1:1000, 350, replace = FALSE);
venn.plot <- venn.diagram(
  #数据列表
  x = list(
    A = A,
    B = B,
    C = C
  ),
  filename ="1.tiff",    #保存路径
  height = 450, 
  width = 450,
  resolution =300, 
  #imagetype="png", 
  col = "transparent",      #指定图形的圆周边缘颜色  transparent 透明           
  fill = c("cornflowerblue", "green",  "darkorchid1"),  #填充颜色
  alpha = 0.50,                                      #透明度
  label.col = c("orange", "white", "darkorchid4", "white",
                "white", "darkgreen", "white"),
  cex = 0.45,    #每个区域label名称的大小
  fontfamily = "serif",  #字体
  fontface = "bold",     #字体格式
  cat.col = c("darkblue", "darkgreen", "darkorchid4"),  #分类颜色 
  cat.cex = 0.45,      #每个分类名称大小
  cat.pos = c(100, 260, 0),        #
  cat.dist = c(0.07, 0.07, 0.05),    #
  cat.fontfamily = "serif",     #分类字体
  rotation.degree =180,        #旋转角度
  margin = 0.2               #在网格单元中给出图周围空白量的编号
);


## 三个数据集的例2
A <- c("C", "D", "B", "E")
B <- c("C", "E", "B", "A")
C <- c("C", "E", "X", "Y")

##使用venn.diagram功能绘图
venn.plot=venn.diagram(x=list(Tumor=A, Organoids=B, Primary=C), 
                       filename="My1.png", 
                       height = 450, width = 450, resolution =300, 
                       #imagetype="png", 
                       col="white", 
                       fill=c(colors()[616], colors()[38], colors()[468]), 
                       alpha=c(0.6, 0.6, 0.6), lwd=c(1, 1, 1), 
                       cex=0.55, #数字文字大小
                       cat.dist=c(0.07, 0.07, 0.05), #注释文字大小
                       cat.pos=c(300, 60, 180), 
                       cat.cex=0.45,                      
                       margin=0.1)
#可以不保存查看图片，但是效果不佳（命令如下，但是需要首先把filename设置为（filename=NULL））
grid.newpage()
grid.draw(venn.plot);
dev.off();
#




例2:两个基因列表的交集
只能使用
library("VennDiagram")
venn.diagram(x=list(nonS=nonS$gene, sync=sync$gene),filename="a1.png",
             imagetype = "png",height = 800, width = 800, 
             resolution = 150, units = "px",
             fill=c("blue", "red") )

#
# 给出集合内容，R自动求交集、差集
library(VennDiagram)
venn.diagram(list(A=1:10,B=3:18), 
             fill=c("red","blue"), 
             alpha=c(0.5,0.5),  #设置透明度
             resolution =500, imagetype = "png", units = "px",
             main="1S_gt5_",
             cex=2, cat.fontface=4, fontfamily=3, filename="VennDiagram.png")
#


例3: 维恩图直观看DESeq2结果
library(VennDiagram)
library(grid)

data <- list(
  deg_1=as.character(deg_1$Description),
  deg_2=as.character(deg_2$Description)
)

data1 <- list(
  deg_ens_1=as.character(nrDEG_ens),
  deg_ens_2=as.character(nrDEG2_ens)
)

ven <- venn.diagram(data,filename = NULL,fill=c('red','yellow'))
ven1 <- venn.diagram(data1,filename = NULL,fill=c('red','yellow'))

grid.newpage()
grid.draw(ven)

grid.newpage()
grid.draw(ven1)





### 四个数据集：
#sample为抽样函数，首先指定抽样范围，然后制定抽样个数，最后指定是否允许同样的抽样值
A <- sample(1:1000, 400, replace = FALSE);
B <- sample(1:1000, 600, replace = FALSE);
C <- sample(1:1000, 350, replace = FALSE);
D <- sample(1:1000, 550, replace = FALSE);
E <- sample(1:1000, 375, replace = FALSE);
venn.plot <- venn.diagram(
  #数据列表
  x = list(
    A = A,
    D = D,
    B = B,
    C = C
  ),
  filename = "Venn_4set_pretty.tiff",    #保存路径
  col = "transparent",      #指定图形的圆周边缘颜色  transparent 透明           
  fill = c("cornflowerblue", "green", "yellow", "darkorchid1"),  #填充颜色
  alpha = 0.50,                                      #透明度
  label.col = c("orange", "white", "darkorchid4", "white",
                "white", "white", "white", "white", "darkblue", "white",
                "white", "white", "white", "darkgreen", "white"),
  cex = 1.5,    #每个区域label名称的大小
  fontfamily = "serif",  #字体
  fontface = "bold",     #字体格式
  cat.col = c("darkblue", "darkgreen", "orange", "darkorchid4"),  #分类颜色 
  cat.cex = 1.5,      #每个分类名称大小
  cat.pos = 0,        #
  cat.dist = 0.07,    #
  cat.fontfamily = "serif",     #分类字体
  rotation.degree = 270,        #旋转角度
  margin = 0.2               #在网格单元中给出图周围空白量的编号
);



### 五个数据集：
A <- sample(1:1000, 400, replace = FALSE);
B <- sample(1:1000, 600, replace = FALSE);
C <- sample(1:1000, 350, replace = FALSE);
D <- sample(1:1000, 550, replace = FALSE);
E <- sample(1:1000, 375, replace = FALSE);
venn.plot <- venn.diagram(
  x = list(
    A = A,
    B = B,
    C = C,
    D = D,
    E = E
  ),
  filename = "Venn_5set_pretty.tiff",
  col = "black",
  fill = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  alpha = 0.50,
  cex = c(1.5, 1.5, 1.5, 1.5, 1.5, 1, 0.8, 1, 0.8, 1, 0.8, 1, 0.8,
          1, 0.8, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 0.55, 1, 1, 1, 1, 1, 1.5),
  cat.col = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"),
  cat.cex = 1.5,
  cat.fontface = "bold",
  margin = 0.05
);








2.在线 http://bioinfogp.cnb.csic.es/tools/venny/index.html
这个程序是在线运行的，无需安装任何插件.输出一张图真的是分分钟的事儿！其实即使不是画韦恩图，也可以利用这个网站，找出两种不同处理（状态）的共有基因，或者特有基因等等.



ref:
http://blog.sciencenet.cn/blog-2985160-957210.html
http://www.360doc.com/content/19/1231/13/46931810_883308977.shtml






========================================
|-- venn.diagram保存pdf格式文件？
----------------------------------------
vennDiagram包中的主函数绘图时，好像不直接支持PDF格式文件，只能指定filename = NULL, 然后通过pdf()函数输出。
如果不行，先安装加载library(grDevices)包。


1. 示例文件
#(1) data
dat = list(a = c('a','b','c','e'),b = c('a', 'x', 'c', 'd','y'))
names(dat) <- c('SetA', 'SetB')

#(2) plot
venn.plot <- venn.diagram(
  dat,
  filename = NULL, #设为空
  lwd = 3,
  col = "transparent",
  fill = c("cornflowerblue", "darkorchid1"),
  alpha = 0.6,
  label.col = "black",
  cex = 1.5,
  fontfamily = "serif",
  fontface = "bold",
  cat.col = c("cornflowerblue", "darkorchid1"),
  cat.cex = 2,
  cat.fontfamily = "serif",
  cat.fontface = "bold",
  margin = 0.05,
  cat.dist = c(0.03, 0.03),
  cat.pos = c(-20, 20)
)

# (3) save
pdf(file="proteinGroup_venn.pdf")
grid.draw(venn.plot)
dev.off()




========================================
|-- 画多个(n>5)集合的交集: UpSetR包
----------------------------------------
1. UpsetR这个包确实对多个交集的可视化做了提供了更好的展示方式

(1) 示例1：简单数据示例
install.packages("UpSetR")
library("UpSetR")

1) UpsetR 接受三种类型的数据输入：
- 表格形式，在 R 语言里就是数据框了。行表示元素，列表示数据集分配和额外信息。
- 元素名的集合( fromList )。
- venneuler 包引入的用于描述集合交集的向量 ( fromExpression）。


# fromList
listinput <- list(one = c(1, 2, 3, 5, 7, 8, 11, 12, 13), 
	two = c(1, 2, 4, 5, 10), 
	three = c(1, 5, 6, 7, 8, 9, 10, 12, 13))
> str(listinput)
List of 3
 $ one  : num [1:9] 1 2 3 5 7 8 11 12 13
 $ two  : num [1:5] 1 2 4 5 10
 $ three: num [1:9] 1 5 6 7 8 9 10 12 13

# fromExpression
expressionInput <- c(one = 2, two = 1, three = 2, 
	`one&two` = 1, `one&three` = 4, `two&three` = 1, 
	`one&two&three` = 2)
> str(expressionInput)
 Named num [1:7] 2 1 2 1 4 1 2
 - attr(*, "names")= chr [1:7] "one" "two" "three" "one&two" ...
#



2) 画图 
> upset(fromList(listinput), order.by = "freq")

# 下面绘制的图形等同于上图
> upset(fromExpression(expressionInput), order.by = "freq")

下面是3个集合，左下角是集合的size，黑色原点是哪几个集合的交集，上面 柱状图是该交集的元素数目，可以想象如果集合更多这种方式会更直观，但是--

当我输入为基因名列表（abcde），并在R中存为一个list时，会有一个fromList函数将我的list整合为upsetR自己的输入格式，等一下！！朕的基因名字呢！！

> z=fromList(listinput)
> z
   one two three
1    1   1     1
2    1   1     0
3    1   0     0
4    1   1     1
5    1   0     1
6    1   0     1
7    1   0     0
8    1   0     1
9    1   0     1
10   0   1     0
11   0   1     1
12   0   0     1
13   0   0     1



(2) 示例2：使用 UpSetR 内置的数据集 movies 来绘制。
#导入数据
> movies <- read.csv(system.file("extdata", "movies.csv", package = "UpSetR"), header = TRUE, sep = ";")
> dim(movies)
[1] 3883   21

#先大致浏览一下该数据集,数据集太长，就只看前几列
knitr::kable(head(movies[,1:10]))

> head(movies) #1行一部电影，3-19列是类型，1是该类型，0不是
> colnames(movies)[3:19]
 [1] "Action"      "Adventure"   "Children"    "Comedy"      "Crime"       "Documentary" "Drama"       "Fantasy"     "Noir"       
[10] "Horror"      "Musical"     "Mystery"     "Romance"     "SciFi"       "Thriller"    "War"         "Western" 


> upset(movies, nsets = 6, number.angles = 30, point.size = 2, line.size = 1, mainbar.y.label = "Genre Intersections", sets.x.label = "Movies Per Genre", text.scale = c(1.3, 1.3, 1, 1, 1.5, 1))



df=movies[,3:19]
dim(df) #3883   17

head(df)
hist( apply(df, 1, sum) ) #type per film
hist( apply(df, 2, sum), n=10 ) #film per type

# 2 film has no type
table(apply(df, 1, sum)>0)
movies[apply(df, 1, sum)==0,]
colnames(df)


upset(df, nsets=10, #底下显示几个类，默认5
      nintersects = 20,#顶部显示几个交集bar, 默认40
      number.angles = 90, #顶部文字倾斜角度
      order.by = 'freq', #对顶部排序，按频数
      point.size = 2, # 底部圆点大小
      line.size = 1, #底部连线粗细
      
      
      #text.scale = c(1.3, 1.3, 1, 1, 1.5, 1), #6个字体大小
      # c(intersection size title, intersection size tick labels, 
      #   set size title, set size tick labels, set names, numbers above bars)
      sets.x.label = "Movies Per Genre", #xlab
      mainbar.y.label = "Genre Intersections" #ylab
    )

# 限定几个特定集合
upset(df, sets = c("Action", "Adventure", "Comedy", "Drama", "Mystery", 
                       "Thriller", "Romance", "War", "Western"), 
      mb.ratio = c(0.55, 0.45), #mb.ratio：控制上方条形图以及下方点图的比例。
      order.by = "freq")
#order.by：如何排序，这里 freq 表示从大到小排序展示，
#其他选项有 degree 以及先按 freq 再按 degree 排序。







2. 是否能给出交集元素？
https://github.com/hms-dbmi/UpSetR/issues/85

只能使用原始方式，各种intersect(a,b)嵌套。


例: intersect(listinput[['one']], listinput[['two']]) #1 2 5




ref:
官方: https://www.rdocumentation.org/packages/UpSetR/versions/1.4.0
https://cran.r-project.org/web/packages/UpSetR/UpSetR.pdf
https://cran.r-project.org/web/packages/UpSetR/readme/README.html

Interactive set visualization for more than three sets: https://jku-vds-lab.at/tools/upset/

webapp: https://hiplot.com.cn/basic/upset-plot

https://www.zhihu.com/question/59118999/answer/741196973
更多实例: https://my.oschina.net/shenweiyan/blog/4538670


========================================
GenVisR包: 瀑布图/突变图谱 Waterfall Plot
----------------------------------------
1. 官网
https://bioconductor.org/packages/release/bioc/html/GenVisR.html
https://github.com/griffithlab/GenVisR

实验室: https://griffithlab.org/


中文: 
https://www.jianshu.com/p/8723aa6c9845
https://www.jianshu.com/p/726310b02a56
https://www.jianshu.com/p/d3d3a34e95c2







ref:




========================================
Gviz 包 - Visualize genomic data (能一定程度上代替IGV的R包: 画bam文件的 read coverage 图)
----------------------------------------
这个R包是可以完全替代IGV的， 前提是你对它的了解足够深。

使用refGenome加上dplyr玩转gtf文件
原创： 生信技能树  生信技能树  2018-12-05


1.
全称：Plotting data and annotation information along genomic coordinates
正式发表于期刊：Source Code Biol Med. 2016
doi: 10.1186/s13029-016-0052-z

官方教程: 很厚
http://52.71.54.154/packages/devel/bioc/vignettes/Gviz/inst/doc/Gviz.html

入门教程: http://www.sthda.com/english/wiki/gviz-visualize-genomic-data


R包的示例数据，都可以 载入慢慢玩：
list.files(system.file('data' ,package = 'Gviz'))


(1) 安装 
# BiocManager::install("Gviz")
library(Gviz)


# 1. 画基因在染色体的位置
idTrack <- IdeogramTrack(chromosome="X", genome='hg19') 
plotTracks(idTrack, from=153285264, to=153365188) 
# chrX:153285264-153365188


# 2. 画一个track，就是竖线/矩形，只有最后一句起作用了
library(GenomicRanges)
data(cpgIslands)
#print( class(cpgIslands) ) #"GRanges"
print( head(cpgIslands) )
#    seqnames            ranges strand
#<Rle>         <IRanges>  <Rle>
#  [1]     chr7 26549019-26550183      *
#  [2]     chr7 26564119-26564500      *

print('***********')
chr <- as.character(unique(seqnames(cpgIslands))) #"chr7"
gen <- genome(cpgIslands)
print(chr)
print('***')
print(gen)
#  chr7 
#"hg19"

atrack <- AnnotationTrack(cpgIslands, name='CpG') 
plotTracks(atrack)



# 3. 画带箭头的外显子，最后一行起作用
# BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
library(TxDb.Hsapiens.UCSC.hg19.knownGene) 
txdb=TxDb.Hsapiens.UCSC.hg19.knownGene
#print(str(txdb))
#print(length(exonsBy(txdb))) #82960
#print(TxDb.Hsapiens.UCSC.hg19.knownGene)

g1 = exonsBy(txdb)[[1]] 
print(class(g1))
print(g1)
#print(str(g1))

atrack <- AnnotationTrack(g1, name='g1') 
plotTracks(atrack)



# 4. 画覆盖度
#需要读取bw格式的reads覆盖情况文件，这个时候可以使用R包自带的bw文件，使用 函数 DataTrack 来读取bw文件：

bgFile=system.file('extdata' ,package = 'Gviz','test.wig')
print(head(bgFile)) #filename

bw<-DataTrack(range = bgFile,genome='hg19',
			type='histogram', name='test')
print(bw)
plotTracks(bw)



# 5. 组合：把染色体信息，基因结构信息，覆盖度情况结合起来
假设，我们上面3个例子绘制的都是同一个区域的图，就可以结合：

tracklist=list()
tracklist[['bw']]=bw
tracklist[['atrack']]=atrack
tracklist[['idTrack']]=idTrack
plotTracks(tracklist)
# 其中 bw, atrack, idTrack 都是 AnnotationTrack 对象，它们组合为一个list，就可以一起绘制了。



// todo


ref:
http://www.bioconductor.org/packages/release/bioc/html/Gviz.html
http://www.bioconductor.org/packages/release/bioc/vignettes/Gviz/inst/doc/Gviz.html
http://www.sthda.com/english/wiki/gviz-visualize-genomic-data





========================================
ggvis: 浏览器中显示可交互式图
----------------------------------------
1.Vega: A Visualization Grammar 
https://github.com/vega/vega

With Vega you can describe data visualizations in a JSON format, and generate interactive views using either HTML5 Canvas or SVG.

2.ggvis is a data visualization package for R
http://ggvis.rstudio.com/

The goal is to combine the best of R (e.g. every modelling function you can imagine) and the best of the web (everyone has a web browser). Data manipulation and transformation are done in R, and the graphics are rendered in a web browser, using Vega.









========================================
曼哈顿图: 展示突变基因在染色体上的位置和p值
----------------------------------------
1. 什么是曼哈顿图 Manhattan Plot
曼哈顿图是一种散点图，通常用于显示具有大量数据点，许多非零振幅和更高振幅值分布的数据。该图通常用于全基因组关联研究（GWAS）以显示重要的SNP（来源wiki）。

在图中每个点代表一个SNP，纵轴为每个SNP计算出来的Pvalue取-log10，横轴为SNP所在的染色体。基因位点的Pvalue越小即-log10(Pvalue)越大，其与表型性状或疾病等关联程度越强。而且通常来说受到连锁不平衡的影响，强关联位点周围的SNP也会显示出相对较高的信号强度，并依次向两边递减，所以会出现上图中红色部分的现象。一般，在GWAS的研究中，Pvalue的阈值在10^-6 或者10^-8以下。


2.怎么做曼哈顿图 Manhattan Plot
使用R包 qqman——an R package for creating Q-Q and manhattan plots

(1) 安装包
install.packages("qqman")

(2) 所需数据的格式
library(qqman)
data("gwasResults")
head(gwasResults)
#   SNP CHR BP         P
# 1 rs1   1  1 0.9148060
# 2 rs2   1  2 0.9370754
# 3 rs3   1  3 0.2861395
# 4 rs4   1  4 0.8304476
# 5 rs5   1  5 0.6417455
# 6 rs6   1  6 0.5190959

第一列为SNP的名字，第二列CHR为所在染色体，第三列BP为染色体上所在位置。要注意如果你的CHR中存在X，Y这样的，需要给他们转化为数字如赋予23，24等。
其中第一列SNP的名字是可选择的，后三列是必须提供的。

(3) 画图
1)基础版: 按照chr黑灰交替
manhattan(gwasResults, chr="CHR", bp="BP", snp="SNP", p="P" )


2)标记其中一系列你感兴趣的SNP：给出你感兴趣的snpsOfInterest列表即可。
snpsOfInterest #这些点会高亮显示
# [1] "rs3001" "rs3002" "rs3003" "rs3004" "rs3005" "rs3006" "rs3007" "rs3008" "rs3009" "rs3010" "rs3011"
# [12] "rs3012" "rs3013" "rs3014" "rs3015" "rs3016" "rs3017" "rs3018" "rs3019" "rs3020" "rs3021" "rs3022"
manhattan(gwasResults, highlight = snpsOfInterest)


3)想知道每条染色体上pvalue最小的SNP
manhattan(gwasResults, annotatePval = 0.01)
manhattan(gwasResults, annotatePval = 0.0001)#不符合该筛选条件的即使-log10(pvalue)最高也不显示


4)不喜欢黑色和灰色的搭配，也可以自行改变颜色。
manhattan(gwasResults, annotatePval = 0.01,annotateTop = T, col = c("grey", "skyblue")) #灰蓝交替







3. 还可以使用ggplot2来绘制 

(1) 使用dplyr 包的%>% 管道符整理数据

library(dplyr)
don <- gwasResults %>% 
  
  # Compute chromosome size
  group_by(CHR) %>% 
  summarise(chr_len=max(BP)) %>% 
  
  # Calculate cumulative position of each chromosome
  mutate(tot=cumsum(chr_len)-chr_len) %>%
  select(-chr_len) %>%
  
  # Add this info to the initial dataset
  left_join(gwasResults, ., by=c("CHR"="CHR")) %>%
  
  # Add a cumulative position of each SNP
  arrange(CHR, BP) %>%
  mutate( BPcum=BP+tot)

head(don)
#   SNP CHR BP         P tot BPcum
# 1 rs1   1  1 0.9148060   0     1
# 2 rs2   1  2 0.9370754   0     2
# 3 rs3   1  3 0.2861395   0     3
# 4 rs4   1  4 0.8304476   0     4
# 5 rs5   1  5 0.6417455   0     5
# 6 rs6   1  6 0.5190959   0     6

axisdf = don %>% group_by(CHR) %>% summarize(center=( max(BPcum) + min(BPcum) ) / 2 )
head(axisdf)
# # A tibble: 6 x 2
#     CHR center
#   <int>  <dbl>
# 1     1   750.
# 2     2  2096 
# 3     3  3212.
# 4     4  4204 
# 5     5  5115 
# 6     6  5966 


don是用于作图的主要数据表，而axisdf是用于处理x轴，因为我们想要他们按照染色体的位置排布。



(2) 绘图
ggplot(don, aes(x=BPcum, y=-log10(P))) +
    geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3) +
    scale_color_manual(values = rep(c("grey", "skyblue"), 22 )) +
    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +
    scale_y_continuous(expand = c(0, 0) ) +     # remove space between plot area and x axis
    theme_bw() +
    theme( 
      legend.position="none",
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    )

其中 scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center )控制着x轴的刻度位置和标签文本。



(3)如果想要把某些SNP标记出来呢？那么我们在前期处理数据的时候需要将这些数据标记出来，这个过程和之前火山图标记显著的基因很类似:
don <- gwasResults %>% 
  
  # Compute chromosome size
  group_by(CHR) %>% 
  summarise(chr_len=max(BP)) %>% 
  
  # Calculate cumulative position of each chromosome
  mutate(tot=cumsum(chr_len)-chr_len) %>%
  select(-chr_len) %>%
  
  # Add this info to the initial dataset
  left_join(gwasResults, ., by=c("CHR"="CHR")) %>%
  
  # Add a cumulative position of each SNP
  arrange(CHR, BP) %>%
  mutate( BPcum=BP+tot) %>%

  # ！！！！！！Add highlight and annotation information
 mutate( is_highlight=ifelse(SNP %in% snpsOfInterest, "yes", "no")) %>%
  mutate( is_annotate=ifelse(-log10(P)>4, "yes", "no")) 

# Prepare X axis
axisdf <- don %>% group_by(CHR) %>% summarize(center=( max(BPcum) + min(BPcum) ) / 2 )


## 然后画图的时候geom_point在颜色上进行区分，并使用geom_label_repel标注出来即可：
ggplot(don, aes(x=BPcum, y=-log10(P))) +
    
    # Show all points
    geom_point( aes(color=as.factor(CHR)), alpha=0.8, size=1.3) +
    scale_color_manual(values = rep(c("grey", "skyblue"), 22 )) +
    
    # custom X axis:
    scale_x_continuous( label = axisdf$CHR, breaks= axisdf$center ) +
    scale_y_continuous(expand = c(0, 0) ) +     # remove space between plot area and x axis

    # Add highlighted points
    geom_point(data=subset(don, is_highlight=="yes"), color="orange", size=2) +
  
    # Add label using ggrepel to avoid overlapping
    geom_label_repel( data=subset(don, is_annotate=="yes"), aes(label=SNP), size=2) +

    # Custom the theme:
    theme_bw() +
    theme( 
      legend.position="none",
      panel.border = element_blank(),
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank()
    )








ref:
https://www.jianshu.com/p/1edc44fe922f









========================================
聚类树/进化树 Phylogenetic tree //todo
----------------------------------------
1. R做聚类树分别用到了cor.dist、hclust、plot三个函数分别算相关性，聚类并作图。
有关聚类的R包可以参考cluster包和ape包。


把相近的放一起，再把次相近的放一起。
	怎么定义相近？ How do we define close?
	怎么分组？ How do we group things?
	怎么可视化分组？ How do we visualize the grouping?
	怎么解释分组？ How do we interpret the grouping?
#


todo: https://bookdown.org/rdpeng/exdata/hierarchical-clustering.html









2. 推荐博客，很详细，且文艺到艺术：
三角形、环形进化树，实线、虚线，旋转90度，染色、不同背景色，
原文：http://rstudio-pubs-static.s3.amazonaws.com/1876_df0bf890dd54461f98719b461d987c3d.html
翻译：http://blog.csdn.net/u010157382/article/details/45562435


算法不清楚，看文献：
(1).如果是dna或者蛋白序列信息，可以使用mega构建进化树。
how: http://blog.sina.com.cn/s/blog_5eb2fefb0101gny0.html
(2).如果是vntr数据，或者多位点可变数量串联重复序列分析(multiple-locus variable-numbertandem-repeat analysis,MLVA)数据，则只能用BioNumerics 了。
http://www.applied-maths.com/bionumerics
http://www.bionumerics.cn/download.html
申请免费： https://www.researchgate.net/post/Is_there_any_trial_version_of_Bionumerics_software_available_online_or_any_other_free_software


Data analysis services
Unravelling the puzzleApplied Maths offers a service of having your data analyzed at an hourly rate. Data sources include any type of 1D gels, 2D gels, chromatography, HPLC or MALDI, MLST, VNTR and other typing techniques, phenotype data, microarrays, sequences up to full chromosomes, including comparison, gene mapping and annotation.

If you would like to obtain more information or a quotation about this Applied Maths' service please do not hesitate to contact us.








3. 可视化 mega，上色是mega画好后ai添加的
http://muchong.com/html/201602/9981406.html














ref:
https://bookdown.org/rdpeng/exdata/hierarchical-clustering.html








========================================
ggpubr 包: 一条命令轻松绘制CNS顶级配图
----------------------------------------
ggpubr 实际上是基于ggplot2 开发出来的包，目的是为了简化ggplot2的操作，便于画出满足论文出版要求的图。

Reference: http://rpkgs.datanovia.com/ggpubr/reference/index.html#section-make-programming-easy-with-ggplot-

install.packages("ggplot2")
install.packages("ggpubr")

#加载包
library(ggplot2)
library(ggpubr)


1.Plot One Variable - X, Continuous

ggdensity() 密度图
stat_overlay_normal_density() 密度图，同时叠加正态分布的图，有助于检查偏离值
gghistogram() 直方图。
ggecdf() 经验累积密度分布图
ggqqplot() 分位数-分位数图，简称QQ图。



2. Plot Two Vriables - X and Y, Discrete X and Continuous Y

ggboxplot() 箱图
ggviolin() 小提琴图

ggdotplot() 点图
ggstripchart() strip chart, 也可以称为一维散点图。

ggbarplot() 柱状图
ggline() 线图
ggerrorplot() Visualizing Error 绘制误差棒图

ggpie() 饼图
ggdonutchart() 甜甜圈饼图
ggdotchart()theme_cleveland() 克利夫兰点图



3. 更多

ggscatter() 散点图
stat_cor() 将有P值的相关系数添加到散点图中
stat_stars()) Add Stars to a Scatter Plot

ggscatterhist() 绘制具有边际直方图的散点图

ggpaired() Plot Paired Data

ggballoonplot()



ggmaplot()
Make MA-plot which is a scatter plot of log2 fold changes (on the y-axis) versus the mean expression signal (on the x-axis).

MA plot充分展示了基因丰度和表达变化之间的关系。我们可以看到，越靠左下或者右上的点，就是丰度越高而且变化幅度越大的基因。当然了，MA plot就丢了FDR这类统计量。二维图嘛，死活两个参数，顶多用颜色做个假三维。

不过对于终端小白用户来说，如果在volcano plot和MA plot中发现了重叠的靶点（实际上会有不少重叠），那就愉快地拿去做实验吧。





4. 例子 

内有箱线图的小提琴图+星标记

data("ToothGrowth")
df1 <- ToothGrowth
head(df1)

ggviolin(df1, x="dose", y="len", fill = "dose", 
         palette = c("#00AFBB", "#E7B800", "#FC4E07"),  
         add = "boxplot", add.params = list(fill="white"))+ 
  stat_compare_means(comparisons = my_comparisons, label = "p.signif")+#label这里表示选择显著性标记（星号） 
  stat_compare_means(label.y = 50)
#




(2) 配色
# palette = "npg", #杂志nature的配色 





ref:
https://zhuanlan.zhihu.com/p/102653888
http://blog.sciencenet.cn/blog-3334560-1091714.html





========================================
R包实战第n版: 如何写一个R包
----------------------------------------
ref: 
https://www.bilibili.com/video/BV1M4411S72M
https://cosx.org/2011/05/write-r-packages-like-a-ninja

写R扩展: https://cran.r-project.org/doc/manuals/R-exts.html



写包只是程序开发的一方面啦，很多人不写包但做的事情很牛。
要说中高级R程序员，窃以为还是得看John Chambers老爷子的原著（如Software for Data Analysis），S语言和R语言的设计之精巧，似乎并没有引起人们的注意。
比如这里介绍的命名空间（主要是Luke Tierney的工作），可能绝大部分用户永远都不会接触到，但的确是一个很好的管理对象的方式；
还有S3与S4以及最新的ReferenceClass（参见?setRefClass），这些概念都很有意思，很能体现设计者的智慧。
这些东西才能体现R作为一门“语言”的特征，对多数人来说，R只是一门“程序”，是用来完成数据处理任务的。
当然，这也无妨，R就像一盘大餐，爱吃哪部分就挑哪部分。


可以看看 http://adv-r.had.co.nz/C-interface.html 
不过个人觉得还是Rcpp更人性化一点 http://adv-r.had.co.nz/Rcpp.html




##############
# R包实战第一版
##############

1. 在文件fun.R中先写一个函数，读入到R的内存中。

add=function(x){
  return (x+7)
}



2. 下一步是生成R包目录结构

(1) 在R中执行如下2行:
> setwd('/home/wangjl/data/r-pkg/') #要生成的目录位置
> package.skeleton(name="wjl007", list="add") # name="包的名字", list="函数的名字"
## package.skeleton(name='RoxygenSkeleton', code_files = "Roxygen.R", force=TRUE)


则在目录下生成文件结构
$ cd /home/wangjl/data/r-pkg/
$ tree 
.
├── fun.R
└── wjl007
    ├── DESCRIPTION ##项目描述文件。
    ├── man ##帮助文档
    │   ├── add.Rd
    │   └── wjl007-package.Rd
    ├── NAMESPACE
    ├── R ##具体代码
    │   └── add.R
    └── Read-and-delete-me

3 directories, 7 files

其中重点关注新生成的 wjl007/ 文件夹，里面有几个基本的R包的文件。

(2) 其中的 Read-and-delete-me 告诉我们接下来干什么:
* Edit the help file skeletons in 'man', possibly combining help files for multiple functions.
* Edit the exports in 'NAMESPACE', and add necessary imports.
* Put any C/C++/Fortran code in 'src'.
* If you have compiled code, add a useDynLib() directive to 'NAMESPACE'.
* Run R CMD build to build the package tarball.
* Run R CMD check to check the package tarball.

Read "Writing R Extensions" for more information.

完善项目描述文件 DESCRIPTION: 我们象征性的把版本号修改为 0.1.2.3
完善帮助文件 man/。

删除掉 Read-and-delete-me 文件。



3. 建立包
可以在terminal中进行build了：
cd your_directory
R CMD INSTALL --build mypkg 


会报错的 man/add.Rd 文件添加一行
\title{
%%  ~~function to do ... ~~
  Add 7 for a given number.
}


$ cd /home/wangjl/data/r-pkg/
$ R CMD INSTALL --build wjl007 
## packaged installation of ‘wjl007’ as ‘wjl007_0.1.2.3_R_x86_64-pc-linux-gnu.tar.gz’
## * DONE (wjl007)



4. 使用包 
然后，在R中library(yourpackage)一下就好了！

## 退出这个包，删除同名函数
> rm(add)
> detach("package:wjl007", unload=TRUE)
> add(10)
## Error in add(10) : could not find function "add"


## 载入包，并使用包中的函数
> library(wjl007)  ##> library("wjl007", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.6")
> add(10)
[1] 17


## 永久卸载这个包
> remove.packages("wjl007", lib="~/R/x86_64-pc-linux-gnu-library/3.6")

## 再次安装
$ cd /home/wangjl/data/r-pkg/
$ R CMD INSTALL wjl007










========================================
|-- R 文档与 roxygen2：从代码注释生成.Rd files
----------------------------------------

1. 简介
如果有30个函数，每次函数更新完，还要更新man/下的文档，会抓狂的。
于是有人发明了在函数内直接写文档，然后用程序翻译成文档的方法。

流程：你在源代码中写 roxygen comments --> roxygen2::roxygenise() 抽取翻译出.Rd文件 --> R翻译出人看的文档。


roxygen2 是一个 R 包（它的前任是 roxygen，但已经停止更新了），它实现了把特定注释 “翻译” 为 R 文档的工作，例如：
##' @author Yihui Xie
##' @source \url{https://cos.name}

会被翻译为：
\author{Yihui Xie}
\source{\url{https://cos.name}}



R provides a standard way of documenting packages: you write .Rd files in the man/ directory. These files use a custom syntax, loosely based on latex. Roxygen2 provides a number of advantages over writing .Rd files by hand:

- 代码文档一起，方便更新。Code and documentation are adjacent so when you modify your code, it’s easy to remember that you need to update the documentation. 

- 动态检查，自动代替手动添加。Roxygen2 dynamically inspects the objects that it’s documenting, so it can automatically add data that you’d otherwise have to write by hand.

- 提取S3和S4方法的差异，学更少的细节。It abstracts over the differences in documenting S3 and S4 methods, generics and classes so you need to learn fewer details.

As well as generating .Rd files, roxygen will also create a NAMESPACE for you, and will manage the Collate field in DESCRIPTION.
自动生成Rd文件，创建 NAMESPACE，并管理 DESCRIPTION 中的 Collate字段。






2. 函数的注释要符合一定的规范

$ mkdir -p /home/wangjl/data/r-pkg/wjl008/R
$ vim /home/wangjl/data/r-pkg/wjl008/R/fun.R

##' title of stupid_f...
##'
##' description...
##'
##' details here
##' @param a ###<<-------- 这里不标准，会warning，后面有修改版
##' @param b
##' @return
##' @author Yihui Xie &lt;\url{http://yihui.name}&gt;
##' @examples
stupid_f = function(a, b){
    a + b
}


#' A wrap of linear regression
#' @description This function performs linear regression (a simplified version)
#' @param formula: a formula
#' @param data: dataset
#' @return a lm object
#' @examples
#' linear_reg(Sepal.Length~., iris)
#' @export
linear_reg <- function(formula, data){         
    result <- lm(formula, data)         
    return(result) 
} 

注释：
每行开头必须是 #' 
@param 中的冒号可选
@export 才能在外面被用户直接使用，否则只能内部函数使用。


roxygen2 的常规是，第一段是标题（将来翻译为\title{}），段落之间以空行分开，第二段是描述（\description{}），然后接着是这个函数的详细描述（\details{}），它可以是若干段落，你愿意写多长就写多长。剩下的@字段就不必多解释了，参数、返回值、作者、示例等。


roxygen2 还实现了一些自动功能，比较重要的就是对命名空间文件 NAMESPACE 和描述文件 DESCRIPTION 的自动更新，这些我们第五节再说。先说如何从 roxygen 注释翻译到 Rd 文档，很简单：如果一个包已经按第二节的结构写好（不需要有 man 文件夹），函数和相应的 roxygen 注释都已经存在，那么用函数roxygenize()就可以把这样一个初级包翻译为一个完整 R 包了：

setwd('/a/b/c/')  # 先把工作目录切换到pkg之上
library(roxygen2)
roxygenize('pkg')

默认情况下新生成的 R 文档以及更新的 NAMESPACE 和 DESCRIPTION 都生成在包的目录下，现在 pkg 就是一个完整的 R 包，包含自动生成的 man 文件夹，可以直接用R CMD INSTALL pkg安装。





##############
# R包实战第二版
##############
(1) 建立目录，在文件R/fun.R内写函数及要求格式的注释，见上文 stupid_f 和 linear_reg 函数。
$ tree wjl008/
wjl008/
├── DESCRIPTION2 #这个文件需要提前准备。
├── man
└── R
    └── fun.R

(2) 编译出帮助文档Rd：需要提前准备好 DESCRIPTION文件。
> setwd("/home/wangjl/data/r-pkg/")
> library(roxygen2)
> roxygenize('wjl008')
Error: `package.dir` must include a DESCRIPTION file:
  * "/data/wangjl/r-pkg/wjl008" does not.

$ cp wjl007/DESCRIPTION wjl008/ ##复制一个过来，修改一下
Package: wjl008
Type: Package
Title: Title of pkg wjl008
Version: 0.1.2.4
Date: 2021-01-02
Author: wjl <wjl@none.net>
Maintainer: wjl <wjl@none.net>
Description: test pkg of wjl008
License: MIT
Encoding: UTF-8


## 再试
> roxygenize('wjl008')

有三个warning，尝试解决掉吧：
Warning: [/data/wangjl/r-pkg/wjl008/R/fun.R:6] @param requires name and description
Warning: [/data/wangjl/r-pkg/wjl008/R/fun.R:7] @param requires name and description
Warning: [/data/wangjl/r-pkg/wjl008/R/fun.R:10] @examples requires a value

$ vim R/fun.R  #修改第一个函数的注释部分
##' title of stupid_f...
##'
##' description...
##'
##' details here
##' @param a: a number
##' @param b: a number
##' @return a number
##' @author Yihui Xie &lt;\url{http://yihui.name}&gt;
##' @examples
##' stupid_f(2, 6)
stupid_f = function(a, b){
  a + b
}


## 三试
> roxygenize('wjl008')
Loading wjl008
Writing NAMESPACE
Writing NAMESPACE
Writing stupid_f.Rd
一切正常。

查看文件结构
$ tree wjl008
wjl008
├── DESCRIPTION
├── man
│   ├── linear_reg.Rd
│   └── stupid_f.Rd
├── NAMESPACE
└── R
    └── fun.R

##
(3) 安装 
$ cd /home/wangjl/data/r-pkg/
$ R CMD INSTALL --build wjl008
packaged installation of ‘wjl008’ as ‘wjl008_0.1.2.4_R_x86_64-pc-linux-gnu.tar.gz’
* DONE (wjl008)

这时，刷新Rstudio的Packages面板，就能看到已经安装了 wjl008 Version 0.1.2.4

这时所有函数都可以访问，因为为了生成注释，所有函数都读入过了。
> stupid_f(1,2)
[1] 3
为了防止副作用，要重启R！！


(4) 使用R包
十分重要: 要先重启R! 
- 点击菜单 Session - restart R.
- 或者更好的策略： 菜单 Session - Quit Session.


> library(wjl008)
> stupid_f(2,3)
Error in stupid_f(2, 3) : could not find function "stupid_f"

> linear_reg(speed~dist, cars)
Call:
lm(formula = formula, data = data)

Coefficients:
(Intercept)         dist  
     8.2839       0.1656 
#


另一种调用包内 export出来的函数：
> library(wjl008)
> e1=as.environment("package:wjl008");
> e1$linear_reg(speed~dist, cars)

Call:
lm(formula = formula, data = data)

Coefficients:
(Intercept)         dist  
     8.2839       0.1656
#




(5) 注意点
* 自动生成函数的注释，包的注释怎么生成的呢？没看到包的Rd文件。
* 看函数的源代码或文档，在Console输入函数名，按F1，或者输入?linear_reg。
* @export 一个函数，就只有一个可以直接被用户调用。

* roxygen2 抽取注释前需要有主是好的R/xx.R 函数文件，以及 DESCRIPTION 文件。




ref:
roxygen2官方教程：https://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html
Rd格式: https://cran.r-project.org/doc/manuals/R-exts.html#Rd-format





========================================
|-- R 的命名空间 NAMESPACE
----------------------------------------
1.
命名空间（NAMESPACE）是 R 包管理包内对象的一个途径，它可以控制哪些 R 对象是对用户可见的，哪些对象是从别的包导入（import），哪些对象从本包导出（export）。

为什么要有这么个玩意儿存在？主要是为了更好管理你的一堆对象。写 R 包时，有时候可能会遇到某些函数只是为了另外的函数的代码更短而从中抽象、独立出来的，这些小函数仅仅供你自己使用，对用户没什么帮助，他们不需要看见这些函数，这样你就可以在包的根目录下创建一个 NAMESPACE 文件，里面写上export(函数名)来导出那些需要对用户可见的函数。自 R 2.14.0 开始，命名空间是 R 包的强制组成部分，所有的包必须有命名空间，如果没有的话，R 会自动创建。

前面我们也提到 DESCRIPTION 文件中有 Imports 一栏，这里设置的包通常是你只需要其部分功能的包，例如我只想在我的包中使用 foo 包中的bar()函数，那么 Imports 中就需要填 foo，而 NAMESPACE 中则需要写importFrom(foo, bar)，在自己的包的源代码中则可以直接调用bar()函数，R 会从 NAMESPACE 看出这个bar()对象是从哪里来的。

roxygen 注释对这一类命名空间有一系列标签，如一个函数的文档中若标记了##' @export，那么这个函数将来就会出现在命名空间文件中（被导出），若写了##' @importFrom foo bar，那么 foo 包的bar对象也会被写在命名空间中。这些内容参见 R-exts 的 1.6 节和 roxygen2 的?export帮助。





2. 

R 一定程度上也可以用文件作为一个“命名空间”：sys.source() 可以指定环境，比如
bar = new.env()
sys.source('foo.R', bar)
然后就可以 bar$对象 调用 foo.R 里创建的对象了。






========================================
|-- 介绍文档（Vignette）
----------------------------------------
前面我们提到了 inst/doc / 目录，下面可以放一个 Sweave 文件，在R CMD INSTALL过程中这个 Sweave 文件会被执行并生成 PDF 文档，若 Sweave 文件中有一句注释：

%\VignetteIndexEntry{An Introduction to XXX}
那么这句话将来会出现在 HTML 帮助页面中（点开链接 “Overview of user guides and package vignettes”），例如 Rd2roxygen 包或者 formatR 包的帮助页面中就有介绍文档的链接。



========================================
|-- 其它语言
----------------------------------------
在 src 目录下我们可以放置一些其它语言的源代码，里面可能包含一些函数，这些函数在被编译之后，（以 C 语言为例）可以在 R 代码中以.C('routine_name', ..., package = 'pkg')的形式调用，但要注意，如果需要用这个功能，在 R 目录下需要有一个 zzz.R 文件（这个特殊文件是用来在加载包之前加载运行的代码），里面写上：

.onLoad <- function(lib, pkg) {
    library.dynam("pkg_name", pkg, lib)  # pkg_name是你的包的名字
}
这些东西我并不在行，只介绍到这里，详细内容还请深挖 R-exts。




========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------







========================================
----------------------------------------


========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



