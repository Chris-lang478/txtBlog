c语言入门

什么是预处理、什么是表达式、什么是语句、什么是函数、什么是操作符、什么是数据类型。


编译环境：
$ gcc --version
gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.



========================================
资料
----------------------------------------


1. 视频资料
浙大翁凯老师 https://www.icourse163.org/course/ZJU-199001




2. 文字资料 (教程、博客等)

(1) 英文资料
https://www.geeksforgeeks.org/c-programming-language/?ref=ghm


(2) 中文资料
http://c.biancheng.net/c/
学习C语言，除了要学习语法，还要学习内存、字符编码、调试技巧以及编程思维。


C 语言教程 https://www.runoob.com/cprogramming/c-tutorial.html
C快速入门教程 https://www.jianshu.com/p/92e8279de2fc

谭浩强 的C语言书： https://www.7down.com/soft/313992.html


2015-06-03 10:12:02
《C语言学习攻略》： http://www.imooc.com/course/programdetail/pid/37


笨办法学C https://wizardforcel.gitbooks.io/lcthw/content/preface.html






1.入门
C语言入门 https://www.imooc.com/learn/249 本C语言教程从以下几个模块来贯穿主要知识点：初始C程序、数据类型、运算符、语句结构、函数和数组。
|-- c语言入门这一篇就够了-学习笔记(一万字) https://blog.csdn.net/qq_23079443/article/details/81108901 图片已经挂了！
C魔法书 http://www.nowamagic.net/librarys/books/contents/c




2.中级
《Linux C语言编程基本原理与实践》： http://www.imooc.com/view/248 


3.核心是指针与内存、结构体
《Linux C语言指针与内存》： http://www.imooc.com/view/394
《Linux C语言结构体》： http://www.imooc.com/view/409


C语言算法博客： https://blog.csdn.net/lalor




(2) 计算机知识结构
https://www.zhihu.com/question/454220559/answer/1885130153





========================================
第1章 导言
----------------------------------------
C语言入门 -> Linux C语言编程基本原理与实践 -> Linux C语言指针与内存 -> Linux C语言结构体


C语言一经出现就以其功能丰富、表达能力强、灵活方便、应用面广等特点迅速在全世界普及和推广。C语言不但执行效率高而且可移植性好，可以用来开发应用软件、驱动、操作系统等。C语言也是其它众多高级语言的鼻祖语言，所以说学习C语言是进入编程世界的必修课。




#include<stdio.h> 
int main()
{
    /*在双引号中间输入Hello World*/ 
    printf("Hello World");
    return 0; 
}

注：在最新的C标准中，main函数前的类型为int而不是void

c语言的具体结构
简单来说，一个C程序就是由若干头文件和函数组成。
 - #include <stdio.h>就是一条预处理命令, 它的作用是通知C语言编译系统在对C程序进行正式编译之前需做一些预处理工作。
 - 函数就是实现代码逻辑的一个小的单元。
 - 每一句必须有分号结尾，一行可以写多句；


注释：
	多行注释：  /* 多行注释内容 */ 
	单行注释：  //注释一行

标识符
C语言规定，标识符可以是字母(A～Z，a～z)、数字(0～9)、下划线_组成的字符串，并且第一个字符必须是字母或下划线。在使用标识符时还有注意以下几点：
	(1)标识符的长度最好不要超过8位，因为在某些版本的C中规定标识符前8位有效，当两个标识符前8位相同时，则被认为是同一个标识符。 
	(2)标识符是严格区分大小写的。例如Imooc和imooc 是两个不同的标识符。 
	(3)标识符最好选择有意义的英文单词组成做到"见名知意"，不要使用中文。
	(4)标识符不能是C语言的关键字。想了解更多C语言关键字的知识，请查阅WIKI。




========================================
第2章 类型、运算符与表达式
----------------------------------------


1. 变量的定义
变量定义的一般形式为：数据类型 变量名;
多个类型相同的变量：数据类型 变量名, 变量名, 变量名...;

#include<stdio.h> 
int main()
{
	int age=10;
    printf("I am %d years old! \n", age);
    return 0; 
}

# I am 10 years old! 
变量名和标识符的命名规范完全相同。%d在后面会有详细讲解

注意:在定义中不允许连续赋值，如int a=b=c=5;是不合法的。

变量的赋值分为两种方式：
	- 先声明再赋值  int num; num=100;
	- 声明的同时赋值 int num=10;



2. 基本数据类型
C语言中，数据类型可分为4大类：
	基本数据类型
		|-整型 int
			|--短整形 short int (int可省略)
			|--长整形 long int (int可省略)
			|--无符号整形 unsigned short int (int可省略)
			|--无符号长整形 unsigned long int (int可省略)
		|-字符型 char
		|-实型(浮点型)
			|--单精度型 float
			|--双精度型 double
			|--长双精度型 long double
	构造数据类型
		|-枚举类型
		|-数组类型
		|-结构体类型
		|-共用体烈性
	指针类型
	空类型

注：int、short int、long int是根据编译环境的不同，所取范围不同。而其中short int和long int至少是表中所写范围，但是int在表中是以16位编译环境写的取值范围。
另外 c语言int的取值范围在于他占用的字节数 ，不同的编译器，规定是不一样。
ANSI标准定义int是占2个字节，TC是按ANSI标准的，它的int是占2个字节的。但是在VC里，一个int是占4个字节的。

注：C语言中不存在字符串变量，字符串只能存在字符数组中，这个后面会讲。



3.格式化输出语句
printf("输出格式符"，输出项);
%d 带符号十进制整数
%c 单个字符
%s 字符串
%f 6位小数

例如:
int a=10;
printf("a=%d", a); 
输出:
a=10 


如果要输出多个变量的并指定变量的位置时候，格式符还可以连用，变量之间需要用逗号隔开
#include <stdio.h>
int main(){
    int age = 18;
	float height = 1.85;
	char unit = 'm';
	printf("小明今年%d岁\n", age);
	printf("小明身高%f%c\n", height, unit);
	printf("小明现在慕课网上学习IT技术"); 
	return 0;
}
输出:
小明今年18岁
小明身高1.850000m
小明现在慕课网上学习IT技术





4.常量
值不发生改变的量称为常量。C语言的常量可以分为直接常量和符号常量。

直接常量:
printf("%d\n",100); //整型常量
printf("%f\n",3.1415); //实型常量
printf("%c\n",'A'); //字符常量
printf("I love C"); //字符串常量

在C语言中，可以用一个标识符来表示一个常量，称之为符号常量。符号常量在使用之前必须先定义，其一般形式为：
#define 标识符 常量值 

#include <stdio.h>
# define PI 3.1415926535897932
int main()
{
	printf("圆周率: %f\n", PI);
	return 0;
}
输出:
圆周率: 3.141593
# 换成 %d， 输出就很怪异: 圆周率: 487130584

注意：常量是不可改变的






5.类型转换

#自动类型转换
char -> int -> double 
自动转换发生在不同数据类型运算时，在编译的时候自动完成。自动转换遵循的规则就好比小盒子可以放进大盒子里面一样。
#include<stdio.h>
int main()
{
	char c='a';
	int x=c;
	printf("x=%d\n",x);
	return 0;
}
# x=97

注：字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换



#强制类型转换
强制类型转换是通过定义类型转换运算来实现的。其一般形式为： (数据类型) (表达式) 
#include <stdio.h>
int main()
{
    double num = 2.5; //定义浮点型变量num并赋值为2.5
    int num2=(int)num;
    printf("num的整数部分是%d\n", num2);  
	// 或者只用一句 printf("num的整数部分是%d\n", (int)num); 
    return 0;
}
#num的整数部分是2


在使用强制转换时应注意以下问题：
1、数据类型和表达式都必须加括号，如把(int)(x/2+y)写成(int)x/2+y则成了把x转换成int型之后再除2再与y相加了。
2、转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换。
3、强制转换后的运算结果不遵循四舍五入原则。





6.运算符 
#include <stdio.h>
int main()
{
    int a,b,c,d;
    double result;
    a = 1;
    b = 2;
    c = 3;
    d = 4;
    result = a + b - c * d;    //在这里体验哦~
    printf("%f\n", result);
    return 0;
}


6.1 算术运算符
除了 +-*/外， 求余（模运算）%， 自增++， 自减--
注：C语言中没有乘方这个运算符

#include <stdio.h>
int main()
{
    int x,y;
    x = 10;
    y = -3;
    printf("x+y=%d\n", x+y); 
    printf("x-y=%d\n", x-y);
    printf("x*y=%d\n", x*y);
    printf("x/y=%d\n", x/y);
    printf("x%%y=%d\n",x%y);  
    return 0;    
}
输出：
x+y=7
x-y=13
x*y=-30
x/y=-3
x%y=1

模运算后的符号取决于被模数的符号，如(-10)%3 = -1;而10%(-3) = 1。

//自增运算
#include <stdio.h>
int main()
{
    int x = 0;
    printf("0x=%d\n", x); //0
    printf("1x=%d\n",++x); //先自增，在显示值 1
    printf("2x=%d\n", x); //1
    printf("3x=%d\n",x++); //1先给值，再自增
    printf("4x=%d\n", x); //2
    
    return 0;
}
输出:
0x=0
1x=1
2x=1
3x=1
4x=2


6.2 ※ 赋值运算符
基本的 =
复合的 +=、-=、*=、/=、%=

int a = 3;
a += 5;
分析：定义整型变量a并赋值为3，a += 5;这个算式就等价于a = a+5; 将变量a和5相加之后再赋值给a

#include <stdio.h>
int main()
{
    int x = 10;
    int y = 10;
    //使用简单赋值语句实现x乘以2。
    x=x*2;
    //使用复合赋值语句实现y乘以2。
    y*=2;
    printf("x=%d\n", x);
    printf("y=%d\n", y);
    return 0;
}

注意：复合运算符中运算符和等号之间是不存在空格的。


6.3 ※ 关系运算符
关系表达式的值是“真”和“假”，在C程序用整数1和0表示。

#include <stdio.h>
int main()
{
    int x=5;
    int y=5;
    int z=10;
    printf("x=%d;y=%d;z=%d; \n",x,y,z);
    printf("x是否大于y:%d\n", x>y ); //x是否大于y
    printf("y是否大于等于x:%d\n", y>=x); //y是否大于等于x
    printf("y是否小于z:%d\n",   y<z ); //y是否小于z
    printf("z是否小于等于x:%d\n",  z<=x ); //z是否小于等于x
    printf("z是否等于x+y:%d\n", z==(x+y)); //z是否等于x+y
    return 0;
}
输出:
x=5;y=5;z=10; 
x是否大于y:0
y是否大于等于x:1
y是否小于z:1
z是否小于等于x:0
z是否等于x+y:1

注意：>=，<=，==，!=这种符号之间不能存在空格。




6.4 ※ 逻辑运算符
&& 与
|| 或
! 非



6.5 ※ 三目运算符 / 也叫三元运算符
表达式1 ? 表达式2 : 表达式3; 

#include <stdio.h>
int main()
{
    //定义小编兜里的钱
    double money = 12; 
    //定义打车回家的费用
    double cost =  11.5;  
    printf("小编能不能打车回家呢："); 
    //输出y小编就打车回家了，输出n小编就不能打车回家
    printf("%c", money>=cost?'y':'n' );
    return 0;
}



6.6 逗号表达式
从左到右依次计算，赋值的话取最右侧那个值。

经典案例：逗号表达式的值
#include<stdio.h>
int main(){
        //int a=b=c=5; // 是不合法的！
        int a,b,c;
        a=b=c=1;
        c=(a=10, b=2*a+5, a+a*b+c);
        printf("a=%d, b=%d, c=%d\n", a,b,c);
        return 0;
}
输出： 
a=10, b=25, c=261





6.x 优先级
优先级别为1的优先级最高，优先级别为10的优先级别最低。
记住最高优先级别的，在开发中就会无敌啦~()

口诀：括号最大 > 逻辑非! > 算数运算符 > 关系运算符 > 逻辑与&& > 逻辑或|| > 赋值运算符
同一优先级的运算符，运算次序由结合方向所决定。
详细查阅： https://blog.csdn.net/coder_pig/article/details/37650817








========================================
第3章 控制流 - break和continue语句
----------------------------------------
1.if分支
#include <stdio.h>
int main() 
{       
    int height = 185;
    if(height>=180){
        printf("OK");
    }
	return 0;
}


1.2 if-else分支
#include <stdio.h>
int main() 
{
    int year = 2019; //今年是2019年
    //能被4整除但不能被100整除，或者能被400整除的数。
    if( (year%4==0 && year%100!=0) || (year%400==0) ){
        printf("今年%d是闰年",year);
    }else{
        printf("今年%d是平年",year);
    }
    return 0;
}
输出:今年2019是平年


1.3 多重if-else语句
#include <stdio.h>
int main() 
{
    int score = 7200;
    //完善一下代码
    if(score>=10000){
        printf("钻石玩家");
    }
    else if(score>=5000 && score<10000){
        printf("白金玩家");    
    }
    else if(score>=1000 && score<5000){
        printf("青铜玩家");     
    }
    else{
        printf("普通玩家");    
    }
    return 0;
}
输出: 白金玩家



1.4 嵌套if-else语句
#include <stdio.h>
int main() 
{
    int sale=120; //销售业绩为120万
    int year=1; //刚刚进入公司1年
    
    if(sale>100){
        if(year>2){
            printf("优秀员工奖");
        }else{
            printf("sale达标，但不够2年");
        }
    }else{
        printf("sale不够");
    }
    return 0;
}
# sale达标，但不够2年






1.5 分支结构之switch语句
小明参加期末考试，分数等级分为A-D,等级划分方式如下：
90<=分数<=100 ,等级为A。
80<=分数<90 ,等级为B。
60<=分数<80 ,等级为C。
分数<60 ,等级为D。
小明期末考试分数为87分，在代码编辑器中完善代码使其输出结果为： 等级B 

#include <stdio.h>
int main() 
{
    int score = 87; //考试分数为87分 
    score /= 10;
    
    switch(score)
    {
        /*想想以下代码为什么用这种方式；
          这种方式的好处？*/
        case 10:
        case 9:
            printf("等级A");
            break;
        case 8:
            printf("等级B");
            break;  //这里必须加break语句          
        case 7:
        case 6: 
            printf("等级C");
            break; 
        default:
            printf("等级D");
            break;    
    }
    return 0;
}


switch语句时还应注意以下几点：
 - 在case后的各常量表达式的值不能相同，否则会出现错误。
 - 在case子句后如果没有break;会一直往后执行一直到遇到break;才会跳出switch语句。
 - switch后面的表达式语句只能是整型或者字符类型。
 - 在case后，允许有多个语句，可以不用{}括起来。
 - 各case和default子句的先后顺序可以变动，而不会影响程序执行结果。
 - default子句可以省略不用。




1.6 switch与if语句的应用
请使用switch语句和if...else语句，计算2008年8月8日这一天，是该年中的第几天。
程序分析：以5月1日为例，应该先把前4个月的天数加起来，然后再加上1天即本年的第几天。
特殊情况：在计算闰年的时候，2月是29天。

#include <stdio.h>
int main() 
{ 
    /* 定义需要计算的日期 */
    int year = 2008;
    int month = 8;
    int day = 8;
    /*
     * 请使用switch语句，if...else语句完成本题
     */
    int days=0;
    int i=0,sum=0;
    for(i=1; i<month;i++){
        switch(i){
            case 4:
            case 6:
            case 9:
            case 11:
                days=30;
                break;
            case 2:
                if( (year%100!=0 && year%4==0) ||(year%400==0) ){
                    days=29; //闰年
                }else{
                    days=28; //平年
                }
                break;
            default:
                days=31;
        }
        sum+=days;
        printf("%d月有%d天,月末是全年的第%d天；\n",i,days,sum);
    }
    sum+=day;
    printf("%d\n",sum);

	return 0;
}



1.7 臭名远扬之goto语句(能不用就别用，就当不存在该语句)
goto 语句标号;

输完3就跳出循环。
#include <stdio.h>
int main()
{
    int sum = 0;
    int i;
    for(i=1; i<=10; i++)
    {
        printf("%d\n", i);
        if(i==3)    //数完3就跳出循环体
          goto END;    //使用goto语句跳到标识符
    }
    END: printf("结束for循环了....");  //添加标识符
    return 0;    
}






2. while循环
#include <stdio.h>
int main()
{
    int i,sum=0;
    i=1;
    while( i<=100 ) //循环条件
    {
        sum=sum+i;
        i+=1;//改变循环变量
    }
    printf("100以内所有整数之和为：%d\n", sum);
    return 0;
}
# 100以内所有整数之和为：5050


2.2 do-while循环(至少会循环一次)
注意：使用do-while结构语句时，while括号后必须有分号。
#include <stdio.h>
int main()
{
    int number=200;
    int year=2014;
    do{
      year++;     
      number*=1.2; //每年20%扩招人数
    }while(number<1000); //do-while最后要有分号结尾
    printf("到%d年招工规模突破1000人\n", year);
    return 0;
}
# 到2023年招工规模突破1000人



2.3 for循环(一)
#include <stdio.h>
int main()
{
    // 定义变量sum, num
    int sum, num;  
    sum = 0;
    for(num = 0; num<=100; num++) //for循环条件与num的变化值
    {
        sum+=num; //计算每次数字之间的和sum
    }
    printf("100以内数的和为：%d", sum);
    return 0;
}
# 100以内数的和为：5050


2.4 for循环(二)
在for循环中，表达式1是一个或多个赋值语句，它用来控制变量的初始值；
表达式2是一个关系表达式，它决定什么时候退出循环；
表达式3是循环变量的步进值，定义控制循环变量每循环一次后按什么方式变化。
这三部分之间用分号(;)分开。
可以省略部分，但是分号不能省略。


输出所有水仙花数字。
所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数，如：153就是一个水仙花数，153=1*1*1+5*5*5+3*3*3。
#include <stdio.h>
int main(){
	int a1=0, a2=0, a3=0, sum=0;
	int i=100;
	for(i=100;i<=999;i++){
		a1=i/100; //百位
		a2=i/10%10; //十位
		a3=i%10; //个位
		sum=a1*a1*a1 + a2*a2*a2 + a3*a3*a3;
		if(sum==i){
			printf("%d \n",i);
		}
	}
	return 0;
}
输出:
153 
370 
371 
407



2.5 三种循环比较
while、do-while和for三种循环在具体的使用场合上是有区别的，如下：
1、在知道循环次数的情况下更适合使用for循环；
2、在不知道循环次数的情况下适合使用while或者do-while循环，如果有可能一次都不循环应考虑使用while循环，如果至少循环一次应考虑使用do-while循环。
但是从本质上讲，while,do-while和for循环之间是可以相互转换的。

例1： 计算1+2+3+...+100的值?
#include <stdio.h>
int main()
{
    /* 小伙伴们：选择你们认为最合理的循环结构完成功能吧 */
    int sum = 0;  //定义计算结果变量sum
    int i = 1;    //定义循环数字变量i
    
    //1.使用while循环
    while(i<=100)
    {
        sum+=i;
        i++;
    }
    printf("while: %d \n", sum);
    
    

    i = 1;  //重新初始化变量i
    sum=0;
    //2.do-while循环
    do{
        sum+=i;
        i++;
    }while(i<=100);
    printf("do-while: %d \n", sum);
    
    
    
    i = 1;  //重新初始化变量i
    sum=0;
    //3.使用for循环
    for(i=1;i<=100;i++)
    {
        sum+=i;
    }  
    printf("for: %d\n",sum); 
    
    return 0;    
}
输出: 
while: 5050 
do-while: 5050 
for: 5050




例2：使用循环计算1-2+3-4+5-6+…-100的值？就是偶数前是负号，奇数前是正号。
#include <stdio.h>
int main()
{
    /* 小伙伴们：
           选择你们认为最合理的循环结构完成功能吧 */
    int sum = 0;  //定义计算结果变量sum
    int i = 1;    //定义循环数字变量i
    int flag = 1; //定义符号状态变量flag
    
    //1.使用while循环
    while(i<=100)
    {
        flag=i%2==0?-1:1;
        sum+=i*flag;
        i++;
    }
    printf("while: %d \n", sum);
    
    

    i = 1;  //重新初始化变量i
    sum=0;
    //2.do-while循环
    do{
        flag=i%2==0?-1:1;
        sum+=i*flag;
        i++;
    }while(i<=100);
    printf("do-while: %d \n", sum);
    
    
    
    i = 1;  //重新初始化变量i
    sum=0;
    //3.使用for循环
    for(i=1;i<=100;i++)
    {
        flag=i%2==0?-1:1;
        sum+=i*flag;
    }  
    printf("for: %d\n",sum); 
    
    return 0;    
}
输出:
while: -50 
do-while: -50 
for: -50




2.6 多重循环
打印图形
    *
   ***
  *****
 *******
#include <stdio.h>
int main()
{
    int i, j, k;
    for(i=1; i<5; i++)
    {
        /* 观察每行的空格数量，补全循环条件 */
        for(j=i ;j<5 ;j++)  
        {
            printf(" ");    //输出空格
        }
        /* 观察每行*号的数量，补全循环条件 */
        for(k=0;k<2*i-1 ;k++) 
        {
            printf("*");   //每行输出的*号
        }
        printf("\n");     //每次循环换行
    }
    return 0;
}
 
使用for循环打印九九乘法表
#include <stdio.h>
int main() 
{ 
    // 定义相乘数字i,j以及结果result
    int i, j, result;
    /*使用for循环解决本题相对简单哦~ */
     for(i=9;i>0;i--){
         for(j=1;j<=i;j++){
             printf("%d*%d=%d\t",i,j,i*j);
         }
         printf("\n");
     }
    return 0;
}


2.7 循环结束语句 break
使用break语句时注意以下几点：
1、在没有循环结构的情况下，break不能用在单独的if-else语句中。
2、在多层循环中，一个break语句只跳出当前循环。

求100以内的质数(所谓素数就是只能被1和它本身整除的整数:2,3,5,7,13,...):
#include <stdio.h>
int main()
{
    int m, n;
    for(m=2; m<=100; m++)
    {
        for(n=2; n<m; n++)
        {
            if( m%n==0 )       //什么条件下跳出当前循环
               break;           //这里应该退出当前循环了
        }       
        if(m == n)   //n循环结束后，如果m=n的话就输出m
            printf("%d  ", m);
     }  
     printf("\n");
     return 0;    
}
# 2  3  5  7  11  13  17  19  23  29  31  37  41  43  47  53  59  61  67  71  73  79  83  89  97


2.8 循环结束语句 continue
continue语句的作用是结束本次循环开始执行下一次循环。
break语句与continue语句的区别是：break是跳出当前整个循环，continue结束本次循环开始下一次循环。 

计算1到20之间不能被3整除的数字之和。
运算结果为： sum=147 
#include <stdio.h>
int main()
{
    int i, sum;
    for(i=1, sum=0; i<=20; i++)
    {
        if(i%3==0)    //能被3整除这个条件如何写呢？
        {
            continue; //应该用哪个循环结束语句呢？
        }      
        sum += i;
    }
    printf("sum=%d\n", sum);
    return 0;    
}



2.9 练习
打印如下字母组成的图形：
A
BC
DEF
GHIJ
KLMNO
PQRSTU

#include<stdio.h>
int main()
{
        int i,j,c=0;
        for(i=1;i<=6;i++){
                for(j=1;j<=i;j++){
                        printf("%c",(char)(65+c) );
                        c++;
                }                       
                printf("\n");                   
        }
        return 0;
}





========================================
第4章 函数与程序结构 - c中函数都是并列的，可以嵌套调用，不允许嵌套定义(main函数内除外)
----------------------------------------
https://www.imooc.com/code/5434

1. 自定义函数与调用函数
函数的一般结构：
[数据类型说明] 函数名称([参数列表]){
	执行代码块;
	return(表达式);
}
注意：
1)、[]包含的内容可以省略，数据类型说明省略，默认是int类型函数；
参数省略表示该函数是无参函数，参数不省略表示该函数是有参函数；
2)、函数名称遵循标识符命名规范；
3)、自定义函数尽量放在main函数之前，如果要放在main函数后面的话，需要在main函数之前先声明自定义函数，声明格式为：[数据类型说明] 函数名称（[参数]）;


函数调用的一般形式为： 函数名（[参数]）; 
注意：
1)、对无参函数调用的时候可以将[]包含的省略。
2)、[]中可以是常数，变量或其它构造类型数据及表达式，各参数之间用逗号分隔。

#include <stdio.h>
/* 自定义整型函数 sayLove() */
int sayLove()
{
    //在这里输入输出语句printf，输出内容为I Love imooc 
   printf("I Love imooc\n");
   return 0;
}
/* 主函数 */
int main()
{
    sayLove();
    return 0;
}




2.局部与全局
C语言中的变量，按作用域范围可分为两种，即局部变量和全局变量。
(1)局部变量也称为内部变量。局部变量是在函数内作定义说明的。其作用域仅限于函数内， 离开该函数后再使用这种变量是非法的。在复合语句中也可定义变量，其作用域只在复合语句范围内。
(2)全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。

#include <stdio.h>
int x = 77;
void fn1()
{
    printf("fn1(): x=%d\n", x);       
}
int main()
{
    int x = 10;
    if(x>0)
    {
        int x = 100; //这里不写int则覆盖函数内定义的x=10
        x /= 2;
        printf("if语句内, x=%d\n", x);       
    }
    printf("main方法内, x=%d\n", x);
    fn1();
    return 0;
}
输出:
if语句内, x=50
main方法内, x=10
fn1(): x=77




3.变量存储类别
C语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式。
1)静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。
2)动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。

C语言中存储类别又分为四类：自动（auto）、静态（static）、寄存器的（register）和外部的（extern）。

1)、用关键字auto定义的变量为自动变量，auto可以省略，auto不写则隐含定为“自动存储类别”，属于动态存储方式。
2)、用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。

注意：静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放；
静态局部变量在编译时赋初值，即只赋初值一次；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。

3)、为了提高效率，C语言允许将局部变量得值放在CPU中的寄存器中，这种变量叫“寄存器变量”，用关键字register作声明。
注意：只有局部自动变量和形式参数可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；局部静态变量不能定义为寄存器变量。

4)、用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。

#include <stdio.h>
void fn()
{
    static int x = 1;   //定义静态局部变量，只初始化一次
    x*=2;
    printf("fn x=%d\n",x);     
}

int main()
{
    int i;
    for(i=0;i<5;i++)
    {
        fn();
    }
    extern int x;      //调用外部变量
    printf("x=%d\n",x);
    return 0;
}
int x=100;

输出:
fn x=2
fn x=4
fn x=8
fn x=16
fn x=32
x=100






4.内部函数与外部函数
在C语言中不能被其他源文件调用的函数称谓内部函数 ，内部函数由static关键字来定义，因此又被称谓静态函数，形式为：
 static [数据类型] 函数名（[参数]） 
这里的static是对函数的作用范围的一个限定，限定该函数只能在其所处的源文件中使用，因此在不同文件中出现相同的函数名称的内部函数是没有问题的。

在C语言中能被其他源文件调用的函数称谓外部函数 ，外部函数由extern关键字来定义，形式为：
 extern [数据类型] 函数名([参数]) 
C语言规定，在没有指定函数的作用范围时，系统会默认认为是外部函数，因此当需要定义外部函数时extern也可以省略。


test.c 
#include <stdio.h>
static void say(){ //这里为什么必须加static?否则会报错printLine没有明确定义？
    printLine();
    printf("I love imooc\n");
    printf("good good study!\n");
    printf("day day up!\n");
    printLine();
}


hello.c 
#include <stdio.h>
#include "test.c"   //引用test.c文件
extern void printLine()     //extern 可加可不加
{
   printf("**************\n");   
}

int main()
{
    say();
    return 0;
}
输出:
**************
I love imooc
good good study!
day day up!
**************

如果把test.c中的函数去掉static，则该文件不需要被引用到hello.c中，也就是注释掉include "test.c" 也可以正常运行。

首先都要修改printLine()为extern，然后有两个方法:
方法1. #include "test.c"作用就是被引入到hello.c，引入进去相当与hello.c的一部分，所以将say()改为static,调用内部函数。
方法2. 删除#include "test.c"，直接调用say().因为say()默认是extern,外部函数是可以直接调用的。

我使用自己的gcc测试，发现还需要在test.c第二行添加一行。
extern void printLine(); //下文将要使用的函数，要在使用前声明。










========================================
|-- 参数 
----------------------------------------
1.有参函数和无参函数的唯一区别在于：函数（）中多了一个参数列表。

#include <stdio.h>
/* 考虑一下哪个输出该用无参函数哪个输出该用有参函数呢？ */
int say1(){
    printf("小明学习\n");
    return 0;
}

int say2(int n){
    printf("小明学习了%d门课程\n", n);
    return 0;
}

int main()
{
    say1();
    say2(3);
    return 0;
}





2 形参与实参
形参是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数；
实参是在调用时传递该函数的参数。


函数的形参和实参具有以下特点：
- 形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。
- 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值等办法使实参获得确定值。
在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配”的错误。





3.函数返回值
1). 函数的值只能通过return语句返回主调函数。return语句的一般形式为：
  return 表达式   或者为：  return (表达式);
2). 函数值的类型和函数定义中函数的类型应保持一致。如果两者不一致，则以函数返回类型为准，自动进行类型转换。
3). 没有返回值的函数，返回类型为void。如果小刚算了一会没有返回结果的话，那么用代码表示就是：
注意：void函数中可以有执行代码块，但是不能有返回值，另void函数中如果有return语句，该语句只能起到结束函数运行的功能。其格式为：return;








========================================
|-- 递归函数
----------------------------------------
######################## 开始使用 sublime编辑和运行C代码。



一句话总结递归：自我调用且有完成状态。
https://www.imooc.com/code/5504

例1: 阶乘
#include<stdio.h>
int factorial(int n){
	if(n<0){
		printf("输入错误！\n");
		return 0;
	}else if(n==0 ||n==1){
		return 1;
	}else{
		return n*factorial(n-1);
	}
}

int main(){
	//
	int n=5;
	printf("%d的阶乘=%d\n", n, factorial(n));
	return 0;
}
输出:
5的阶乘=120



例2:猴子第一天摘下N个桃子，当时就吃了一半，还不过瘾，就又多吃了一个。第二天又将剩下的桃子吃掉一半，又多吃了一个。以后每天都吃前一天剩下的一半零一个。到第10天在想吃的时候就剩一个桃子了,问第一天共摘下来多少个桃子？并反向打印每天所剩桃子数。

#include<stdio.h>
int getPeachNumber(int day){
	int sum=0;
	if(day==10){
		sum=1;
	}else{
		sum=(getPeachNumber(day+1)+1)*2; 
	}
	printf("第%d天吃之前桃子个数：%d\n", day, sum);
	return sum;
}

int main(){
	getPeachNumber(1);
	return 0;
}
输出:
第10天吃之前桃子个数：1
第9天吃之前桃子个数：4
第8天吃之前桃子个数：10
第7天吃之前桃子个数：22
第6天吃之前桃子个数：46
第5天吃之前桃子个数：94
第4天吃之前桃子个数：190
第3天吃之前桃子个数：382
第2天吃之前桃子个数：766
第1天吃之前桃子个数：1534


例3:有5个人坐在一起，问第5个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第3个人，又说比第2人大两岁。问第2个人，说比第1个人大两岁。最后 问第1个人，他说是10岁。请问第5个人多大？
#include<stdio.h>
int getAge(int num){
	int age=0;
	if(num==1){
		age=10;
	}else{
		age=getAge(num-1)+2; 
	}
	printf("第%d个人年龄是：%d\n", num, age);
	return age;
}

int main(){
	int age=getAge(5);
	printf("第5个人的年龄是%d岁", age); 
	return 0;
}
输出:
第1个人年龄是：10
第2个人年龄是：12
第3个人年龄是：14
第4个人年龄是：16
第5个人年龄是：18
第5个人的年龄是18岁





========================================
第5章 指针与数组
----------------------------------------
1.是一块连续的，大小固定并且里面的数据类型一致的内存空间，它还有个好听的名字叫数组。可以将数组理解为大小固定，所放物品为同类的一个购物袋，在该购物袋中的物品是按一定顺序放置的。

我们来看一下如何声明一个数组： 数据类型 数组名称[长度]; 

数组只声明也不行啊，看一下数组是如何初始化的。说到初始化，C语言中的数组初始化是有三种形式的，分别是：
1)、 数据类型 数组名称[长度n] = {元素1,元素2…元素n};
2)、 数据类型 数组名称[] = {元素1,元素2…元素n};
3)、 数据类型 数组名称[长度n]; 数组名称[0] = 元素1; 数组名称[1] = 元素2; 数组名称[n-1] = 元素n;

我们将数据放到数组中之后又如何获取数组中的元素呢？
获取数组元素时： 数组名称[元素所对应下标]; 
如：初始化一个数组 int arr[3] = {1,2,3}; 那么arr[0]就是元素1。

注意：
1)、数组的下标均以0开始；
2)、数组在初始化的时候，数组内元素的个数不能大于声明的数组长度；
3)、如果采用第一种初始化方式，元素个数小于数组的长度时，多余的数组元素初始化为0；
4)、在声明数组后没有进行初始化的时候，静态（static）和外部（extern）类型的数组元素初始化元素为0，自动（auto）类型的数组的元素初始化值不确定。

#include <stdio.h>
int main()
{
    //第一种形式
    int arrFirst[3] ={1,2,3};
    //第二种形式
    int arrSecond[] = {4,5,6};
    //第三种形式
    int arrThird[3];
    //给arrThird数组每个元素初始化
    arrThird[0]=10;
    arrThird[1]=11;
    arrThird[2]=12;
    //输出第一个数组中的第二个元素
    printf("%d\n", arrFirst[1]);
    //输出第二个数组中的第二个元素
    printf("%d\n", arrSecond[1]);
    //输出第三个数组中的第二个元素
    printf("%d\n", arrThird[1]);
    return 0;
}
输出:
2
5
11



2.数组的遍历
数组遍历时要注意以下几点：
1)、最好避免出现数组越界访问，循环变量最好不要超出数组的长度;
2)、C语言的数组长度一经声明，长度就是固定，无法改变，并且C语言并不提供计算数组长度的方法。
由于C语言是没有检查数组长度改变或者数组越界的这个机制，可能会在编辑器中编译并通过，但是结果就不能肯定了，因此还是不要越界或者改变数组的长度;
#include <stdio.h>
int main()
{
    int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    //对数组arr遍历
    for(int i=0;i<10;i++){
        printf("%d\n",arr[i]);
    }
    return 0;
}
输出:
0
1
2
3
4
5
6
7
8
9



3.数组作为函数参数
https://www.imooc.com/code/5638

数组作为函数参数时注意以下事项：
1)、数组名作为函数实参传递时，函数定义处作为接收参数的数组类型形参既可以指定长度也可以不指定长度。
2)、数组元素作为函数实参传递时，数组元素类型必须与形参数据类型一致。


例1：数组是按照地址传递的，在函数中修改其值，原始数组也被修改了。
#include<stdio.h>
void fn(int arr[]){
	int i;
	for(i=0;i<5;i++){
		arr[i]=arr[i]*2;//函数中修改形式参数的值
		printf("arr[%d]=%d, ",i, arr[i]);
	}
}

int main(){
	int i;
	
	int myArr[5]={0,1,2,3,4};
	fn(myArr);
	printf("\n");

	//原数组也被修改了
	for(i=0;i<5;i++){
		printf("myArr[%d]=%d, ",i, myArr[i]);
	}
	return 0;
}


例2：找出指定数组中的最大值，并把其替换为另一个数组的第一个值。
#include <stdio.h>
void replaceMax(int arr[],int value)
{
    int max = arr[0];
    int index = 0;
    int i;
    for(i=1;i<5;i++)
    {
        if(arr[i]>max)
        {
            max=arr[i]; //将数组中较大的数赋值给max
            index = i;  //记录当前索引
        }                
    }  
    arr[index] = value;
}

int main()
{
    int arr1[] = {10,41,3,12,22};
    int arr2[] = {1,2,3,4,5};
    int i;
    replaceMax(arr1,arr2[0] ); //将数组arr1和数组arr2的第一个元素传入函数中
    for(i=0;i<5;i++)
    {
        printf("%d ",arr1[i]);                
    }
    return 0;    
}
输出: 10 1 3 12 22 


例3： 查找数组中是否包含某个值，下表是多少？
#include <stdio.h>
int getIndex(int arr[5],int value)
{
    int i;
    int index=-1;
    for(i=0;i<5;i++)
    {
       /* 请完善数组查询功能 */
       if(arr[i]==value){
           index=i;
           break;
       }
    }
    return index;
}

int main()
{
    int arr[5]={3,12,9,8,6};
    int value = 8;
    int index = getIndex(arr, value);      //这里应该传什么参数呢？
    if(index!=-1)
    {
        printf("%d在数组中存在，下标为：%d\n",value,index);             
    }
    else
    {
        printf("%d在数组中不存在。\n",value);    
    }
    return 0;    
}
输出: 8在数组中存在，下标为：3



========================================
|-- 字符串与数组
----------------------------------------
1.字符串就是由多个字符组合而成的一段话。

在C语言中，是没有办法直接定义字符串数据类型的，但是我们可以使用数组来定义我们所要的字符串。一般有以下两种格式：
1、char 字符串名称[长度] = "字符串值";
2、char 字符串名称[长度] = {'字符1','字符2',...,'字符n','\0'};

注意：
1、[]中的长度是可以省略不写的；
2、采用第2种方式的时候最后一个元素必须是'\0'，'\0'表示字符串的结束标志；
3、采用第2种方式的时候在数组中不能写中文。
在输出字符串的时候要使用：printf(“%s”,字符数组名字);或者puts(字符数组名字);

#include <stdio.h>
/* 定义say函数 */
void say(char string[]) //数组参数应该怎么写呢？
{
    printf("%s\n",string); //打印字符串
}

int main()
{
    //定义字符串数组
    char string[] = "我在慕课网上学习IT技能！";
    say(string); //调用say函数输出字符串
    return 0;
}




========================================
|-- 字符串函数
----------------------------------------

使用string.h提供的字符串操作函数： 
strlen(a)：返回字符串的长度，不包括字符串结束的标记’\0’
strcmp(a,b)：将a，b两个字符串从左到右对每个字符，按照ASCII码的值进行比较，直到出现不同的或者’\0’，终止比较，如果内容一样，返回0；大于返回正整数，小于则返回负整数；
strcpy(a,b)：将b的字符串复制到a中，会覆盖
strcat(a,b)：将字符串b的内容拼接到a的后面



1.strlen("abc") //3 获得字符串的长度
strlen()获取字符串的长度，在字符串长度中是不包括‘\0’而且汉字和字母的长度是不一样的。
#include<stdio.h>
#include<string.h>
int main(){
	char str1[]="旺财";
	char str2[]=" is a dog";
	printf("str1的长度是%d\n", (int)strlen(str1));
	printf("str2的长度是%d\n", (int)strlen(str2));
	return 0;
}
输出:
str1的长度是6
str2的长度是9



2.strcmp("ab","ab"); //1 比较字符串
strcmp()在比较的时候会把字符串先转换成ASCII码再进行比较,返回的结果为0表示s1和s2的ASCII码相等,返回结果为1表示s1比s2的ASCII码大,返回结果为-1表示s1比s2的ASCII码小。
#include<stdio.h>
#include<string.h>
int main(){
	char str1[]="旺财";
	char str2[]=" is a dog";
	printf("str1和str2比较：%d\n", strcmp(str1,str2));
	printf("字符串比较1: %d\n", strcmp("ab","ab"));
	printf("字符串比较2: %d\n", strcmp("ab","ac"));
	printf("字符串比较3: %d\n", strcmp("ab","aa"));
	return 0;
}
输出:
str1和str2比较：1
字符串比较1: 0
字符串比较2: -1
字符串比较3: 1



3.strcpy(s1, "abc"); //字符串拷贝
strcpy()拷贝之后会覆盖原来字符串且不能对字符串常量进行拷贝，

#include<stdio.h>
#include<string.h>
int main(){
	char str1[]="旺财";
	char str2[]=" is a dog";
	strcpy(str2," is a cat");
	printf("str1=%s \nstr2=%s;\n", str1, str2);
	return 0;
}
输出:
str1=旺财 
str2= is a cat;



4.strcat(s1, "abc"); //把后一个字符串拼接到第一个字符串后面
strcat在使用时s1与s2指的内存空间不能重叠，且s1要有足够的空间来容纳要复制的字符串。

#include<stdio.h>
#include<string.h>
int main(){
	char str1[]="旺财";
	char str2[]=" is a dog";
	strcat(str1," is not a cat.");
	//strcat(str1, str2); //这样为什么不行？//done
	printf("str1=%s \nstr2=%s;\n", str1, str2);
	return 0;
}
输出:
str1=旺财 is not a cat. 
str2= is a dog;

因为str1空间不够，如果添加str[100]，则上文strcat(str1, str2);就不会报错。




5.atoi("100"); //100 字符串转换为整数

#include<stdio.h>
#include <stdlib.h>
int main(){
	char str1[]="100";
	int num=atoi(str1);
	printf("str1=%s \nnum=%d;\n", str1, num+2);
	return 0;
}
输出:
str1=100 
num=102;


例1: 把s2复制给s1(长度足够)，s3链接到s1后面，输出“我爱,慕课网”
#include <stdio.h>
#include <string.h>
int main()
{
    char s1[100]="";
    char s2[]="我爱,";
    char s3[]="慕课网";
    /*在以下补全代码*/
    strcpy(s1,s2);
    strcat(s1,s3);
    printf("%s\n",s1);
    return 0;    
}



========================================
|-- 输入输出函数 printf, scanf 与 puts, gets的区别
----------------------------------------


printf()函数
printf()函数是格式化输出函数, 一般用于向标准输出设备按规定格式输出信息。在编写程序时经常会用到此函数。printf()函数的调用格式为:
printf("<格式化字符串>", <参量表>);
其中格式化字符串包括两部分内容: 一部分是正常字符, 这些字符将按原样输出; 另一部分是格式化规定字符, 以"%"开始, 后跟一个或几个规定字符,用来确定输出内容格式。



scanf()函数
scanf()函数是格式化输入函数, 它从标准输入设备(键盘) 读取输入的信息。其调用格式为:
scanf("<格式化字符串>", <地址表>);
格式化字符串包括以下三类不同的字符;
1. 格式化说明符: 格式化说明符与printf()函数中的格式说明符基本相同。
2. 空白字符: 空白字符会使scanf()函数在读操作中略去输入中的一个或多个空白字符。
3. 非空白字符: 一个非空白字符会使scanf()函数在读入时剔除掉与这个非空白字符相同的字符。
地址表是需要读入的所有变量的地址, 而不是变量本身。这与printf()函数完全不同, 要特别注意。各个变量的地址之间同","分开。



puts()函数
puts()函数用来向标准输出设备(屏幕)写字符串并换行, 其调用格式为:
puts(s); 其中s为字符串变量(字符串数组名或字符串指针)。
puts()函数的作用与语printf("%s\n", s)相同。


gets()函数
gets()函数用来从标准输入设备(键盘)读取字符串直到回车结束, 但回车符不属于这个字符串。其调用格式为:
gets(s); 其中s为字符串变量(字符串数组名或字符串指针)。
gets(s)函数与scanf("%s", &s)相似, 但不完全相同, 使用scanf("%s", &s)函数输入字符串时存在一个问题, 就是如果输入了空格会认为输入字符串结束,空格后的字符将作为下一个输入项处理, 但gets() 函数将接收输入的整个字符串直到回车为止。

gets()函数实现字符串的输入，其调用形式为：gets(字符数组)；
puts()函数实现字符串的输出，其调用形式为：puts(字符数组)；



printf scanf是格式化输入输出函数：更清晰标准
puts gets是非格式化输入输出函数 ：编译后代码少, 相对占用内存也小, 从而提高了速度, 同时使用也比较方便。






========================================
|-- 多维数组
----------------------------------------
https://www.imooc.com/code/5636

1.定义
数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n];
num[行数][列数]

例如：int num[3][3]={{1,2,3},{4,5,6},{7,8,9}};
这样定义了一个名称为num，数据类型为int的二维数组。其中第一个[3]表示第一维下标的长度，就像购物时分类存放的购物；第二个[3]表示第二维下标的长度，就像每个购物袋中的元素。

我们可以把上面的数组看作一个3×3的矩阵。
num[0][0]=1;	num[0][1]=2;	num[0][2]=3;
num[1][0]=4;	num[1][1]=5;	num[1][2]=6;
num[2][0]=7;	num[2][1]=8;	num[2][2]=9;


多维数组的初始化与一维数组的初始化类似也是分两种：
1)、数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n] = {{值1,..,值n},{值1,..,值n},...,{值1,..,值n}};
2)、数据类型 数组名称[常量表达式1][常量表达式2]...[常量表达式n]; 数组名称[下标1][下标2]...[下标n] = 值;


多维数组初始化要注意以下事项：
1)、采用第一种始化时数组声明必须指定【列】的维数。因为系统会根据数组中元素的总个数来分配空间，当知道元素总个数以及列的维数后，会直接计算出行的维数；
也就是以下是合法的:
int x[][3]={{0},{1},{1,2,3}};
int x[4][3]={{1,2,3},{1,2,3},{1,2,3},{1,2,3}}
int x[][3]={1,2,3,4}; //会有warning。自动计算总个数4除以列数3得到1.3，也就是2行。x[1][0]=4
而以下是错误的:
int x[4][]={{1,2,3},{1,2,3},{1,2,3},{1,2,3}};//二维数组定义的时候，可以不指定行的数量，但是必须指定列的数量。

2)、采用第二种初始化时数组声明必须同时指定行和列的维数。



例: 给arr1和arr2数组元素初始化为10,20,30，40。第一行元素为10和20，第二行元素为30和40。
#include <stdio.h>
int main()
{
    //使用第一种方式初始化方式声明并初始化二维数组arr1
    int arr1[2][2]={{10,20},{30,40}};
    
    //使用第二种方式初始化方式声明并初始化二维数组arr2
    int arr2[2][2];
    arr2[0][0]=10;
    arr2[0][1]=20;
    arr2[1][0]=30;
    arr2[1][1]=40;
    //
    return 0;    
}




2.遍历：嵌套循环

例:现有三行三列的二维数组int arr[3][3] = {{1,2,3},{4,5,6},{7,8,9}};，编写程序实现计算对角线元素之和。
#include <stdio.h>
int main()
{
    int arr[3][3] = {{1,2,3},{4,5,6},{7,8,9}};
    int i,j;
    int sum=0;
    for(i=0;i<3;i++)
    {
       for(j=0;j<3;j++){
           if(i==j || i+j==2){
               sum+=arr[i][j];
           }
       }
    }
    printf("对角线元素之和是：%d\n",sum);
    return 0;    
}
输出:
对角线元素之和是：25




例： 在一个长度为10的整型数组里面，保存了班级10个学生的考试成绩。要求编写5个函数，分别实现计算考试的总分，最高分，最低分，平均分和考试成绩降序排序。

#include <stdio.h>
#define N 10
int max(int arr[N]){
    int max=arr[0];
    int i;
    for(i=0; i<10;i++){
    	if( arr[i]>max){
    		max=arr[i];
    	}
    }
    return max;
}
int min(int arr[N]){
    int min=arr[0];
    int i;
    for(i=0; i<10;i++){
    	if( arr[i]<min){
    		min=arr[i];
    	}
    }
    return min;
}
int mean(int arr[N]){
	int i=0,sum=0;
	for(;i<N;i++){
		sum+=arr[i];
	}
	return sum/N;
}
void sort(int arr[N]){
	int temp,i,j;
	for(i=0;i<N-1;i++){
		for(j=i+1;j<N;j++){
			if(arr[i]<arr[j]){
				temp=arr[i];
				arr[i]=arr[j];
				arr[j]=temp;
			}
		}
	}
}
int main()
{
    int score[N]={67,98,75,63,82,79,81,91,66,84};
    printf("max=%d\n", max(score));
    printf("min=%d\n", min(score));
    printf("mean=%d\n", mean(score));
    sort(score);
    int i=0;
    for(;i<N;i++){
    	printf("%d, ", score[i]);
    }
    printf("\n");
    return 0;
}
输出： 
max=98
min=63
mean=78
98, 91, 84, 82, 81, 79, 75, 67, 66, 63, 



========================================
|-- 数组的排序算法
----------------------------------------
1. 冒泡法排序
相邻元素两两比较，将较大的数字放在后面，直到将所有数字全部排序。
#include <stdio.h>
int main()
{
    double arr[10]={1.78, 1.67, 1.82, 1.79, 1.85, 1.75, 1.86, 1.77, 1.81, 1.80};
    int i,j;
    printf("\n************排队前*************\n");
    for(i=0;i<10;i++)
    {
        if(i != 9)   
            printf("%.2f, ", arr[i]);  //%.2f表示小数点后精确到两位
        else
            printf("%.2f", arr[i]);    //%.2f表示小数点后精确到两位
    }
    for(i=8; i>=0; i--)
    {
        for(j=0;j<=i;j++) //i=8,arr[j+1]=arr[9]就是最后一个
        {
            if(arr[j]>arr[j+1] )      //当前面的数比后面的数大时
            {
                double temp;    //定义临时变量temp
                temp=arr[j];     //将前面的数赋值给temp
                arr[j]=arr[j+1];    //前后之数颠倒位置
                arr[j+1]=temp;  //将较大的数放在后面    
            }
        }
    }
    printf("\n************排队后*************\n");
    for(i=0;i<10;i++)
    {
        if(i != 9)   
            printf("%.2f, ", arr[i]);  //%.2f表示小数点后精确到两位     
        else
            printf("%.2f", arr[i]);    //%.2f表示小数点后精确到两位
    }
    return 0;    
}





2. 找出最大的，和第一个交换；再找剩下的最大的，和第二个交换
(1) 示例1
#include<stdio.h>
//打印数组
void printArr(int arr[]){
	int i;
	printf("[");
	for(i=0;i<5;i++){
		printf("%d, ", arr[i]);
	}
	printf("]\n");
}

void sortBubble(int arr[]){
	int i,j,tmp;
	for(i=0;i<4;i++){
		for(j=i;j<5;j++){
			if(arr[i]>arr[j]){
				tmp=arr[i];
				arr[i]=arr[j];
				arr[j]=tmp;
			}
		}
	}
}

int main(){
	int myArr[5]={100,21,2000,63,4,};
	printArr(myArr);
	sortBubble(myArr);
	printArr(myArr);
	return 0;
}




(2) 示例2: 更通用的写法，是传入数组长度
$ cat 07_arr_sort.c
#include<stdio.h>

void printArr(double arr[], int len){
  printf("[");
  for(int i=0; i<len; i++){
    //printf("arr[%d]=%2.1f\n", i, arr[i]);
    if(i<len-1){ printf("%2.1f, ", arr[i]); }
    else{ printf("%2.1f", arr[i] ); }
  }
  printf("]\n");
}

void sort(double arr[], int len){
 for(int i=0; i<len; i++){
  for(int j=i; j<len; j++){
    if( arr[i] > arr[j]){
      double tmp=arr[i];
      arr[i]=arr[j];
      arr[j]=tmp;
    }
   }
 }
}

int main(){
  double arr2[]={1.1, 1, 4.5, -5, 20, -2.1, 10, 2001, 1.3, -300};
  printArr(arr2, 10);
  sort(arr2, 10);
  printArr(arr2, 10);
}

$ gcc 07_arr_sort.c
$ ./a.out 
[1.1, 1.0, 4.5, -5.0, 20.0, -2.1, 10.0, 2001.0, 1.3, -300.0]
[-300.0, -5.0, -2.1, 1.0, 1.1, 1.3, 4.5, 10.0, 20.0, 2001.0]








========================================
|-- sizeof 与数组: 变量占了多少内存？
----------------------------------------
使用了sizeof关键字来问C语言这些东西占多少个字节。
在初始化之前，C就确定了每个元素占用的空间，则全部数组长度确定后，这个数组占用的位置也是可以计算的。


1. 可以通过 sizeof() 知道每个变量占了多少内存空间
int a1=sizeof(int); //4
int a2=sizeof(1);  //4

int arr[]={1,2,3,400};
int a3=sizeof(arr); //16

char arr2[][5]={"this", "is", "good"};
printf("arr2: %ld, first ele: %ld\n", sizeof(arr2), sizeof(arr2[0])); // 15  5


int var=100;
int *ptr=&var;
int **pptr=&ptr;
printf("sizeof(var)=%ld, sizeof(ptr)=%ld, sizeof(pptr)=%ld\n",sizeof(var), sizeof(ptr), sizeof(pptr)); 
//sizeof(var)=4, sizeof(ptr)=8, sizeof(pptr)=8
指针占了8位。








2. 可以通过 sizeof 知道数组测长度

# include<stdio.h>
int main(){
	int arr1[]={1,2,3,4,100};
	char arr2[][5]={"this", "is","a","book"};

	int N1=sizeof(arr1) / sizeof(1);
	printf("len(arr1)=%d\n", N1);
	for(int i=0; i<N1; i++){
		printf("arr1[%d] = %d \n", i, arr1[i]);
	}

	int N2=sizeof(arr2)/ sizeof( arr2[0] );
	printf("\nlen(arr2)=%d\n", N2);
	for(int j=0; j<N2; j++){
		printf("arr2[%d]=%s\n", j, arr2[j]);
	}
	
	return 0;
}

运行后
len(arr1)=5
arr1[0] = 1 
arr1[1] = 2 
arr1[2] = 3 
arr1[3] = 4 
arr1[4] = 100 

len(arr2)=4
arr2[0]=this
arr2[1]=is
arr2[2]=a
arr2[3]=book








========================================
指针 ############### (很重要) ###############
----------------------------------------

变量前加&获得其指针: int a=10; &a 就是指向a的指针地址，是一个16进制数。
指针前加*就获得了该值: int *p; 则p是指向int的指针变量(16进制数)，而*p则是该指针地址对应的int值。



1.学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。

正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：

#include <stdio.h>
 
int main ()
{
   int  var1;
   char var2[10];
 
   printf("var1 变量的地址： %p\n", &var1  );
   printf("var2 变量的地址： %p\n", &var2  );
 
   return 0;
}

window输出:
var1 变量的地址： 000000000061FE4C
var2 变量的地址： 000000000061FE42

Ubuntu输出:
var1 变量的地址： 0x7ffe6a0f83b8
var2 变量的地址： 0x7ffe6a0f83be

下文指针部分，我们按照Ubuntu输出记录和分析。


2.什么是指针？
指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

type *var-name;
如 
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;     /* 一个字符型的指针 */

所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。

不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。


2.如何使用指针？
使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：

#include <stdio.h>
 
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &var;  /* 在指针变量中存储 var 的地址 */
   printf("Address of var variable: %p\n", &var  );
 
   /* 在指针变量中存储的地址 */
   printf("Address stored in ip variable: %p\n", ip );
 
   /* 使用指针访问值 */
   printf("Value of *ip variable: %d\n", *ip );
   return 0;
}
输出:
Address of var variable: 0x7ffc34c740fc
Address stored in ip variable: 0x7ffc34c740fc
Value of *ip variable: 20


3.C 中的 NULL 指针
在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。
NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：

实例
#include <stdio.h>

int main ()
{
   int  *ptr = NULL;
   printf("ptr 的地址是 %p\n", ptr  );
   return 0;
}
输出:ptr 的地址是 (nil)
win10的输出是: ptr 的地址是 0000000000000000


在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

如需检查一个空指针，您可以使用 if 语句，如下所示：

if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */




4.C 指针详解
在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念：

========================================
|-- 指针的算术运算: 可以对指针进行四种算术运算：++、--、+、-
----------------------------------------

假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：

ptr++
在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。
如果 ptr 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。


例1： 数组变量名就是一个指针。
#include<stdio.h>
const int MAX =3;
int main(){
  int var[]={10,100,200};
  int i, *ptr;
  ptr=var; //指针中的数组地址
  printf("%p\n", var );

return 0;
}
输出 0x7ffeefc3662c


例2： 递增一个指针
我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。
下面的程序递增变量指针，以便顺序访问数组中的每一个元素：

#include<stdio.h>
const int MAX =3;
int main(){
  int var[]={10,100,200};
  int i, *ptr;
  ptr=var; //指针中的数组地址
  printf("%p, value=%d, %d\n", var, *var, var[0]);
  for(i=0;i<MAX; i++){
    printf("存储地址: var[%d]=%p; ", i, ptr);
    printf("值：var[%d]=%d \n", i, *ptr);
    ptr++;//移动指针到下一个位置
  }
return 0;
}
输出： 
0x7ffeb613940c, value=10, 10  #数组名就是指针，指向数组or数组第一个值，*var则取出该值，等价于var[0]；
存储地址: var[0]=0x7ffeb613940c; 值：var[0]=10 
存储地址: var[1]=0x7ffeb6139410; 值：var[1]=100 
存储地址: var[2]=0x7ffeb6139414; 值：var[2]=200


例3：递减一个指针。
取值第三个元素时，加上%符号就获得了该位置的指针。

#include<stdio.h>
const int MAX =3;
int main(){
  int var[]={10,100,200};
  int i, *ptr;
  ptr= &var[MAX-1]; //指针指向数组第三个元素
  printf("%p, value[2]=%d\n", &var[2], var[2]);
  for(i=MAX;i>0; i--){
    printf("存储地址: var[%d]=%p; ", i, ptr);
    printf("值：var[%d]=%d \n", i, *ptr);
    ptr--;//移动指针到下一个位置
  }
return 0;
}
输出:
0x7fffca52e114, value[2]=200
存储地址: var[3]=0x7fffca52e114; 值：var[3]=200 
存储地址: var[2]=0x7fffca52e110; 值：var[2]=100 
存储地址: var[1]=0x7fffca52e10c; 值：var[1]=10





例4： 指针的比较
指针可以用关系运算符进行比较，如 ==、< 和 >。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。

只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &var[MAX - 1]，则把变量指针进行递增：

#include<stdio.h>
const int MAX =3;
int main(){
  int var[]={10,100,200};
  int i, *ptr;
  ptr= var; //指针指向数组第1个元素第一个元素的地址
  i=0;
  while(ptr<= &var[MAX-1]){
    printf("存储地址: var[%d]=%p; ", i, ptr);
    printf("值：var[%d]=%d \n", i, *ptr);
    ptr++;
    i++;
  }
return 0;
}

输出： 
存储地址: var[0]=0x7ffc354838ac; 值：var[0]=10 
存储地址: var[1]=0x7ffc354838b0; 值：var[1]=100 
存储地址: var[2]=0x7ffc354838b4; 值：var[2]=200


========================================
|-- 指针数组	可以定义用来存储指针的数组。
----------------------------------------

1.一个数组 int  var[] = {10, 100, 200};
我们把其每个元素的地址保存到一个数组中：int *ptr[MAX];
数组的每个元素都是指向int值的指针: ptr[0]=&var[0]
取值的时候可以var[0], 或者 *ptr[0]。 递增的时候，可以使用 ptr++ //todo

#include <stdio.h>
int main(){
  int var[]={10,200,30};
  int i, *ptr[3];
  for(i=0;i<3;i++){
    ptr[i]=&var[i];
  }
  for(i=0; i<3; i++){
    printf("Value of var[%d]=%d or %d, pointer=%p \n",i,var[i], *ptr[i], ptr[i] );
  }
  return 0;
}

输出结果：
Value of var[0]=10 or 10, pointer=0x7ffc8702e764 
Value of var[1]=200 or 200, pointer=0x7ffc8702e768 
Value of var[2]=30 or 30, pointer=0x7ffc8702e76c 






2.用一个指向字符的指针数组来存储一个字符串列表
#include<stdio.h>
int main(){
  char *names[]={"Tom", "Jim", "Robin", "Page"};
  char *tmp;
  int i=0;
  for(;i<4;i++){
    tmp=names[i];
    printf("pointer[%d]=%p, value: %s;   char1=%c\t", i, names[i], names[i], *names[i]); //字符串本质是字符的数组，所以它记录的就是该数组的首元素的地址。
    printf("__point[%d]=%p, char2=%c; char1=%c;\n", i, tmp, *tmp, *tmp++);  //这里为什么char1和char2是这个顺序？
  }
  return 0;
}


输出： 
pointer[0]=0x5624e5dda838, value: Tom;   char1=T        __point[0]=0x5624e5dda839, char2=o; char1=T;
pointer[1]=0x5624e5dda83c, value: Jim;   char1=J        __point[1]=0x5624e5dda83d, char2=i; char1=J;
pointer[2]=0x5624e5dda840, value: Robin;   char1=R      __point[2]=0x5624e5dda841, char2=o; char1=R;
pointer[3]=0x5624e5dda846, value: Page;   char1=P       __point[3]=0x5624e5dda847, char2=a; char1=P;

//todo
可能是因为形式赋值，和实质赋值不是一个时间？
++前先给了值，所以是第一个字符； 而其本身已经是第二个字符了。

实例2:
#include<stdio.h>
int main(){
  char *names[]={"Tom", "Jim", "Robin", "Page"};
  char *tmp;
  int i=0;
  for(;i<4;i++){
    printf("pointer[%d]=%p, value: %s;   char1=%c\t", i, names[i], names[i], *names[i]);
    tmp=names[i]++; //tmp还是第一个字符的地址， names中已经移动到第二个字符了
    printf("__point[%d]=%p, char1=%c; char2=%c;\n", i, tmp, *tmp, *names[i]);
  }
  return 0;
}
输出:
pointer[0]=0x557d73d88848, value: Tom;   char1=T        __point[0]=0x557d73d88848, char1=T; char2=o;
pointer[1]=0x557d73d8884c, value: Jim;   char1=J        __point[1]=0x557d73d8884c, char1=J; char2=i;
pointer[2]=0x557d73d88850, value: Robin;   char1=R      __point[2]=0x557d73d88850, char1=R; char2=o;
pointer[3]=0x557d73d88856, value: Page;   char1=P       __point[3]=0x557d73d88856, char1=P; char2=a;






3. 指针数组和数组指针的区别
要看结尾词！

(1)指针数组
指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组。
其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型。
在 32 位系统中，指针占四个字节。

数组指针
数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针。
其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。

根据上面的解释，可以了解到指针数组和数组指针的区别，因为二者根本就是两种类型的变量。


(2)
指针数组：表示的是一个由指针变量组成的数组，也就是说其中的元素都是指针变量。

数组指针：表示的是这是个指向数组的指针，那么该指针变量存储的地址就必须是数组的首地址，得是个指向行的地址，如 a[2][3] 数组中的 a，a+1 等，不能是具体的指向列的地址，如 &a[0][1], &a[1][1] 这类地址。








========================================
|-- 指向指针的指针	C 允许指向指针的指针。
----------------------------------------
指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。
当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

pointer1   pointer2    Variable
Address  -> Address  -> Value

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：
int **var;

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符
本身第第一个指针(指向第二个指针)，加一个星号是第二个指针(指向值)，加2个星号才取到值。


例1： 
#include<stdio.h>
int main(){
 int var=100;
 int *ptr;
 int  **pptr;

 ptr=&var; //获取var的地址
 pptr=&ptr; //获取 ptr的地址

 //获取值
 printf("value of var=%d\n", var);
 printf("value by ptr=%p, *ptr=%d\n", ptr, *ptr);
 printf("value by pptr=%p, *pptr=%p( == ptr), **pptr=%d\n", pptr, *pptr, **pptr);

 return 0;
}

输出：
value of var=100
value by ptr=0x7ffedff40f04, *ptr=100
value by pptr=0x7ffedff40f08, *pptr=0x7ffedff40f04( == ptr), **pptr=100





========================================
|-- 传递指针给函数	通过引用或地址传递参数，使传递的参数在调用函数中被改变。
----------------------------------------
C 语言允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。

下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值：

例1：接收指针的函数
#include<stdio.h>
#include<time.h>
void getSeconds(unsigned long *per);

int main(){
 unsigned long sec=0;
 printf("sec=%ld\n", sec);
 getSeconds( &sec ); //输出被改变后的值
 printf("Number of seconds: %ld\n", sec);
 return 0;
}

void getSeconds(unsigned long *par){
 *par=time(NULL);
 return;
}

输出： 
sec=0
Number of seconds: 1564059253




能接受指针作为参数的函数，也能接受数组作为参数
例2：接收指针数组的函数
#include<stdio.h>
double getAverage(int *arr, int size);


int main(){
 int balance[5]={1000,2,3,17,50}; //有5个元素的整数型数组 
 double avg;
 
 printf("the para=%p, 1st element=%d \n", balance, *balance);
 avg=getAverage( balance, 5); //指向数组的指针作为参数

 printf("Average value is: %f\n", avg);
 return 0;
}

double getAverage(int *arr, int size){
        int i, sum=0;
        double avg;
        for(i=0;i<size;i++){
                sum+=arr[i];
        }
        avg=(double)sum/size;
        return avg;
}

输出： 
the para=0x7ffcdd27e500, 1st element=1000 
Average value is: 214.400000




例3: 在外部函数中，加倍每个数组元素的值（数组是按照地址传递）
#include<stdio.h>
void doubleInt(int *arr,int size);

int main(){
        int i,r[5]={1,2,3,4,5};
        for(i=0;i<5;i++){ printf("a[%d]=%d, ",i,r[i]);} 
        printf("\n");

        doubleInt(r,5);
        for(i=0;i<5;i++){ printf("a[%d]=%d, ",i,r[i]); }
        printf("\n");
}

void doubleInt(int *arr, int size){
        int i=0;
        for(i=0;i<size;i++){
                arr[i]*=2;
        }
        return;
}
输出： 
a[0]=1, a[1]=2, a[2]=3, a[3]=4, a[4]=5, 
a[0]=2, a[1]=4, a[2]=6, a[3]=8, a[4]=10,



========================================
|-- 从函数返回指针	C 允许函数返回指针到局部变量、静态变量和动态内存分配。
----------------------------------------
C 语言中可以从函数返回数组，类似地，C 允许您从函数返回指针。

声明一个返回指针的函数：
int * myFunction(){
//some code;
}


例1: 返回指针的函数，就是返回的数组名
#include<stdio.h>
#include<time.h>
#include<stdlib.h>

//要生成和返回随机数的函数 
int *getRandom(){
  static  int r[3];
  int i;
  srand( (unsigned)time(NULL) );
  for(i=0; i<3; i++){
    r[i]=rand();
    printf("arr[%d] = %d\n",i, r[i]);
  }
  return r;
}

int main(){
  int *p, i;
  p=getRandom();
  for(i=0; i<3; i++){
    printf("*(p + [%d]): %d;\n", i, *(p+i));
  }
}

输出： 
arr[0] = 1018462428
arr[1] = 1425683971
arr[2] = 1191730623
*(p + [0]): 1018462428;
*(p + [1]): 1425683971;
*(p + [2]): 1191730623;



另外，C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。
如果上例中声明r时不加static，则会报错： a11.c:14:10: warning: function returns address of local variable [-Wreturn-local-addr]

从内存角度解释：C 不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。
因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。
除非将其变量定义为 static 变量，static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。




========================================
|-- 函数指针与回调函数，及静态库和动态库的实现方法
----------------------------------------
1.函数指针是指向函数的指针变量。
通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。
函数指针可以像一般函数一样，用于调用函数、传递参数。

函数指针变量的声明：
typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型


例1： 函数指针
声明了函数指针变量 p，指向函数 max：

#include<stdio.h>
int max(int x, int y){
  return x>y?x:y;
}

int main(void){
  //*p是函数指针
  int (*p)(int ,int)= &max; // &可以省略
  int a,b,c,d;

  printf("请输入三个数字:");
  scanf("%d %d %d", &a, &b, &c);

  /* 与直接调用函数等价，d = max(max(a, b), c) */
  d=p( p(a,b), c);
  printf("最大的数字是: %d\n", d);

  return 0;
}
运行结果：
$ ./a12
请输入三个数字:23
34
56
最大的数字是: 56

或
$ ./a12
请输入三个数字:12 45 3
最大的数字是: 45



##
例2: 
我们首先定义了一个函数指针fuc ,这个函数指针的返回值为void型,然后我们给函数指针赋值，赋值为print,也就是print函数的首地址，此时fuc获得了print的地址，fuc的地址等于print的地址，所以最终调用fuc();也就相当于调用了print();

#include <stdio.h>
void print();
int main(void){
	void (*fuc)(); 
	fuc = print ; 
	fuc(); 	
} 
void print(){
	printf("hello world!\n");
}






2.函数指针作为某个函数的参数
函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。


(1)以下是来自知乎作者常溪玲的解说：
你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。


(2)百度的权威解释如下：
回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。


(3)来自Stack Overflow某位大神
简洁明了的表述：A "callback" is any function that is called by another function which takes the first function as a parameter。 
也就是说，函数 F1 调用函数 F2 的时候，函数 F1 通过参数给 函数 F2 传递了另外一个函数 F3 的指针，在函数 F2 执行的过程中，函数F2 调用了函数 F3，这个动作就叫做回调（Callback），而先被当做指针传入、后面又被回调的函数 F3 就是回调函数。




例1: 回调示例
#include<stdio.h>
#include<stdlib.h>

//A函数，其一个参数是指针函数。在其函数体中调用被传入的函数。
void populate_array(int *array, int arraySize, int (*getNextValue)(void)){
  for(int i=0; i<arraySize; i++){
    array[i]=getNextValue(); //要用传入的函数，否则传入函数指针就没有意义了
  }
}

//回调函数。B函数，符合上述指针函数的格式即可。
int getNextRandomValue(void){
  return rand();
}

//调用A函数，在其参数中传入B函数
int main(void){
  int myarray[5];
  populate_array(myarray, 5, getNextRandomValue);
  for(int i=0; i<5; i++){
    printf("arr[%d] = %d\t",i,myarray[i]);
  }
  printf("\n");
  return 0;
}
输出：
arr[0] = 1804289383     arr[1] = 846930886      arr[2] = 1681692777     arr[3] = 1714636915     arr[4] = 1957747793

调用者要先写好这个回调函数的实例。才能调用 回调函数。
回调函数A相当于制定规则的，但具体函数体、函数名、函数实现不细化，具体细则还得调用者自己实现(即回调函数的实现)。

简单说：函数参数里有函数指针，指针指向的是函数地址，不是变量地址。这样，函数就可以随便写，都可以用这个回调函数当一个参数来调用，多方便。程序通用性就更强了！

回调函数的好处和作用，就是解耦。









##
例2: 带参数的回调。我们再写一个求平方、立方的例子，只需要写函数，改变传入的函数即可。符合开闭原则。

如何添加参数？
并不是直接把int Handle(int (*Callback)()) 改成 int Handle(int (*Callback)(int)) 就可以的，而是通过另外增加一个参数来保存回调函数的参数值，像这里 int Handle(int y, int (*Callback)(int)) 的参数 y。


#include<stdio.h>
#include<stdlib.h>

//Handle函数A，其一个参数是指针函数。在其函数体中调用被传入的函数。
void populate_array(int *array, int arraySize, int (*getNextValue)(int)){
  for(int i=0; i<arraySize; i++){
    array[i]=getNextValue(i);
  }
}

//Callback 回调函数 返回平方。B函数，符合上述指针函数的格式即可。
int power2(int i){
  return i*i;
}
//回调函数 返回立方
int power3(int i){
  return i*i*i;
}


//调用A函数，在其参数中传入B函数
int main(void){
  int myarray[5];
  //传入平方函数
  populate_array(myarray, 5, power2);
  for(int i=0; i<5; i++){
    printf("%d, ",myarray[i]);
  }
  printf("\n");
  
  //换一个函数，立方函数
  populate_array(myarray, 5, power3);
  for(int i=0; i<5; i++){
    printf("%d, ",myarray[i]);
  }
  printf("\n");

  return 0;
}
输出结果： 
0, 1, 4, 9, 16, 
0, 1, 8, 27, 64,





例3: 库的实现方式。用于在回调函数中自定义运算规则。

#include<stdio.h>

//#include<softwareLib.h> // 包含Library Function所在读得Software library库的头文件
//本该在 Library 中的函数，用户知道怎么调用即可，无需知道内部细节。
int Handle(int a, int b, int (*operator)() ){
  //return (*operator)(a,b); //(*add_value)(a+b) 和直接运行 add_value(a+b) 结果相同。
  return operator(a,b);
}


//Callback Function 用户自定义实现的回调函数
int operator(); //可以不带参数的简单声明，在main后再定义
int operator2(int x, int y){ return x-y;}
int operator3(int x, int y){ return (x+y)*2;} //用户自定义函数
int operator4(int x, int y){ return x*x + y*y;}

int main(){
  int a=12,b=4;
  printf("Result of %d x?x %d = %d\n",a, b,  Handle(a,b, operator) );
  printf("Result of %d x?x %d = %d\n",a, b,  Handle(a,b, operator2) );
  printf("Result of %d x?x %d = %d\n",a, b,  Handle(a,b, operator3) );
  printf("Result of %d x?x %d = %d\n",a, b,  Handle(a,b, operator4) );
  return 0;
}

int operator(int x, int y){ return x+y;}

输出：
Result of 12 x?x 4 = 16
Result of 12 x?x 4 = 8
Result of 12 x?x 4 = 32
Result of 12 x?x 4 = 160


在回调中，主程序把回调函数像参数一样传入库函数。这样一来，只要我们改变传进库函数的参数，就可以实现不同的功能，这样有没有觉得很灵活？
并且丝毫不需要修改库函数的实现，这就是解耦。

再仔细看看，主函数和回调函数是在同一层的，而库函数在另外一层，想一想，如果库函数对我们不可见，我们修改不了库函数的实现，也就是说不能通过修改库函数让库函数调用普通函数那样实现，那我们就只能通过传入不同的回调函数了，这也就是在日常工作中常见的情况。


如果需要降低耦合度的时候，更应该使用回调函数。





refer:
C语言回调函数详解 https://www.cnblogs.com/jiangzhaowei/p/9129105.html
怎么使用回调函数制作libvendor.so文件: https://blog.csdn.net/morixinguan/article/details/65494239
静态库和动态库的使用和制作方法 https://blog.csdn.net/morixinguan/article/details/52451612







========================================
第6章 结构体
----------------------------------------
1. C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。



2. 定义结构
为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：
struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;

tag 是结构体标签。
member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。
variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：

struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;


在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例：

(1)无tag.
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//同时又声明了结构体变量s1
//这个结构体并没有标明其标签
struct 
{
    int a;
    char b;
    double c;
} s1;


(2) 无variable-list，后面可以单独声明变量名。
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//结构体的标签被命名为SIMPLE,没有声明变量
struct SIMPLE
{
    int a;
    char b;
    double c;
};
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3
struct SIMPLE t1, t2[20], *t3;


(3) 也可以用typedef创建新类型
typedef struct
{
    int a;
    char b;
    double c; 
} Simple2;
//现在可以用Simple2作为类型声明新的结构体变量
Simple2 u1, u2[20], *u3;


在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&s1，则是非法的。



结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。

(4)此结构体的声明包含了其他的结构体
struct COMPLEX
{
    char string[100];
    struct SIMPLE a;
};

(5)此结构体的声明包含了指向自己类型的指针
struct NODE
{
    char string[100];
    struct NODE *next_node;
};



如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：
(6)
struct B;    //对结构体B进行不完整声明

//结构体A中包含指向结构体B的指针
struct A
{
    struct B *partner;
    //other members;
};

//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明
struct B
{
    struct A *partner;
    //other members;
};







3. 结构体变量的初始化
和其它类型变量一样，对结构体变量可以在定义时指定初始值。

实例
#include<stdio.h>
struct Books
{
 char title[50];
 char author[50];
 char subject[100];
 int book_id;
} book = {"C 语言", "谭浩强","编程语言", 1002};

int main(){
 printf("title: %s\n", book.title);
 printf("author: %s\n", book.author);
 printf("subject: %s\n", book.subject);
 printf("book_id: %d\n", book.book_id);
}
输出:
title: C 语言
author: 谭浩强
subject: 编程语言
book_id: 1002






4.访问结构成员
为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 struct 关键字来定义结构类型的变量。

上个例子刚用过。再举一个例子。
#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;
 
 
   /* 输出 Book1 信息 */
   printf( "Book 1 title : %s\n", Book1.title);
   printf( "Book 1 author : %s\n", Book1.author);
   printf( "Book 1 subject : %s\n", Book1.subject);
   printf( "Book 1 book_id : %d\n", Book1.book_id);
 
   return 0;
}
输出： 
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407






5.结构作为函数参数
把结构作为函数参数，传参方式与其他类型的变量或指针类似。
#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
/* 函数声明 */
void printBook( struct Books book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;
 
   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;
 
   /* 输出 Book1 信息 */
   printBook( Book1 );
 
   /* 输出 Book2 信息 */
   printBook( Book2 );
 
   return 0;
}
void printBook( struct Books book )
{
   printf( "Book title : %s\n", book.title);
   printf( "Book author : %s\n", book.author);
   printf( "Book subject : %s\n", book.subject);
   printf( "Book book_id : %d\n", book.book_id);
}






6. 指向结构的指针
您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似： struct Books *struct_pointer;

现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面：
struct_pointer = &Book1;

为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符：struct_pointer->title;

让我们使用结构指针来重写上面的实例，
#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
/* 函数声明 */
void printBook( struct Books *book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;
 
   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;
 
   /* 通过传 Book1 的地址来输出 Book1 信息 */
   printBook( &Book1 );
 
   /* 通过传 Book2 的地址来输出 Book2 信息 */
   printBook( &Book2 );
 
   return 0;
}
void printBook( struct Books *book )
{
   printf( "Book title : %s\n", book->title);
   printf( "Book author : %s\n", book->author);
   printf( "Book subject : %s\n", book->subject);
   printf( "Book book_id : %d\n", book->book_id);
}








========================================
|-- 位域
----------------------------------------
1.
有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为"位域"或"位段"。

所谓"位域"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。

典型的实例：
- 用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。
- 读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。


位域的定义和位域变量的说明
位域定义与结构定义相仿，其形式为：
struct 位域结构名 
{
 位域列表
};

其中位域列表的形式为：类型说明符 位域名: 位域长度 

例如：
struct bs{
    int a:8;
    int b:2;
    int c:6;
}data;
说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。


让我们再来看一个实例：
struct packed_struct {
  unsigned int f1:1;
  unsigned int f2:1;
  unsigned int f3:1;
  unsigned int f4:1;
  unsigned int type:4;
  unsigned int my_int:9;
} pack;
在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。






2. 对于位域的定义尚有以下几点说明：
(1)一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：

struct bs{
    unsigned a:4;
    unsigned  :4;    /* 空域 */
    unsigned b:4;    /* 从下一单元开始存放 */
    unsigned c:4
}
在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。


(2)由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。


(3)位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：
struct k{
    int a:1;
    int  :2;    /* 该 2 位不能使用 */
    int b:3;
    int c:2;
};

从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。






3. 位域的使用
位域的使用和结构成员的使用相同，其一般形式为：
	位域变量名.位域名
	位域变量名->位域名

位域允许用各种格式输出。

#include<stdio.h>
int main(){
    struct bs{
        unsigned a:1;
        unsigned b:3;
        unsigned c:4;
    } bit,*pbit;
    bit.a=1;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.b=7;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.c=15;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    printf("%d,%d,%d\n",bit.a,bit.b,bit.c);    /* 以整型量格式输出三个域的内容 */
    pbit=&bit;    /* 把位域变量 bit 的地址送给指针变量 pbit */
    pbit->a=0;    /* 用指针方式给位域 a 重新赋值，赋为 0 */
    pbit->b&=3;    /* 使用了复合的位运算符 "&="，相当于：pbit->b=pbit->b&3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&011=011，十进制值为 3） */
    pbit->c|=1;    /* 使用了复合位运算符"|="，相当于：pbit->c=pbit->c|1，其结果为 15 */
    printf("%d,%d,%d\n",pbit->a,pbit->b,pbit->c);    /* 用指针方式输出了这三个域的值 */
	
	return 0;
}
输出： 
1,7,15
0,3,15


上例程序中定义了位域结构 bs，三个位域为 a、b、c。说明了 bs 类型的变量 bit 和指向 bs 类型的指针变量 pbit。这表示位域也是可以使用指针的。




例2： 
#include <stdio.h>
#include <string.h>
 
struct
{
  unsigned int age : 3;
} Age;
 
int main( )
{
   Age.age = 4;
   printf( "Sizeof( Age ) : %d\n", sizeof(Age) );
   printf( "Age.age : %d\n", Age.age );
 
   Age.age = 7;
   printf( "Age.age : %d\n", Age.age );
 
   Age.age = 8; // 二进制表示为 1000 有四位，超出
   printf( "Age.age : %d\n", Age.age );
 
   return 0;
}

当上面的代码被编译时，它会带有警告，当上面的代码被执行时，它会产生下列结果：
Sizeof( Age ) : 4
Age.age : 4
Age.age : 7
Age.age : 0







========================================
|-- 共用体
----------------------------------------
1. C 共用体
共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

定义共用体
为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：
union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];

union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：

union Data
{
   int i;
   float f;
   char  str[20];
} data;





2.
现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。

共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：

实例
#include <stdio.h>
#include <string.h>
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        
 
   printf( "Memory size occupied by data : %d\n", sizeof(data));
 
   return 0;
}

当上面的代码被编译和执行时，它会产生下列结果：
Memory size occupied by data : 20






3. 访问共用体成员
为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 union 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法：

例1：
#include <stdio.h>
#include <string.h>
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        
 
   data.i = 10;
   data.f = 220.5;
   strcpy( data.str, "C Programming");
 
   printf( "data.i : %d\n", data.i);
   printf( "data.f : %f\n", data.f);
   printf( "data.str : %s\n", data.str);
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：
data.i : 1917853763
data.f : 4122360580327794860452759994368.000000
data.str : C Programming

在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。




例2：
#include <stdio.h>
#include <string.h>
 
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main( )
{
   union Data data;        
 
   data.i = 10;
   printf( "data.i : %d\n", data.i);
   
   data.f = 220.5;
   printf( "data.f : %f\n", data.f);
   
   strcpy( data.str, "C Programming");
   printf( "data.str : %s\n", data.str);
 
   return 0;
}
当上面的代码被编译和执行时，它会产生下列结果：
data.i : 10
data.f : 220.500000
data.str : C Programming

在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。



========================================
|-- 枚举类型 //todo
----------------------------------------
https://blog.csdn.net/coder_pig/article/details/78252898


========================================
|-- typedef 关键字 //todo
----------------------------------------






========================================
第7章 文件IO(输入与输出)
----------------------------------------
https://blog.csdn.net/coder_pig/article/details/78262020

C系统在处理文本文件或二进制文件时，并不区分类型，都看成是字符流，按字节进行处理。 

输入输出字符流的开始和结束只由程序控制而不受物理符号(如回车符)的控制。 因此也把这种文件称作“流式文件”。 本章讨论流式文件的打开、关闭、读、写、 定位等各种操作。

在Ｃ语言中用一个指针变量指向一个文件，这个指针称为文件指针。通过文件指针就可对它所指的文件进行各种操作。
FILE *指针变量标识符；



========================================
第8章 UNIX系统接口
----------------------------------------



========================================
|-- C socket API
----------------------------------------
https://baijiahao.baidu.com/s?id=1671370288734495212&wfr=spider&for=pc




========================================
附录A参考手册
----------------------------------------

========================================
附录B标准库
----------------------------------------

========================================
附录C变更小结
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------
