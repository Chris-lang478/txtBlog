c102-adv: c语言的高级话题


多文件编译
	命令行参数


指针
	数组：指针与数组是重点、难点
	结构体
	函数参数接收指针
	函数作为指针传给函数



高层应用
	linux 嵌入式开发
	linux 小工具开发
	linux 网络程序开发




========================================
编译、调试小技巧、参考资料
----------------------------------------

1. 编译技巧

(1) 在gcc下用到数学函数 Math.h ，如sqrt。在gcc时要加上 -lm 参数，这样告诉编译器我要用到数学函数了 。
如：
gcc a.c -o a -lm

对于非标准库，是否都需要-l参数说明呢？
$ gcc  multi_thread.c -lpthread #引入多线程库 -l pthread




(2) gcc加上 -Wall参数，则显示全部警告，并可能有编译产出。
比如有未使用的变量。

$ cat p75.c 
// 使用 -Wall 参数编译
#include <stdio.h>
int main(){
	int i=10;
	int j;
	printf("hello\n");
	return 0;
}

$ gcc -Wall p75.c 
p75.c: In function ‘main’:
p75.c:5:6: warning: unused variable ‘j’ [-Wunused-variable]
  int j;
      ^
p75.c:4:6: warning: unused variable ‘i’ [-Wunused-variable]
  int i=10;
      ^

(3) 如果使用 -Werror 参数，则把warning都认为是error
有error就不会有编译产出。

$ gcc -Wall -Werror p75.c 
p75.c: In function ‘main’:
p75.c:5:6: error: unused variable ‘j’ [-Werror=unused-variable]
  int j;
      ^
p75.c:4:6: error: unused variable ‘i’ [-Werror=unused-variable]
  int i=10;
      ^
cc1: all warnings being treated as errors










2. gdb 调试技巧

(1) 带有命令行参数
进入gdb调试：
gcc -g -Wall httpTest.c -o test    生成了可调试文件
gdb test                                        进入调试

下面可以使用两种方法输入命令行参数
1) run  命令行参数
2) set args  命令行参数

如：我的程序中需要输入的时服务器端ip地址，可以通过以下两种方法输入
1) 如果直接运行程序，run  www.baidu.com
2) set  args www.baidu.com,后面再继续进行调试




(2) 设置断点

如果想跳过某一个for循环，则可以把断点设置在for循环之后的那一行。

比如在12行断点
> b 12
> start //然后从头运行，停在第12行







3. 更多高级的C项目
https://github.com/Ewenwan/ShiYanLou/blob/master/README.md

(1) Tinyhttpd
tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，
附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。
项目主页: http://sourceforge.net/projects/tinyhttpd/


(2) cJSON
cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。
cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。
其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。
项目主页: http://sourceforge.net/projects/cjson/

(3) Libev
libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。
其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。
基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。
项目主页: http://software.schmorp.de/pkg/libev.html


(4) Memcached
Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。
它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。
Memcached 基于一个存储键/值对的 hashmap。
Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。
项目主页: http://memcached.org/

(5) Lua
Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。
让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。
在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。
Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。
项目主页: http://www.lua.org/


(6) SQLite
SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 
其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。
项目主页: http://www.sqlite.org/ 。


(7) UNIX v6
UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。
有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。
看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？

另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。
就算不是初学者，想完全理解全部代码基本上也是不可能的。
项目主页: http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6





4. 其他资料

https://github.com/Ewenwan/ShiYanLou












========================================
多文件联合编译：同时编译、预编译
----------------------------------------
1. 场景: 对于大文件，可以分开编译，以便节省编译时间。

(1) 一个简单的例子: 求2个数的最大值。
$ cat 03_max.c
int max(int a, int b){
  if(a>b) return a;
  else return b;
}

仅编译, 加-c 选项
$ gcc -c 03_max.c -o max.o


(2) 编译主文件
$ cat 03_multiple_files.c 
#include<stdio.h>
// 多文件分别编译
//#include "02_max.c"

//声明函数，否则会报 警告
int max(int a, int b);

int main(){
  printf("the max is:%d\n", max(10, 20));
}

$ gcc max.o 03_multiple_files.c -o main.out
$ ./main.out 
the max is:20


(3) 可能还有更多的函数，比如 
$ cat 03_min.c
int min(int a, int b){
  if(a<b) return a;
  else return b;
}

仅编译, 加-c 选项
$ gcc -c 03_min.c -o min.o


ii)修改主函数，加入新功能
$ cat 03_multiple_files-v2.c 
#include<stdio.h>
//声明函数
int max(int a, int b);
int min(int a, int b);

int main(){
  int a=10, b=200;
  printf("the max is:%d\n", max(a, b));
  printf("the min is:%d\n", min(a, b));
}

组合编译
$ gcc max.o min.o 03_multiple_files-v2.c -o main_v2.out

$ ./main_v2.out 
the max is:200
the min is:10




(4) 最佳实践，就是把常用的函数编译成静态资源库 xx.o，作为工具库。
把经常变化的部分单独写，编译时联合编译，以便节省时间。

上面的例子看不出时间差异，因为函数太简单。
实际项目的重头编译通常需要好几个小时，甚至好几天，预编译会大大缩短编译时间。



(5) 头文件和函数定义分离：头文件公开，函数定义则编译后保密。

可以模仿系统文件 stdio.h 做法，把前面的函数声明放到一个单独的 .h 文件中。
新建2个新文件，和 .o 同名。
$ cat max.h 
int max(int a, int b);

$ cat min.h 
int min(int a, int b);


$ cat 03_multiple_files-v3.c 
#include<stdio.h>
#include "max.h"
#include "min.h"

int main(){
  int a=10, b=200;
  printf("the max is:%d\n", max(a, b));
  printf("the min is:%d\n", min(a, b));
}

$ gcc max.o min.o 03_multiple_files-v3.c -o main_v3.out

$ ./main_v3.out 
the max is:200
the min is:10







========================================
|-- Makefile 的编写和使用：多文件自动化编译
----------------------------------------
1. 像上面只有2个函数文件，gcc 命令已经很长了。
每次变动都需要重新编译，光输编译命令就很费劲了。有没有自动化的工具？
这就是make 命令，虽然它内部也是使用 gcc 的。

$ make -v
GNU Make 4.1
Built for x86_64-pc-linux-gnu
Copyright (C) 1988-2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.




2. 定义配置文件 Makefile。
要告诉 make 要生成什么文件，依赖哪些源码文件，这些都定义在配置文件中。

先删掉 .o 和 .out 文件： 
$ rm *.o
$ rm *.out

要求：
 - 文件名只能是 Makefile 或者 makefile。如果是其他名字，需要使用参数 -f fileName
	$ make -f makefile2 
 - 第二行的命令前是一个tab键，linux下是6个空格的位置。如果不是有可能报错。



$ cat Makefile
# this is make file
# 冒号前是最终的目标文件，冒号后是依赖文件
# tab键，后面是要执行的命令
main_v3.out: max.o min.o 03_multiple_files-v3.c
	gcc max.o min.o 03_multiple_files-v3.c -o main_v3.out

# 然后是依赖文件怎么生成的
max.o: 03_max.c
	gcc -c 03_max.c -o max.o
min.o: 03_min.c
	gcc -c 03_min.c -o min.o

执行编译 
$ make 
gcc -c 03_max.c -o max.o
gcc -c 03_min.c -o min.o
gcc max.o min.o 03_multiple_files-v3.c -o main_v3.out


测试效果 
$ ./main_v3.out 
the max is:200
the min is:10


(2) 如果依赖文件已经有了，则自动跳过其生成步骤
$ cat Makefile
# 修改第一行，生成 a.out 文件
a.out: max.o min.o 03_multiple_files-v3.c
	gcc max.o min.o 03_multiple_files-v3.c -o a.out

max.o: 03_max.c
	gcc -c 03_max.c -o max.o
min.o: 03_min.c
	gcc -c 03_min.c -o min.o


再编译时，已经有的中间文件就直接用了。
$ make 
gcc max.o min.o 03_multiple_files-v3.c -o a.out


再次编译，则提示已经是最新版了。
$ make
make: 'a.out' is up to date.


如果修改源文件，把其中一个数字添加负号，则改动后的文件重新编译。
$ vim 03_multiple_files-v3.c
$ make 
gcc max.o min.o 03_multiple_files-v3.c -o a.out

$ ./a.out 
the max is:10
the min is:-200


也就是使用 Makefile 的好处是，
	- 以后不需要写那些麻烦的命令了。
	- 编译时，会检查时间戳(我猜测的)，如果没有修改过，则不再编译。







3. 设置其他目标

(1) 在文件末尾加上: 

clean:
    rm -f *.out && rm -f *.o


执行的时候写上，则自动执行第二行语句，清除中间文件。
$ make clean


(2) 按照这个规律，你还可以添加更多自定义子命令。

可以使用“make all”来编译所有的程序。当然也可以使用“make 程序名”来单独编译某一个文件。

既然make可以指定所有Makefile中的目标，那么也包括“伪目标”。我们可以根据这种性质来让我们的Makefile根据指定的不同目标来完成不同的任务。

通常情况下参考linux源码的Makefile规则来书写我们的Makefile中的目标。

“all”—— 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。

“clean” —— 这个伪目标功能是删除所有被make创建的文件。

“install” —— 这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。

“print” —— 这个伪目标的功能是例出改变过的源文件。

“tar” —— 这个伪目标功能是把源程序打包备份。也就是一个tar文件。

“dist” —— 这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件，或是gz文件。

“TAGS” —— 这个伪目标功能是更新所有的目标，以备完整地重编译使用。

“check”和“test” —— 这两个伪目标一般用来测试makefile的流程。

上述的这些伪目标都是GNU开源软件定义和采用的，为了规范和统一，我们如果编写Makefile时也尽量使用上述的关键字命名目标。




ref:
https://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:make%E8%BF%90%E8%A1%8C






========================================
Linux 下的 C语言
----------------------------------------



========================================
|-- main 函数中的 return 与 错误码
----------------------------------------
1. main 函数的完整形式

$ cat 04_hello.c
#include <stdio.h>
int main(int argc, char* argv[]){
	printf("Hello, world!\n");
	return 0;
}

编译并执行

$ gcc 04_hello.c -o 04.out && ./04.out
Hello, world!


linux 是怎么判断 && 前的命令执行结束了呢？就是看返回值0。
如果返回值不是0，则是报错。


最后一条执行的返回值是0，就是我们编译好的C程序的返回值。
$ echo $?
0



2. 返回其他错误码

(1) 比如返回 101 
场景：合并另个字符串，如果输入的字符串小于2个，则报错 101 

$ cat 05_return_101.c
#include <stdio.h>
#include<string.h>
int main(int argc, char* argv[]){
	if(argc<3){
		return 101;
	}
	printf("input: |%s|, |%s|\n", argv[1],  *(argv+2));

	char c1[10], c2[10];
	strcpy(c1, argv[1]);
	strcpy(c2, argv[2]);
	printf("c1=|%s|, c2=|%s|\n", c1, c2);

	strcat(c1, c2);
	printf("combined: '%s'\n", c1);
	return 0;
}

不提供参数时:
$ ./a.out 
$ echo $? # 前一个命令的返回值
101

$ ./a.out && echo "OK" # 前一个不返回0，则&&后不能连续执行
$


再试试提供2个参数时
$ ./a.out this Dog
input: |this|, |Dog|
c1=|this|, c2=|Dog|
combined: 'thisDog'
$ echo $?
0

$ ./a.out this Cat && echo "OK" 
input: |this|, |Cat|
c1=|this|, c2=|Cat|
combined: 'thisCat'
OK


ref:https://www.imooc.com/video/6207




========================================
|-- 命令行参数 int main(int argc, int* argv[]);
----------------------------------------


1. 使用场景
执行程序时，可以从命令行传值给 C 程序。
这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。



2. 实现方式

命令行参数是使用 main() 函数参数来处理的，其中，
- argc 是指传入参数的个数，
- argv[] 是一个指针数组，指向传递给程序的每个参数。

下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：


#include <stdio.h>
int main(int argc, char *argv[]){
	for(int i=0; i<argc; i++){
		printf("input paras[%d]=%s\n", i, *(argv+i) );
		//printf("input paras[%d]=%s | %s\n", i, *(argv+i), argv[i]);
	}
	return 0;
}

输出结果:
$ ./a.out some times
input paras[0]=./a.out
input paras[1]=some
input paras[2]=times

第0个参数是脚本本身，后面是其余的参数。
为了获得用户传入的参数，可以从下标1开始。



如果传入带空格的字符串呢？用引号隔开
$ ./a.out some times "a book"
input paras[0]=./a.out | ./a.out
input paras[1]=some | some
input paras[2]=times | times
input paras[3]=a book | a book






========================================
|-- 标准输入输出流及错误流(stdin/stdout/stderr) 与 重定向
----------------------------------------

1. linux 基本概念

stdin  0  默认是键盘
stdout  1  默认是显示器终端
stderr  2  



2. C语言示例

(1) 常见形式
$ cat 06_cio.c
#include<stdio.h>
int main(){
	int a;
	printf("input a number:");
	scanf("%d", &a);
	printf("hello world! you input: %d\n", a);
	return 0;
}

运行后，系统会自动提供一个指针，指向标准输出流。


(2) 手动指定输出设备
$ cat 07_cio_stdout.c
#include<stdio.h>
int main(){
	//fprintf(fp, "xx %c $d", char1, 20);
	fprintf(stdout, "please input a %s:\n", "number");
	// 等同于 
	printf("please input a %s:\n", "number");
	
	int a;
	//scanf("%d", &a);
	// 等价于
	//fscanf(fp,"%s%s%s%s%s%s",&c1,&c2,&c3,&c4,&c5,&c6);
	fscanf(stdin, "%d", &a);
	printf("your input is %d\n", a);
	
	//错误流，记着返回一个非0整数。
	if(a<0){
		fprintf(stderr, "the value must be positive! But you input %d\n", a);
		return 1;
	}
		
	return 0;
}


测试
$ ./a.out
please input a number:
please input a number:
-12
your input is -12
the value must be positive! But you input -12

$ echo $?
1


(3) 尝试重定向 1(默认) 也就是标准输出流 到文件。
$ ./a.out >1.log #是一样的效果，重定向左侧默认是1.
$ ./a.out 1>1.log
20

$ cat 1.log 
please input a number:
please input a number:
your input is 20
发现两个输出方式printf(), fprintf()，都重定向到了文件。


ii) 也可以使用追加模式，这样每次新增的内容都在最后，老内容不被覆盖。
$ ./a.out >>1.log
1
$ cat 1.log 
please input a number:
please input a number:
your input is 20
please input a number:
please input a number:
your input is 1



(4) 尝试重定向 2 也就是标注错误流 到文件 
$ ./a.out 1>1.log 2>err.log
-10

$ cat err.log
the value must be positive! But you input -10


(5) 输入 重定向：使用文件输入数字，而不是键盘
$ cat num.log
11
$ ./a.out <num.log
please input a number:
please input a number:
your input is 11


(6) 3个设备全部重定向到文件
$ ./a.out 1>1.log 2>err.log <num.log
没有报错。


尝试输入一个不存在的文件
$ ./a.out 1>1.log 2>err.log <num2.log
$ cat err.log 
-bash: num2.log: No such file or directory





========================================
|-- C语言与 管道 |
----------------------------------------

1. linux 示例

$ ls /etc/ | grep ab
anacrontab
crontab
crypttab
fstab
mtab

前一个命令的输出，作为下一个命令的输入，这个起连接作用的就是管道。




2. 给出任意多个整数，求平均值。
(1) 输入总数，n，求平均数
$ cat 08_mean.c
#include<stdio.h>
int main(){
	int sum, n;
	//printf("please input sum,n:");
	scanf("%d,%d", &sum, &n);
	if(n<=0){
		fprintf(stderr, "Error: N>0\n");
		return 1;
	}
	float mean=sum/n;
	//printf("sum=%d, n=%d, mean=%f\n", sum, n, mean);
	printf("%f", mean);
	return 0;
}

$ gcc 08_mean.c -o mean.out
$ ./mean.out 
80,5 回车
16.000000




(2) 接收用户的输入，求总数和n
$ cat 08_count.c 
#include<stdio.h>
int main(){
	int flag=1;
	int i;
	int count=0;
	int sum=0;
	while(flag){
		scanf("%d", &i);
		if(0==i) break; //输入0则停止
		count++;
		sum+=i;
	}
	printf("%d,%d", sum, count);
	return 0;
}

$ gcc 08_count.c -o count.out
$ ./count.out 
1
2
3
0
6,3


(3) 两个连起来使用

$ ./count.out | ./mean.out
$ ./count.out | ./mean.out
10
20
0
15.000000




========================================
GNU symbolic debugger,简称「GDB 调试器」
----------------------------------------
1. GDB工具简介

(1)gdb是GNU开源组织发布的一个强大的Linux下的程序调试工具。

一般来说，GDB主要帮助你完成下面四个方面的功能：
- 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。
- 可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）
- 当程序被停住时，可以检查此时你的程序中所发生的事。
- 你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。

(2) GDB调试一定要是可执行文件而不是.c文件
要用gcc进行编译，具体的命令如下：
$ gcc -g -O0 源文件.c -o 输出的目标文件

参数解释：
-g,-O参数缺一不可
加上-g 选项，会保留代码的文字信息，便于调试。
-O0 就是不做编译优化。
	比如没使用的变量，编译器优化后直接删掉了，不在内存中初始化。



加上-g选项以后，gcc在编译是会做以下额外的操作：
- 创建符号表，符号表包含了程序中使用的变量名称的列表。
- 关闭所有的优化机制，以便程序执行过程中严格按照原来的C代码进行。


(3) Ubuntu 默认已经安装了
$ gdb --version
GNU gdb (Ubuntu 8.2-0ubuntu1~18.04) 8.2
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.





2. 尝试使用 gdb 调试程序

(1) 交换值：失败版本
$ cat 01_swap.c 
#include<stdio.h>
void swap(int x, int y){
  int tmp=x;
  x=y;
  y=x;
  printf("in swap(): a=%d, b=%d\n", x,y);
}

int main(){
  int a=10, b=20;
  printf("a=%d, b=%d\n", a,b);
  swap(a, b);
  printf("a=%d, b=%d\n", a,b);
  return 0;
}


2) 编译与执行
$ gcc -g 01_swap.c -o 01_swap.out

$ ./01_swap.out 
a=10, b=20
in swap(): a=20, b=10
a=10, b=20


3) gdb运行
$ gdb 01_swap.out

l 或 list 列出源代码，再按回车，继续显示
(gdb) l
11        printf("a=%d, b=%d\n", a,b);
12        swap(a, b);
13        printf("a=%d, b=%d\n", a,b);
14        return 0;
15      }

单步调试: 
(gdb) start

查看变量值，p, print:
(gdb) p b
$2 = 0

执行下一行
(gdb) n
输出下一行的行号和内容。

查看变量值，p, print:
(gdb) p b
$4 = 20

(gdb) n
a=10, b=20   ## 这有实参的值
12        swap(a, b);
到函数这一行了，查看函数内部，使用s 
(gdb) s
swap (x=10, y=20) at 01_swap.c:3  #这是形参的值
3         int tmp=x;

查看堆栈，有2个编号，目前是最上面的有效
(gdb) bt
#0  swap (x=20, y=20) at 01_swap.c:5
#1  0x00005555555546c4 in main () at 01_swap.c:12

切换到主函数，主函数还在第12行没动。
(gdb) f 1
#1  0x00005555555546c4 in main () at 01_swap.c:12
12        swap(a, b);

在这里检查变量
(gdb) p a
$7 = 10
(gdb) p b
$8 = 20

这时，子函数中的变量是不能访问的
(gdb) p x
No symbol "x" in current context.

切换回子函数，子函数执行到5行了(第5行还没有执行)
(gdb) bt
#0  swap (x=20, y=20) at 01_swap.c:5
#1  0x00005555555546c4 in main () at 01_swap.c:12
(gdb) f 0
#0  swap (x=20, y=20) at 01_swap.c:5
5         y=tmp;
(gdb) p x
$9 = 20
(gdb) p y
$10 = 20

还可以查看变量的地址
(gdb) p &x
$11 = (int *) 0x7fffffffdd3c


退出 
(gdb) q





(2) 交换值，使用指针：成功的版本
$ cat 01_swap2.c 
#include<stdio.h>
void swap(int* x, int* y){
  int tmp=*x;
  *x=*y;
  *y=tmp;
  printf("in swap(): a=%d, b=%d\n", *x,*y);
}

int main(){
  int a=10, b=20;
  printf("a=%d, b=%d\n", a,b);
  swap(&a, &b);
  printf("a=%d, b=%d\n", a,b);
  return 0;
}

编译执行，成功交换了值
$ gcc -g 01_swap2.c -o 01_swap2.out
$ ./01_swap2.out 
a=10, b=20
in swap(): a=20, b=10
a=20, b=10





2) 使用 gdb 调试
$ gdb 01_swap2.out
(gdb) start

多次输入 next ，直到执行到函数
(gdb) n
a=10, b=20
12        swap(&a, &b);


进入子函数内部s，发现传递的确实是指针。指针相差4个字节，就是int类型的sizeof。
(gdb) s
swap (x=0x7fffffffdd60, y=0x7fffffffdd64) at 01_swap2.c:3
3         int tmp=*x;

(gdb) p x
$3 = (int *) 0x7fffffffdd60
(gdb) p *x
$5 = 10

回到主函数
(gdb) bt
#0  swap (x=0x7fffffffdd60, y=0x7fffffffdd64) at 01_swap2.c:3
#1  0x000055555555474b in main () at 01_swap2.c:12
(gdb) f 1
#1  0x000055555555474b in main () at 01_swap2.c:12
12        swap(&a, &b);

查看变量 a的地址 == 子函数中的指针x。也就是他们指向的是同一个内存块。
(gdb) p a
$6 = 10
(gdb) p &a
$7 = (int *) 0x7fffffffdd60


回到子函数
(gdb) f 0
#0  swap (x=0x7fffffffdd60, y=0x7fffffffdd64) at 01_swap2.c:3
3         int tmp=*x;
执行到交换值后
(gdb) n
5         *y=tmp;
(gdb) n
6         printf("in swap(): a=%d, b=%d\n", *x,*y);

(gdb) p *x
$8 = 20
(gdb) p *y
$9 = 10

回到主函数，检查变量，发现也交换过了。
(gdb) f 1
#1  0x000055555555474b in main () at 01_swap2.c:12
12        swap(&a, &b);
(gdb) p a
$10 = 20
(gdb) p b
$11 = 10








3. GDB常用的调试命令
一大波命令来袭，hold,或者jump
（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h
（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r
（gdb）start：单步执行，运行程序，停在第一执行语句
（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l
（gdb）set：设置变量的值
（gdb）next：单步调试（逐过程，函数直接执行）,简写n
（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s
（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt
（gdb）frame：切换函数的栈帧,简写f
（gdb）info：查看函数内部局部变量的数值,简写i
（gdb）finish：结束当前函数，返回到函数调用点
（gdb）continue：继续运行,简写c
（gdb）print：打印值及地址,简写p
（gdb）quit：退出gdb,简写q
（gdb）break+num：在第num行设置断点,简写b
（gdb）info breakpoints：查看当前设置的所有断点
（gdb）delete breakpoints num：删除第num个断点,简写d
（gdb）display：追踪查看具体变量值
（gdb）undisplay：取消追踪观察变量
（gdb）watch：被设置观察点的变量发生修改时，打印显示
（gdb）i watch：显示观察点
（gdb）enable breakpoints：启用断点
（gdb）disable breakpoints：禁用断点
（gdb）x：查看内存x/20xw 显示20个单元，16进制，4字节每单元
（gdb）run argv[1] argv[2]：调试时命令行传参



(1)函数的调用

call name 调用和执行一个函数

(gdb) call rect(2,3)
$12 = 6


(2) 按地址打印值
(gdb) p *0x7fffffffdd50
$19 = 3


(3) 内存各部分的起始位置在哪里？

有一组专用的gdb变量可以用来检查和修改计算机的通用寄存器，gdb提供了目前每一台计算机中实际使用的4个寄存器的标准名字：
$pc ： 程序计数器
$fp ： 帧指针（当前堆栈帧）
$sp ： 栈指针
$ps ： 处理器状态

测试: 
(gdb) p $pc
$18 = (void (*)()) 0x5555555546dc <rect+50>
(gdb) p $fp
$19 = (void *) 0x7fffffffdd08
(gdb) p $sp
$20 = (void *) 0x7fffffffdd08
(gdb) p $ps
$21 = [ PF IF ]


(4) 你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：

x/

n、f、u是可选的参数。

n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。
u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。
  u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。
  当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。

表示一个内存地址。

n/f/u三个参数可以一起使用。例如：

命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。






## 查看栈内存起始地址
(gdb) p $sp  
$7 = (void *) 0x7fffffffdd08

## 打印栈开始的前40个字(160个字节)
(gdb) x/40x $sp
0x7fffffffdd08: 0xffffdd30      0x00007fff      0x55554719      0x00005555
0x7fffffffdd18: 0x756e6547      0x00000003      0x00000009      0x00000000
0x7fffffffdd28: 0xf7dd7660      0x00007fff      0xffffdd80      0x00007fff
0x7fffffffdd38: 0x55554777      0x00005555      0x00000001      0x00000000
0x7fffffffdd48: 0x555547fd      0x00000003      0x00000004      0x00007fff
0x7fffffffdd58: 0xffffdd4c      0x00007fff      0xffffdd50      0x00007fff
0x7fffffffdd68: 0x55755014      0x00005555      0x555546e1      0x00005555
0x7fffffffdd78: 0x88589500      0xa161f7f7      0x555547b0      0x00005555
0x7fffffffdd88: 0xf7a05b97      0x00007fff      0x00000001      0x00000000
0x7fffffffdd98: 0xffffde68      0x00007fff      0x00008000      0x00000001











以上就是GDB的命令其中的部分，下面列详细写一些基础常用的命令：
 **list **
list 可写为l,可以列出所调试程序的代码

list+linenumber 可以列出linenumber附近的代码
$ list 20

list function 可以列出函数上下文的源程序



run & quit
在GDB中如何将程序运行起来，此时只要输入run命令,就可以将命令跑起来
而quit则是退出GDB调试
break




(1)GDB查看，执行汇编语言
查看汇编 disassemble

下面就是查看的汇编代码




ref:
https://blog.csdn.net/awm_kar98/article/details/82840811
https://blog.csdn.net/lxb_champagne/article/details/5282316






========================================
|-- 内存管理：堆内存、栈内存的差异，静态变量、局部变量
----------------------------------------
1. 计算机中数据表示方法
计算机使用二进制，电路只有通电、不通电2个状态。
	而二进制写出来又太长，所以经常使用16进制打印，比如内存地址。
	2进制和16进制的转换很方便，就是4位2进制->压缩到1位16进制。
人类使用的是十进制，因为人有十个手指头。




2. 内存管理概述

(1) 计算机内存

1 byte = 8 bits;
字节(Byte)是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位(8-bits)。

字符(Character)计算机中使用的字母、数字、字和符号，比如'A'、'B'、'$'、'&'等。
一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。


8 bit = 1B (1 byte 1个字节)  一个字节存放8个二进制位的数据。
1024 byte=1K =2**10
1024 K=1M    =2**20
1024 M=1G    =2**30
1024 G=1T    =2**40
1024 T=1PB   =2**50
1024 P=1EB   =2**60

32位操作系统只能识别4G内存，为什么？
因为地址总线是32位，也就是寻址空间是32位。
	32位指的是：给内存编号只能编到32个二进制位。
	32根地址总线就有2**32个状态：(2**10)*(2**10)*(2**10)*(2**2)=4*k*k*k=4*k*M=4G;
		2**32/1e9=4.294967296

那么 64 位操作系统最多支持多少内存呢？
	头疼 2**64=(2**10)*(2**10)*(2**10)*(2**10)*(2**10)*(2**10)*(2**4)=16KKKKKK=16KKKG=16GG=16x10**18
		2**64/1e18=18.446744073709553
		也即是说 16KMG=16MT 的内存条，远超过了我们市面上能买到的内存总数。
	4位二进制对应一个16进制位，所以64位的内存地址，写成16进制是16位，从0-9a-f。
	0x开头，从最低的 16个0，到最高的16个f。








(2) linux 内存

根据Linux内核相关文档描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。
所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）

用户使用的是后32位，也就是8个16进制位。
其他是操作系统使用的。
内存按照大部分分为
- 系统内核 Kernal Space
- Unused 自由可分配内存。
- User space
	- Stack 栈
	- Mapping Area
	- Heap 堆
	- BSS 
	- data 数据段：定义的 const 常量，全局变量。内存编号大于 代码段。
	- code 代码段：源代码。编号处于低位。


对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：
Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）
Data：这里存放的是初始化过的全局变量
BSS：这里存放的是未初始化的全局变量
Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存
Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长
Stack：这是栈区域，自高地址向低地址增长


一般来说，malloc所申请的内存主要从Heap区域分配





(3) 页与地址构成
在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。

所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下
********页号(52bit)******| 偏移(12bit)
           *页号(20bit)**| 偏移(12bit)
		   
上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内便宜都是用低12位表示，而剩下的高地址表示页号。


ref: https://www.cnblogs.com/Commence/p/5785912.html










(100) 我测试的，64位ubuntu，指针占了8位，为什么不是16位?
#include<stdio.h>
int main(){
  int *p, i=100;
  p=&i;
  printf("i=%d, p=%p, len(p)=%ld\n", *p, p, sizeof(p));
}

$ ./a.out 
i=100, p=0x7ffd91c7b4ac, len(p)=8



指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，
譬如以前是16位地址，指针即为2个字节，
现在一般是32位系统，所以是4个字节，
以后64位，则就为8个字节。










3. 看一下C语言的各个组分都保存在内存内的什么位置。

(1) 实例代码
$ cat 02_mem.c 
//求正方形、长方形面积
//为了检查各个变量在内存中的位置，加入很多无关变量。
#include<stdio.h>

int global =0;
int rect(int a, int b){
	static int count=0;
	count++;
	global++;
	int s=a*b;
	return s;
}

int square(int a){
	static int count =0;
	count++;
	global++;
	int s=rect(a, a);
	return s;
}

int main(){
	int a=3, b=4;
	int *pa=&a, *pb=&b;
	int *pglobal=&global;
	int (*psquare)(int a)=&square;
	int s=(*psquare)(a);
	printf("%d\n", s);
}

$ gcc -g 02_mem.c
$ ./a.out
9



(2) gdb 调试 

$ gdb a.out
(gdb) start
Temporary breakpoint 1 at 0x729: file 02_mem.c, line 22.
Starting program: /data/wangjl/test/C/a.out 

Temporary breakpoint 1, main () at 02_mem.c:22
22      int main(){


当按几下next时，可以看到代码，这就是内存中的代码段，
不过，C语言语法不允许直接操作代码段。
(gdb) n
25              int *pglobal=&global;

(gdb) n
28              printf("%d\n", s);


除了代码编译后存在代码段以外，
- 当前调用了哪个函数呢？
- 当前调用的函数运行到多少行？
- 并且这个函数中有哪些变量，这些变量的值是什么？
这些信息都记录在栈中。栈是内存中的编号比较高的位置。

(gdb) p a
$1 = 3
(gdb) p &a
$3 = (int *) 0x7fffffffdd4c
(gdb) p pa
$2 = (int *) 0x7fffffffdd4c
## 变量名只是一个代号。变量的本质就是内存。


(gdb) p &pa ## 指向指针的指针
$4 = (int **) 0x7fffffffdd58
(gdb) p *(&pa)  ## 指向变量的指针
$5 = (int *) 0x7fffffffdd4c
(gdb) p **(&pa)
$6 = 3
(gdb) p *pa
$7 = 3

C语言中所有的变量都是有类型的。
int 类型保存整数。
指针保存的就是内存地址。
指针的本质就是地址。





(3) 代码段：保存函数，编号最小。
我们比较一下各种变量的内存编号的大小

(gdb) p &rect
$8 = (int (*)(int, int)) 0x5555555546aa <rect>
(gdb) p &square
$9 = (int (*)(int)) 0x5555555546e1 <square>
(gdb) p &main
$10 = (int (*)()) 0x555555554721 <main>

说明函数加载顺序：先加载的 main，然后是 rect，最后是 square。
而连续加载的函数内存编号相减，就是上一个占用的内存空间。





(4) 数据段：全局变量、常量 

(gdb) p &global
$12 = (int *) 0x555555755014 <global>

这个比代码段要大，说明 数据段 在 代码段 之上。


按照变量声明的顺序查看其地址
(gdb) list
23              int a=3, b=4;
24              int *pa=&a, *pb=&b;
25              int *pglobal=&global;
26              int (*psquare)(int a)=&square;
27              int s=(*psquare)(a);
28              printf("%d\n", s);
29      }

(gdb) p &a
$13 = (int *) 0x7fffffffdd4c
(gdb) p &b
$14 = (int *) 0x7fffffffdd50
(gdb) p &pa
$15 = (int **) 0x7fffffffdd58
(gdb) p &pb
$16 = (int **) 0x7fffffffdd60
(gdb) p &pglobal
$21 = (int **) 0x7fffffffdd68
(gdb) p &psquare
$22 = (int (**)(int)) 0x7fffffffdd70

(gdb) p psquare  ##这是指向函数的指针
$17 = (int (*)(int)) 0x5555555546e1 <square>

(gdb) p &s
$19 = (int *) 0x7fffffffdd54

(gdb) q
退出。

可见a占4位，首地址加4就是b的地址。
中间间隔4，why? 往后找 变量s在这4位上。可能是C语言编译时优化了，把相同类型的变量放一起声明。
然后声明的指针变量 pa，pb，pglobal，psquare，保存的地址，其本身的内存地址各占8字节。





(5) 栈(stack)内存
在代码段、数据段、堆中声明的变量，先声明的地址小，后来的大。
而栈则相反，先声明的大，越后来越小。

重新执行到函数调用部分
$ gdb a.out
(gdb) start

(gdb) n
27              int s=(*psquare)(a);


i)进入函数
(gdb) s
square (a=3) at 02_mem.c:16
16              count++;

(gdb) bt # 查看栈，预先不知道要放到栈中多少个变量，最先分配的栈地址最大，往后越来越小。
#0  square (a=3) at 02_mem.c:16
#1  0x0000555555554777 in main () at 02_mem.c:27

(gdb) n
18              int s=rect(a, a);

函数内又调用了一个函数，目前都在#0  square (a=3) at 02_mem.c:16 内部
(gdb) p &s
$1 = (int *) 0x7fffffffdd2c



ii) 再次进入函数
(gdb) s
rect (a=3, b=3) at 02_mem.c:8
8               count++;

查看栈，这时最早的是最底部的 main(内存编号最大)，然后是 square 内存编号略小。
栈的最上面始终是当前正在执行的函数。
栈的特点：先进后出。只有顶部一个出口/入口。
(gdb) bt
#0  rect (a=3, b=3) at 02_mem.c:8
#1  0x0000555555554719 in square (a=3) at 02_mem.c:18
#2  0x0000555555554777 in main () at 02_mem.c:27


(gdb) n
10              int s=a*b;
(gdb) n
11              return s;

(gdb) p &s
$2 = (int *) 0x7fffffffdd04
## 对比上一层 i) 中的 &s，发现这个后入栈的 s 的内存编号更小。

(gdb) p &count
$3 = (int *) 0x555555755018 <count>
## 这个静态变量，内存地址和前面几个变量都不一样，这是在堆中。





iii) 切换到#1栈，就是函数square内部
(gdb) f 1
#1  0x0000555555554719 in square (a=3) at 02_mem.c:18
18              int s=rect(a, a);

(gdb) p &count
$4 = (int *) 0x55555575501c <count>

在正方形和长方形面积函数中都有一个叫 count 的静态变量，他们是2个独立的变量，内存地址不同。


(gdb) p &global
$5 = (int *) 0x555555755014 <global>





iv) 切换回#0栈，就是rect内部

(gdb) f 0
#0  rect (a=3, b=3) at 02_mem.c:11
11              return s;
(gdb) p &global
$6 = (int *) 0x555555755014 <global>

这个全局变量，地址是一样的。

静态变量、全局变量、常量，都在数据段中，内存地址编号比较小。
所以函数可以调用很多次，但是函数内的静态变量都是指向数据段的，是可以保留值的。




## 查看栈内存起始地址
(gdb) p $sp  
$7 = (void *) 0x7fffffffdd08


## 打印栈开始的前40个字(160个字节)
(gdb) x/40x $sp
0x7fffffffdd08: 0xffffdd30      0x00007fff      0x55554719      0x00005555
0x7fffffffdd18: 0x756e6547      0x00000003      0x00000009      0x00000000
0x7fffffffdd28: 0xf7dd7660      0x00007fff      0xffffdd80      0x00007fff
0x7fffffffdd38: 0x55554777      0x00005555      0x00000001      0x00000000
0x7fffffffdd48: 0x555547fd      0x00000003      0x00000004      0x00007fff
0x7fffffffdd58: 0xffffdd4c      0x00007fff      0xffffdd50      0x00007fff
0x7fffffffdd68: 0x55755014      0x00005555      0x555546e1      0x00005555
0x7fffffffdd78: 0x88589500      0xa161f7f7      0x555547b0      0x00005555
0x7fffffffdd88: 0xf7a05b97      0x00007fff      0x00000001      0x00000000
0x7fffffffdd98: 0xffffde68      0x00007fff      0x00008000      0x00000001









========================================
|-- gdb 查看 函数指针
----------------------------------------
1. 函数指针 

$ gdb a.out 
(gdb) start

(gdb) n
26              int (*psquare)(int a)=&square;
(gdb) n
27              int s=(*psquare)(a);
(gdb) bt
#0  main () at 02_mem.c:27


进入函数内部
(gdb) s
square (a=3) at 02_mem.c:16
16              count++;
(gdb) bt
#0  square (a=3) at 02_mem.c:16
#1  0x0000555555554777 in main () at 02_mem.c:27

回到主函数 
(gdb) f 1
#1  0x0000555555554777 in main () at 02_mem.c:27
27              int s=(*psquare)(a);

这是一个指向函数的指针
(gdb) p psquare 
$3 = (int (*)(int)) 0x5555555546e1 <square>  #指向堆中的函数
(gdb) p &psquare  
$1 = (int (**)(int)) 0x7fffffffdd70  #这个指针本身在栈中保存

尝试打印其指向的内容：解引用
(gdb) p *psquare 
$4 = {int (int)} 0x5555555546e1 <square> #不懂为什么是这个形式 //todo


尝试通过这个函数的指针调用该函数
(gdb) call (*psquare)(20)
$2 = 400











========================================
|-- 指针与内存: 指针、数组、字符串
----------------------------------------
CPU做了什么，内存发生了什么变化？

1. 数组的本质

(1) 示例程序
$ cat 03_mem_array.c
#include<stdio.h>
int main(){
	int a=3;
	int  b=2;
	int arr[3];
	arr[0]=1;
	arr[1]=20;
	arr[2]=300;
	int *p=&a, i;
	int N=10;
	for(i=0; i<N; i++){
		printf("*p=%d\n", *p);
		p++;
	}
	printf("== ==\n");
	p=&a;
	for(i=0; i<N; i++){
		printf("p[%d]=%d\n",i, p[i]);
	}
}
上下打印的值完全相同，也就是说：数组就是指针。
arr == &arr[0]



(2) 编译执行
$ gcc -g -O0  03_mem_array.c -o a.out0
$ gcc -g  03_mem_array.c -o a.out

参数-O0表示不编译优化，结果文件可能略大。
-rwxrwxr-x 1 wangjl wangjl 11008 Jul 25 21:56 a.out
-rwxrwxr-x 1 wangjl wangjl 11008 Jul 25 21:56 a.out0
$ md5sum a.out*
d9a6fd1ac496ca7db8cfc261545c3dce  a.out
4c2900c395789379f0365e56566b4a9c  a.out0



$ gcc -g 03_mem_array.c
$ ./a.out
*p=3
*p=1
*p=2
*p=10
*p=1353044336
*p=32767
*p=2138310128
*p=1
*p=20
*p=300
== ==
p[0]=3  //a
p[1]=1  //i
p[2]=2  //b
p[3]=10  //N
p[4]=1353044320
p[5]=32767
p[6]=2138310128
p[7]=1
p[8]=20
p[9]=300


为什么连续声明的变量a=3,b=2不连续？
为什么变量和数组中间有间隔？
这个都需要使用 gdb 查看内存找答案。


(3) gdb 调试 
$ gdb a.out
(gdb) start

连续执行几个next，
(gdb) n
*p=3
13                      p++;


(gdb) p &a
$1 = (int *) 0x7fffffffdd50
(gdb) p &b
$2 = (int *) 0x7fffffffdd58
(gdb) p &N
$3 = (int *) 0x7fffffffdd5c

(gdb) p &i
$4 = (int *) 0x7fffffffdd54
(gdb) p i
$8 = 0

发现原来a和b之间的是变量i。

(gdb) p *p #解指针，取值
$11 = 3
(gdb) p p  #指针指向的地址，就是 &a
$9 = (int *) 0x7fffffffdd50
(gdb) p &p  #指针本身存放的位置
$10 = (int **) 0x7fffffffdd60
(gdb) whatis p # 查看p的类型，是 int指针
type = int *


(gdb) p &arr[0]
$5 = (int *) 0x7fffffffdd6c
(gdb) p &arr[1]
$6 = (int *) 0x7fffffffdd70
(gdb) p &arr[2]
$7 = (int *) 0x7fffffffdd74


打印栈的前12个位置，
第一行4个: a=3, i=0, b=2, N=10
第二行4个: 前三个不知道是啥。
	前两个是指针p本身在内存中的位置 &p，倒着放的。
		第三个不知道啥，可能是指针类型 int。//todo 
	第四个是数组第一个元素 arr[0]=1
第三行前两个: arr[1]=20, arr[2]=300

(gdb) x/12x $sp
0x7fffffffdd50: 0x00000003      0x00000000      0x00000002      0x0000000a
0x7fffffffdd60: 0xffffdd50      0x00007fff      0x555545f0      0x00000001
0x7fffffffdd70: 0x00000014      0x0000012c      0x355a2500      0x17c15553


x表示要输出内存的值，12x就是输出12个16进制， $sp 就是从这个位置开始输出。
还可以d指定按照10进制输出，更直观了，但是指针变量 p 就乱了。
(gdb) x/12d $sp
0x7fffffffdd50: 3       0       2       10
0x7fffffffdd60: -8880   32767   1431651824      1
0x7fffffffdd70: 20      300     895100160       398546259





2. 数组与指针：任何使用数组的地方都可以使用指针代替。

方便 p++ 做指针偏移时，按照int类型递增。
p += 3 则表示指针向下移动 int 的3倍，就是4*3=12个。
甚至更厉害的数组样偏移 p[3]=200 直接赋值。


(1) 使用指针操作数组

$ cat 04_array_pointer.c
#include<stdio.h>
int main(){
	int arr[]={1,20,303, 444};
	int *p=arr;
	//使用指针改变值
	p[3]=505;
	for(int i=0; i<4; i++){
		//使用指针下标，输出数组
		printf("p[%d]=%d\n", i, p[i]);
	}
	for(int i=0; i<4; i++){
		//使用指针偏移，输出数组
		printf("*(p+%d)=%d\n", i, *p);
		p++;
	}
	return 0;
}


输出:
p[0]=1
p[1]=20
p[2]=303
p[3]=505  //被修改过。
*(p+0)=1
*(p+1)=20
*(p+2)=303
*(p+3)=505







========================================
|-- 字符数组(字符串)、二维字符数组(字符串数组)
----------------------------------------
1. 字符串在内存中就是字符构成的数组，遇到\0结束。

(1) 示例代码
$ cat 05_string_pointer.c 
#include<stdio.h>
int main(){
	char str[]="hello";
	char *str2="world";
	char str3[10];
	printf("input a string\n");
	scanf("%s", str3);
	printf("str is %s\n", str);
	printf("str2 is %s\n", str2);
	printf("str3 is %s\n", str3);
	return 0;
}

$ gcc -g 05_string_pointer.c 
$ ./a.out 
input a string
what is your name
str is hello
str2 is world
str3 is what  #只读取到空格就停了



(2) 开始调试
$ gdb a.out
(gdb) start


多次按next:
(gdb) n
input a string
7               scanf("%s", str3);
(gdb) n
what
8               printf("str is %s\n", str);

这时查看类型
(gdb) p str
$1 = "hello"
(gdb) p &str
$2 = (char (*)[6]) 0x7fffffffdd68
(gdb) p &str2
$3 = (char **) 0x7fffffffdd60
(gdb) p str2
$4 = 0x5555555548a4 "world"
(gdb) p &str3
$5 = (char (*)[10]) 0x7fffffffdd6e


发现str, str3是装着指针的数组，
(gdb) p &str[0]
$15 = 0x7fffffffdd68 "hello"
(gdb) p &str[1]
$16 = 0x7fffffffdd69 "ello"
(gdb) p &str[2]
$17 = 0x7fffffffdd6a "llo"
(gdb) p &str[3]
$18 = 0x7fffffffdd6b "lo"
(gdb) p &str[4]
$19 = 0x7fffffffdd6c "o"
(gdb) p &str[5]
$20 = 0x7fffffffdd6d ""


str2是指向指针的指针，真实字符串在代码段(不是堆吗？看能否修改吧)中
(gdb) x/6c 0x5555555548a4
0x5555555548a4: 119 'w' 111 'o' 114 'r' 108 'l' 100 'd' 0 '\000'
(gdb) p &str2[0]
$23 = 0x5555555548a4 "world"
(gdb) p &str2[1]
$24 = 0x5555555548a5 "orld"
(gdb) p &str2[2]
$25 = 0x5555555548a6 "rld"





(3) 字符串可以使用字符数组形式直接编辑
尝试把中间某个字符修改为结束符\0.

$ cat 06_string_end.c
#include<stdio.h>
int main(){
	char str[]="this is";
	char str3[10]="OK";
	printf("%s\n", str);
	//使用指针操作提前终止
	str[3]='\0';
	printf("%s\n", str);
	
	int i;
	for(i=0; i<8; i++){
		printf("%c\n", str[i]);
	}
	return 0;
}

$ ./a.out 
this is
thi
t
h
i

 
i
s

按照数组，逐个字符可以都打印出来，\0就是一个空行。




(4) 如果第一个字符接收的输入过长，则会覆盖掉接下来的内存块。
$ cat 07_str_overwrite.c 
#include<stdio.h>
int main(){
	char str[]="hello";
	char *str2="world";
	char str3[10];
	printf("input a string\n");
	scanf("%s", str);
	printf("str is %s\n", str);
	printf("str2 is %s\n", str2);
	printf("str3 is %s\n", str3);
	return 0;
}

$ ./a.out 
input a string
nihao
str is nihao
str2 is world
str3 is 


2) 如果输入超过5个字符呢，会覆盖掉str3
$ ./a.out 
input a string
1234567890
str is 1234567890
str2 is world
str3 is 7890

可见，str会从指针开始的位置，读到\0；
str3 也是。所以他们的后半段是重叠的。








2. 字符串数组本质：二维数组
$ cat 08_2d_array.c
#include<stdio.h>
int main(){
	char str[][5]={"this", "is", "dog"};
	int i=0;
	for(;i<3;i++){
		printf("str[%d]=%s \t%p\n", i, str[i], &str[i]);
	}
	return 0;
}

$ gcc -g 08_2d_array.c
$ ./a.out 
str[0]=this     0x7ffee4d421e9
str[1]=is       0x7ffee4d421ee
str[2]=dog      0x7ffee4d421f3

(2) 进行调试
$ gdb a.out 
运行命令 start, 多次 n后:
(gdb) n
5               for(;i<3;i++){

检查 str 的内存结构：
(gdb) p str
$1 = {"this", "is\000\000", "dog\000"}
(gdb) p &str
$2 = (char (*)[3][5]) 0x7fffffffdd69
(gdb) p &str[0]
$3 = (char (*)[5]) 0x7fffffffdd69
(gdb) p &str[0][0]
$4 = 0x7fffffffdd69 "this"

(gdb) p &str[1]
$5 = (char (*)[5]) 0x7fffffffdd6e
(gdb) p &str[2]
$6 = (char (*)[5]) 0x7fffffffdd73
(gdb) p &str[2][0]
$7 = 0x7fffffffdd73 "dog"

可见二维数组占用的空间是连续的，可以认为是线性的一排。
第一维是字符串数组，3个；
第二维是每个字符串内部的字符数组，每个占5位。

在内存中的结构为：
(gdb) x/15x 0x7fffffffdd69
0x7fffffffdd69: 0x73696874      0x00736900      0x6f640000      0x00000067
0x7fffffffdd79: 0x1d252cb4      0x60069490      0x55555547      0x97000055
0x7fffffffdd89: 0xfff7a05b      0x0100007f      0x00000000      0x68000000
0x7fffffffdd99: 0xffffffde      0x0000007f      0x01000080
(gdb) x/15c 0x7fffffffdd69
0x7fffffffdd69: 116 't' 104 'h' 105 'i' 115 's' 0 '\000'        105 'i' 115 's' 0 '\000'
0x7fffffffdd71: 0 '\000'        0 '\000'        100 'd' 111 'o' 103 'g' 0 '\000'        0 '\000'








========================================
Valgrind：查找内存泄露利器 (缺点：巨慢) //todo 
----------------------------------------
Valgrind这个名字取自北欧神话中英灵殿的入口。
Valgrind的最初作者是Julian Seward，他于2006年由于在开发Valgrind上的工作获得了第二届Google-O'Reilly开源代码奖。


1. 简介
(1) Valgrind是一款用于内存调试、内存泄漏检测以及性能分析的软件开发工具。

官网：https://www.valgrind.org/
源码：https://sourceware.org/git/?p=valgrind.git
文档：https://www.valgrind.org/docs/

安装 Valgrind
$ sudo apt install valgrind

$ valgrind --version
valgrind-3.13.0


(2)关于：https://www.valgrind.org/info/about.html
With Valgrind's tool suite you can automatically detect many memory management and threading bugs, avoiding hours of frustrating bug-hunting, making your programs more stable. You can also perform detailed profiling to help speed up your programs.


(3) 为什么用？
最近老是遇上各种奇奇怪怪的core dump，不太会分析的情况下看到了这款工具。
Valgrind可以检测内存泄漏和内存越界，还可以分析cache的使用等，灵活轻巧而又强大。   

Valgrind是一个运行你的程序的程序，并且随后会报告所有你犯下的可怕错误。
你可以在它的环境中运行你的程序来监视内存的使用情况，比如C 语言中的malloc和free。


(4) 想要从源头杜绝内存泄漏，最直接的方式是时刻牢记
内存分配函数Xalloc( malloc, calloc, realloc) 和内存释放函数 free 必须成对出现。

但是在一些比较复杂的c语言程序中，甚至包含很多文件，有很多循环和分支，我们往往无法逐一验证内存分配函数和内存释放函数的配对。

这时候就需要工具了，valgrind就是其中之一。





2. Valgrind的主要功能
Valgrind工具包包含多个工具，如 Memcheck, Cachegrind, Helgrind, Callgrind, Massif。下面分别介绍个工具的作用。

Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。

Callgrind。它主要用来检查程序中函数调用过程中出现的问题。

Cachegrind。它主要用来检查程序中缓存使用出现的问题。

Helgrind。它主要用来检查多线程程序中出现的竞争问题。

Massif。它主要用来检查程序中堆栈使用中出现的问题。

Extension。可以利用core提供的功能，自己编写特定的内存调试工具。



(1) 使用 Valgrind 十分简单，只要执行valgrind theprogram，它就会运行你的程序，随后打印出你的程序运行时出现的所有错误。

valgrind 的命令一般都很长，不过可以用到了再查。

$ valgrind --tool=memcheck --leak-check=yes --show-reachable=yes ./a.out

--tool=memcheck 表示选择工具 memcheck
--leak-check=yes 表示退出后搜索内存泄漏
--show-reachable=yes 相当于 --show-leak-kines=all 显示所有类型的内存泄漏

注意：想要输出正确的行号信息，程序必须使用 -g 选项编译。




(2) 测试 正例：内存正常

$ cat 09_valgrind.c
#include <stdio.h>
/* Warning: This program is wrong on purpose. */
int main(){
    int age = 10;
    int height;

    printf("I am %d years old.\n");
    printf("I am %d inches tall.\n", height);
    return 0;
}

两个经典错误：
- 没有初始化height变量
- 没有将age变量传入第一个printf函数

$ gcc -Wall -g 09_valgrind.c -o a.out
09_valgrind.c: In function ‘main:.
09_valgrind.c:7:19: warning: format ‘%d’ expects a matching ‘int’ argument [-Wfor]at=
     printf("I am %d years old.\n");
                  ~^
$ ./a.out 
I am 1326168792 years old.
I am 0 inches tall.

输出很乱，不知道怎么看
$ valgrind ./a.out
$ valgrind --track-origins=yes ./a.out
==14322== Memcheck, a memory error detector
==14322== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==14322== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==14322== Command: ./a.out
==14322==
I am -16777768 years old.
==14322== Conditional jump or move depends on uninitialised value(s) //未初始化的值
==14322==    at 0x4E9896A: vfprintf (vfprintf.c:1642)
==14322==    by 0x4EA0FA5: printf (printf.c:33)
==14322==    by 0x10867F: main (09_valgrind.c:8)
==14322==
==14322== Use of uninitialised value of size 8
==14322==    at 0x4E948FB: _itoa_word (_itoa.c:179)
==14322==    by 0x4E97F9D: vfprintf (vfprintf.c:1642)
==14322==    by 0x4EA0FA5: printf (printf.c:33)
==14322==    by 0x10867F: main (09_valgrind.c:8)
==14322==
==14322== Conditional jump or move depends on uninitialised value(s) //未初始化的值
==14322==    at 0x4E94905: _itoa_word (_itoa.c:179)
==14322==    by 0x4E97F9D: vfprintf (vfprintf.c:1642)
==14322==    by 0x4EA0FA5: printf (printf.c:33)
...
I am 0 inches tall.
==14322==
==14322== HEAP SUMMARY:
==14322==     in use at exit: 0 bytes in 0 blocks
==14322==   total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated
==14322==
==14322== All heap blocks were freed -- no leaks are possible
==14322==
==14322== For counts of detected and suppressed errors, rerun with: -v
==14322== Use --track-origins=yes to see where uninitialised values come from
==14322== ERROR SUMMARY: 5 errors from 5 contexts (suppressed: 0 from 0)

解释：
- 左边显示类似行号的数字（14322）表示的是 Process ID
- 最上面是 valgrind 的版本信息
- 中间是 valgrind 通过运行被测试程序，发现的内存问题。通过阅读这些信息，可以发现：
	发生错误时的函数堆栈，以及具体的源代码行号。
	非法写操作的具体地址空间。
- 最下面是对发现的内存问题和内存泄露问题的总结。
	内存泄露的大小 0 bytes，本程序没有内存泄漏。in use at exit: 0 bytes in 0 blocks



(3) 测试3 反例：内存不释放
需要分配内存的，但是不释放的例子。

$ cat 12.c
#include<stdio.h>
#include<stdlib.h>
int main(){
	int i, arr[]={1,27,34};
	int *p=malloc( sizeof(int) * 3);
	for(i=0; i<3; i++){
		p[i]=arr[i];
		printf("%d->%d\n", i, *(p+i));
	}
	return 0;
}

$ gcc 12.c
$ ./a.out
0->1
1->27
2->34

$ ./a.out 
0->1
1->27
2->34



$ valgrind ./a.out
版本信息略。
0->1
1->27
2->34
==32065== 
==32065== HEAP SUMMARY:
==32065==     in use at exit: 12 bytes in 1 blocks
==32065==   total heap usage: 2 allocs, 1 frees, 1,036 bytes allocated
==32065== 
==32065== LEAK SUMMARY:
==32065==    definitely lost: 12 bytes in 1 blocks //泄漏了12字节( int * 3)
==32065==    indirectly lost: 0 bytes in 0 blocks
==32065==      possibly lost: 0 bytes in 0 blocks
==32065==    still reachable: 0 bytes in 0 blocks
==32065==         suppressed: 0 bytes in 0 blocks
==32065== Rerun with --leak-check=full to see details of leaked memory
==32065== 
==32065== For counts of detected and suppressed errors, rerun with: -v
==32065== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)


按照最后几行的提示，再试
$ valgrind --tool=memcheck --leak-check=full ./a.out
版本信息略。
0->1
1->27
2->34
==32584== 
==32584== HEAP SUMMARY:
==32584==     in use at exit: 12 bytes in 1 blocks
==32584==   total heap usage: 2 allocs, 1 frees, 1,036 bytes allocated
==32584== 
==32584== 12 bytes in 1 blocks are definitely lost in loss record 1 of 1
==32584==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==32584==    by 0x10872F: main (in /data/wangjl/test/linux_C/a.out)
==32584== 
==32584== LEAK SUMMARY:
==32584==    definitely lost: 12 bytes in 1 blocks
==32584==    indirectly lost: 0 bytes in 0 blocks
==32584==      possibly lost: 0 bytes in 0 blocks
==32584==    still reachable: 0 bytes in 0 blocks
==32584==         suppressed: 0 bytes in 0 blocks
==32584== 
==32584== For counts of detected and suppressed errors, rerun with: -v
==32584== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)




(4) 测试4：内存越界
#include<stdio.h>
#include<stdlib.h>
int main(){
	int i;
	int len = 4;
	int *pt = (int*)malloc(len*sizeof(int)); //返回的是空指针，可以主动转换为某个类型
	int *p = pt;

	for(i=0;i<len;i++){
		*p=i;
		p++;
	}

	*p = 5;
	return 0;
}

$ gcc -g 13.c

$ valgrind --tool=memcheck --leak-check=full ./a.out
...
==4109== 
==4109== Invalid write of size 4  //非法写入4个字节
==4109==    at 0x10869D: main (13.c:15) //位置是第15行 *p = 5;
==4109==  Address 0x522d050 is 0 bytes after a block of size 16 alloc'd
==4109==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==4109==    by 0x108669: main (13.c:7)
==4109== 
==4109== 
==4109== HEAP SUMMARY:
==4109==     in use at exit: 16 bytes in 1 blocks //程序退出后还有16字节没有释放
==4109==   total heap usage: 1 allocs, 0 frees, 16 bytes allocated
==4109== 
==4109== 16 bytes in 1 blocks are definitely lost in loss record 1 of 1
==4109==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==4109==    by 0x108669: main (13.c:7)
==4109== 
==4109== LEAK SUMMARY:
==4109==    definitely lost: 16 bytes in 1 blocks
==4109==    indirectly lost: 0 bytes in 0 blocks
==4109==      possibly lost: 0 bytes in 0 blocks
==4109==    still reachable: 0 bytes in 0 blocks
==4109==         suppressed: 0 bytes in 0 blocks
==4109== 
==4109== For counts of detected and suppressed errors, rerun with: -v
==4109== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)




ref:
https://blog.csdn.net/andylauren/article/details/93189740
https://zhuanlan.zhihu.com/p/56538645







========================================
|-- malloc 函数详解 (与free函数连用)
----------------------------------------

1. 简介
#include<stdlib.h>
C 库函数 void *malloc(size_t size) 【在堆上】分配所需的内存空间，并返回一个指向它的指针。

参数
size -- 内存块的大小，以字节为单位。

返回值
该函数返回一个指针 ，指向已分配大小的内存。如果请求失败，则返回 NULL。



(2) 关于malloc以及相关的几个函数
#include <stdlib.h>(Linux下)

void *malloc(size_t size);
void free(void *ptr);
void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);


如果分配成功：则返回指向被分配内存空间的指针
不然，返回空指针NULL。
同时，当内存不再使用的时候，应使用free（）函数将内存块释放掉。
关于：void *,表示未确定类型的指针。C，C++规定，void *类型可以强转为任何其他类型的的指针。

关于void *的其他说法：其他任意类型都可以直接赋值给它，无需进行强转，但是反过来不可以。
void * p1;
int *p2;
p1 = p2;


(3) malloc：
malloc分配的内存大小至少为size参数所指定的字节数
malloc的返回值是一个指针，指向一段可用内存的起始地址
多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉
malloc应该尽快完成内存分配并返回（不能使用NP-hard的内存分配算法）
实现malloc时应同时实现内存大小调整和内存释放函数（realloc和free）

malloc和free函数是配对的，如果申请后不释放就是内存泄露;如果无故释放那就是什么都没有做，释放只能释放一次，如果释放两次及两次以上会出现错误（但是释放空指针例外，释放空指针其实也等于什么都没有做，所以，释放多少次都是可以的）


简单的说：
malloc 函数其实就是在内存中：找一片指定大小的空间，然后将这个空间的首地址给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址， 这要看malloc函数中参数size的具体内容。

我们这里malloc分配的内存空间在逻辑上是连续的，而在物理上可以不连续。我们作为程序员，关注的 是逻辑上的连续，其它的，操作系统会帮着我们处理的。







2. 实例 
$ cat 10_malloc.c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
int main(){
	char *str;
	//最初的内存分配
	str= (char *) malloc(6);
	strcpy(str, "hello");
	printf("string=%s, address=%p\n", str, str);
	
	// 重新分配内存，更大空间
	str=(char *) realloc(str, 25);
	strcat(str, " world!");
	printf("string=%s, address=%p\n", str, str);
	
	//释放内存
	free(str);
	
	return 0;
}

$ gcc -g 10_malloc.c
$ ./a.out 
string=hello, address=0x55782a276260
string=hello world!, address=0x55782a276690



(2) 使用 gdb 跟踪查看内存位置
$ gdb a.out
(gdb) start

(gdb) n
8               strcpy(str, "hello");
(gdb) n
9               printf("string=%s, address=%p\n", str, str);

指针str本身在 栈 上，但是指向的位置编号较小，应该是在堆上。
(gdb) p str
$1 = 0x555555756260 "hello"
(gdb) p &str
$2 = (char **) 0x7fffffffdd78


重新分配内存后：
(gdb) n
string=hello, address=0x555555756260
12              str=(char *) realloc(str, 25);
(gdb) n
13              strcat(str, " world!");

指针本身存储的位置不变，但是指向的地址变了。
(gdb) p str
$1 = 0x555555756690 "hello"
(gdb) p &str
$2 = (char **) 0x7fffffffdd78


(gdb) n
string=hello world!, address=0x555555756690
17              free(str);
(gdb) x/15c 0x555555756690
0x555555756690: 104 'h' 101 'e' 108 'l' 108 'l' 111 'o' 32 ' '  119 'w' 111 'o'
0x555555756698: 114 'r' 108 'l' 100 'd' 33 '!'  0 '\000'        0 '\000'        0 '\000'



free执行后，内存中的值被清空了
(gdb) n
19              return 0;
(gdb) x/15c 0x555555756690
0x555555756690: 0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'
0x555555756698: 114 'r' 108 'l' 100 'd' 33 '!'  0 '\000'        0 '\000'        0 '\000'











ref:
https://www.cnblogs.com/Commence/p/5785912.html
https://www.runoob.com/cprogramming/c-function-malloc.html










========================================
C 指针详解  ############### (很重要) ###############
----------------------------------------
在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念：




========================================
|-- 指针的算术运算: 可以对指针进行四种算术运算：++、--、+、-
----------------------------------------

假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：

ptr++
在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。
如果 ptr 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。


例1： 数组变量名就是一个指针。
#include<stdio.h>
const int MAX =3;
int main(){
  int var[]={10,100,200};
  int i, *ptr;
  ptr=var; //指针中的数组地址
  printf("%p\n", var );

return 0;
}
输出 0x7ffeefc3662c


例2： 递增一个指针
我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。
下面的程序递增变量指针，以便顺序访问数组中的每一个元素：

#include<stdio.h>
const int MAX =3;
int main(){
  int var[]={10,100,200};
  int i, *ptr;
  ptr=var; //指针中的数组地址
  printf("%p, value=%d, %d\n", var, *var, var[0]);
  for(i=0;i<MAX; i++){
    printf("存储地址: var[%d]=%p; ", i, ptr);
    printf("值：var[%d]=%d \n", i, *ptr);
    ptr++;//移动指针到下一个位置
  }
return 0;
}
输出： 
0x7ffeb613940c, value=10, 10  #数组名就是指针，指向数组or数组第一个值，*var则取出该值，等价于var[0]；
存储地址: var[0]=0x7ffeb613940c; 值：var[0]=10 
存储地址: var[1]=0x7ffeb6139410; 值：var[1]=100 
存储地址: var[2]=0x7ffeb6139414; 值：var[2]=200


例3：递减一个指针。
取值第三个元素时，加上%符号就获得了该位置的指针。

#include<stdio.h>
const int MAX =3;
int main(){
  int var[]={10,100,200};
  int i, *ptr;
  ptr= &var[MAX-1]; //指针指向数组第三个元素
  printf("%p, value[2]=%d\n", &var[2], var[2]);
  for(i=MAX;i>0; i--){
    printf("存储地址: var[%d]=%p; ", i, ptr);
    printf("值：var[%d]=%d \n", i, *ptr);
    ptr--;//移动指针到下一个位置
  }
return 0;
}
输出:
0x7fffca52e114, value[2]=200
存储地址: var[3]=0x7fffca52e114; 值：var[3]=200 
存储地址: var[2]=0x7fffca52e110; 值：var[2]=100 
存储地址: var[1]=0x7fffca52e10c; 值：var[1]=10





例4： 指针的比较
指针可以用关系运算符进行比较，如 ==、< 和 >。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。

只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &var[MAX - 1]，则把变量指针进行递增：

#include<stdio.h>
const int MAX =3;
int main(){
  int var[]={10,100,200};
  int i, *ptr;
  ptr= var; //指针指向数组第1个元素第一个元素的地址
  i=0;
  while(ptr<= &var[MAX-1]){
    printf("存储地址: var[%d]=%p; ", i, ptr);
    printf("值：var[%d]=%d \n", i, *ptr);
    ptr++;
    i++;
  }
return 0;
}

输出： 
存储地址: var[0]=0x7ffc354838ac; 值：var[0]=10 
存储地址: var[1]=0x7ffc354838b0; 值：var[1]=100 
存储地址: var[2]=0x7ffc354838b4; 值：var[2]=200


========================================
|-- 指针数组	可以定义用来存储指针的数组。
----------------------------------------

1.一个数组 int  var[] = {10, 100, 200};
我们把其每个元素的地址保存到一个数组中：int *ptr[MAX];
数组的每个元素都是指向int值的指针: ptr[0]=&var[0]
取值的时候可以var[0], 或者 *ptr[0]。 递增的时候，可以使用 ptr++ //todo

#include <stdio.h>
int main(){
  int var[]={10,200,30};
  int i, *ptr[3];
  for(i=0;i<3;i++){
    ptr[i]=&var[i];
  }
  for(i=0; i<3; i++){
    printf("Value of var[%d]=%d or %d, pointer=%p \n",i,var[i], *ptr[i], ptr[i] );
  }
  return 0;
}

输出结果：
Value of var[0]=10 or 10, pointer=0x7ffc8702e764 
Value of var[1]=200 or 200, pointer=0x7ffc8702e768 
Value of var[2]=30 or 30, pointer=0x7ffc8702e76c 






2.用一个指向字符的指针数组来存储一个字符串列表
#include<stdio.h>
int main(){
  char *names[]={"Tom", "Jim", "Robin", "Page"};
  char *tmp;
  int i=0;
  for(;i<4;i++){
    tmp=names[i];
    printf("pointer[%d]=%p, value: %s;   char1=%c\t", i, names[i], names[i], *names[i]); //字符串本质是字符的数组，所以它记录的就是该数组的首元素的地址。
    printf("__point[%d]=%p, char2=%c; char1=%c;\n", i, tmp, *tmp, *tmp++);  //这里为什么char1和char2是这个顺序？
  }
  return 0;
}


输出： 
pointer[0]=0x5624e5dda838, value: Tom;   char1=T        __point[0]=0x5624e5dda839, char2=o; char1=T;
pointer[1]=0x5624e5dda83c, value: Jim;   char1=J        __point[1]=0x5624e5dda83d, char2=i; char1=J;
pointer[2]=0x5624e5dda840, value: Robin;   char1=R      __point[2]=0x5624e5dda841, char2=o; char1=R;
pointer[3]=0x5624e5dda846, value: Page;   char1=P       __point[3]=0x5624e5dda847, char2=a; char1=P;

//todo
可能是因为形式赋值，和实质赋值不是一个时间？
++前先给了值，所以是第一个字符； 而其本身已经是第二个字符了。

实例2:
#include<stdio.h>
int main(){
  char *names[]={"Tom", "Jim", "Robin", "Page"};
  char *tmp;
  int i=0;
  for(;i<4;i++){
    printf("pointer[%d]=%p, value: %s;   char1=%c\t", i, names[i], names[i], *names[i]);
    tmp=names[i]++; //tmp还是第一个字符的地址， names中已经移动到第二个字符了
    printf("__point[%d]=%p, char1=%c; char2=%c;\n", i, tmp, *tmp, *names[i]);
  }
  return 0;
}
输出:
pointer[0]=0x557d73d88848, value: Tom;   char1=T        __point[0]=0x557d73d88848, char1=T; char2=o;
pointer[1]=0x557d73d8884c, value: Jim;   char1=J        __point[1]=0x557d73d8884c, char1=J; char2=i;
pointer[2]=0x557d73d88850, value: Robin;   char1=R      __point[2]=0x557d73d88850, char1=R; char2=o;
pointer[3]=0x557d73d88856, value: Page;   char1=P       __point[3]=0x557d73d88856, char1=P; char2=a;






3. 指针数组和数组指针的区别
要看结尾词！

(1)指针数组
指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组。
其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型。
在 32 位系统中，指针占四个字节。

数组指针
数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针。
其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。

根据上面的解释，可以了解到指针数组和数组指针的区别，因为二者根本就是两种类型的变量。


(2)
指针数组：表示的是一个由指针变量组成的数组，也就是说其中的元素都是指针变量。

数组指针：表示的是这是个指向数组的指针，那么该指针变量存储的地址就必须是数组的首地址，得是个指向行的地址，如 a[2][3] 数组中的 a，a+1 等，不能是具体的指向列的地址，如 &a[0][1], &a[1][1] 这类地址。








========================================
|-- 指向指针的指针	C 允许指向指针的指针。
----------------------------------------
指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。
当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

pointer1   pointer2    Variable
Address  -> Address  -> Value

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：
int **var;

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符
本身第第一个指针(指向第二个指针)，加一个星号是第二个指针(指向值)，加2个星号才取到值。


例1： 
#include<stdio.h>
int main(){
 int var=100;
 int *ptr;
 int  **pptr;

 ptr=&var; //获取var的地址
 pptr=&ptr; //获取 ptr的地址

 //获取值
 printf("value of var=%d\n", var);
 printf("value by ptr=%p, *ptr=%d\n", ptr, *ptr);
 printf("value by pptr=%p, *pptr=%p( == ptr), **pptr=%d\n", pptr, *pptr, **pptr);

 return 0;
}

输出：
value of var=100
value by ptr=0x7ffedff40f04, *ptr=100
value by pptr=0x7ffedff40f08, *pptr=0x7ffedff40f04( == ptr), **pptr=100





========================================
|-- 传递指针给函数	通过引用或地址传递参数，使传递的参数在调用函数中被改变。
----------------------------------------
C 语言允许您传递指针给函数，只需要简单地声明函数参数为指针类型即可。

下面的实例中，我们传递一个无符号的 long 型指针给函数，并在函数内改变这个值：

例1：接收指针的函数
#include<stdio.h>
#include<time.h>
void getSeconds(unsigned long *per);

int main(){
 unsigned long sec=0;
 printf("sec=%ld\n", sec);
 getSeconds( &sec ); //输出被改变后的值
 printf("Number of seconds: %ld\n", sec);
 return 0;
}

void getSeconds(unsigned long *par){
 *par=time(NULL);
 return;
}

输出： 
sec=0
Number of seconds: 1564059253




能接受指针作为参数的函数，也能接受数组作为参数
例2：接收指针数组的函数
#include<stdio.h>
double getAverage(int *arr, int size);


int main(){
 int balance[5]={1000,2,3,17,50}; //有5个元素的整数型数组 
 double avg;
 
 printf("the para=%p, 1st element=%d \n", balance, *balance);
 avg=getAverage( balance, 5); //指向数组的指针作为参数

 printf("Average value is: %f\n", avg);
 return 0;
}

double getAverage(int *arr, int size){
        int i, sum=0;
        double avg;
        for(i=0;i<size;i++){
                sum+=arr[i];
        }
        avg=(double)sum/size;
        return avg;
}

输出： 
the para=0x7ffcdd27e500, 1st element=1000 
Average value is: 214.400000




例3: 在外部函数中，加倍每个数组元素的值（数组是按照地址传递）
#include<stdio.h>
void doubleInt(int *arr,int size);

int main(){
        int i,r[5]={1,2,3,4,5};
        for(i=0;i<5;i++){ printf("a[%d]=%d, ",i,r[i]);} 
        printf("\n");

        doubleInt(r,5);
        for(i=0;i<5;i++){ printf("a[%d]=%d, ",i,r[i]); }
        printf("\n");
}

void doubleInt(int *arr, int size){
        int i=0;
        for(i=0;i<size;i++){
                arr[i]*=2;
        }
        return;
}
输出： 
a[0]=1, a[1]=2, a[2]=3, a[3]=4, a[4]=5, 
a[0]=2, a[1]=4, a[2]=6, a[3]=8, a[4]=10,



========================================
|-- 从函数返回指针	C 允许函数返回指针到局部变量、静态变量和动态内存分配。
----------------------------------------
C 语言中可以从函数返回数组，类似地，C 允许您从函数返回指针。

声明一个返回指针的函数：
int * myFunction(){
//some code;
}


例1: 返回指针的函数，就是返回的数组名
#include<stdio.h>
#include<time.h>
#include<stdlib.h>

//要生成和返回随机数的函数 
int *getRandom(){
  static  int r[3];
  int i;
  srand( (unsigned)time(NULL) );
  for(i=0; i<3; i++){
    r[i]=rand();
    printf("arr[%d] = %d\n",i, r[i]);
  }
  return r;
}

int main(){
  int *p, i;
  p=getRandom();
  for(i=0; i<3; i++){
    printf("*(p + [%d]): %d;\n", i, *(p+i));
  }
}

输出： 
arr[0] = 1018462428
arr[1] = 1425683971
arr[2] = 1191730623
*(p + [0]): 1018462428;
*(p + [1]): 1425683971;
*(p + [2]): 1191730623;



另外，C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。
如果上例中声明r时不加static，则会报错： a11.c:14:10: warning: function returns address of local variable [-Wreturn-local-addr]

从内存角度解释：C 不支持在调用函数时返回局部变量的地址，除非定义局部变量为 static 变量。
因为局部变量是存储在内存的栈区内，当函数调用结束后，局部变量所占的内存地址便被释放了，因此当其函数执行完毕后，函数内的变量便不再拥有那个内存地址，所以不能返回其指针。
除非将其变量定义为 static 变量，static 变量的值存放在内存中的静态数据区，不会随着函数执行的结束而被清除，故能返回其地址。




========================================
|-- 函数指针与回调函数，及静态库和动态库的实现方法
----------------------------------------
函数指针的主要用途是向其他函数传递“回调”，或者模拟类和对象。


1.函数指针是指向函数的指针变量。
通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。
函数指针可以像一般函数一样，用于调用函数、传递参数。


(1)函数指针变量的声明
声明一个指向同样参数、返回值的函数指针类型。格式：
int (*POINTER_NAME)(int a, int b)

简写: 只写参数类型，省略形参
int (*fun_ptr)(int,int); 


记住如何编写它的一个方法是：
编写一个普通的函数声明：int callme(int a, int b)
将函数用指针语法包装：int (*callme)(int a, int b)
将名称改成指针名称：int (*compare_cb)(int a, int b)


// case for a function pointer
typedef int (*compare_cb)(int a, int b);

就可以谁用类 compare_cb 了
int *bubble_sort(int *numbers, int count, compare_cb cmp)




例1： 函数指针
声明了函数指针变量 p，指向函数 max：

#include<stdio.h>
int max(int x, int y){
  return x>y?x:y;
}

int main(void){
  //*p是函数指针
  int (*p)(int ,int)= &max; // &可以省略
  int a,b,c,d;

  printf("请输入三个数字，space separated:");
  scanf("%d %d %d", &a, &b, &c);

  /* 与直接调用函数等价，d = max(max(a, b), c) */
  d=p( p(a,b), c);
  printf("最大的数字是: %d\n", d);

  return 0;
}
运行结果：
$ ./a12
请输入三个数字:23
34
56
最大的数字是: 56

或
$ ./a12
请输入三个数字:12 45 3
最大的数字是: 45



##
例2: 
我们首先定义了一个函数指针fuc ,这个函数指针的返回值为void型,然后我们给函数指针赋值，赋值为print,也就是print函数的首地址，此时fuc获得了print的地址，fuc的地址等于print的地址，所以最终调用fuc();也就相当于调用了print();

#include <stdio.h>
void print();
int main(void){
	void (*fuc)(); 
	fuc = print ; 
	fuc(); 	
} 
void print(){
	printf("hello world!\n");
}



例3：指向函数的指针，调用时加(*funName)也可以。
#include<stdio.h>
void bubbleSort(int arr[], int n){
	int i,j, tmp;
	for(i=0; i<n; i++){
		for(j=1; j<n; j++){
			if(arr[i]<arr[j]){
				tmp=arr[j];
				arr[j]=arr[i];
				arr[i]=tmp;
			}
		}
	}
}

int main(){
	int arr[]={0, -1,20,-300,4000}, N=sizeof(arr)/sizeof(int);
	void (*p)(int arr[], int N)=&bubbleSort;
	(*p)(arr, N);
	for(int i=0; i<N; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}






2.函数指针作为某个函数的参数
函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。


(1)以下是来自知乎作者常溪玲的解说：
你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。


(2)百度的权威解释如下：
回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。


(3)来自Stack Overflow某位大神
简洁明了的表述：A "callback" is any function that is called by another function which takes the first function as a parameter。 
也就是说，函数 F1 调用函数 F2 的时候，函数 F1 通过参数给 函数 F2 传递了另外一个函数 F3 的指针，在函数 F2 执行的过程中，函数F2 调用了函数 F3，这个动作就叫做回调（Callback），而先被当做指针传入、后面又被回调的函数 F3 就是回调函数。




例1: 回调示例
#include<stdio.h>
#include<stdlib.h>

//A函数，其一个参数是指针函数。在其函数体中调用被传入的函数。
void populate_array(int *array, int arraySize, int (*getNextValue)(void)){
  for(int i=0; i<arraySize; i++){
    array[i]=getNextValue(); //要用传入的函数，否则传入函数指针就没有意义了
  }
}

//回调函数。B函数，符合上述指针函数的格式即可。
int getNextRandomValue(void){
  return rand();
}

//调用A函数，在其参数中传入B函数
int main(void){
  int myarray[5];
  populate_array(myarray, 5, getNextRandomValue);
  for(int i=0; i<5; i++){
    printf("arr[%d] = %d\t",i,myarray[i]);
  }
  printf("\n");
  return 0;
}
输出：
arr[0] = 1804289383     arr[1] = 846930886      arr[2] = 1681692777     arr[3] = 1714636915     arr[4] = 1957747793

调用者要先写好这个回调函数的实例。才能调用 回调函数。
回调函数A相当于制定规则的，但具体函数体、函数名、函数实现不细化，具体细则还得调用者自己实现(即回调函数的实现)。

简单说：函数参数里有函数指针，指针指向的是函数地址，不是变量地址。这样，函数就可以随便写，都可以用这个回调函数当一个参数来调用，多方便。程序通用性就更强了！

回调函数的好处和作用，就是解耦。





## 回调函数示例
在 A 函数中将参数与 C 函数传递给 B 函数，B函数调用 C 函数；
B 函数调用的动作称为回调，C 函数称为回调函数。

#include <stdio.h>
// 回调函数a
void callback_a(int n){
    printf("Call callback_a, n: %d\n", n);
}

// 回调函数b
void callback_b(int n){
    printf("Call callback_b, n: %d\n", n);
}

// 回调动作：传入函数的指针
void callback_act(int x, void (*callback) (int var)){
    printf("Call callback_act, x: %d\n", x);
    callback(x);
}

void main(){
    int a = 1, b = 2;
    callback_act(a, callback_a);
    callback_act(b, callback_b);
    printf("Main program has done.");
}


输出：
Call callback_act, x: 1
Call callback_a, n: 1
Call callback_act, x: 2
Call callback_b, n: 2








##
例2: 带参数的回调。我们再写一个求平方、立方的例子，只需要写函数，改变传入的函数即可。符合开闭原则。

如何添加参数？
并不是直接把int Handle(int (*Callback)()) 改成 int Handle(int (*Callback)(int)) 就可以的，而是通过另外增加一个参数来保存回调函数的参数值，像这里 int Handle(int y, int (*Callback)(int)) 的参数 y。


#include<stdio.h>
#include<stdlib.h>

//Handle函数A，其一个参数是指针函数。在其函数体中调用被传入的函数。
void populate_array(int *array, int arraySize, int (*getNextValue)(int)){
  for(int i=0; i<arraySize; i++){
    array[i]=getNextValue(i);
  }
}

//Callback 回调函数 返回平方。B函数，符合上述指针函数的格式即可。
int power2(int i){
  return i*i;
}
//回调函数 返回立方
int power3(int i){
  return i*i*i;
}


//调用A函数，在其参数中传入B函数
int main(void){
  int myarray[5];
  //传入平方函数
  populate_array(myarray, 5, power2);
  for(int i=0; i<5; i++){
    printf("%d, ",myarray[i]);
  }
  printf("\n");
  
  //换一个函数，立方函数
  populate_array(myarray, 5, power3);
  for(int i=0; i<5; i++){
    printf("%d, ",myarray[i]);
  }
  printf("\n");

  return 0;
}
输出结果： 
0, 1, 4, 9, 16, 
0, 1, 8, 27, 64,








例3: 库的实现方式。用于在回调函数中自定义运算规则。

#include<stdio.h>

//#include<softwareLib.h> // 包含Library Function所在读得Software library库的头文件
//本该在 Library 中的函数，用户知道怎么调用即可，无需知道内部细节。
int Handle(int a, int b, int (*operator)() ){
  //return (*operator)(a,b); //(*add_value)(a+b) 和直接运行 add_value(a+b) 结果相同。
  return operator(a,b);
}


//Callback Function 用户自定义实现的回调函数
int operator(); //可以不带参数的简单声明，在main后再定义
int operator2(int x, int y){ return x-y;}
int operator3(int x, int y){ return (x+y)*2;} //用户自定义函数
int operator4(int x, int y){ return x*x + y*y;}

int main(){
  int a=12,b=4;
  printf("Result of %d x?x %d = %d\n",a, b,  Handle(a,b, operator) );
  printf("Result of %d x?x %d = %d\n",a, b,  Handle(a,b, operator2) );
  printf("Result of %d x?x %d = %d\n",a, b,  Handle(a,b, operator3) );
  printf("Result of %d x?x %d = %d\n",a, b,  Handle(a,b, operator4) );
  return 0;
}

int operator(int x, int y){ return x+y;}

输出：
Result of 12 x?x 4 = 16
Result of 12 x?x 4 = 8
Result of 12 x?x 4 = 32
Result of 12 x?x 4 = 160


在回调中，主程序把回调函数像参数一样传入库函数。这样一来，只要我们改变传进库函数的参数，就可以实现不同的功能，这样有没有觉得很灵活？
并且丝毫不需要修改库函数的实现，这就是解耦。

再仔细看看，主函数和回调函数是在同一层的，而库函数在另外一层，想一想，如果库函数对我们不可见，我们修改不了库函数的实现，也就是说不能通过修改库函数让库函数调用普通函数那样实现，那我们就只能通过传入不同的回调函数了，这也就是在日常工作中常见的情况。


如果需要降低耦合度的时候，更应该使用回调函数。





refer:
C语言回调函数详解 https://www.cnblogs.com/jiangzhaowei/p/9129105.html
怎么使用回调函数制作libvendor.so文件: https://blog.csdn.net/morixinguan/article/details/65494239
静态库和动态库的使用和制作方法 https://blog.csdn.net/morixinguan/article/details/52451612








========================================
《POSIX 线程编程》：C 与多线程 //todo
----------------------------------------

1. 实例引入

$ cat multi_thread.c
#include <stdio.h>   
#include <pthread.h>  
#include <time.h>
//#include <windows.h>//使用Sleep的头
#include <unistd.h>

int g_number = 0;

#define MAX_COUNT 10000

//pthread_mutex_t mut;

void *counter3(void* args) {
	int i = 1;
	while (i <= MAX_COUNT / 4) {
		//pthread_mutex_lock(&mut);
		g_number++;
		//pthread_mutex_unlock(&mut);
		printf("hi,i am pthread 3, my g_number is [%d]\n", g_number);
		//Sleep(1);// 单位ms
		//sleep(1);// 单位s
		i++;
	}
}

void *counter4(void* args) {
	int j = 1;
	while (j <= MAX_COUNT / 4) {
		//pthread_mutex_lock(&mut);
		g_number++;
		//pthread_mutex_unlock(&mut);
		printf("hi,i am pthread 4, my g_number is [%d]\n", g_number);
		//sleep(1);
		j++;
	}
}

int main() {
	printf("没加互斥锁：非线程安全的\n");
	//pthread_mutex_init(&mut, NULL);
	pthread_t t3;
	pthread_t t4;
	pthread_create(&t3, NULL, counter3, NULL);
	pthread_create(&t4, NULL, counter4, NULL);

	getchar(); //这句不加就不显示任何数字，直接结束了。
	return 0;
}

在linux上执行gcc thread.c,  结果出现编译错误undefined reference to 'pthread_create'。由于pthread库不是标准linux库， 所以出错。 改为gcc thread.c -lpthread 即可。

$ gcc multi_thread.c -lpthread
$ ./a.out 
没加互斥锁：非线程安全的
hi,i am pthread 3, my g_number is [1]
hi,i am pthread 4, my g_number is [2]
... 很快就出现不同步的情况了
hi,i am pthread 4, my g_number is [13]
hi,i am pthread 3, my g_number is [13]
hi,i am pthread 3, my g_number is [14]
hi,i am pthread 4, my g_number is [14]
... 可能需要重复多次才能看到
hi,i am pthread 3, my g_number is [34]
hi,i am pthread 4, my g_number is [35]
hi,i am pthread 3, my g_number is [35]
或者输出到文件。

去掉sleep函数，输出到文件，检查是否有重复数字
$ awk -F'[' '{print $2}' 0.out | sed 's/\]//'| sort|uniq -c|sort -k1nr | head
      2 1029
      2 1066
      2 1074
      2 1173
      2 1236
      2 1250
      2 1282
$ awk -F'[' '{print $2}' 0.out | sed 's/\]//'| sort|uniq -c|sort -k1nr | awk '$1>1'|wc
    116     232    1481




(2) 尝试加互斥锁
把原文的互斥锁的注释打开。

互斥对象是这样工作的。如果线程 a 试图锁定一个互斥对象，而此时线程 b 已锁定了同一个互斥对象时，线程 a就将进入睡眠状态。一旦线程 b 释放了互斥对象（通过 pthread_mutex_unlock() 调用），线程 a就能够锁定这个互斥对象（换句话说，线程 a 就将从 pthread_mutex_lock()函数调用中返回，同时互斥对象被锁定）。同样地，当线程 a 正锁定互斥对象时，如果线程 c 试图锁定互斥对象的话，线程 c也将临时进入睡眠状态。对已锁定的互斥对象上调用 pthread_mutex_lock()的所有线程都将进入睡眠状态，这些睡眠的线程将“排队”访问这个互斥对象。

通常使用 pthread_mutex_lock() 和 pthread_mutex_unlock()来保护数据结构。这就是说，通过线程的锁定和解锁，对于某一数据结构，确保某一时刻只能有一个线程能够访问它。可以推测到，当线程试图锁定一个未加锁的互斥对象时，POSIX线程库将同意锁定，而不会使线程进入睡眠状态。

注意：全局变量的操作都要放到互斥锁中，否则可能出现累加互斥了，但是打印没有互斥的情况，输出还是有重复数字。

$ cat multi_thread2.c
#include <stdio.h>   
#include <pthread.h>  
#include <time.h>
//#include <windows.h>//使用Sleep的头
#include <unistd.h>

int g_number = 0;

#define MAX_COUNT 10000

pthread_mutex_t mut;

void *counter3(void* args) {
	int i = 1;
	while (i <= MAX_COUNT / 4) {
		pthread_mutex_lock(&mut);
		g_number++;
		printf("hi,i am pthread 3, my g_number is [%d]\n", g_number);
		pthread_mutex_unlock(&mut);
		//Sleep(1);// 单位ms
		//sleep(1);// 单位s
		i++;
	}
}

void *counter4(void* args) {
	int j = 1;
	while (j <= MAX_COUNT / 4) {
		pthread_mutex_lock(&mut);
		g_number++;
		printf("hi,i am pthread 4, my g_number is [%d]\n", g_number);
		pthread_mutex_unlock(&mut);
		//sleep(1);
		j++;
	}
}

int main() {
	printf("加互斥锁：线程安全的\n");
	pthread_mutex_init(&mut, NULL);
	pthread_t t3;
	pthread_t t4;
	pthread_create(&t3, NULL, counter3, NULL);
	pthread_create(&t4, NULL, counter4, NULL);

	getchar();
	return 0;
}

$ gcc multi_thread2.c -lpthread
$ ./a.out 
hi,i am pthread 4, my g_number is [2]
hi,i am pthread 3, my g_number is [1]
hi,i am pthread 4, my g_number is [3]
hi,i am pthread 3, my g_number is [4]
hi,i am pthread 4, my g_number is [5]
hi,i am pthread 3, my g_number is [6]
hi,i am pthread 4, my g_number is [7]
hi,i am pthread 3, my g_number is [8]
...
hi,i am pthread 3, my g_number is [27]
hi,i am pthread 4, my g_number is [28]
hi,i am pthread 3, my g_number is [29]
hi,i am pthread 4, my g_number is [30]
顺序可能会变(比如2,1)，但是值没有重复的。


去掉sleep函数，输出到文件，检查是否有重复数字
$ awk -F'[' '{print $2}' 1.out | sed 's/\]//'| sort|uniq -c|sort -k1nr | head
     1 
      1 1
      1 10
      1 100
      1 1000
      1 1001

$ awk -F'[' '{print $2}' 1.out | sed 's/\]//'| sort|uniq -c|sort -k1nr | awk '$1>1'|wc
 0       0       0

小结：之前把g++放到锁内，把printf放到锁外，还是有重复的。要把全局对象的操作都放到锁内，才能保证输出没有重复。






2. pthread_create() 函数

pthread_create是（Unix、Linux、Mac OS X）等操作系统的创建线程的函数。它的功能是创建线程（实际上就是确定调用该线程函数的入口点），在线程创建以后，就开始运行相关的线程函数。
pthread_create的返回值表示成功，返回0；表示出错，返回表示-1。

函数原型声明：
#include <pthread.h>
int pthread_create(
	pthread_t *restrict tidp,   //新创建的线程ID指向的内存单元。
	const pthread_attr_t *restrict attr,  //线程属性，默认为NULL
	void *(*start_rtn)(void *), //新创建的线程从start_rtn函数的地址开始运行
	void *restrict arg //默认为NULL。若上述函数需要参数，将参数放入结构中并将地址作为arg传入。
);


(1) 传递参数注意的问题
问题：
避免直接在传递的参数中传递发生改变的量，否则会导致结果不可测。
即使是只再创造一个单线程，也可能在线程未获取传递参数时，线程获取的变量值已经被主线程进行了修改。

通常解决方案：
重新申请一块内存，存入需要传递的参数，再将这个地址作为arg传入。


(2) 使用时注意防止内存泄漏
在默认情况下通过pthread_create函数创建的线程是非分离属性的，由pthread_create函数的第二个参数决定，在非分离的情况下，当一个线程结束的时候，它所占用的系统资源并没有完全真正的释放，也没有真正终止。

只有在pthread_join函数返回时，该线程才会释放自己的资源。
或者是设置在分离属性的情况下，一个线程结束会立即释放它所占用的资源。

如果要保证创建线程之后，确保无内存泄漏，必须采用如下方法来规范pthread_create的使用:


1)设置线程是detached（分离属性的）
void run() { 
    return;
} 

int main(){ 
    pthread_t thread; 
    pthread_attr_t attr; 
    pthread_attr_init( &attr ); 
    pthread_attr_setdetachstate(&attr,1); 
    pthread_create(&thread, &attr, run, 0); //第二个参数决定了分离属性

    //...... 
    return 0; 
}
也有人不赞成这样做，原因：


2) 配套使用pthread_join()函数
pthread_join()函数会一直阻塞调用线程，直到指定的线程终止。当pthread_join()返回之后，应用程序可回收与已终止线程关联的任何数据存储空间。
但是，同时需要注意，一定要和上面创建的某一线程配套使用，这样还可以起到互斥的作用。否则多线程可能抢占CPU资源，导致运行结果不确定。

牛客一道题目： 下面程序输出结果是什么？（不能确定）

#include<stdio.h>
#include<string.h>
#include <pthread.h>

void* print1(void* data){
    printf("1 ");
}

void* print2(void* data){
    printf("2 ");
}

void* print3(void* data){
    printf("3 ");
}

int main(void){
    pthread_t t,t1,t2;

    pthread_create(&t,0,print1,NULL);
    pthread_create(&t1,0,print2,NULL);
    pthread_create(&t2,0,print3,NULL);

    pthread_join(t,NULL);
    pthread_join(t1,NULL);
    pthread_join(t2,NULL);
    printf("\n");
	return 0;
}

$ gcc 03.c -lpthread

执行10次，顺序都不一样。
$ seq 1 10|while read id; do ./a.out; done;
1 2 3 
2 1 3 
1 3 2 
1 2 3 
1 2 3 
1 2 3 
1 3 2 
1 2 3 
1 3 2 
2 1 3

对于大多数多线程，可能并不要求返回顺序，因为每个任务都有些差异。
但是如果要求返回顺序，则需要设置阻塞。

int main(void){
    pthread_t t,t1,t2;

    pthread_create(&t,0,print1,NULL);
    pthread_join(t,NULL);
    
	pthread_create(&t1,0,print2,NULL);
    pthread_join(t1,NULL);
	
    pthread_create(&t2,0,print3,NULL);
    pthread_join(t2,NULL);

    printf("\n");
	return 0;
}
执行顺序保证了，因为pthread_join阻塞着，等结束才能继续。
$ seq 1 10|while read id; do ./a.out; done;
1 2 3 
1 2 3 



函数原型：
int pthread_join(
	pthread_t tid, //需要等待的线程,指定的线程必须位于当前的进程中，而且不得是分离线程
	void **status  //线程tid所执行的函数返回值（返回值地址需要保证有效），其中status可以为NULL
);
pthread非linux系统的默认库， 需手动链接-线程库 -lpthread

返回值：
调用成功返回0.
ESRCH 描述: 没有找到与给定的线程ID 相对应的线程。（如果多个线程等待同一个线程终止，则所有等待线程将一直等到目标线程终止。然后一个等待线程成功返回。其余的等待线程将失败返回ESRCH错误）
EDEADLK 描述: 将出现死锁，如一个线程等待其本身，或者线程A和线程B 互相等待。
EINVAL 描述: 与给定的线程ID相对应的线程是分离线程。




ref:
https://blog.csdn.net/gisxs/article/details/17115981






========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------




========================================
----------------------------------------

========================================
----------------------------------------






========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------




========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------




========================================
----------------------------------------

========================================
----------------------------------------






========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------
