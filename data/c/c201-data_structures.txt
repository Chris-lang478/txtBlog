数据结构

这是个体力活，需要时间、体力。
看得多了，练得多了，自然就会了，精通了。

https://www.geeksforgeeks.org/array-data-structure/?ref=ghm

线性表 
栈和队列 
串
数组和广义表
树和二叉树
图
查找 
排序 



========================================
数据结构前言，及学习资料
----------------------------------------
1. 例子引入
(1) 图像修复技术
如何把人在海边的照片中，去掉人及其阴影。

关键技术：
	分成小块，“搜索”统计特征相同的小块。 -- 数据结构
	小块的边界处理。 -- 信号处理

在本图片中找不到统计特性相同的小块怎么办？
	网上搜索，参考其他图片。

(2) 水的模拟：粒子系统
用小球模拟，小球很小时候就近似表示液体了。
关键技术：
	多个小球模拟水的非线性运动
	例子多，效果好，运算量大
	如何减少运动量？中间用打球

(3) 人工智能

(4) 区块链
区(节点)+hash表+链表+分布式




2. 启示
(1)从生活和实际需求出发 -- 观察
抽象出模型 -- 数学模型 -- 才能解决它
程序模拟 -- 与其他方法的比较

实际问题 --> 模型 --> 模型的形式 
 --> 解决方案 --> 评估 --> 提出新的问题
 --> 实际应用


(2) 两个最重要的能力
抽象：不抽象，无法深入思考
还原：不还原，看不到本来面目。编码实现落地。

(3) 思维
计算机思维：是一个解决问题的流程。
理工科思维：数据、量化、逻辑 



3. 具体题目引入

有100桶水，中间有一桶含有害物质，一个志愿者可以试喝一桶或几桶中的水，喝到有害物质哪一桶2小时后会出现恶心、呕吐等症状，20min后恢复正常。请问要在3h内鉴定出是哪一桶，至少需要几个志愿者？

分析：2小时后有反应，没有机会试下一次了，也就是说没人只有一次机会，二分法无效？一次可以尝试喝n桶。

参考答案是：一个志愿者只测试一次，但是一次可以喝很多桶的水。
使用二进制表示喝与不喝，则共表示多少个编码？
1位: 1
2位: 1+2=3=2^2-1
3位: 1+2+4=7=2^3-1
6位: 2^6-1=63
7位: 2^7-1=127 种。

现在共有7个杯子，把1-100个桶编号写成二进制，比如
1号桶编号 0000001，则在#7杯中添加少量1号桶液体；
2号桶编号 0000010，则在#6杯中添加少量2号桶液体；
69=(2^6+2^2+1)2，1000101，则在#1,#5,#7号杯中添加液体。 
100=64+32+4=(1100100)，则在第#1,#2,#5号杯中添加液体。

任何一个桶中的异常，都对应着唯一一个二进制。
就看谁20分钟后呕吐了，就能组装好二进制，进而转为10进制，知道是哪一桶。



(2) 为什么是二进制？
因为和逻辑判断对应！
具体问题 转化为 逻辑问题，然后进一步 可编程问题。






4. 数据结构的学习
(1) 课程目标：解决什么问题？
(2) 解决这些问题的方法是什么？
是系统的方法还是一门技术？
(3) 有哪些实际应用？
如何运用这些理论和方法解决其他的问题，见前面的例子。



5. 如何学习数据结构？
三多
(1) 多动脑
深入理解问题的本质，抽象出模型

(2) 多动笔
纸上推演，深刻领会

(3) 多动手
上机编程实践


深度思考比勤奋编码更重要！




6. 书本资料
(1) 严蔚敏 清华大学出版社
《数据结构》C语言版
《数据结构题集》C语言版

学时 48(讲课+ 实验+演示)


(2) 




7. 视频资料
https://www.bilibili.com/video/BV15E411V7S2?p=2








========================================
数据结构绪论
----------------------------------------

1. 如何找最大值和次最大值？
方法1: 排序肯定可以，但是做多余计算了。
方法2: 一次循环求出最大值，第二次循环找出小于最大值的最大数。
https://github.com/miostudio/linux_C/tree/master/practice 练习题 p77.c 

方法3: 采用淘汰制或许更快。紧邻的两个比较，保留较大的，然后重复执行。
最后剩下的一个就是最大值。
而和最大值直接比较的才可能是次最大值。
//todo 不知道怎么记录和最大值比较的变量。


(2) 解决问题
- 找出一个解决方案
- 找出最优解。
	节省CPU
	节省内存


1) 判断表达式中括号是否匹配
简单版: 统计每个char，是(计数器+1，是)计数器-1,最后如果计数器==0，则匹配，否则不匹配。
反例：如果是 f=)a+b(; 符合上述程序，但是只能判断为不匹配。

2) 交叉路口交通管理系统
栈和队列。

3) 走迷宫问题。


(3) 非数值计算的程序设计问题
- 数据结构：数学 + 软件 + 硬件。
- 实际问题 抽象 -> 模型化，便于处理 ->存储结构，便于存放，算法 -> 分析 -> 回归模型，解释说明原始问题。









2. 数据结构的三个方面

(1) 逻辑结构
线性结构：线性表、栈，对，串，数组
非线性结构：树，图

- 集合：没有逻辑结构
- 线性结构：右前后关系，前驱元素，后继元素
- 树形结构：分叉
- 图形结构(网状结构)


(2) 物理结构/存储结构
- 顺序存储：连续的存储
- 链式存储：存储空间不要求连续，依靠指针关联前后
- 索引存储：索引也要占空间
- 散列存储：

(3) 数据的运算
基本的：插入、删除、修改、查找、排序
+-*/
字符串的复制、追加、截取、比较大小、查找等。







3. 抽象数据类型(ADT)
(1) Abstract Data Type, ADT.

ADT 是值一个数学模型，以及定义在该模型上的一组操作。
抽象数据类型=逻辑结构 + 数据运算的定义。
ADT是描述数据结构的一种理论工具，关注的是数据结构的特性，与物理结构、数据运算的实现无关，与编程语言也无关。


(2) 抽象数据类型的定义 (D,S,P)
- D 数据对象
- S 是D中数据元素关系的集合
- P 是对D的基本操作的集合。

ADT 抽象数据类型名{
	数据对象: <数据对象的定义>
	数据关系: <数据关系的定义>
	基本操作: <基本操作的定义>
} ADT 抽象数据类型名







4. 实现主要靠指针 + 结构体

C/C++越是底层的代码越是指针非常多，特别是二级甚至多级指针，还有非常复杂的函数指针。比如链表、红黑树、map、set、图等等各种数据结构底层实现都需要指针，指针拿到的是内存地址，修改数据非常方便，同时也避免大的结构体复制浪费内存。

尤其是函数指针、多级指针等，如果没有函数指针，那么回调、动态编程、泛型编程等基本没法实现了。







第3章 表、栈和队列
第4章 树
第5章 散列
第6章 优先队列（堆）

线性表：顺序表、链表、栈、队列

数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；


1. 视频课程 
Java：https://www.bilibili.com/video/BV1M7411f7aU?p=2

清华大学邓俊辉 数据结构 C/C++: https://www.bilibili.com/video/BV1C54y1L7JM?p=4

考研数据结构 https://www.bilibili.com/video/BV1oN411Q7Yz?p=2



2. 文字教程

https://www.cprogramming.com/algorithms-and-data-structures.html?inl=nv






========================================
数组
----------------------------------------
在C是基本数据结构，在内存中连续空间中存储。The elements are stored at contiguous memory locations 
常见的有栈数组。
还可以动态分配空间，保存堆中。

1. 数组初始化

(1) 先声明再赋值
int arr1[10];
arr1[0]=10;
arr1[2]=22;

(2) 一步
int arr[6] = { 10, 20, 30, 40 }



2. 查看地址
//查看元素在内存中的地址
#include <stdio.h>
int main(){
    int arr[5], i;

    printf("Size of integer in this compiler is %lu\n", sizeof(int));

    for (i = 0; i < 5; i++)
        // The use of '&' before a variable name, yields address of variable.
        printf("Address arr[%d] is %p\n", i, &arr[i]);
    return 0;
}

输出：
Size of integer in this compiler is 4
Address arr[0] is 0x7ffef77bd3d0
Address arr[1] is 0x7ffef77bd3d4
Address arr[2] is 0x7ffef77bd3d8
Address arr[3] is 0x7ffef77bd3dc
Address arr[4] is 0x7ffef77bd3e0







ref: https://www.cnblogs.com/zhujialei123/p/9182069.html






========================================
链表：单链表
----------------------------------------

1. 概念
一旦链表中某个节点的指针域数据丢失，那么意味着将无法找到下一个节点，该节点后面的数据将全部丢失。


前一个元素叫 前驱元素。
后一个元素叫 后继元素。
head -> note -> end -> NULL;

| next|  -> |d1, next| -> |d2, next| -> |NULL|
head 头元素没有值，只有一个指向下一个节点的指针。
end 末尾元素的指针指向NULL。
中间节点node都是有值，并指向下一个节点。



(2) 常见操作
作为有强大功能的链表，对他的操作当然有许多，比如：链表的创建，修改，删除，插入，输出，排序，反序，清空链表的元素，求链表的长度等等。






2. 单链表

(1) 单链表的创建与输出

$ cat 01.c 
#include<stdio.h>
#include<stdlib.h>

//定义链表数据类型，数据，及指向下一个元素的指针
typedef struct student{
	int score;
	struct student *next;
} LinkList;


//创建链表
LinkList *create(int n){
	LinkList *head, *node, *end;
	head=(LinkList *)malloc(sizeof(LinkList)); //get address
	end=head; //if empty, head and end are the same
	
	printf("请输入需要创建的%d个链表的值，回车结束\n", n);
	for(int i=0; i<n; i++){
		node=(LinkList *)malloc(sizeof(LinkList));
		scanf("%d", &node->score);
		end->next=node;//point to the last end
		end=node; //the new end;
	}
	end->next=NULL; //the last node
	return head;
}

//输出链表 
void print(LinkList* h){
	while(h->next!=NULL){
		h=h->next;
		printf("value=%d, next:%p\n", h->score, h->next );
	}
}


int main(){
	int N=3;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	return 0;
}

$ ./a.out 
请输入需要创建的3个链表的值，回车结束
10 20 30
value=10, next:0x55c10cf6fac0
value=20, next:0x55c10cf6fae0
value=30, next:(nil)



(2) 单链表删除节点
把前一个元素的指针指向下一个元素即可。

//把等于某个值的节点都删除
void delete(LinkList *h, int val){
	LinkList *pre;
	int flag=0;
	while(h->next!=NULL){
		pre=h;
		h=h->next;
		if(h->score==val){
			flag+=1;
			pre->next = h->next;
			free(h); //释放该节点内存
			
			if(pre->next != NULL){
				h=pre->next; //当前节点指向下一个节点
			}else{
				h=pre; //下一节点为NULL则指向上一个节点
			}
		}
	}
	if(!flag){
		printf("没有可删除的元素。\n");
	}else{
		printf("删除了%d个元素\n", flag);
	}
}


int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("输入要删除元素的值\n");
	int del;
	scanf("%d", &del);
	delete(h, del);
	
	print(h);

	return 0;
}


测试，注意删除头尾时是否异常。

$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 30 20
value=10, next:0x559107f84ac0
value=20, next:0x559107f84ae0
value=30, next:0x559107f84b00
value=20, next:(nil)
输入要删除元素的值
20
删除了2个元素
value=10, next:0x559107f84ae0
value=30, next:(nil)




(3) 单节点修改元素
单循环，遇到相等的直接修改即可。

//修改链表的值 
void sup(LinkList* h, int old, int new){
	while(h->next!=NULL){
		h=h->next;
		if(h->score == old){
			h->score = new;
		}
	}
}


int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("输入要替换元素的值, old new\n");
	int new, old;
	scanf("%d %d", &old, &new);
	sup(h, old, new);
	
	print(h);
	return 0;
}


$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 30 40
value=10, next:0x557f8f103ac0
value=20, next:0x557f8f103ae0
value=30, next:0x557f8f103b00
value=40, next:(nil)
输入要替换元素的值, old new
40 -400
value=10, next:0x557f8f103ac0
value=20, next:0x557f8f103ae0
value=30, next:0x557f8f103b00
value=-400, next:(nil)



(4) 插入新元素
操作指针的时候要防止覆盖，先移动新节点指向后一个指针，再移动当前节点指向新节点。

//在第n个元素后添加新元素val
void insert(LinkList* h, int n, int val){
	int i=0;
	LinkList *pre;
	LinkList* node=(LinkList*)malloc(sizeof(LinkList));
	node->score=val;
	while(h->next != NULL){
		if(i==n){
			break;
		}
		h=h->next;
		i++;
	}
	//如果插入位置在最后一个位置后面，则特殊考虑
	if(i==n){
		node->next=h->next; //null
		h->next=node;
	}else if(i<n){
		free(node);  //如果没有插入值，额释放新建元素的内存
		printf("链表总长度为%d，没有第%d个元素，插入失败\n", i, n);
	}
}

int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("输入要插入元素的位置和值, nth val\n");
	int nth, val;
	scanf("%d %d", &nth, &val);
	insert(h, nth, val);
	
	print(h);
	return 0;
}

$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 30 40
value=10, next:0x56121fbccac0
value=20, next:0x56121fbccae0
value=30, next:0x56121fbccb00
value=40, next:(nil)
输入要插入元素的位置和值, nth val
3 -300
value=10, next:0x56121fbccac0
value=20, next:0x56121fbccae0
value=30, next:0x56121fbccb20
value=-300, next:0x56121fbccb00
value=40, next:(nil)




(5) 求链表的长度
遍历，计数即可。

//链表长度
int length(LinkList* h){
	int i=0;
	while(h->next != NULL){
		h=h->next;
		i++;
	}
	return i;
}


(6) 排序
直接采用冒泡或者选择排序，而且不是交换结点，只交换数据域。

// 冒泡法排序
void sort(LinkList *h){
	LinkList *h2;
	while(h->next != NULL){
		h=h->next;
		h2=h;
		while(h2->next != NULL){
			h2=h2->next;
			if(h->score > h2->score){
				int tmp= h->score;
				h->score=h2->score;
				h2->score=tmp;
			}
		}
	}
}

int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("排序后\n");
	sort(h);  //排序
	print(h);
	return 0;
}


$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 -30 -40
value=10, next:0x559f23cc9ac0
value=20, next:0x559f23cc9ae0
value=-30, next:0x559f23cc9b00
value=-40, next:(nil)
排序后
value=-40, next:0x559f23cc9ac0
value=-30, next:0x559f23cc9ae0
value=10, next:0x559f23cc9b00
value=20, next:(nil)



(7) 反序
就是把指针倒置。然后返回end的地址。
需要一个辅助节点，保存上一个的地址元素。
//LinkList *pre, *cur=(LinkList*)malloc(sizeof(LinkList)); //当前节点，用于暂存被覆盖的当前节点的下一个元素
就使用head元素当辅助节点了。

//反序
void reverse(LinkList* h){
	LinkList *pre, *cur;
	
	//销毁head元素
	cur=h;
	h=h->next;
	cur->next = NULL;
	
	while(h->next != NULL){
		pre=h;
		h=h->next;

		//翻转指针
		pre->next = cur->next;
		
		//备份上一个节点坐标
		cur->next = pre;
	}
	//翻转最后一个指针
	h->next = cur->next;
	cur->next=h;
	h=cur;
}


int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("反序后\n");
	reverse(h);
	print(h);
	return 0;
}


$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 30 40
value=10, next:0x56066edd6ac0
value=20, next:0x56066edd6ae0
value=30, next:0x56066edd6b00
value=40, next:(nil)
反序后
value=40, next:0x56066edd6ae0
value=30, next:0x56066edd6ac0
value=20, next:0x56066edd6690
value=10, next:(nil)
没看懂翻转前后地址的关系，有点乱。
应该是对的，主要核对中间节点的地址。


## 试一下6个数
请输入需要创建的6个链表的值，回车结束
10 20 -30 -40 50 -600
value=10, next:0x56372c9c8ac0
value=20, next:0x56372c9c8ae0
value=-30, next:0x56372c9c8b00
value=-40, next:0x56372c9c8b20
value=50, next:0x56372c9c8b40
value=-600, next:(nil)
反序后
value=-600, next:0x56372c9c8b20
value=50, next:0x56372c9c8b00
value=-40, next:0x56372c9c8ae0
value=-30, next:0x56372c9c8ac0
value=20, next:0x56372c9c8690
value=10, next:(nil)


(8) 获取第n个元素的值
预期像数组一样，首个元素下标是0.

int getEle(LinkList* h, int n){
	int i=0;
	while(h->next != NULL){
		h=h->next;
		if(i==n){
			return h->score;
		}
		i++;
	}
	printf("Error: arr length(%d) < n(%d)\n", i, n);
	return -1;
}

int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("输出第几个元素?\n");
	int n;
	scanf("%d", &n);
	printf("the %dth ele is %d\n", n, getEle(h, n));
	return 0;
}


$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 30 40
value=10, next:0x56320cdb0ac0
value=20, next:0x56320cdb0ae0
value=30, next:0x56320cdb0b00
value=40, next:(nil)
输出第几个元素?
2
the 2th ele is 30



(9) 清空链表的元素
记得使用free释放内存!
节点被删除后，只是将它从链表中断开而已，它仍占用着内存，必须释放其所占的内存，否则将出现内存泄漏.

void freeAll(LinkList* h){
	LinkList* pre;
	while(h->next != NULL){
		pre=h;
		h=h->next();
		free(pre);
	}
	free(h); //尾节点
}

int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	//释放节点空间
	freeAll(h);
	return 0;
}






ref: https://blog.csdn.net/Endeavor_G/article/details/80552680



========================================
链表：双向链表 //todo
----------------------------------------








========================================
堆与栈
----------------------------------------
现代计算机把内存分为三种类型：栈内存、堆内存、程序内存。

堆更容易解释，因为它就是你电脑中的剩余内存，你可以通过malloc访问它来获取更多内存，OS会使用内部函数为你注册一块内存区域，并且返回指向它的指针。当你使用完这片区域时，你应该使用free把它交还给OS，使之能被其它程序复用。如果你不这样做就会导致程序“泄露”内存，但是Valgrind会帮你监测这些内存泄露。


栈是一个特殊的内存区域，它储存了每个函数的创建的临时变量，它们对于该函数为局部变量。它的工作机制是，函数的每个函数都会“压入”栈中，并且可在函数内部使用。它是一个真正的栈数据结构，所以是后进先出的。这对于main中所有类似char section和int id的局部变量也是相同的。使用栈的优点是，当函数退出时C编译器会从栈中“弹出”所有变量来清理。这非常简单，也防止了栈上变量的内存泄露。


理清内存的最简单的方式是遵守这条原则：如果你的变量并不是从malloc中获取的，也不是从一个从malloc获取的函数中获取的，那么它在栈上。



下面是三个值得关注的关于栈和堆的主要问题：
- 如果你从malloc获取了一块内存，并且把指针放在了栈上，那么当函数退出时，指针会被弹出而丢失。
- 如果你在栈上存放了大量数据（比如大结构体和数组），那么会产生“栈溢出”并且程序会中止。这种情况下应该通过malloc放在堆上。
- 如果你获取了指向栈上变量的指针，并且将它用于传参或从函数返回，接收它的函数会产生“段错误”。因为实际的数据被弹出而消失，指针也会指向被释放的内存。


最后，当一个程序退出时，OS会为你清理所有的资源，但是有时不会立即执行。一个惯用法（也是本次练习中用到的）是立即终止并且让OS清理错误。



1. 

$ cat 01.c
#include<stdio.h>
#include<stdlib.h>
int a = 0; //全局初始化区
char *p1; //全局未初始化区
int main() {
	int b; //栈
	char s1[] = "abc"; //栈
	char *p2; //栈
	char *p3 = "123456";  //123456\0在常量区，p3在栈上。
	static int c =0;   //全局（静态）初始化区
	p1 = (char *)malloc(10);  //堆
	p2 = (char *)malloc(20);  //堆
	
	printf("%p(a)\n", &a);
	printf("%p(b)\n", &b);
	printf("%p(c)\n", &c);
	
	printf("%p(p1) -> %p\n", &p1, p1);
	printf("%p(p2) -> %p\n", &p2, p2);
	printf("%p(p3) -> %p\n", &p3, p3);
	printf("%p(s1) -> %p %p %p\n", &s1, s1, &s1[0], &s1[1]);
	return 0;
}

输出： 
0x559eac04b014(a)
0x7fff7b4072bc(b)
0x559eac04b018(c)
0x559eac04b020(p1) -> 0x559ead427260
0x7fff7b4072c0(p2) -> 0x559ead427280
0x7fff7b4072c8(p3) -> 0x559eabe4a8b4
0x7fff7b4072d4(s1) -> 0x7fff7b4072d4 0x7fff7b4072d4 0x7fff7b4072d5

三个常量，b在栈，a和c在堆。
四个指针变量，p1 在堆，p2,p3,s1在栈。
	直接初始化的字符数组就在栈上。







========================================
|-- 栈
----------------------------------------

栈内存严格按照“先入后出”的原则。通常使用栈的顶部进行操作，数据在栈顶“入栈”，之后还是在栈顶“出栈”。

栈内存用来干嘛呢？栈内存也叫调用栈，每一个C程序都由它来控制其函数执行的流程。具体点说，就是栈内存分为很多栈帧，每个栈帧里面保存一个函数的信息，按照程序中函数的调用顺序依次入栈，再依次出栈来实现函数的调用次序。

栈帧保存了每一个函数的返回位置、实参、局部变量、返回值地址。

调用栈规则：
1.如果函数返回了一个值，这个值（包括地址和值）会被写到该函数对应栈帧的一个局部变量中。
2.如果函数有局部变量，局部变量被保存在栈帧。
3.如果函数有实参，实参也被保存在栈帧。
4.函数的返回位置也要保存在栈帧。一般返回位置就是函数调用之后的行编号。
5.如果相同函数在不同行被调用，则每个调用都有一个相应的返回位置。
6.一个函数执行结束后，程序将从栈顶部栈帧中的返回位置（行编号）处继续执行。栈顶栈帧随即被弹出。

总结
推荐使用DDD（命令行调试程序）来检测调用栈。



========================================
队列 //todo
----------------------------------------





========================================
树: 二叉树 //todo
----------------------------------------



========================================
散列表(hash 表，又叫关联数组) //todo
----------------------------------------


========================================
图、Trie 树 //todo
----------------------------------------


========================================
并查集 //todo
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

