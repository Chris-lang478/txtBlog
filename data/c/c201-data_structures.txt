数据结构


========================================
概述与教程
----------------------------------------
第3章 表、栈和队列
第4章 树
第5章 散列
第6章 优先队列（堆）

线性表：顺序表、链表、栈、队列

数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；


1. 视频课程 
不好：https://www.bilibili.com/video/BV1M7411f7aU?p=2








========================================
数组 //todo
----------------------------------------



========================================
链表 //todo
----------------------------------------

1. 前一个元素叫 前驱元素。
后一个元素叫 后继元素。








========================================
堆与栈
----------------------------------------
现代计算机把内存分为三种类型：栈内存、堆内存、程序内存。

堆更容易解释，因为它就是你电脑中的剩余内存，你可以通过malloc访问它来获取更多内存，OS会使用内部函数为你注册一块内存区域，并且返回指向它的指针。当你使用完这片区域时，你应该使用free把它交还给OS，使之能被其它程序复用。如果你不这样做就会导致程序“泄露”内存，但是Valgrind会帮你监测这些内存泄露。


栈是一个特殊的内存区域，它储存了每个函数的创建的临时变量，它们对于该函数为局部变量。它的工作机制是，函数的每个函数都会“压入”栈中，并且可在函数内部使用。它是一个真正的栈数据结构，所以是后进先出的。这对于main中所有类似char section和int id的局部变量也是相同的。使用栈的优点是，当函数退出时C编译器会从栈中“弹出”所有变量来清理。这非常简单，也防止了栈上变量的内存泄露。


理清内存的最简单的方式是遵守这条原则：如果你的变量并不是从malloc中获取的，也不是从一个从malloc获取的函数中获取的，那么它在栈上。



下面是三个值得关注的关于栈和堆的主要问题：
- 如果你从malloc获取了一块内存，并且把指针放在了栈上，那么当函数退出时，指针会被弹出而丢失。
- 如果你在栈上存放了大量数据（比如大结构体和数组），那么会产生“栈溢出”并且程序会中止。这种情况下应该通过malloc放在堆上。
- 如果你获取了指向栈上变量的指针，并且将它用于传参或从函数返回，接收它的函数会产生“段错误”。因为实际的数据被弹出而消失，指针也会指向被释放的内存。


最后，当一个程序退出时，OS会为你清理所有的资源，但是有时不会立即执行。一个惯用法（也是本次练习中用到的）是立即终止并且让OS清理错误。





========================================
|-- 栈
----------------------------------------

栈内存严格按照“先入后出”的原则。通常使用栈的顶部进行操作，数据在栈顶“入栈”，之后还是在栈顶“出栈”。

栈内存用来干嘛呢？栈内存也叫调用栈，每一个C程序都由它来控制其函数执行的流程。具体点说，就是栈内存分为很多栈帧，每个栈帧里面保存一个函数的信息，按照程序中函数的调用顺序依次入栈，再依次出栈来实现函数的调用次序。

栈帧保存了每一个函数的返回位置、实参、局部变量、返回值地址。

调用栈规则：
1.如果函数返回了一个值，这个值（包括地址和值）会被写到该函数对应栈帧的一个局部变量中。
2.如果函数有局部变量，局部变量被保存在栈帧。
3.如果函数有实参，实参也被保存在栈帧。
4.函数的返回位置也要保存在栈帧。一般返回位置就是函数调用之后的行编号。
5.如果相同函数在不同行被调用，则每个调用都有一个相应的返回位置。
6.一个函数执行结束后，程序将从栈顶部栈帧中的返回位置（行编号）处继续执行。栈顶栈帧随即被弹出。

总结
推荐使用DDD（命令行调试程序）来检测调用栈。



========================================
队列 //todo
----------------------------------------





========================================
树: 二叉树 //todo
----------------------------------------



========================================
散列表(hash 表，又叫关联数组) //todo
----------------------------------------


========================================
图、Trie 树 //todo
----------------------------------------


========================================
并查集 //todo
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

