数据结构

这是个体力活，需要时间、体力。
看得多了，练得多了，自然就会了，精通了。




========================================
概述与教程
----------------------------------------
1. 数据结构的三个方面

(1) 逻辑结构
- 集合：没有逻辑结构
- 线性结构：右前后关系，前驱元素，后继元素
- 树形结构：分叉
- 图形结构(网状结构)

(2) 物理结构/存储结构
- 顺序存储：连续的存储
- 链式存储：存储空间不要求连续，依靠指针关联前后
- 索引存储：索引也要占空间
- 散列存储：

(3) 数据的运算
+-*/
字符串的复制、追加、截取、比较大小、查找等。





2. 抽象数据类型(ADT)
(1) Abstract Data Type, ADT.

ADT 是值一个数学模型，以及定义在该模型上的一组操作。
抽象数据类型=逻辑结构 + 数据运算的定义。
ADT是描述数据结构的一种理论工具，关注的是数据结构的特性，与物理结构、数据运算的实现无关，与编程语言也无关。


(2) 抽象数据类型的定义 (D,S,P)
- D 数据对象
- S 是D中数据元素关系的集合
- P 是对D的基本操作的集合。

ADT 抽象数据类型名{
	数据对象: <数据对象的定义>
	数据关系: <数据关系的定义>
	基本操作: <基本操作的定义>
} ADT 抽象数据类型名










第3章 表、栈和队列
第4章 树
第5章 散列
第6章 优先队列（堆）

线性表：顺序表、链表、栈、队列

数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；


1. 视频课程 
Java：https://www.bilibili.com/video/BV1M7411f7aU?p=2

清华大学邓俊辉 数据结构 C/C++: https://www.bilibili.com/video/BV1C54y1L7JM?p=4

考研数据结构 https://www.bilibili.com/video/BV1oN411Q7Yz?p=2



2. 文字教程

https://www.cprogramming.com/algorithms-and-data-structures.html?inl=nv






========================================
数组 //todo
----------------------------------------



========================================
链表 //todo
----------------------------------------

1. 概念
一旦链表中某个节点的指针域数据丢失，那么意味着将无法找到下一个节点，该节点后面的数据将全部丢失。


前一个元素叫 前驱元素。
后一个元素叫 后继元素。
head -> note -> end -> NULL;

| next|  -> |d1, next| -> |d2, next| -> |NULL|
head 头元素没有值，只有一个指向下一个节点的指针。
end 末尾元素的指针指向NULL。
中间节点node都是有值，并指向下一个节点。



(2) 常见操作
作为有强大功能的链表，对他的操作当然有许多，比如：链表的创建，修改，删除，插入，输出，排序，反序，清空链表的元素，求链表的长度等等。






2. 单链表

(1) 单链表的创建与输出

$ cat 01.c 
#include<stdio.h>
#include<stdlib.h>

//定义链表数据类型，数据，及指向下一个元素的指针
typedef struct student{
	int score;
	struct student *next;
} LinkList;


//创建链表
LinkList *create(int n){
	LinkList *head, *node, *end;
	head=(LinkList *)malloc(sizeof(LinkList)); //get address
	end=head; //if empty, head and end are the same
	
	printf("请输入需要创建的%d个链表的值，回车结束\n", n);
	for(int i=0; i<n; i++){
		node=(LinkList *)malloc(sizeof(LinkList));
		scanf("%d", &node->score);
		end->next=node;//point to the last end
		end=node; //the new end;
	}
	end->next=NULL; //the last node
	return head;
}

//输出链表 
void print(LinkList* h){
	while(h->next!=NULL){
		h=h->next;
		printf("value=%d, next:%p\n", h->score, h->next );
	}
}


int main(){
	int N=3;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	return 0;
}

$ ./a.out 
请输入需要创建的3个链表的值，回车结束
10 20 30
value=10, next:0x55c10cf6fac0
value=20, next:0x55c10cf6fae0
value=30, next:(nil)



(2) 单链表删除节点
把前一个元素的指针指向下一个元素即可。

//把等于某个值的节点都删除
void delete(LinkList *h, int val){
	LinkList *pre;
	int flag=0;
	while(h->next!=NULL){
		pre=h;
		h=h->next;
		if(h->score==val){
			flag+=1;
			pre->next = h->next;
			free(h); //释放该节点内存
			
			if(pre->next != NULL){
				h=pre->next; //当前节点指向下一个节点
			}else{
				h=pre; //下一节点为NULL则指向上一个节点
			}
		}
	}
	if(!flag){
		printf("没有可删除的元素。\n");
	}else{
		printf("删除了%d个元素\n", flag);
	}
}


int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("输入要删除元素的值\n");
	int del;
	scanf("%d", &del);
	delete(h, del);
	
	print(h);

	return 0;
}


测试，注意删除头尾时是否异常。

$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 30 20
value=10, next:0x559107f84ac0
value=20, next:0x559107f84ae0
value=30, next:0x559107f84b00
value=20, next:(nil)
输入要删除元素的值
20
删除了2个元素
value=10, next:0x559107f84ae0
value=30, next:(nil)




(3) 单节点修改元素
单循环，遇到相等的直接修改即可。

//修改链表的值 
void sup(LinkList* h, int old, int new){
	while(h->next!=NULL){
		h=h->next;
		if(h->score == old){
			h->score = new;
		}
	}
}


int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("输入要替换元素的值, old new\n");
	int new, old;
	scanf("%d %d", &old, &new);
	sup(h, old, new);
	
	print(h);
	return 0;
}


$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 30 40
value=10, next:0x557f8f103ac0
value=20, next:0x557f8f103ae0
value=30, next:0x557f8f103b00
value=40, next:(nil)
输入要替换元素的值, old new
40 -400
value=10, next:0x557f8f103ac0
value=20, next:0x557f8f103ae0
value=30, next:0x557f8f103b00
value=-400, next:(nil)



(4) 插入新元素
操作指针的时候要防止覆盖，先移动新节点指向后一个指针，再移动当前节点指向新节点。

//在第n个元素后添加新元素val
void insert(LinkList* h, int n, int val){
	int i=0;
	LinkList *pre;
	LinkList* node=(LinkList*)malloc(sizeof(LinkList));
	node->score=val;
	while(h->next != NULL){
		if(i==n){
			break;
		}
		h=h->next;
		i++;
	}
	//如果插入位置在最后一个位置后面，则特殊考虑
	if(i==n){
		node->next=h->next; //null
		h->next=node;
	}else if(i<n){
		free(node);  //如果没有插入值，额释放新建元素的内存
		printf("链表总长度为%d，没有第%d个元素，插入失败\n", i, n);
	}
}

int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("输入要插入元素的位置和值, nth val\n");
	int nth, val;
	scanf("%d %d", &nth, &val);
	insert(h, nth, val);
	
	print(h);
	return 0;
}

$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 30 40
value=10, next:0x56121fbccac0
value=20, next:0x56121fbccae0
value=30, next:0x56121fbccb00
value=40, next:(nil)
输入要插入元素的位置和值, nth val
3 -300
value=10, next:0x56121fbccac0
value=20, next:0x56121fbccae0
value=30, next:0x56121fbccb20
value=-300, next:0x56121fbccb00
value=40, next:(nil)




(5) 求链表的长度
遍历，计数即可。

//链表长度
int length(LinkList* h){
	int i=0;
	while(h->next != NULL){
		h=h->next;
		i++;
	}
	return i;
}


(6) 排序
直接采用冒泡或者选择排序，而且不是交换结点，只交换数据域。

// 冒泡法排序
void sort(LinkList *h){
	LinkList *h2;
	while(h->next != NULL){
		h=h->next;
		h2=h;
		while(h2->next != NULL){
			h2=h2->next;
			if(h->score > h2->score){
				int tmp= h->score;
				h->score=h2->score;
				h2->score=tmp;
			}
		}
	}
}

int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("排序后\n");
	sort(h);  //排序
	print(h);
	return 0;
}


$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 -30 -40
value=10, next:0x559f23cc9ac0
value=20, next:0x559f23cc9ae0
value=-30, next:0x559f23cc9b00
value=-40, next:(nil)
排序后
value=-40, next:0x559f23cc9ac0
value=-30, next:0x559f23cc9ae0
value=10, next:0x559f23cc9b00
value=20, next:(nil)



(7) 反序
就是把指针倒置。然后返回end的地址。
需要一个辅助节点，保存上一个的地址元素。
//LinkList *pre, *cur=(LinkList*)malloc(sizeof(LinkList)); //当前节点，用于暂存被覆盖的当前节点的下一个元素
就使用head元素当辅助节点了。

//反序
void reverse(LinkList* h){
	LinkList *pre, *cur;
	
	//销毁head元素
	cur=h;
	h=h->next;
	cur->next = NULL;
	
	while(h->next != NULL){
		pre=h;
		h=h->next;

		//翻转指针
		pre->next = cur->next;
		
		//备份上一个节点坐标
		cur->next = pre;
	}
	//翻转最后一个指针
	h->next = cur->next;
	cur->next=h;
	h=cur;
}


int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("反序后\n");
	reverse(h);
	print(h);
	return 0;
}


$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 30 40
value=10, next:0x56066edd6ac0
value=20, next:0x56066edd6ae0
value=30, next:0x56066edd6b00
value=40, next:(nil)
反序后
value=40, next:0x56066edd6ae0
value=30, next:0x56066edd6ac0
value=20, next:0x56066edd6690
value=10, next:(nil)
没看懂翻转前后地址的关系，有点乱。
应该是对的，主要核对中间节点的地址。


## 试一下6个数
请输入需要创建的6个链表的值，回车结束
10 20 -30 -40 50 -600
value=10, next:0x56372c9c8ac0
value=20, next:0x56372c9c8ae0
value=-30, next:0x56372c9c8b00
value=-40, next:0x56372c9c8b20
value=50, next:0x56372c9c8b40
value=-600, next:(nil)
反序后
value=-600, next:0x56372c9c8b20
value=50, next:0x56372c9c8b00
value=-40, next:0x56372c9c8ae0
value=-30, next:0x56372c9c8ac0
value=20, next:0x56372c9c8690
value=10, next:(nil)


(8) 获取第n个元素的值
预期像数组一样，首个元素下标是0.

int getEle(LinkList* h, int n){
	int i=0;
	while(h->next != NULL){
		h=h->next;
		if(i==n){
			return h->score;
		}
		i++;
	}
	printf("Error: arr length(%d) < n(%d)\n", i, n);
	return -1;
}

int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	printf("输出第几个元素?\n");
	int n;
	scanf("%d", &n);
	printf("the %dth ele is %d\n", n, getEle(h, n));
	return 0;
}


$ ./a.out 
请输入需要创建的4个链表的值，回车结束
10 20 30 40
value=10, next:0x56320cdb0ac0
value=20, next:0x56320cdb0ae0
value=30, next:0x56320cdb0b00
value=40, next:(nil)
输出第几个元素?
2
the 2th ele is 30



(9) 清空链表的元素
记得使用free释放内存!
节点被删除后，只是将它从链表中断开而已，它仍占用着内存，必须释放其所占的内存，否则将出现内存泄漏.

void freeAll(LinkList* h){
	LinkList* pre;
	while(h->next != NULL){
		pre=h;
		h=h->next();
		free(pre);
	}
	free(h); //尾节点
}

int main(){
	int N=4;
	LinkList* h=create(N);//创建链表
	print(h);//输出链表
	
	//释放节点空间
	freeAll(h);
	return 0;
}






ref: https://blog.csdn.net/Endeavor_G/article/details/80552680







========================================
堆与栈
----------------------------------------
现代计算机把内存分为三种类型：栈内存、堆内存、程序内存。

堆更容易解释，因为它就是你电脑中的剩余内存，你可以通过malloc访问它来获取更多内存，OS会使用内部函数为你注册一块内存区域，并且返回指向它的指针。当你使用完这片区域时，你应该使用free把它交还给OS，使之能被其它程序复用。如果你不这样做就会导致程序“泄露”内存，但是Valgrind会帮你监测这些内存泄露。


栈是一个特殊的内存区域，它储存了每个函数的创建的临时变量，它们对于该函数为局部变量。它的工作机制是，函数的每个函数都会“压入”栈中，并且可在函数内部使用。它是一个真正的栈数据结构，所以是后进先出的。这对于main中所有类似char section和int id的局部变量也是相同的。使用栈的优点是，当函数退出时C编译器会从栈中“弹出”所有变量来清理。这非常简单，也防止了栈上变量的内存泄露。


理清内存的最简单的方式是遵守这条原则：如果你的变量并不是从malloc中获取的，也不是从一个从malloc获取的函数中获取的，那么它在栈上。



下面是三个值得关注的关于栈和堆的主要问题：
- 如果你从malloc获取了一块内存，并且把指针放在了栈上，那么当函数退出时，指针会被弹出而丢失。
- 如果你在栈上存放了大量数据（比如大结构体和数组），那么会产生“栈溢出”并且程序会中止。这种情况下应该通过malloc放在堆上。
- 如果你获取了指向栈上变量的指针，并且将它用于传参或从函数返回，接收它的函数会产生“段错误”。因为实际的数据被弹出而消失，指针也会指向被释放的内存。


最后，当一个程序退出时，OS会为你清理所有的资源，但是有时不会立即执行。一个惯用法（也是本次练习中用到的）是立即终止并且让OS清理错误。





========================================
|-- 栈
----------------------------------------

栈内存严格按照“先入后出”的原则。通常使用栈的顶部进行操作，数据在栈顶“入栈”，之后还是在栈顶“出栈”。

栈内存用来干嘛呢？栈内存也叫调用栈，每一个C程序都由它来控制其函数执行的流程。具体点说，就是栈内存分为很多栈帧，每个栈帧里面保存一个函数的信息，按照程序中函数的调用顺序依次入栈，再依次出栈来实现函数的调用次序。

栈帧保存了每一个函数的返回位置、实参、局部变量、返回值地址。

调用栈规则：
1.如果函数返回了一个值，这个值（包括地址和值）会被写到该函数对应栈帧的一个局部变量中。
2.如果函数有局部变量，局部变量被保存在栈帧。
3.如果函数有实参，实参也被保存在栈帧。
4.函数的返回位置也要保存在栈帧。一般返回位置就是函数调用之后的行编号。
5.如果相同函数在不同行被调用，则每个调用都有一个相应的返回位置。
6.一个函数执行结束后，程序将从栈顶部栈帧中的返回位置（行编号）处继续执行。栈顶栈帧随即被弹出。

总结
推荐使用DDD（命令行调试程序）来检测调用栈。



========================================
队列 //todo
----------------------------------------





========================================
树: 二叉树 //todo
----------------------------------------



========================================
散列表(hash 表，又叫关联数组) //todo
----------------------------------------


========================================
图、Trie 树 //todo
----------------------------------------


========================================
并查集 //todo
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

