C 语言100题


熟能生巧
- 先分析，手动分解已知条件
- 设计程序步骤
- 具体编码实现



========================================
题目来源
----------------------------------------
1. 基础练习

(1)100题：
https://www.runoob.com/cprogramming/c-100-examples.html


(2) C语言小项目
https://juejin.cn/post/6844903946331521038




(3) C 语言实现高并发聊天室
https://www.lanqiao.cn/courses/315
知识点: 1.实现聊天室的基本功能 2.epoll机制实现并发 3.fork创建进程 4.进程间通信（管道）

本课程实现客户端和服务端编程，服务端使用epoll机制，高并发实现，支持多客户聊天室聊天；客户端使用epoll和fork，父进程与子进程通过pipe通信。学习本课程可以很好的入门linux服务端编程，学习本课程也可用于在局域网搭建聊天室。本课程linux服务端编程入门课程，适合有C语言基础和linux基础，对于服务端编程有兴趣的同学。





========================================
|-- 练习题 组1：基本的条件/循环语句、逻辑运算、数据类型、输入输出
(n=10)
----------------------------------------
我在 Ubuntu 环境做的测试，输出字符、图案的效果都不好。


1.题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？
难度：*

$ cat p01.c
#include<stdio.h>
int main(){
	int i,j,z, counter=1;
	for(i=1; i<5; i++){
		for(j=1; j<5; j++){
			for(z=1; z<5; z++){
				if(i!=j && i!=z && j!=z){
					printf("%d %d%d%d\n", counter++, i,j,z);
				}
			}
		}
	}
	return 0;
}

# 共24个。


优化后，提前结束一下不必要的循环。
$ cat p01-v2.c 
#include<stdio.h>
int main(){
	int i,j,z, counter=1;
	for(i=1; i<5; i++){
		for(j=1; j<5; j++){
			if(i==j) continue;
			for(z=1; z<5; z++){
				if(i==z || j==z) continue;
				printf("%d %d%d%d\n", counter++, i,j,z);
			}
		}
	}
	return 0;
}









2. 题目：企业发放的奖金根据利润提成。

利润(I)低于或等于10万元时，奖金可提10%；
利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；
20万到40万之间时，高于20万元的部分，可提成5%；
40万到60万之间时高于40万元的部分，可提成3%；
60万到100万之间时，高于60万元的部分，可提成1.5%；
高于100万元时，超过100万元的部分按1%提成。
从键盘输入当月利润I，求应发放奖金总数？

程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。

难度：***

重点：从命令行获取参数； 字符串变数字/浮点数

测试功能
$ cat p02-v0.c 
#include<stdio.h>
#include<stdlib.h>
int main(int argc, char *argv[]){
        if(argc<2){
                printf("You must provide a long int!\n");
                return 1;
        }
        for(int i=0; i<argc; i++){
                printf("argv[%d]=%s\n", i, argv[i]);
        }
        long total=atol(argv[1]);
        //long total=argv[1];
        printf("you input:%ld\n", total);
}

$ ./a.out 500 600
argv[0]=./a.out
argv[1]=500
argv[2]=600
you input:500



正式版
$ cat p02.c 
#include<stdio.h>
#include<stdlib.h>
#define WAN 10000

int main(int argc, char *argv[]){
	if(argc<2){
		printf("You must provide a long int!\n");
		return 1;
	}

	// 接收第一个参数，并字符串转为长整数
	double  total=atof(argv[1]);
	printf("Your sales is %lf\n", total);
	
	// 实际上，浮点数才够用
	double bonus=0;
	total /= WAN;
	double  x1=10*0.1,
		x2=(total-10)*0.075,
		x3=(total-20)*0.05,
		x4=(total-40)*0.03,
		x5=(total-60)*0.015,
		x6=(total-100)*0.01;
	
	if(total<=10){
		bonus+= total*0.1;
	}else if(total>10 && total <=20){
		bonus += x1+x2;
	}else if(total>20 && total <=40){
		bonus += x1+x2+x3;
	}else if(total>40 && total <=60){
		bonus += x1+x2+x3+x4;
	}else if(total>60 && total <=100){
		bonus += x1+x2+x3+x4+x5;
	}else{
		bonus += x1+x2+x3+x4+x5+x6;
	}
	printf("Your bonus is %lf\n", bonus*WAN );
	return 0;
}


$ ./a.out 120000
Your sales is 120000.000000
Your bonus is 11500.000000






3.题目：一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？
难度：****

完全平方指用一个整数乘以自己例如1*1，2*2，3*3等，依此类推。若一个数能表示成某个整数的平方的形式，则称这个数为完全平方数。

提示：这个题目很典型，分析占了至少一半时间，剩下的才是编程实现。

分析：
x+100 = p*p
x+100+168 = t*t
求 x?

两边分别相减后 t*t-p*p=168
(t-p)(t+p)=168
设x,y是168的因子，则 x=t-p, y=t+p, x*y=168, 得 t=(x+y)/2, p=(y-x)/2
对168做因式分解 168=2*2*2*3*7
x和y要么都是偶数，要么都是奇数。后者不可能，则x,y都是偶数。
	最小的偶数因子是2，所以x和y都是>=2的偶数。

#include <stdio.h>
int main(){
	int x,y;
	for(x=2; x<168/2+1; x+=2){
		if(168%x !=0){ continue; }
		y=168/x;
		if(y%2!=0){ continue;}
		
		int p=(y-x)/2, t=(y+x)/2;
		if(p>t) {continue;}
		
		//printf("%d | x=%d, (%d**2), (%d**2)\n", x, p*p-100, p, t);
		printf("(%d) | %d + 100 = %d * %d\n", x, p*p-100, p, p);
		printf("(%d) | %d + 268 = %d * %d\n", x, p*p-100, t, t);
	}
}

输出: 两行为单位，x的值共4个: 1581/261/21/-99
(2) | 1581 + 100 = 41 * 41
(2) | 1581 + 268 = 43 * 43
(4) | 261 + 100 = 19 * 19
(4) | 261 + 268 = 23 * 23
(6) | 21 + 100 = 11 * 11
(6) | 21 + 268 = 17 * 17
(12) | -99 + 100 = 1 * 1
(12) | -99 + 268 = 13 * 13
(14) | -99 + 100 = -1 * -1
(14) | -99 + 268 = 13 * 13
(28) | 21 + 100 = -11 * -11
(28) | 21 + 268 = 17 * 17
(42) | 261 + 100 = -19 * -19
(42) | 261 + 268 = 23 * 23
(84) | 1581 + 100 = -41 * -41
(84) | 1581 + 268 = 43 * 43







4. 题目：输入某年某月某日，判断这一天是这一年的第几天？
难度：**

分析：
先看这个月之前有几天，在加上本月的。
二月需要判断是否闰年。

程序设计：数组结构保存每月的天数。

#include<stdio.h>
int main(){
	int year, month, day, i, sumDay=0;
	printf("please input year, month, day, eg: 2021/3/15\n");
	scanf("%d/%d/%d", &year, &month, &day);
	//计算天数
	int days[12]={31,0, 31,30,31,30,31,31,30,31,30,31};
	days[1]= ((year%400==0) || (year%100!=0 && year%4==0))?29:28; //二月
	//之前的月份天数累加：当前3月，则前面2个月就是0,1
	for(i=0; i<month-1; i++){
		sumDay+=days[i];
	}
	sumDay+=day; //加上当月的天数
	printf("%d年%d月%d日是今年的第%d天\n", year, month, day, sumDay);
}

$ ./a.out 
please input year, month, day, eg: 2021/3/15
2021/3/5
2021年3月5日是今年的第64天

2015年10月1日是今年的第274天







5. 题目：输入三个整数x,y,z，请把这三个数由小到大输出。
难度：*


分析：排序，输出。

#include<stdio.h>
int main(){
	int a[3];
	printf("please input 3 numbers, separated by comma\n");
	scanf("%d,%d,%d", &a[0], &a[1], &a[2]);
	//排序
	int i,j;
	for(i=0; i<3; i++){
		for(j=i+1; j<3; j++){
			printf("==>i=%d, j=%d\n", i,j);
			if(a[i]>a[j]){
				int t=a[i];
				a[i]=a[j];
				a[j]=t;
			}
		}
	}
	//输出
	for(i=0; i<3; i++)
			printf("%d ", a[i]);
	printf("\n");
	return 0;
}

$ ./a.out 
please input 3 numbers, separated by comma
20,-10,300
==>i=0, j=1
==>i=0, j=2
==>i=1, j=2
-10 20 300 

其实一共比较了三次。
x,y 保证x小
x,z 保证x最小
y,z 保证y中间，z最大







6. 题目：用*号输出字母C的图案。
难度：简单

需要多大的相似度？
****
*
*
****

printf(" ****\n");
printf(" *\n");
printf(" *\n");
printf(" ****\n");







7.题目：古典问题（兔子生崽）：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？（输出前40个月即可）

程序分析：兔子的规律为数列1,1,2,3,5,8,13,21....，即下个月是上两个月之和（从第三个月开始）。

难度：**** 用到递归


#include<stdio.h>
static long arr[41]={0, 1,1,2};

long fib(int n){
	if(arr[n]!=0){
		return arr[n];
	}
	return fib(n-1)+fib(n-2);
}

int main(){
	int i=0;
	for(i=1; i<=40; i++){
		arr[i]=fib(i);
		printf("arr[%d]=%ld\n", i, arr[i]);
	}
	return 0;
}

输出:
arr[1]=1
arr[2]=1 
arr[3]=2 
arr[4]=3 
arr[5]=5 
arr[6]=8 
arr[7]=13 
arr[8]=21 
arr[9]=34
...
arr[36]=14930352
arr[37]=24157817
arr[38]=39088169
arr[39]=63245986
arr[40]=102334155












8. 题目：输出9*9口诀。
难度:*

#include<stdio.h>
int main(){
	int i,j;
	for(i=1; i<10; i++){
		for(j=1; j<=i; j++){
			//printf("%d*%d=%d\t", i,j,i*j);
			printf("%d*%d=%-3d",j,i,i*j); /*-3d表示左对齐，占3位*/
		}
		printf("\n");
	}
}

$ ./a.out 
1*1=1
1*2=2   2*2=4
1*3=3   2*3=6   3*3=9
1*4=4   2*4=8   3*4=12  4*4=16
1*5=5   2*5=10  3*5=15  4*5=20  5*5=25
1*6=6   2*6=12  3*6=18  4*6=24  5*6=30  6*6=36
1*7=7   2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49
1*8=8   2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64
1*9=9   2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81











9. 题目：判断101到200之间的素数。

程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除， 则表明此数不是素数，反之是素数。

#include<stdio.h>
#include <math.h>
int main(){
	int i, j, flag, n=1;
	for(i=101; i<200; i++){
		flag=1;
		for(j=2; j<i; j++){
			if(i % j ==0){
				flag=0;
				break;
			}
		}
		if(1==flag){
			printf("%d\t", i);
			n++;
			if(n%5==0) 
				printf("\n");
		}
	}
	printf("\n");
	return 0;
}

输出：
101     103     107     109     113
127     131     137     139     149
151     157     163     167     173
179     181     191     193     197
199






10. 水仙花数
题目：打印出所有的"水仙花数"，所谓"水仙花数"是指一个三位数，其各位数字立方和等于该数 本身。
例如：153是一个"水仙花数"，因为153=1的三次方＋5的三次方＋3的三次方。

难度：** 
知识点：整除

#include<stdio.h>
int cubic(int a){
	return a*a*a;
}
int main(){
	int i;
	for(i=100; i<=999; i++){
		int a,b,c;
		//a=i/100; //百位
		//b=i/10 - 10*a; //十位
		//c=i-10*b-100*a; //个位
		
		a=i%10; //个位
        b=i/10%10; //十位
        c=i/100%10; //百位
		
		if( i == cubic(a)+cubic(b)+cubic(c) ){
			printf("%d\t", i);
		}
	}
	printf("\n");
}

输出:
153	370	371	407









========================================
|-- 练习题 组2：数论(因式分解、质数、公约数)、分析
(n=10)
----------------------------------------

11. 将一个正整数分解质因数
题目：将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。

难度： *****

分析：怎么分解？怎么保证质数？
先给出质数列表
然后依次对质数列表求余数，如果余数为0，则循环，然后下一个质数。

比如第一个质数 2
90/2=45 余数0
45/2 余数不是0，则下一个质数 3
45/3=15
15/3=5
5/3 余数不是0，则下一个质数 5
5/5=1 余数是0，结果是1，则结束。
输出中间结果 90=2*3*3*5

#include<stdio.h>
#include<math.h>
// is return 0; not return -1;
int isPrimer(int x){
	if(x<=0){
		printf("Error: please ensure x>0 !\n");
		return -1;
	}
	for(int i=2; i< (sqrt(x)+1); i++){
		if(x%i == 0){
			return -1;
		}
	}
	return 0;
}

int getNextPrimer(int x){
	while(1){
		x++;
		if(0==isPrimer(x)){
			return x;
		}
	}
}

int main(){
	int num;
	printf("please input a number:");
	scanf("%d", &num);
	printf("%d=", num);
	
	int primer=2; //质数
	while(num != 1){ //商
		int resid = num % primer; //余数
		while(resid==0){
			printf("%d", primer);
			num=num/primer;
			resid = num % primer;
			if(num!=1)
				printf("*");
		}
		primer=getNextPrimer(primer); //获取下一个质数
	}
	printf("\n");
	return 0;
}


在gcc下用到数学函数，如sqrt。在gcc时要加上 -lm 参数，这样告诉编译器我要用到数学函数了 。
gcc a.c -o a -lm


$ ./a.out 
please input a number:90
90=2*3*3*5

$ ./a.out
please input a number:945
945=3*3*3*5*7




(2) 更简练版本
程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：
1)如果这个质数恰等于（小于的时候，继续执行循环）n，则说明分解质因数的过程已经结束，另外 打印出即可。
2)但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数n.重复执行第二步。
3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。

#include<stdio.h>
int main()
{
    int n,i;
    printf("请输入整数：");
    scanf("%d",&n);
	
    printf("%d=",n);
    for(i=2;i<=n;i++) //如果除以2的余数不为0，则除以4的余数更不会是0。
    {
        while(n%i==0) //如果余数为0，则继续除
        {
            printf("%d",i);
            n/=i;  //更新n
            if(n!=1) printf("*");
        }
    }
    
    printf("\n");
    return 0;
}







12. 题目：利用条件运算符的嵌套来完成此题：学习成绩>=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。
难度：* 

#include<stdio.h>
int main(){
	int x;
	printf("请输入分数： ");
	scanf("%d", &x);
	char grade=x>=90?'A':( x<60?'C':'B' );
	printf("score:%d, grade:%c\n", x, grade);
	return 0;
}






13. 最大公约数和最小公倍数
题目：输入两个正整数m和n，求其最大公约数和最小公倍数。

难度：*** 
难点：数学原理 辗转相除法。

程序分析：
（1）最小公倍数=输入的两个数之积除于它们的最大公约数，关键是求出最大公约数；
（2）求最大公约数用辗转相除法（又名欧几里德算法）

1）证明：设c是a和b的最大公约数，记为c=gcd(a,b),a>=b,
令r=a mod b
设a=kc，b=jc，则k，j互素，否则c不是最大公约数
据上，r=a-mb=kc-mjc=(k-mj)c
可知r也是c的倍数，且k-mj与j互素，否则与前述k，j互素矛盾,
由此可知，b与r的最大公约数也是c，即gcd(a,b)=gcd(b,a mod b)，得证。

2）算法描述：
第一步：a ÷ b，令r为所得余数 0≤r 
第二步：互换：置 a←b，b←r，并返回第一步。

#include<stdio.h>
int main(){
	int a,b, c;
	printf("input 2 numer, separate by blank:\n");
	scanf("%d %d", &a, &b);
	
	c=a*b;
	printf("(%d,%d)的最大公约数是", a,b);
	
	
	if(a<b){
		int t=a;
		a=b;
		b=t;
	}
	
	int r=a%b;
	while( 0 != r ){
		a=b;
		b=r;
		r=a%b;
	}
	printf("最大公约数是%d, 最小公倍数是%d\n", b, c/b);
}



$ ./a.out
input 2 numer, separate by blank:
16 10
(16,10)的最大公约数是最大公约数是 2, 最小公倍数是 80

(12,26)的最大公约数是最大公约数是 2, 最小公倍数是 156







14.题目：输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。
难度：*
要点：ascii码与字符的对应

分析： 
英文字母：大小写
空格：
数字：
其他：

//失败，scanf遇到空格会停止
#include<stdio.h>
int main(){
	char str[20];
	scanf("%s", str);
	
	printf("%s\n", str);
}


#include<stdio.h>
int main(){
	char c;
	int letter=0, blank=0, digits=0, other=0;
	while( (c=getchar())!='\n' ){
		if( (c>='a' && c<='z') || (c>='A' && c<='Z') ){
			letter++;
		}else if( c>='0' && c<='9' ){
			digits++;
		}else if( ' '==c ){
			blank++;
		}else
			other++;
	}
	
	printf("字符统计: \n 字母: %d\n 数字: %d\n 空格: %d\n 其他:%d\n", letter, digits, blank, other);
}

输出：
$ ./a.out
this is an book. That is 2 PCs!
字符统计: 
 字母: 21
 数字: 1
 空格: 7
 其他:2









15. 题目：求s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。

难度：***
难点：中间数据怎么保存？不保存!

分析： 
输入2个数字，第一个数字是a，第二个数字是n个。
使用指针，动态获取内存。


#include<stdio.h>
int getNum(int a, int n){
	int num=a;
	while(--n >0){
		num*=10;
		num+=a;
	}
	return num;
}

int main(){
	int a, n, i, sum=0;
	printf("input 2 number a and n, separate by blank\n");
	scanf("%d %d", &a, &n);
	
	for(i=1; i<=n; i++){
		int tmp=getNum(a, i);
		printf("%d\t", tmp);
		sum+=tmp;
	}
	printf(", sum is %d\n", sum);
	return 0;
}

$ ./a.out
input 2 number a and n, separate by blank
2 5
2	22	222	2222	22222	, sum is 24690








16. 题目：一个数如果恰好等于它的因子之和，这个数就称为"完数"。例如6=1＋2＋3.编程找出1000以内的所有完数。

分析： 因子，只要能整除就算。
看例子，包括1，不包括自己。

#include<stdio.h>
int main(){
	int i,j, sum;
	for(i=1; i<=1000; i++){
		sum=0;
		for(j=1; j<i; j++){
			if(i%j==0){
				sum+=j;
			}
		}
		if(sum==i){
			printf("%d\t", i);
		}
	}
	printf("\n");
	return 0;
}

输出:
6	28	496

一万以内的还能再多一个
6	28	496	8128











17.题目：一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？
难度：**

分析：
第一次落地时经过h=100米，反弹h/2=50米，
第二次落地时又经过 50*2米，反弹 h/2**2 = 25米，
第三次落地时又经过 25*2米，反弹 h/2**3 = 12.5米，
第n次落地时又经过 h/2**(n-1) *2米，反弹 h/2**n 米。

#include<stdio.h>
int main(){
	float h=100, sum=h;
	int i=0;
	h/=2;
	for(i=2; i<=10; i++){
		sum+= h *2;
		h /= 2;
	}
	printf("共经过 %3.2f 米， 第十次反弹高度 %f 米\n", sum, h);
	return 0;
}

输出：
共经过 299.61 米， 第十次反弹高度 0.097656 米









18.题目：猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个；第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。

难度：**
第10天，吃前剩下1个；
第9天，吃前剩下 (1+1)*2=4
第8天，吃前剩下 (4+1)*2=10个
...
第1天，吃前剩下 (n+1)*2 个 


#include<stdio.h>
int main(){
	int i=10, sum=1;
	printf("第 %d 天，吃前剩下 %d 个\n", i, sum);
	for(i=9; i>0; i--){
		sum=(sum+1)*2;
		printf("第 %d 天，吃前剩下 %d 个\n", i, sum);
	}
	return 0;
}

输出: 
$ ./a.out 
第 10 天，吃前剩下 1 个
第 9 天，吃前剩下 4 个
第 8 天，吃前剩下 10 个
第 7 天，吃前剩下 22 个
第 6 天，吃前剩下 46 个
第 5 天，吃前剩下 94 个
第 4 天，吃前剩下 190 个
第 3 天，吃前剩下 382 个
第 2 天，吃前剩下 766 个
第 1 天，吃前剩下 1534 个



问题: 上述代码中出现重复行，怎么优化掉？
#include<stdio.h>
int main(){
	int i=10, sum=1;
	for(i=10; i>0; i--){
		printf("第 %d 天，吃前剩下 %d 个\n", i, sum);
		sum=(sum+1)*2;
	}
	return 0;
}







19.题目：两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。

难度：***

分析：甲 a,b,c，乙 x,y,z
已知：
a not x 
c not x, not z
则 c-y, b-x, a-z;

这个貌似分析完就已经是最终结果了。
写代码的意义是什么？

//失败，结果不能输出我们推测的结果。
#include<stdio.h>
int main(){
	char g1[3]={'a', 'b', 'c'};
	char g2[3]={'x', 'y', 'z'};
	int i,j;
	for(i=0; i<3; i++){
		char c1=g1[i];
		for(j=0; j<3; j++){
			char c2=g2[j];
			if(c1=='a' && c2=='x') continue;
			if(c1=='c' && (c2=='x' || c2=='z') ) continue;
			printf("%c vs %c\n", c1, c2);
		}
	}
	return 0;
}

输出不对： 
a vs y
a vs z
b vs x
b vs y
b vs z
c vs y



## 看别人的答案：
a,b,c 固定，看怎么放x,y,z 

#include<stdio.h>
int main(){
	int i,j, k;
	for(i='x'; i<='z'; i++){
		for(j='x'; j<='z'; j++){
			if(i==j) continue; //保证不能重复
			for(k='x'; k<='z'; k++){
				if(i==k || j==k) continue; //保证不能重复
				//保证满足条件
				if(i=='x') continue;
				if(k=='x' || k=='z') continue;
				printf("a-%c, b-%c, c-%c\n", i,j,k);
				
			}
		}
	}
	return 0;
}

输出：a-z, b-x, c-y









20. 题目：打印出如下图案（菱形）。

   *
  ***
 *****
*******
 *****
  ***
   *
难度：***

分析：要分上下两部分。
程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重for循环，第一层控制行，第二层控制列。

上面是4行7列，
第1行，3个空格，1个星号；
第2行，2个空格，3个星号；
第3行，1个空格，5个星号；
第4行，0个空格，7个星号；

#include<stdio.h>
int main(){
	int i,j;
	for(i=0; i<5; i++){
		for(j=0; j<5-i; j++){
			printf(" ");
		}
		for(j=0; j< (2*i-1) ; j++){
			printf("*");
		}
		printf("\n");
	}
	//下半部分
	for(i=3; i>=0; i--){
		for(j=0; j<5-i; j++){
			printf(" ");
		}
		for(j=0; j< (2*i-1) ; j++){
			printf("*");
		}
		printf("\n");
	}
}








========================================
|-- 练习题 组3: 递归、
(n=10)
----------------------------------------

21. 题目：有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13...求出这个数列的前20项之和。

分析：fib数列

难度：**

#include<stdio.h>
static int arr[30]={1, 1,2,3,5,8,13, 21};

int fib(int n){
	if( 0 != arr[n] ){
		return arr[n];
	}
	return fib(n-1)+fib(n-2);
}

int main(){
	int i=0;
	for(i=5; i<23; i++){
		arr[i]=fib(i);
	}
	
	float sum=0;
	for(i=1; i<=20; i++){
		sum+= (float)arr[i+1]/(float)arr[i];
		printf("i=%d, %d/%d,  sum=%f\n", i, arr[i+1], arr[i], sum);
	}
	return 0;
}

输出： 
i=20, 17711/10946,  sum=32.660263







22. 题目：求1+2!+3!+...+20!的和。

难度：**
难点：各种数据类型的上限在哪里？会不会重复？

分析：求阶乘，不保存中间变量，直接加。

#include<stdio.h>
int main(){
	int i;
	long double sum=0, item=1;
	for(i=1; i<=20; i++){
		item*=i;
		sum+=item;
		printf("%2d!=%20.0Lf, sum=%20.0Lf\n",i, item, sum);
	}
	//printf("sum=%20.0Lf\n", sum);
	return 0;
}

$ ./a.out 
 1!=                   1, sum=                   1
 2!=                   2, sum=                   3
 3!=                   6, sum=                   9
 4!=                  24, sum=                  33
 5!=                 120, sum=                 153
 6!=                 720, sum=                 873
 7!=                5040, sum=                5913
 8!=               40320, sum=               46233
 9!=              362880, sum=              409113
10!=             3628800, sum=             4037913
11!=            39916800, sum=            43954713
12!=           479001600, sum=           522956313
13!=          6227020800, sum=          6749977113
14!=         87178291200, sum=         93928268313
15!=       1307674368000, sum=       1401602636313
16!=      20922789888000, sum=      22324392524313
17!=     355687428096000, sum=     378011820620313
18!=    6402373705728000, sum=    6780385526348313
19!=  121645100408832000, sum=  128425485935180313
20!= 2432902008176640000, sum= 2561327494111820313







23. 题目：利用递归方法求5!。
难度：*

#include<stdio.h>
long double fact(int x){
	if(x<=1)
		return 1;
	else
		return x*fact(x-1);
}

int main(){
	int n=5;
	for(int i=0; i<=n; i++){
		long double result=fact(i);
		printf("%d!=%5.0Lf\n", i, result);
	}
	return 0;
}


$ ./a.out 
0!=    1
1!=    1
2!=    2
3!=    6
4!=   24
5!=  120






24. 题目：利用递归函数调用方式，将所输入的5个字符，以相反顺序打印出来。
难度：***** 
难点：读不懂题目意思。
反向输出字符容易，但是怎么递归函数调用实现？

//错误实现，没用递归
#include<stdio.h>
int main(){
	char c[5];
	printf("请输入5个字符: ");
	for(int i=0; i<5; i++){
		c[i]=getchar();
	}
	for(int i=4; i>=0; i--){
		printf("%c", c[i]);
	}
	printf("\n");
	return 0;
}

$ ./a.out 
请输入5个字符: abcde
edcba


##==== 参考答案
#include <stdio.h>
void palin(int n);
int main(){
    int i=5;
    printf("请输入5个字符: ");
    palin(i);
    printf("\n");
	return 0;
}

void palin(int n){
    char next;
    if(n<=1) {
        next=getchar();
        printf("相反顺序输出结果: ");
        putchar(next);
    } else {
        next=getchar();
        palin(n-1);
        putchar(next);
    }
}

$ ./a.out 
请输入5个字符: abcde
相反顺序输出结果: edcba

递归流程：
i=5 五个字符，进入递归函数内部，（递归内部走v字形，逐层压入栈，再逐个从顶部弹出）
n=5走else, 获取一个输入a，
	递归n=4，走else，获取一个输入b,
		递归n=3，走else，获取一个输入c,
			递归n=2，走else，获取一个输入d,
				递归n=1，走if，获取一个输入e, 输出汉字，输出字符 e，
					返回上一层，输出d;
					返回上一层，输出c;
					返回上一层，输出b;
					返回上一层，输出a;
					递归函数结束。
返回主程序，换行。程序结束。







25. 题目：有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？

难度：*
分析：这是递归

#include<stdio.h>
int getAge(int n){
	if(n==1)
		return 10;
	else
		return getAge(n-1)+2;
}

int main(){
	for(int i=1; i<=5; i++){
		int age = getAge(i);
		printf("the %d th man's age: %d\n", i, age);
	}
	return 0;
}

$ ./a.out 
the 1 th man's age: 10
the 2 th man's age: 12
the 3 th man's age: 14
the 4 th man's age: 16
the 5 th man's age: 18



参考答案看不懂
旧语法：函数定义中，参数没有类型，参数类型在下一行定义的。
https://www.codenong.com/1585390 
https://stackoverflow.com/questions/1585390/c-function-syntax-parameter-types-declared-after-parameter-list

#include <stdio.h>
int age(n)
int n;
{
    int c;
    if(n==1) c=10;
    else c=age(n-1)+2;
    return(c);
}
int main(){
    printf("%d\n",age(5));
}

看不懂这个 int n 和函数并列什么意思？
但是运行正常，结果正确。

This is the so caller K&R style or old-style declaration.

Note, that this declaration is significantly different from the modern declaration. K&R declaration does not introduce a prototype for the function, meaning that it doesn't expose the types of the parameters to the outside code.









26. 题目：给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。

难度：*

#include<stdio.h>
int main(){
	int num0,num, i=0, j, arr[6];
	printf("please input a number, 1 to 1e6: ");
	scanf("%d", &num);
	if(num<=0){
		printf("Error: must positive!\n");
		return 1;
	}
	
	num0=num;
	while(num>0){
		arr[i]=num%10;
		i++;
		num/=10;
	}
	printf("%d 是 %d 位数，逆序打印出各位数字: ", num0, i);
	for(j=0; j<i; j++){
		printf("%d", arr[j]);
	}
	printf("\n");
	return 0;
}






27. 题目：回文数：一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。

难度：*
分析：一个数字拆开，再倒序组装回去，和原来一样，则是。
扩展一下，任意位数。10位以内吧。

#include<stdio.h>

//手写乘方运算
int power(int a, int n){
	int i, rs=1;
	for(i=0; i<n; i++){
		rs*=a;
	}
	return rs;
}

int main(){
	int i,j, num, num0, arr[20];
	printf("input a number, 10 to 1e10:");
	scanf("%d", &num);
	
	//获取长度和每位是什么，如 123 -> {3,2,1}
	num0=num;
	i=0;
	while(num>0){
		arr[i]=num%10;
		i++;
		num/=10;
	}
	//倒序组装回去
	num=0;
	for(j=0; j<i; j++){
		printf("%d ", arr[j]);
		num+=arr[j]*power(10, i-j-1);
	}
	
	printf("\nbefore:%d, after:%d\n", num0, num);
	if(num==num0){
		printf("是\n");
	}else{
		printf("不是\n");
	}
	return 0;	
}


$ ./a.out 
input a number, 10 to 1e10:123454321
1 2 3 4 5 4 3 2 1 
before:123454321, after:123454321
是

$ ./a.out 
input a number, 10 to 1e10:123210
0 1 2 3 2 1 
before:123210, after:12321
不是

$ ./a.out 
input a number, 10 to 1e10:12321
1 2 3 2 1 
before:12321, after:12321
是

还可以改进：
- 使用字符串方式，只需要一个for循环。
- 拆分成数字数组后，比较首尾是否一致，减少了复原运算，只需要比较一半。
- 使用更长的数据类型，可以容纳更大的数。unsigned long long input; 








28. 题目：请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。

难度：***
分析：怎么判断是否唯一？需要设立flag，第一遍测试全部编号，第二次缩小范围。

#include<stdio.h>
#include<string.h>
int main(){
	char *toDay[]={"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
	char input[5];
	int arr[7]={1,1,1,1,1,1,1}, n=7;
	printf("input from Monday to Sunday, any length is OK:");
	scanf("%s", input);
	
	//匹配
	int len=strlen(input), i=0, j=0;
	printf("your input is: %s, len=%d\n", input, len);
	while(len-- >0 ){
		if( 1==n ){
			break;
		}
		for(i=0; i<7; i++){
			if(arr[i]==0) continue;
			if( toDay[i][j] != input[j] ){
				arr[i]*=0;
				n--;
			}
		}
		j++;
	}
	//输出 
	printf("likely to be: ");
	for(i=0; i<7; i++){
		if(arr[i]>0){
			printf("%s\t", toDay[i]);
		}
	}
	printf("\n");
	return 0;
}

$ ./a.out 
input from Monday to Sunday, any length is OK:T
your input is: T, len=1
likely to be: Tuesday	Thursday


参考答案是使用 case 语句，更符合要求。









29. 题目：删除一个字符串中的指定字母，如：字符串 "aca"，删除其中的 a 字母。

难度：*
分析：输入字符串，然后输入要删除的字母

#include<stdio.h>
int main(){
	//输入
	char str[20], c, i=0;
	printf("please input a string:");
	//scanf("%s", str); getchar(); //吃掉回车键
	while( (c=getchar())!='\n' ){
		str[i]=c;
		i++;
	}
	str[i]='\0';
	
	char d;
	printf("please input a char you want to delete:");
	scanf("%c", &d);
	
	printf("str: %s, del: %c\n", str, d);
	
	//删除指定字符
	int n=i+1;
	for(int j=0; j<n; j++){
		if(str[j]==d){
			//后面的往前移动
			for(int i=j; i<n-1; i++){
				str[i]=str[i+1];
			}
			j--; //再次检查当前位置
		}
	}
	printf("after del %c, str: %s\n",d,  str);
	return 0;
}

输出：
$ ./a.out 
please input a string:this is a book
please input a char you want to delete:i
str: this is a book, del: i
after del i, str: ths s a book

$ ./a.out 
please input a string:this is a book!
please input a char you want to delete:o
str: this is a book!, del: o
after del o, str: this is a bk!

小结：要检查刚刚前进的那个字符是否需要删除。比如book删掉o。









30. 质数（素数）判断
题目：判断一个数字是否为质数。
程序分析：质数（prime number）又称素数，有无限个。一个大于1的自然数，除了1和它本身外，不能被其他自然数整除。

难度：*
分析：前面做过了

#include<stdio.h>

#include<math.h>
int isPrimer(int n){
	int i;
	for(i=2; i<= sqrt(1.0*n); i++){ //优化运算次数
		if(n%i==0){
			return 0;
		}
	}
	return 1;
}

int isPrimer2(int n){
	int i;
	for(i=2; i<n; i++){
		if(n%i==0){
			return 0;
		}
	}
	return 1;
}

int main(){
	int i, j=1;
	for(i=2; i<100; i++){
		if( 1==isPrimer(i) ){
			printf("%3d ", i);
			if(j++%20 ==0){
				printf("\n");
			}
		}
	}
	printf("\n");
	return 0;
}

$ gcc p30.c -lm
$ ./a.out 
  2   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59  61  67  71 
 73  79  83  89  97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 
179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 
283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 
419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 
547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 
661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 
811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 
947 953 967 971 977 983 991 997










========================================
|-- 练习题 组4: 倒置/排序/二分法/ static/auto/register/ 宏/ 位运算/
(n=15)
----------------------------------------

31. 题目：字符串反转，如将字符串 "www.abcd.com" 反转为 "moc.dcba.www"。

难度：***
难点：数组是按照值传递的。数组作为函数参数。对调内容。

#include<stdio.h>

void printArr(char arr[], int n){
	int i;
	for(i=0; i<n; i++){
		printf("%c", arr[i]);
	}
	printf("\n");
}

void reverse(char arr[], int n){
	int i, j, tmp;
	for(i=0; i<n/2; i++){
		j=n-1-i;
		tmp=arr[i];
		arr[i]=arr[j];
		arr[j]=tmp;
	}
}

int main(){
	char arrC[]="www.abcd.com";
	int len=sizeof(arrC) / sizeof(char); //传递前可以获取长度。 //todo why?
	printArr(arrC, len);
	reverse(arrC, len);
	printArr(arrC, len);
	return 0;
}


$ ./a.out 
www.abcd.com
moc.dcba.www









32. 排序：题目：对10个数进行排序。

难度：*
做过很多次了。

#include<stdio.h>

//选择法排序,选出最小的，放到最左边。
void selectSort(int arr[], int n){
	int i,j,index, tmp;
	for(i=0; i<n-1; i++){
		index=i; //最小值默认是第一个
		for(j=i; j<n; j++){
			if( arr[index]>arr[j] ){
				index=j;
			}
		}
		if(index!=i){
			tmp=arr[i];
			arr[i]=arr[index];
			arr[index]=tmp;
		}
	}
}

int main(){
	int n=10, i;
	int arr[]={0,17,-20,35,-42,59,-66,78,-81,92};
	selectSort(arr, 10);
	//打印结果
	for(i=0; i<n; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
	return 0;
}

$ ./a.out 
-81 -66 -42 -20 0 17 35 59 78 92

扩展：更多排序 https://www.runoob.com/cprogramming/c-exercise-example37.html
选择法、冒泡法、快速排序。









33. 题目：求一个3*3矩阵对角线元素之和
难度：*
分析：怎么表示矩阵？使用二维数组。

arr[3][3] 按行存储{ {},{},{} }

#include<stdio.h>
int main(){
	int arr[3][3]={
		{1, 20, 30}, 
		{2, 50, -90}, 
		{3, 30, 60}
		};
	int i,j, N=3, sum=0;
	for(i=0; i<N; i++){
		for(j=0; j<N; j++){
			if(i==j){
				sum+=arr[i][j];
			}
		}
	}
	printf("sum of diag = %d\n", sum);
	return 0;
}

$ ./a.out 
sum of diag = 111

扩展：nxn矩阵呢？









34. 题目：有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。

难度：***

分析：排过序了，加入一个数字。则用二分法。

#include<stdio.h>
int getPos(int arr[], int N, int num){
	//二分法找到前一个元素的位置
	int low=0, high=N-1, mid=(low+high)/2, oldMid=-1;
	while(low<high){
		if( num > arr[mid]){
			low=mid;
			mid=(low+high)/2;
		}else if(num <arr[mid]){
			high=mid;
			mid=(low+high)/2;
		}else{
			return mid;
		}
		//查看是否调整过位置
		if(oldMid==mid){
			return low;
		}else{
			oldMid=mid;
		}
	}
}

int main(){
	int arr[]={-81, -66, -42, -20, 0, 17, 35, 59, 78, 92};
	int N=10, num, i;
	printf("please input a numer, [-100, 100]:");
	scanf("%d", &num);
	
	// 获取前一个元素的位置
	int pos=getPos(arr, N, num);
	for(i=0; i<N; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
	//插入新元素
	for(i=0; i<N; i++){
		printf("%d ", arr[i]);
		if(i==pos){
			printf("%d ", num);
		}
	}
	printf("\n");
	return 0;
}


$ ./a.out 
please input a numer, [-100, 100]:-40
-81 -66 -42 -20 0 17 35 59 78 92 
-81 -66 -42 -40 -20 0 17 35 59 78 92

//todo: 有些情况例外。
-100 就不行，怎么办？
100也不行。


改进：原始数据为升序可以，原始数据为降序怎么修改？
有没有更简洁的写法？
https://www.runoob.com/cprogramming/c-exercise-example39.html









35. 题目：将一个数组逆序输出。
难度：*
之前做过了。首尾互换元素。

#include<stdio.h>
void reverse(int arr[], int n){
	int i,j;
	for(i=0; i<n/2; i++){
		j=n-1-i;
		int tmp=arr[i];
		arr[i]=arr[j];
		arr[j]=tmp;
	}
}

int main(){
	int arr[]={1,2,3,4,5};
	int n=5, i;
	reverse(arr, n);
	for(i=0; i<n; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}

$ ./a.out 
5 4 3 2 1 









36. 题目：学习static定义静态变量的用法。

难度：*
查看数值是否累加，及存放地址。

#include<stdio.h>

void test(int y){
	int i=0;
	static int i_static=0;
	i+=10;
	i_static+=10;
	printf("i=%d(%p), i_static=%d(%p), y=%d(%p)\n", i, &i, i_static, &i_static, y, &y);
}

int main(){
	int x;
	for(x=0; x<3; x++){
		test(x);
	}
	return 0;
}


$ ./a.out 
i=10(0x7ffcb1a97044), i_static=10(0x555a1fbc4014), y=0(0x7ffcb1a9703c)
i=10(0x7ffcb1a97044), i_static=20(0x555a1fbc4014), y=1(0x7ffcb1a9703c)
i=10(0x7ffcb1a97044), i_static=30(0x555a1fbc4014), y=2(0x7ffcb1a9703c)

可见，静态变量地址低，可能是堆。









37. 学习使用auto定义变量的用法。
难度：*
auto在声明变量的时候可根据变量初始值的数据类型自动为该变量选择与之匹配的数据类型。

#include <stdio.h>
int main(){
    int i,num;
    num=2;
    for(i=0;i<3;i++)    {
        printf("num = %d (%p) ", num, &num);
        num++;
		//花括号内变量的作用范围，离开失效。下次进来重新初始化
        {
            auto int num=1;
            printf("内置模块 num = %d (%p) \n",num, &num);
            num++;
        }
    }
    return 0;
}


$ ./a.out 
num 变量为 2 
内置模块 num 变量为 1 
num 变量为 3 
内置模块 num 变量为 1 
num 变量为 4 
内置模块 num 变量为 1


$ ./a.out 
num = 2 (0x7ffcf1dfdd9c) 内置模块 num = 1 (0x7ffcf1dfdda0) 
num = 3 (0x7ffcf1dfdd9c) 内置模块 num = 1 (0x7ffcf1dfdda0) 
num = 4 (0x7ffcf1dfdd9c) 内置模块 num = 1 (0x7ffcf1dfdda0)









38. 题目：学习使用static的另一用法。　
难度：*

#include <stdio.h>
int main(){
    int i,num;
    num=2;
    for(i=0;i<3;i++)    {
        printf("num = %d (%p) ", num, &num);
        num++;
		//花括号内变量的作用范围，离开失效。下次进来重新初始化
        {
            static int num=1;
            printf("内置模块 num = %d (%p) \n",num, &num);
            num++;
        }
    }
    return 0;
}

$ ./a.out 
num = 2 (0x7ffe7b9fb140) 内置模块 num = 1 (0x556c49b24010) 
num = 3 (0x7ffe7b9fb140) 内置模块 num = 2 (0x556c49b24010) 
num = 4 (0x7ffe7b9fb140) 内置模块 num = 3 (0x556c49b24010) 

小结： 静态变量，只初始化一次，在模块中也是。









39. 题目：学习使用register定义变量的方法。
难度：*


#include <stdio.h>
int main(){
    register int i;
    int tmp=0;
    for(i=1;i<=100;i++)
        tmp+=i;
    printf("总和为 %d, i=%d\n",tmp, i);
	//p39.c:7:5: error: address of register variable ‘i’ requested
    return 0;
}

https://www.cnblogs.com/kingqinwang/p/5097335.html
- 寄存器变量不在内存中，所以没有指针。
- 单一值，长度应该小于或者等于整型的长度。









40. 题目：宏#define命令练习。

#include<stdio.h>
#define TRUE 1
#define FALSE 0
#define SQ(x) (x)*(x)

int main(){
	int num;
	int again=1;
	while(again){
		printf("input a number, if larger than 50, the script will stop:");
		scanf("%d", &num);
		printf("该数字的平方为 %d \n",SQ(num));
		if(num>50)
			again=FALSE;
		else
			again=TRUE;
	}
}









41. 题目：宏#define命令练习2。

#include<stdio.h>
#define exchange(a,b) { int t;t=a;a=b;b=t;}//注意放在一行里
int main()
{
    int x=10;
    int y=20;
    printf("x=%d; y=%d\n",x,y);
    exchange(x,y);
    printf("x=%d; y=%d\n",x,y);
    return 0;
}









42. 题目：宏#define命令练习3。

#define LAG >
#define SMA <
#define EQ ==
#include <stdio.h>
int main()
{
    int i,j;
    printf("请输入两个数字：\n");
    scanf("%d %d",&i,&j);
    if(i LAG j)
        printf("%d 大于 %d \n",i,j);
    else if(i EQ j)
        printf("%d 等于 %d \n",i,j);
    else if(i SMA j)
        printf("%d 小于 %d \n",i,j);
    else
        printf("没有值。\n");
    return 0;
}









43. 题目：#if #ifdef和#ifndef的综合应用。


#include<stdio.h>
#define MAX
#define MAXIMUM(x,y)(x>y)?x:y
#define MINIMUM(x,y) (x>y)?y:x
int main()
{
    int a=10,b=20;
#ifdef MAX
    printf("更大的数字是 %d\n",MAXIMUM(a,b));
#else
    printf("更小的数字是 %d\n",MINIMUM(a,b));
#endif

#ifndef MIN
    printf("更小的数字是 %d\n",MINIMUM(a,b));
#else
    printf("更大的数字是 %d\n",MAXIMUM(a,b));
#endif

#undef MAX
#ifdef MAX
    printf("更大的数字是 %d\n",MAXIMUM(a,b));
#else
    printf("更小的数字是 %d\n",MINIMUM(a,b));
#endif

#define MIN
#ifndef MIN
    printf("更小的数字是 %d\n",MINIMUM(a,b));
#else
    printf("更大的数字是 %d\n",MAXIMUM(a,b));
#endif
    return 0;
}









44. 题目：#include 的应用练习。

$ cat test.h
#define LAG >
#define SMA <
#define EQ ==

$ cat p44.c
#include "test.h"  
#include <stdio.h>

int main()
{
    int i=10;
    int j=20;
    if(i LAG j)
        printf("%d 大于 %d \n",i,j);
    else if(i EQ j)
        printf("%d 等于 %d \n",i,j);
    else if(i SMA j)
        printf("%d 小于 %d \n",i,j);
    else
        printf("没有值。\n");
    return 0;
}









45. 题目：取一个整数 a 从右端开始的 4～7 位。
难度：*
分析：要几位就除以几，取余数。
我理解的是按十进制位，答案是按照二进制位，这有歧义。

#include<stdio.h>
int main(){
	int a=123456789;
	int b=a%10000000;
	printf("%d 取右边7位为 %d\n", a,b);
	
	//整除1000
	int c=b/1000;
	printf("%d 取左边3位为 %d\n", b, c);
	return 0;
}

输出：
123456789 取右边7位为 3456789
3456789 取左边3位为 3456



//看不懂 //todo
原文使用的是 位运算，不熟悉，学习一下。
#include <stdio.h>
int main()
{
    unsigned a,b,c,d;
    printf("请输入整数：\n");
    scanf("%d",&a);
	printf("=>输入的: a=%d\n", a);
	
	//右移4位则
    b=a>>4;
	printf("=>右移四位后: b= %d\n", b);
	
	//~0就是1111111，左移4位是 (1111111110000)2, 再取反是 (1111)2=8+4+2+1=15
    c=~(~0<<4);
	printf("=>取反，左移4位，取反: c=%d\n", c);
	
	//与运算，d就是只要b的右4位:  
    d=b&c;
	printf("=>b&c  %d & %d = %d\n", b,c, d);
	
    printf("a=%o\nd=%o\n",a,d);
    return 0;
}

输出：
请输入整数：
1234567
=>输入的: a=1234567
=>右移四位后: b= 77160
=>取反，左移4位，取反: c=15
=>b&c  77160 & 15 = 8
a=4553207
d=10












========================================
|-- 练习题 组5: /杨辉三角 /数组偏移 /结构体 /指针函数
(n=10)
----------------------------------------

46. 杨辉三角形。题目：打印出杨辉三角形（要求打印出10行）。
难度：****
分析：第一行是1，然后每个是顶上2个的和。
这是二项式展开的系数。
1
1 1
1 2 1
1 3 3 1

构建一个数列，首位始终为1，接着是上一行的两两和，最后一个1。


#include<stdio.h>
void printArr(int arr[], int N){
	int i;
	for(i=0; i<N; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}

int main(){
	int i, j, k, N=1;
	int arr[15]={1}, arr2[15];
	for(i=0; i<10; i++){
		printArr(arr, N);
		
		//生成新数组arr2，长度加1
		arr2[0]=1; //首位1
		for(j=1; j<N; j++){
			arr2[j] = arr[j-1] + arr[j];
		}
		arr2[N]=1;//末位1
		N++;
		
		//覆盖掉arr
		for(k=0; k<N; k++){
			arr[k]=arr2[k];
		}
	}
	return 0;
}


$ ./a.out 
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 
1 9 36 84 126 126 84 36 9 1 

参考答案使用二维数组，保证上下游关系。也很巧妙。
还有人使用排列组合公式的，系数等于C(n, k)=n!/ (k! *(n-k)!)









47. 题目：输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。
难度：*

#include<stdio.h>
void swap(int *x, int *y){
	int tmp=*x;
	*x=*y;
	*y=tmp;
}

void printArr(int arr[], int n){
	int i;
	for(i=0; i<n; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}

int main(){
	int i,j, n, arr[20];
	printf("设定数组长度(n<20):");
	scanf("%d", &n);
	
	printf("输入 %d 个数组元素\n", n);
	for(i=0; i<n; i++){
		scanf("%d", &arr[i]);
	}
	
	int iMax=0, iMin=0;
	for(i=1; i<n; i++){
		if( arr[iMax]<arr[i] ){
			iMax=i;
		}
		if( arr[iMin]>arr[i] ){
			iMin=i;
		}
	}
	
	//交换
	swap(&arr[iMax], &arr[0]);
	swap(&arr[iMin], &arr[n-1]);
	
	printArr(arr, n);
}


$ ./a.out 
设定数组长度(n<20):5
输入 5 个数组元素
2
-80
6
84
-10
84 -10 6 2 -80


也可以次输入全部数组元素
$ ./a.out 
设定数组长度(n<20):5
输入 5 个数组元素
2 -80 6 84 -10
84 -10 6 2 -80 









48. 题目：有 n个整数，使其前面各数顺序向后移 m 个位置，最后m个数变成最前面的 m 个数。
难度：*
分析：可能是循环输出。

#include<stdio.h>
void printArr(int arr[], int n){
	int i;
	for(i=0; i<n; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}

int main(){
	int N=10, i;
	int arr[]={10,-26,38,-41,53,-64,-75,80,-98,106};
	int arr2[10];
	int shift=0;
	printf("请输入后移量: ");
	scanf("%d", &shift);
	
	// 偏移位置
	for(i=0; i<N; i++){		
		arr2[i]=arr[ (N+i-shift) %N ];
	}
	
	printArr(arr, N);
	printArr(arr2, N);	
}

$ ./a.out 
请输入后移量: 2
10 -26 38 -41 53 -64 -75 80 -98 106 
-98 106 10 -26 38 -41 53 -64 -75 80 

$ ./a.out 
请输入后移量: 5
10 -26 38 -41 53 -64 -75 80 -98 106 
-64 -75 80 -98 106 10 -26 38 -41 53




方法2：参考答案有一步一步滚动的，一次滚动一位。单个数组实现。很精巧。

#include<stdio.h>
void printArr(int arr[], int n){
	int i;
	for(i=0; i<n; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}
void move2(int arr[], int n, int shift){
	int i, last;
	while(shift--){
		last=arr[n-1];
		for(i=n-1; i>=0; i--){
			arr[i]=arr[i-1];
		}
		arr[0]=last;
	}
}

//滚动数组，指向最后一个元素 arr+n
void move(int array[],int n,int offset){
    int *p,*arr_end;
    arr_end=array+n;   //数组最后一个元素的下一个位置
    int last;
    
    //滚动直到偏移量为0
    while(offset)
    {
        last=*(arr_end-1);
        for(p=arr_end-1; p!=array; --p)   //向右滚动一位
            *p=*(p-1);
        *array=last;
        --offset;
    }
}


int main(){
	int N=10, i;
	int arr[]={10,-26,38,-41,53,-64,-75,80,-98,106};
	int shift=0;
	printf("请输入后移量: ");
	scanf("%d", &shift);
	
	printArr(arr, N);
	// 偏移位置
	move(arr, N, shift);
	printArr(arr, N);	
}

$ ./a.out 
请输入后移量: 2
10 -26 38 -41 53 -64 -75 80 -98 106 
-98 106 10 -26 38 -41 53 -64 -75 80 









49. 题目：有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。

难度：****
难点：动态分配内存。


分析：一圈首尾相连。
结束条件是剩下一个。

#include<stdio.h>
#include<stdlib.h>

void printArr(int *arr, int n){
	int i;
	for(i=0; i<n; i++){
		printf("%d ", *(arr+i));
	}
	printf("\n");
}

// 删除第j个元素，就是第j个元素被后一个元素覆盖
void delArr(int *arr, int n, int j){
	int i;
	for(i=j; i<n; i++){
		*(arr+i)=*(arr+i+1);
	}	
}

int main(){
	int counter=0, n, remain;
	printf("input the number of total people:");
	scanf("%d", &n);
	
	//输入总人数 n
	if(0==n)
		return 1;
	if(n<1){
		printf("Error: must >1\n");
		return 1;
	}
	remain=n;
	//分配一块内存
	int i, *arr0, *arr=malloc( sizeof(int)*n);
	arr0=arr;
	//初始化
	for(i=0; i<n; i++){
		*(arr+i)=(i+1);
	}
	
	int j;
	while(remain>1){
		printf("==> remain=%d (first element counter=%d)\n", remain, counter+1);
		printArr(arr, remain); //剩余元素
		//报数，遇到3的倍数，则
		for(j=0; j<remain; j++){
			counter++;
			counter=counter%3;
			if(counter==0){
				printf("删除元素: %d\n", arr[j]);
				delArr(arr, remain, j); //删除数组arr的第j个元素，后面的前移
				j--;
				remain--;
			}
		}
	}
	printf("剩下的元素是: %d\n", arr[0]);
	return 0;
}



输出:
$ ./a.out 
input the number of total people:8
==> remain=8 (first element counter=1)
1 2 3 4 5 6 7 8 
删除元素: 3
删除元素: 6
==> remain=6 (first element counter=3)
1 2 4 5 7 8 
删除元素: 1
删除元素: 5
==> remain=4 (first element counter=3)
2 4 7 8 
删除元素: 2
删除元素: 8
==> remain=2 (first element counter=1)
4 7 
==> remain=2 (first element counter=3)
4 7 
删除元素: 4
剩下的元素是: 7









50. 题目：写一个函数，求一个字符串的长度，在 main 函数中输入字符串，并输出其长度。

难度：*
做过。

#include<stdio.h>
int main(){
	char c, *str;
	int n=0;
	printf("请输入字符串, 回车结束: ");
	while( (c=getchar()) != '\n' ){
		n++;
	}
	printf("length=%d\n", n);
	return 0;
}









51. 题目：编写input()和output()函数输入，输出5个学生的数据记录。

难度：*
分析：不清楚题目意图，啥记录？从哪来的记录？
既然是学生，是不是要定义结构体？


//结构体.ele, 结构体指针->ele
#include<stdio.h>
#include<string.h>
struct Student{
	int id;
	char name[10];
	char gender;
};

void input(struct Student *s, int id, char name[], char gender){
	s->id=id;
	strcpy(s->name, name);
	s->gender=gender;
}

void output(struct Student *s){
	printf("Student info: \n id:%d,\t name:%s\t gender:%c\n", s->id, s->name, s->gender);
}

int main(){
	struct Student stus[5];
	printf("请输入一个学生的信息，按回车结束，类似 1 Tom M:");
	
	int i, id;
	char name[10];
	char gender;
	
	for(i=0; i<5; i++){
		scanf("%d %s %c", &id, name, &gender);
		input(&stus[i], id, name, gender);
	}
	for(i=0; i<5; i++){
		output(&stus[i]);
	}
	return 0;
}


 ./a.out 
请输入一个学生的信息，按回车结束，类似 1 Tom M:1 Jim M
2 Tom M
3 Lily F
4 Lilei M
5 Lee F
Student info: 
 id:1,	 name:Jim	 gender:M
Student info: 
 id:2,	 name:Tom	 gender:M
Student info: 
 id:3,	 name:Lily	 gender:F
Student info: 
 id:4,	 name:Lilei	 gender:M
Student info: 
 id:5,	 name:Lee	 gender:F









52. 题目：输入一个整数，并将其反转后输出。
难度：*
做过。 

分析：可以获取其每位。还有使用递归的。

#include<stdio.h>
#include<stdlib.h>
int power(int a, int n){
	int rs=1;
	while(n--){
		rs *= a;
	}
	return rs;
}

int main(){
	int num, num0;
	printf("输入一个整数:");
	scanf("%d", &num);
	num0=num;
	
	//获取长度
	int n=0;
	while(num >0){
		n++;
		num/=10;
	}
	
	//获取每一位
	int i, *pArr;
	pArr=malloc( sizeof(int)*n );
	num=num0;
	for(i=0; i<n; i++){
		*(pArr+i)=num%10;
		num /= 10;
	}
	//输出
	num=0;
	for(i=0; i<n; i++){
		num+=*(pArr+i)*power(10, n-1-i);
	}
	free(pArr);
	printf("%d 翻转后为 %d\n", num0, num);
	return 0;
}


$ ./a.out 
输入一个整数:12457
12457 翻转后为 75421




方法2：参考答案更精简，只用一个循环。很精巧。 

#include<stdio.h>
int main(){
	int num;
	printf("输入一个整数:");
	scanf("%d", &num);
	
	int reverse=0, remainder;
	while(num>0){
		remainder=num%10;
		reverse = reverse*10 + remainder;
		num/=10;
	}
	printf("翻转后: %d\n", reverse);
	return 0;
}

$ ./a.out 
输入一个整数:124578
翻转后: 875421









53. 题目：编写一个函数，输入n为偶数时，调用函数求1/2+1/4+...+1/n,当输入n为奇数时，调用函数1/1+1/3+...+1/n(利用指针函数)。

难度：*
分析：指针函数，还是函数，但是返回的是指针。
这里应该是说错了，应该是指向函数逇指针，或简称函数指针。

#include<stdio.h>
double addOdd(int n){
	printf("Odd\n");
	int i;
	double sum=0;
	for(i=1; i<=n; i+=2){
		sum += (double)1/i;
	}
	return sum;
}

double addEven(int n){
	printf("Even\n");
	int i;
	double sum=0;
	for(i=2; i<=n; i+=2){
		sum += (double)1/i;
	}
	return sum;
}

int main(){
	int num;
	printf("please input a number:");
	scanf("%d", &num);
	printf("num=%d\n", num);
	
	double sum=0;
	double (*pfunc)(int); //这是指向函数的指针
	if(0 == num%2){
		pfunc=addEven;
	}else{
		pfunc=addOdd;
	}
	sum=pfunc(num);
	printf("sum=%lf\n",sum);
	return 0;
}

$ ./a.out
please input a number:4
num=4
Even
sum=0.750000









54. 题目：字符串数组的指针都保存在什么位置？（指向指针的指针）。

难度：*
查看指针本身保存的位置。
要点： &a  获取a变量的地址； *p 获取指针p所指向地址的值(&p表示指针变量p本身保存的地址)
字符串数组，
	最外层是一系列指针构成的数组，指向每个字符串的首字母坐标；
	每个字符串又是一个字符数组。

#include<stdio.h>
int main(){
	char *words[]={"apple", "banana", "orange", "book"};
	char **ptr;
	int i;
	for(i=0; i<4; i++){
		ptr=&words[i]; //ptr 和 words[0] 是同一个东西，都是指向（字符数组的）指针的指针。
		printf("words[%d]: addr=%p->%p: %s\n", i, &words[i], words[i], words[i]);
		printf("  ptr[%d]: addr=%p->%p: %s\n", i, &ptr, *ptr, *ptr);
	}
}

输出
words[0]: addr=0x7ffe2d055de0->0x55c645b51834: apple
  ptr[0]: addr=0x7ffe2d055dd8->0x55c645b51834: apple
words[1]: addr=0x7ffe2d055de8->0x55c645b5183a: banana
  ptr[1]: addr=0x7ffe2d055dd8->0x55c645b5183a: banana
words[2]: addr=0x7ffe2d055df0->0x55c645b51841: orange
  ptr[2]: addr=0x7ffe2d055dd8->0x55c645b51841: orange
words[3]: addr=0x7ffe2d055df8->0x55c645b51848: book
  ptr[3]: addr=0x7ffe2d055dd8->0x55c645b51848: book


gdb调试，查看某些变量的内存地址：
(gdb) p &words  ## words本身保存在栈上，地址较大。是个指针构成的len=4的数组，里面的数组指向char字符串。
$1 = (char *(*)[4]) 0x7fffffffe010

(gdb) p words ## words 数组中都是指针，指向堆（编号较小）。
$2 = {0x555555554834 "apple", 0x55555555483a "banana", 0x555555554841 "orange", 0x555555554848 "book"}

(gdb) p &words[0] #数组元素本身保存的位置是栈上，在指针数组内连续保存。
$3 = (char **) 0x7fffffffe010
(gdb) p ptr
$4 = (char **) 0x7fffffffe010

(gdb) p words[0] #指针数组内的元素是指针，该指针指向字符串
$5 = 0x555555554834 "apple"
(gdb) p *ptr
$6 = 0x555555554834 "apple"

(gdb) x/8c 0x555555554834
0x555555554834:	97 'a'	112 'p'	112 'p'	108 'l'	101 'e'	0 '\000'	98 'b'	97 'a'









55. 题目：找到年龄最大的人，并输出。请找出程序中有什么问题。
#include<stdio.h>
#include<stdlib.h>
struct man{
    char name[20];
    int  age;
}
person[3]={"li",18,"wang",25,"sun",22}; //和前面的结构体是连写的。

int main(){
    struct man *q,*p;
    int i,m=0;
    p=person;
    for(i=0; i<3; i++){
        if(m< p->age){
            m=p->age; //记录年龄较大值
            q=p;  //记录指向这个人的指针
        }
        p++; //p开始指向起始位置，后面依次偏移
    }
    printf("%s %d\n",q->name,q->age);
    return 0;
}

难度：*

看不懂这个操作。
使用gdb调试。

$ gdb a.out
(gdb) p p
$1 = (struct man *) 0x555555755020 <person>

(gdb) p person
$2 = {{name = "li", '\000' <repeats 17 times>, age = 18}, {name = "wang", '\000' <repeats 15 times>, age = 25}, {name = "sun", '\000' <repeats 16 times>, age = 22}}











========================================
|-- 练习题 组6: 进制转换、哥德巴赫猜想、加密解密
(n=10)
----------------------------------------

56. 题目：海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只 猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了 一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的， 问海滩上原来最少有多少个桃子？

难度：*****
难点：没独自写出来。


分析：之前做过类似的，递归。
第一只猴子拿之前 n 个。
	丢海里 1个，
	拿走 (n-1)/5
	剩下 (n-1) - (n-1)/5=(n-1)*0.8
第n=2 只猴子拿之前 x个
	剩下 (x-1)*0.8
...
最后一个猴子
	剩下 (x-1)*0.8 =y
	之前有 x=y/4*5+1
	y是4的倍数


答案看懂了。
逐个看自增的j是否符合要求。
这个内循环中检验条件，不符合就中断，直到内循环都符合条件。
外部while循环很巧妙。只要不是5个条件都通过，必然导致i<5，则自增j继续检查。

#include<stdio.h>
int main(){
	int i=0, j=1, x;
	
	while(i<5){
		x=4*j;
		for(i=0; i<5; i++){
			if(x %4 !=0){break;}
			x = (x/4)*5+1;
		}
		j++;		
	}
	printf("%d\n", x);
	return 0;
}

$ ./a.out
3121




写法2: 五人分鱼
A、B、C、D、E 五人在某天夜里合伙去捕鱼，到第二天凌晨时都疲惫不堪，于是各自找地方睡觉。
日上三杆，A 第一个醒来，他将鱼分为五份，把多余的一条鱼扔掉，拿走自己的一份。
B 第二个醒来，也将鱼分为五份，把多余的一条鱼扔掉拿走自己的一份。 。
C、D、E依次醒来，也按同样的方法拿鱼。
问他们台伙至少捕了多少条鱼?以及每个人醒来时见到了多少鱼？

分析：
假设总共x条，
第1个拿走后剩下 x1= (x-1)*4/5 ,就是下一个人见到的
第2个拿走后剩下 x2= (x1-1)*4/5
...
第5个拿走后剩下 x5= (x4-1)*4/5

穷举法
#include<stdio.h>
int main(){
	int x=0,x1,x2,x3,x4,x5;
	for(x=1; ; x++){
		x1= (x-1)*4/5;
		x2= (x1-1)*4/5;
		x3= (x2-1)*4/5;
		x4= (x3-1)*4/5;
		//x5= (x4-1)*4/5;
		if( (x%5==1) && (x1%5==1) && (x2%5==1) &&(x3%5==1) &&(x4%5==1)){
			printf("total: %d\n", x);
			printf("每个人看到的总数: %d %d %d %d %d\n", x, x1, x2, x3, x4);
			break;
		}
	}
	return 0;
}

$ ./a.out 
total: 3121
每个人看到的总数: 3121 2496 1996 1596 1276



















57. 题目：809*??=800*??+9*?? 其中??代表的两位数, 809*??为四位数，8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。

难度：*
直接穷举法

分析: 用两位数ab表示 ??

809*??为四位数，  
8*??的结果为两位数，
9*??的结果为3位数

#include<stdio.h>
int main(){
	int a,b;
	for(a=0; a<9; a++){
		for(b=0; b<9; b++){
			int x=a*10+b;
			if(( 809*x>=1000 && 809*x<=9999 ) && (8*x>=10 && 8*x<=99) && (9*x>=100 && 9*x<=999) ){
				printf("test: %d\n", x);
				if( 809*x == 800*x+9*x){
					printf("809*%d == 800*%d+9*%d\n", x,x,x);
				}
			}
		}
	}
	return 0;
}

输出：
test: 12
809*12 == 800*12+9*12









58. 八进制转换为十进制

难度：**
难点：sum += 这个注意是否有必要写+。使用 gdb 调试可以看到这些细节。
向十进制转还好，就是右侧有几位就乘以进制的几次方，累加。

#include<stdio.h>
int main(){
	char str[20], c;
	int i=0, j=0, sum=0;
	printf("请输入8进制数，不加首位的0:");
	while( (c=getchar())!='\n' && i<20 ){
		printf("%c", c);
		str[i]=c;
		i++;
	}
	str[i]='\0';
	for(j=0; j<i; j++){
		sum = sum*8 + (str[j]-'0');
	}
	printf("\nsum=%d\n", sum);
	return 0;
}

输出： 
$ ./a.out
请输入8进制数，不加首位的0:10
10
sum=8

16
sum=14

改善：抽象成函数，效果更佳。









59. 题目：求0—7所能组成的奇数个数。

难度：***

分析：有点难理解，就是0,1,2,3,4,5,6,7 八个数字，组成的奇数个数。
奇数: 1 3 5 7 n=4;
偶数: 0 2 4 6 n=4;
是不是全用上？全用上8位数，到最小的1位数。
	个位必须是1,3,5,7
	最高位不能是0.
能否重复？
使用排列组合公式
1位数: 4
2位数: 最低位 4* 最高位 (8-1-1)=4*6=24
3位数：4*(8-1-1)*(8-2)=4*6*6=24*6=414
	4*(8-2)*A(6, 1)
8位数: 4*(8-2)*A(6,6)

#include<stdio.h>
int A(int n, int k){
	int i=0, rs=1;
	if(0==k)
		return 1;
	while(k--){
		rs *= n;
		n--;
	}
	return rs;
}
int main(){
	int i, j, num, sum=4;
	for(i=2; i<=8; i++){
		num=4*6*A(6,i-2);
		printf("%d -> %d\n", i, num);
		sum+=num;
	}
	printf("总共的奇数个数是：%d\n", sum);
	return 0;	
}


$ ./a.out
2 -> 24
3 -> 144
4 -> 720
5 -> 2880
6 -> 8640
7 -> 17280
8 -> 17280
总共的奇数个数是：46972



方法2: 看答案，给出的是可重复使用数字。
那就再来一次
奇数: 1 3 5 7 n=4
偶数: 0 2 4 6 n=4
一位: 4
2位: 4*(8-1)*8^0
3位: 4*(8-1)*8^1
4位: 4*(8-1)*8^2
5位: 4*(8-1)*8^3
...
8位: 4*(8-1)*8^6

#include<stdio.h>
int main(){
	int i, sum=4, num=4;
	for(i=2; i<=8; i++){
		if(i==2)
			num *= 7;
		else 
			num *= 8;
		sum+= num;
	}
	printf("总共的奇数个数是：%d\n", sum);
	return 0;	
}

总共的奇数个数是：8388608









60. 题目：一个偶数总能表示为两个素数之和。

难度：***
这就是哥德巴赫猜想：1+1=2
我只能验证一下了，使用穷举法，也没啥技巧可言了。

#include<stdio.h>

int isPrimer(int n){
	int i;
	for(i=2; i<n; i++){
		if(n%i==0){
			return 0;
		}
	}
	return 1;
}

//test from n+1
int nextPrimer(int n){
	int i, flag;
	while(1){
		n++;
		if( isPrimer(n) ){
			return n;
		}
	}
}
void getNprimers(int N){
	int i, n=2;
	for(i=0; i<N; i++){
		printf("质数%d = %d\n", i, n);
		n=nextPrimer(n);
	}
}


int main(){
	//getNprimers(100);
	int num, i, j, flag;
	printf("请输入一个偶数: ");
	scanf("%d", &num);
	if(num<=0 || num%2!=0){
		printf("Error: must positive even!\n");
		return 1;
	}
	
	//开始分解
	flag=0;
	i=1;
	while(i<num){
		//保证一个是质数
		i=nextPrimer(i);
		//判断另一个是不是质数
		j=num-i;
		if(i>j){
			break;
		}
		
		if( isPrimer(j) ){
			flag=1;
			break;
		}
	}
	if(flag){
		printf("%d = %d + %d\n", num, i, j);
	}
		
	return 0;
}









61. 题目：判断一个素数能被几个9整除。

难度：*
分析：
若整数b除以非零整数a，商为整数，且余数为零， 我们就说b能被a整除（或说a能整除b）
b / a =x 余数0；

素数是不 能被除1和自身之外的数整除的。

这个题是错的。改正为: 几个9构成的整数能被质数整除？

#include<stdio.h>
int main(){
	int num, i,x=9;
	printf("input a primer:\n");
	scanf("%d", &num);
		
	for(i=1; i<20; i++){
		x = x*10 +9;
		if(x%num ==0){
			printf("%d / %d = %d 余数为0\n", x,num, x/num);
			break;
		}
	}
	return 0;
}

input a primer:
13
999999 / 13 = 76923 余数为0

修正：怎么防止越界变负数？









62. 题目：两个字符串连接程序 。

难度：*
分析：连接后返回一个新的指针。
逐步改进：写一个获取字符数组长度的函数。
写一个复制的函数。

#include<stdio.h>
#include<stdlib.h>

//字符串长度
int strlen2(char *p){
	int n=0;
	while(*p!='\0'){
		n++;
		p++;
	}
	return n;
}

//复制字符段，并返回新指针
char *strcat2(char *p1, char *p2){
	//获取长度
	int n1=strlen2(p1), n2=strlen2(p2), i;

	//复制字符数组
	char *p3=malloc(sizeof(char)*(n1+n2+1));
	while(*p1!='\0'){
		*(p3++)=*(p1++);		
	}
	while(*p2!='\0'){
		*(p3++)=*(p2++);
	}
	//*p3='\0';
	return p3-n1-n2;
}

int main(){
	char *c1="hello";
	char *c2=" world!";
	
	char *pstr=strcat2(c1, c2);
	printf("'%s'\n", pstr);
	free(pstr);
	return 0;
}

输出: 
$ ./a.out 
hello world!








63.题目：回答结果（结构体变量传递）。
#include<stdio.h>
struct student{
    int x;
    char c;
} a;
void f(struct student b);

int main()
{
    a.x=3;
    a.c='a';
    f(a);
    printf("%d,%c\n",a.x,a.c);
}
void f(struct student b){
    b.x=20;
    b.c='y';
}

我猜测的结果： 20，y
程序结果: 3,a

分析：
结构体变量是按照值传递的？


要想改变，必须改变参数的传递方式为按址传递；
#include<stdio.h>
struct student{
    int x;
    char c;
} a;
void f(struct student *b);

int main()
{
    a.x=3;
    a.c='a';
    f(&a);
    printf("%d,%c\n",a.x,a.c);
}
void f(struct student *b){
    b->x=20;
    b->c='y';
}

结果：20,y










64. 题目：读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的 ＊。

难度：*

#include<stdio.h>

void showStar(int n){
	int i;
	for(i=0; i<n; i++){
		printf("*");
	}
	printf("\n");
}

int main(){
	int i, arr[]={5,10,20};
	for(i=0; i<3; i++){
		showStar(arr[i]);
	}
	return 0;
}

$ ./a.out 
*****
**********
********************









65. 题目：某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下： 每位数字都加上5,然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。

难度：**
难点：是不是还要翻译出原文呢？否则这个加密没有意义。

#include<stdio.h>
void swap(int *p1, int *p2){
	int tmp=*p1;
	*p1=*p2;
	*p2=tmp;
}

int encode(int n){
	if(!(n>=1000 && n<=9999)){
		printf("Error: must be 4 digit number!\n");
		return -1;
	}
	//获取每位数字
	int i=0, arr[4];
	while(n>0){
		//进行加密1
		arr[i++] = (n%10 + 5) % 10;
		n/=10;
	}
	//加密2
	swap(&arr[0], &arr[3]);
	swap(&arr[1], &arr[2]);
	// 输出
	int rs=0;
	for(i=3; i>=0; i--){
		rs = rs *10 + arr[i];
	}
	return rs;
}

//解密
int decode(int n){
	if(!(n>=1000 && n<=9999)){
		printf("Error: must be 4 digit number!\n");
		return -1;
	}
	//获取每位数字
	int i=0, arr[4];
	while(n>0){
		//进行解密1
		arr[i++] = (n%10 - 5 +10) % 10;
		n/=10;
	}
	//解密2
	swap(&arr[0], &arr[3]);
	swap(&arr[1], &arr[2]);
	//输出
	int rs=0;
	for(i=3; i>=0; i--){
		rs = rs *10 + arr[i];
	}
	return rs;
}

int main(){
	int arr[]={1234, 9982, 3369};
	int i, N=sizeof(arr)/sizeof(int);
	int rs[3];
	
	//加密
	for(i=0; i<N; i++){
		rs[i]=encode(arr[i]);
		printf("%d after encoding is %d | decoding: %d\n", arr[i], rs[i], decode(rs[i]) );
	}
	return 0;
}

$ ./a.out 
1234 after encoding is 9876 | decoding: 1234
9982 after encoding is 7344 | decoding: 9982
3369 after encoding is 4188 | decoding: 3369







========================================
|-- 练习题 组7: 首尾交换 /时间戳 /固定范围的随机数 /子串频数 /文件读写 /汉诺塔
(n=10)
----------------------------------------

66. 写出结果
#include<stdio.h>
#include<stdlib.h>

#define M 5
int main()
{
    int a[M]={1,2,3,4,5};
    int i,j,t;
    i=0;j=M-1;
    while(i<j)
    {
        t=*(a+i);
        *(a+i)=*(a+j);
        *(a+j)=t;
        i++;j--;
    }
    for(i=0;i<M;i++) {
        printf("%d\n",*(a+i));
    }
    
}

解析：
i=0, j=4;
while(i<j){
	交换首尾元素。
}
打印结果 
5
4
3
2
1

点评：这个首位交换元素，用到指针，很值得学习。









67. 题目：时间函数举例1

#include <stdio.h>
#include <time.h>

int main (){
    time_t rawtime;
    struct tm * timeinfo;
    
    time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    printf ( "当前本地时间为: %s", asctime (timeinfo) );
    
    return 0;
}

输出：当前本地时间为: Mon Aug  2 20:54:00 2021



//(2)时间函数举例2
#include <stdio.h>
#include <time.h>

int main()
{
    time_t start,end;
    int i;
    start=time(NULL);
    for(i=0;i<300000;i++)
    {
        printf("$d\n", i);  // 返回两个time_t型变量之间的时间间隔
    }
    end=time(NULL);
    
    // 输出执行时间
    printf("时间间隔为 %6.3f\n",difftime(end,start));
}
输出：时间间隔为  4.000




//(3)时间函数举例3
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
    long i=10000000L;
    clock_t start,finish;
    double TheTimes;
    printf("做%ld次空循环需要的时间为",i);
	
    start=clock();
    while(i--);
    finish=clock();
    
	TheTimes=(double)(finish-start)/CLOCKS_PER_SEC;
    printf("%f秒。\n",TheTimes);
    return 0;
}
输出： 做10000000次空循环需要的时间为0.029133秒。









68. 题目：猜谜游戏。随机数字，给出范围，猜测后给出大了/小了的提示。

难度：***
难点：随机数怎么生成

(1) 产生固定范围的随机数的三个步骤
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main(){
	int a=1, b=100, i;
	srand((unsigned)time(NULL)); //1.随机数种子
	//int n=rand(); //2.随机数
	
	//3.生成一定范围内的随机数
	//int n= rand() % 10; [0,9]
	for(i=0; i<100; i++){
		int n= rand() % 100+1; //[0,99]+1 => [1,100]
		printf("%d n=%d\n",i, n);
	}
	return 0;
}


(2) 抽象成函数
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int getRand(int a, int b){
	srand((unsigned)time(NULL)); //1.随机数种子
	//int n=rand(); //2.随机数
	
	//3.生成一定范围内的随机数
	int n= rand() % b+a;
	return n;
}

int main(){
	int a=1, b=100;
	int n=getRand(a, b);
	printf("n=%d\n", n);
	
	return 0;
}


(3) 解答题目
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int getRand(int a, int b){
	srand((unsigned)time(NULL)); //1.随机数种子
	//int n=rand(); //2.随机数
	
	//3.生成一定范围内的随机数
	int n= rand() % b+a;
	return n;
}

int main(){
	int a=1, b=100, count=0;
	int n=getRand(a, b);
	int guess=-1, flag=0;
	
	printf("系统已经生成一个[0, 100]的随机数，请猜出该数字:\n");
	while(0==flag){
		scanf("%d", &guess);
		if(guess<0 || guess>100){
			printf("输入错误，输入范围[0, 100]");
			continue;
		}
		//如果对了
		if(guess == n){
			printf("猜对了！恭喜\n");
			break;
		}else if(guess<n){
			printf("小了，再猜\n");
			continue;
		}else if(guess>n){
			printf("大了，再猜\n");
		}
		
		if(count++>50){
			printf("尝试次数过多，已退出\n");
			break;
		}
	
	}
	return 0;
}








69. 题目：计算字符串中子串出现的次数。

难度：**

先给几个例子
abcdab 中 ab出现2次。
有没有可能循环？
aaa中包含aa多少次？aa，aa 共2次。

#include<stdio.h>
#include<string.h>
int main(){
	char *arr="this is a book, that is a cat! That fox jumps over this box.";
	char *sub="is";
	int n1=strlen(arr), n2=strlen(sub);
	
	int i,j, freq=0, flag;
	for(i=0; i<n1; i++){
		flag=1;
		for(j=0; j<n2; j++){
			if(arr[i+j] != sub[j] ){
				flag=0;
				break;
			}
		}
		if(flag){
			freq++;
			printf("第 %d 次匹配，匹配位置 %d\n", freq, i);
		}
	}
	printf("总匹配次数: %d\n", freq);
	return 0;
}

一次没写对，使用 gdb 调试。发现最开始flag=1，错写成0.
输出：
第 1 次匹配，匹配位置 2
第 2 次匹配，匹配位置 5
第 3 次匹配，匹配位置 21
第 4 次匹配，匹配位置 53
总匹配次数: 4


扩展：怎么实现正则表达式部分功能？









70. 题目：从键盘输入一些字符，逐个把它们送到磁盘上去，直到输入一个#为止。

难度：**
难点：文件的写入

#include<stdio.h>
int main(){
	FILE *fp;
	fp=fopen("backup/01.txt", "w");
	if( fp==NULL ){
        printf("error: cannot open file!\n");
        return -1;
    }
	//保存
	char ch;
	printf("请输入想保存的文件，#结束\n");
	while( (ch=getchar())!= '#'){
		fputc(ch, fp);
	}
	fclose(fp);
	return 0;
}

$ ./a.out 
请输入想保存的文件，#结束
this is a book
that is a dog
#

$ cat backup/01.txt 
this is a book
that is a dog









71. 题目：从键盘输入一个字符串，将小写字母全部转换成大写字母，然后输出到一个磁盘文件"test"中保存。 输入的字符串以！结束。

难度：*
模仿刚做过的写。

#include<stdio.h>
int main(){
	FILE *fp;
	fp=fopen("backup/02.txt", "w");
	if( fp==NULL ){
        printf("error: cannot open file!\n");
        return -1;
    }
	
	printf("A(%d), a(%d)\n", 'A', 'a'); //A(65), a(97)
	printf("Z(%d), z(%d)\n", 'Z', 'z'); //Z(90), z(122)
	
	//保存
	char ch;
	printf("请输入想保存的文件，以!结束\n");
	while( (ch=getchar())!= '!'){
		//小写变大写
		if( ch>=97 && ch<=122 )
			ch=ch-32;		
		fputc(ch, fp);
	}

	fclose(fp);
	return 0;
}

 ./a.out 
A(65), a(97)
Z(90), z(122)
请输入想保存的文件，以!结束
this is 7 books from US.!

$ cat backup/02.txt 
THIS IS 7 BOOKS FROM US.









72. 题目：有两个磁盘文件A和B,各存放一行字母，要求把这两个文件中的信息合并（按字母顺序排列），输出到一个新文件C中。

难度：*****
难点：文件读写。字符串数组的参数传递
分析：读取2个文件，获取单词列表，排序，写文件。

//提前准备两个文件，都放一行英语句子，不加标点。
$ cat backup/A.txt
this is the first line in A

$ cat backup/B.txt
the fox jumps over that box



#include<stdio.h>
#include<stdlib.h>
#include<string.h>

//输出字符串数组
void showArr(char arr[50][10], int n){
	int i;
	for(i=0; i<n; i++){
		printf("%s ", arr[i]);
	}
	printf("\n");
}

//交换字符串
void swap_str(char *a, char *b){
	char tmp[10]; //字符串初始化必须指定大小，否则报错
	strcpy(tmp, a);
	strcpy(a, b);
	strcpy(b, tmp);
}

//对字符串数组排序
void sortArr(char arr[50][10], int n){
	int i, j, small;
	for(i=0; i<n-1; i++){
		small=i;
		for(j=i; j<n; j++){
			if( strcmp(arr[small], arr[j]) >0 ){
				small=j;
			}
		}
		if(small!=i){
			swap_str(arr[small], arr[i]);
		}
	}
}

//读取文件, 并用空格分割为字符串数组，放到指定数组中
//通过指针返回多个值
//bug1: 函数参数传递文件名，使用数组形式，不能使用 char *filename,
//bug2: p72-v4.c:29:9: error: array subscript is not an integer
//		*(arr[n] + i++)='\0'; 发现是传参数是*n，则使用的时候也要是 arr[*n]
//bug3: expected ‘char (*)[10]’ but argument is of type ‘char (*)[50][10]’
//		void readFile2Arr(char filename[], int *n, char arr[50][10]){} //二维数组怎么传参？
//		char arr[50][10]; readFile2Arr(filename, &len, arr); //为什么报错？

void readFile2Arr(char filename[], int *n, char arr[50][10]){
	FILE *fp=NULL;
	fp=fopen(filename, "r");
	if( fp==NULL ){
		printf("error: cannot open file!\n");
		exit(0);
	}
	
	//读文件
	char str;
	int i=0;
	while( (str=fgetc(fp))!= '\n' ){ //EOF
		if(str==' '){
			*(arr[*n] + i++)='\0';
			(*n)++;
			i=0;
		}else
			*(arr[*n] + i++)=str;
	}
	*(arr[*n] + i++)='\0';
	(*n)++;
	i=0;
	fclose(fp);
}


//写入文件
void save2File(char filename[], int n, char arr[50][10]){
	FILE *fp=NULL;
	fp=fopen(filename, "w");
	if( fp==NULL ){
		printf("error: cannot open file!\n");
		exit(0);
	}
	
	//写文件
	int i, j=0;
	char ch;
	for(i=0; i<n; i++){
		j=0;
		while( (ch=*(arr[i] + j++))!='\0' ){
			fputc(ch, fp);
		}
		fputc(' ', fp);
	}
	fputc('\n', fp);
	fclose(fp);
}


int main(){
	int len=0;
	char strArr[50][10];
	
	//读取第一个文件
	char fName1[20]="backup/A.txt";
	readFile2Arr(fName1, &len, strArr);
	showArr(strArr, len); //输出字符串
	
	//读取第二个文件
	char fName2[20]="backup/B.txt";
	readFile2Arr(fName2, &len, strArr);
	showArr(strArr, len); //输出字符串
	
	//按照字母顺序排序
	sortArr(strArr, len);
	showArr(strArr, len); //输出字符串
	
	//输出到文件
	char fName3[20]="backup/C.txt";
	save2File(fName3, len, strArr);
	
	return 0;
}


gdb测试
(gdb) p arr
$1 = (char (*)[10]) 0x7fffffffde40

(gdb) p &strA
$8 = (char (*)[50][10]) 0x7fffffffde40


输出：读取文件A，文件B，排序后。写入文件C。
$ ./a.out 
this is the first line in A 
this is the first line in A the fox jumps over that box 
A box first fox in is jumps line over that the the this 

$ cat backup/C.txt 
A box first fox in is jumps line over that the the this 









73. 题目：有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，并把原有的数据和计算出的平均分数存放在磁盘文件"stud"中。

难度：**
分析：结构体的定义和引用。

扩展：计算学科平均值时，怎么把结构体中的成员作为变量名？sum=stu[i].para; 这个 para="Math"

#include<stdio.h>
#include<stdlib.h>
const int N=3;
struct Student{
	int id;
	char name[10];
	int Chinese;
	int Math;
	int English;
	float avg;
};

float avg(struct Student *ptr){
	return (float)(ptr->Chinese + ptr->Math + ptr->English)/N;
}

int main(){
	struct Student stus[N];
	int i;
	printf("请输入学生的信息: id 姓名 语文 数学 英语\n");
	for(i=0; i<N; i++){
		scanf("%d %s %d %d %d", &stus[i].id, stus[i].name, &stus[i].Chinese, &stus[i].Math, &stus[i].English);
		//计算平均分1
		stus[i].avg = avg(&stus[i]);
	}
		
	//保存到文件
	FILE *fp=fopen("backup/03.txt", "w");
	if( fp==NULL ){
		printf("Error: cannot open file!\n");
		exit(0);
	}
	
	for(i=0; i<N; i++){
		fprintf(fp, "%d %s %d %d %d %f\n", stus[i].id, stus[i].name, stus[i].Chinese, stus[i].Math, stus[i].English, stus[i].avg);
	}
	fclose(fp);
	return 0;
}


$ ./a.out 
请输入学生的信息: id 姓名 语文 数学 英语
1 Tom 80 70 77
2 Kate 90 98 99
21 Tom 60 100 100


$ cat backup/03.txt 
1 Tom 80 70 77 75.666664
2 Kate 90 98 99 95.666664
21 Tom 60 100 100 86.666664









74. 汉诺塔问题求解。
相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘。
游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。
操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。

问，最少多少步能把所有圆盘移动到C上，怎么移？

难度：*****
分析：递归。 
对于这样一个问题，任何人都不可能直接写出移动盘子的每一步，但我们可以利用下面的方法来解决。
设移动盘子数为n，为了将这n个盘子从A杆移动到C杆，可以做以下三步：
(1)以C盘为中介，从A杆将1至n-1号盘移至B杆；
(2)将A杆中剩下的第n号盘移至C杆；
(3)以A杆为中介；从B杆将1至n-1号盘移至C杆。


#include<stdio.h>
int hanoi(int,char,char,char);
int move(char,int,char);

int main(){
    int n,counter;
    printf("Input the number of diskes：");
    scanf("%d",&n);
    printf("\n");
	
    counter=hanoi(n,'A','B','C');
    return 0;
}

//递归式调用
int hanoi(int n,char x,char y,char z){
    if(n==1)
        move(x,1,z);
    else{
        hanoi(n-1,x,z,y);//1.以z为中介，把n-1个从x移动到y上
        move(x,n,z); //2.把第n个从x移动到z
        hanoi(n-1,y,x,z); //3.以x为中介，把n-1个从y移动到z上
    }
    return 0;
}

//移动操作
// getFrom, 递归 step number, to
int move(char getone, int n, char putone){
    static int k=1; //移动步数
    printf("%3d:%3d # %c-->%c\n", k, n, getone,putone);
    if(k++%3==0)
        printf("\n"); //每移动三次换行
    return 0;
}


$ ./a.out 
Input the number of diskes：3

  1:  1 # A-->C
  2:  2 # A-->B
  3:  1 # C-->B

  4:  3 # A-->C
  5:  1 # B-->A
  6:  2 # B-->C

  7:  1 # A-->C
#









75. 题目： 约瑟夫生者死者小游戏
30 个人在一条船上，超载，需要 15 人下船。
于是人们排成一队，排队的位置即为他们的编号。
报数，从 1 开始，数到 9 的人下船。
如此循环，直到船上仅剩 15 人为止，问都有哪些编号的人下船了呢？

分析：排成一队，就是不是循环的？略看一下答案，是循环的。

#include<stdio.h>

//删除数组中的某个元素，就是把后续的都提前一位
void del(int arr[], int len, int i){
	int j;
	for(j=i; j<len-1; j++){
		arr[j]=arr[j+1];
	}
}

int main(){
	int arr[30]; //保存船员编号
	int i;
	for(i=0; i<30; i++){
		arr[i]=i+1;
	}
	
	//计数器 counter， 剩余船员数 remain
	int counter=0, remain=30;
	while(remain>15){
		for(i=0; i<remain; i++){
			// 报数有人数到9，则退出
			counter++;
			counter=counter%9;
			if(counter==0){
				printf("%d leave the boat\n", arr[i]);
				del(arr, remain, i); //数到9，则删除该元素i
				
				remain--;
				i--;
			}
			if(remain<=15){
				break;
			}
		}
	}
	return 0;
}












========================================
|-- 练习题 组8:  //todo
(n=10)
----------------------------------------
76. 输出当前文件执行代码
提示：__FILE__ 为当前执行的文件常量。

#include <stdio.h>
int main() {
    FILE *fp;
    char c;
	
	printf("String of __FILE__=%s\n", __FILE__);
	
    fp = fopen(__FILE__,"r");
    do {
         c = getc(fp);
         putchar(c);
    } while(c != EOF);
    
	fclose(fp);
    return 0;
}

输出：String of __FILE__=p76.c
程序源码。





==> 输出程序源码 / 

========================================
|-- 练习题 组n: 链表
(n=10)
----------------------------------------

52. 链表
创建链表 https://www.runoob.com/cprogramming/c-exercise-example72.html
反向输出一个链表。　73
连接两个链表。74




题目：字符串排序。79



进度：ex39
ex70



























========================================
基于点阵的文字输出：多分辨率、多字符(大小写、数字、特殊符号)
----------------------------------------
1. 输出液晶状态的阿拉伯数字(5*3 最小分辨率)

难度：*****
难点：多维数组、指针操作数组、返回指针的函数、动态分配内存。

#include<stdio.h>
#include<stdlib.h>
//数字点阵
int digits[10][5][3] = { 
		{ {1,1,1},{1,0,1},{1,0,1},{1,0,1},{1,1,1} }, //0
		{ {0,1,0},{1,1,0},{0,1,0},{0,1,0},{1,1,1} }, //1
		{ {1,1,1},{0,0,1},{1,1,1},{1,0,0},{1,1,1} }, //2
		{ {1,1,1},{0,0,1},{1,1,1},{0,0,1},{1,1,1} }, //3
		{ {1,0,1},{1,0,1},{1,1,1},{0,0,1},{0,0,1} }, //4
		{ {1,1,1},{1,0,0},{1,1,1},{0,0,1},{1,1,1} }, //5
		{ {1,1,1},{1,0,0},{1,1,1},{1,0,1},{1,1,1} }, //6
		{ {1,1,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1} }, //7
		{ {1,1,1},{1,0,1},{1,1,1},{1,0,1},{1,1,1} }, //8
		{ {1,1,1},{1,0,1},{1,1,1},{0,0,1},{1,1,1} } //9
	};

//输入字符矩阵，打印
void printDigits(int *ptr, int nRow, int nCol){
	int i,j;
	for(i=0; i<nRow; i++){
		for(j=0; j<nCol; j++){
			char c = (0==*ptr)?' ':'*';
			printf("%c", c);
			ptr++;
		}
		printf("\n");
	}
}

//合并几个数字的点阵，间距是2列0.
int *combineDigits(int number, int spacer){
	//根据输入的数的长度，倒解连环
	int i=0, x[10], res;
	while(1){
		res=number % 10;
		x[i]=res;
		i++;
		number/=10;
		
		if(number<10){
			x[i]=number;
			break;
		}
	}
	//数组倒置
	for(int j=0; j< (i+1)/2; j++){
		int tmp=x[j], j2=i-j;
		x[j]=x[j2];
		x[j2]=tmp;
	}
	//逐个打印数组
	for(int j=0; j<=i; j++){
		printf("%d ", x[j]);
	}
	printf("\n");
	
	int n=i+1, nCol= 3*n+spacer*(n-1);
	//这个要注意返回的是最初的指针，而循环中指针一直在向后偏移。
	int *ptr0=malloc( sizeof(int)*5*nCol ), *ptr; 
	ptr=ptr0;
	for(int i=0; i<5; i++){
		for(int j=0; j<nCol; j++){
			int cur=x[j/(3+spacer)];
			
			int *digit= (int *)digits[cur];
			int r=j%(3+spacer);
			if( r<=2 ){
				*ptr=digit[i*3+r];
			}else{
				*ptr=0;
			}
			ptr++;
		}
	}
	return ptr0;
}


int main(int argc, char *argv[]){
	if(argc<2){
		printf("please provide a number [0, 9]\n");
		return 1;
	}
	//获取输入字符串，转为整数
	int num=atoi(argv[1]);
	printf("%d\n", num);
	
	if(num<0){
		printf("Error: x>=0\n");
		return 1;
	}else if(num<10){
		printDigits( (int *)digits[num], 5, 3 ); //传递参数时，要做指针类型转换
	}else if(num<1000*1000*1000){
		//2位到9位之间的
		int spacer=2;
		int *ptr=combineDigits(num, spacer);
		
		int n=0;
		while(num){
			n++;
			num/=10;
		}
		int nCol= 3*n+spacer*(n-1);
		printDigits( (int *)ptr, 5, nCol );
		free(ptr);
	}else{
		printf("Error: x<1e9\n");
		return 1;
	}
	return 0;
}


测试：
$ ./a.out 314649593
314649593
3 1 4 6 4 9 5 9 3 
***   *   * *  ***  * *  ***  ***  ***  ***
  *  **   * *  *    * *  * *  *    * *    *
***   *   ***  ***  ***  ***  ***  ***  ***
  *   *     *  * *    *    *    *    *    *
***  ***    *  ***    *  ***  ***  ***  ***

$ ./a.out 20210728
20210728
2 0 2 1 0 7 2 8 
***  ***  ***   *   ***  ***  ***  ***
  *  * *    *  **   * *    *    *  * *
***  * *  ***   *   * *    *  ***  ***
*    * *  *     *   * *    *  *    * *
***  ***  ***  ***  ***    *  ***  ***




改进：//todo
怎么增大分辨率？
怎么加入字母点阵?


题目：画图，学用circle画圆形。
https://www.runoob.com/cprogramming/c-exercise-example56.html






========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------


