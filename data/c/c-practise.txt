C 语言100题


熟能生巧
- 先分析，手动分解已知条件
- 设计程序步骤
- 具体编码实现



========================================
题目来源
----------------------------------------
https://www.runoob.com/cprogramming/c-100-examples.html



========================================
基本的条件/循环语句、逻辑运算、数据类型、输入输出
(n=10)
----------------------------------------
我在 Ubuntu 环境做的测试，输出字符、图案的效果都不好。


1.题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？
难度：*

$ cat p01.c
#include<stdio.h>
int main(){
	int i,j,z, counter=1;
	for(i=1; i<5; i++){
		for(j=1; j<5; j++){
			for(z=1; z<5; z++){
				if(i!=j && i!=z && j!=z){
					printf("%d %d%d%d\n", counter++, i,j,z);
				}
			}
		}
	}
	return 0;
}

# 共24个。


优化后，提前结束一下不必要的循环。
$ cat p01-v2.c 
#include<stdio.h>
int main(){
	int i,j,z, counter=1;
	for(i=1; i<5; i++){
		for(j=1; j<5; j++){
			if(i==j) continue;
			for(z=1; z<5; z++){
				if(i==z || j==z) continue;
				printf("%d %d%d%d\n", counter++, i,j,z);
			}
		}
	}
	return 0;
}









2. 题目：企业发放的奖金根据利润提成。

利润(I)低于或等于10万元时，奖金可提10%；
利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；
20万到40万之间时，高于20万元的部分，可提成5%；
40万到60万之间时高于40万元的部分，可提成3%；
60万到100万之间时，高于60万元的部分，可提成1.5%；
高于100万元时，超过100万元的部分按1%提成。
从键盘输入当月利润I，求应发放奖金总数？

程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。

难度：***

重点：从命令行获取参数； 字符串变数字/浮点数

测试功能
$ cat p02-v0.c 
#include<stdio.h>
#include<stdlib.h>
int main(int argc, char *argv[]){
        if(argc<2){
                printf("You must provide a long int!\n");
                return 1;
        }
        for(int i=0; i<argc; i++){
                printf("argv[%d]=%s\n", i, argv[i]);
        }
        long total=atol(argv[1]);
        //long total=argv[1];
        printf("you input:%ld\n", total);
}

$ ./a.out 500 600
argv[0]=./a.out
argv[1]=500
argv[2]=600
you input:500



正式版
$ cat p02.c 
#include<stdio.h>
#include<stdlib.h>
#define WAN 10000

int main(int argc, char *argv[]){
	if(argc<2){
		printf("You must provide a long int!\n");
		return 1;
	}

	// 接收第一个参数，并字符串转为长整数
	double  total=atof(argv[1]);
	printf("Your sales is %lf\n", total);
	
	// 实际上，浮点数才够用
	double bonus=0;
	total /= WAN;
	double  x1=10*0.1,
		x2=(total-10)*0.075,
		x3=(total-20)*0.05,
		x4=(total-40)*0.03,
		x5=(total-60)*0.015,
		x6=(total-100)*0.01;
	
	if(total<=10){
		bonus+= total*0.1;
	}else if(total>10 && total <=20){
		bonus += x1+x2;
	}else if(total>20 && total <=40){
		bonus += x1+x2+x3;
	}else if(total>40 && total <=60){
		bonus += x1+x2+x3+x4;
	}else if(total>60 && total <=100){
		bonus += x1+x2+x3+x4+x5;
	}else{
		bonus += x1+x2+x3+x4+x5+x6;
	}
	printf("Your bonus is %lf\n", bonus*WAN );
	return 0;
}


$ ./a.out 120000
Your sales is 120000.000000
Your bonus is 11500.000000






3.题目：一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？
难度：****

完全平方指用一个整数乘以自己例如1*1，2*2，3*3等，依此类推。若一个数能表示成某个整数的平方的形式，则称这个数为完全平方数。

提示：这个题目很典型，分析占了至少一半时间，剩下的才是编程实现。

分析：
x+100 = p*p
x+100+168 = t*t
求 x?

两边分别相减后 t*t-p*p=168
(t-p)(t+p)=168
设x,y是168的因子，则 x=t-p, y=t+p, x*y=168, 得 t=(x+y)/2, p=(y-x)/2
对168做因式分解 168=2*2*2*3*7
x和y要么都是偶数，要么都是奇数。后者不可能，则x,y都是偶数。
	最小的偶数因子是2，所以x和y都是>=2的偶数。

#include <stdio.h>
int main(){
	int x,y;
	for(x=2; x<168/2+1; x+=2){
		if(168%x !=0){ continue; }
		y=168/x;
		if(y%2!=0){ continue;}
		
		int p=(y-x)/2, t=(y+x)/2;
		if(p>t) {continue;}
		
		//printf("%d | x=%d, (%d**2), (%d**2)\n", x, p*p-100, p, t);
		printf("(%d) | %d + 100 = %d * %d\n", x, p*p-100, p, p);
		printf("(%d) | %d + 268 = %d * %d\n", x, p*p-100, t, t);
	}
}

输出: 两行为单位，x的值共4个: 1581/261/21/-99
(2) | 1581 + 100 = 41 * 41
(2) | 1581 + 268 = 43 * 43
(4) | 261 + 100 = 19 * 19
(4) | 261 + 268 = 23 * 23
(6) | 21 + 100 = 11 * 11
(6) | 21 + 268 = 17 * 17
(12) | -99 + 100 = 1 * 1
(12) | -99 + 268 = 13 * 13
(14) | -99 + 100 = -1 * -1
(14) | -99 + 268 = 13 * 13
(28) | 21 + 100 = -11 * -11
(28) | 21 + 268 = 17 * 17
(42) | 261 + 100 = -19 * -19
(42) | 261 + 268 = 23 * 23
(84) | 1581 + 100 = -41 * -41
(84) | 1581 + 268 = 43 * 43







4. 题目：输入某年某月某日，判断这一天是这一年的第几天？
难度：**

分析：
先看这个月之前有几天，在加上本月的。
二月需要判断是否闰年。

程序设计：数组结构保存每月的天数。

#include<stdio.h>
int main(){
	int year, month, day, i, sumDay=0;
	printf("please input year, month, day, eg: 2021/3/15\n");
	scanf("%d/%d/%d", &year, &month, &day);
	//计算天数
	int days[12]={31,0, 31,30,31,30,31,31,30,31,30,31};
	days[1]= ((year%400==0) || (year%100!=0 && year%4==0))?29:28; //二月
	//之前的月份天数累加：当前3月，则前面2个月就是0,1
	for(i=0; i<month-1; i++){
		sumDay+=days[i];
	}
	sumDay+=day; //加上当月的天数
	printf("%d年%d月%d日是今年的第%d天\n", year, month, day, sumDay);
}

$ ./a.out 
please input year, month, day, eg: 2021/3/15
2021/3/5
2021年3月5日是今年的第64天

2015年10月1日是今年的第274天







5. 题目：输入三个整数x,y,z，请把这三个数由小到大输出。
难度：*


分析：排序，输出。

#include<stdio.h>
int main(){
	int a[3];
	printf("please input 3 numbers, separated by comma\n");
	scanf("%d,%d,%d", &a[0], &a[1], &a[2]);
	//排序
	int i,j;
	for(i=0; i<3; i++){
		for(j=i+1; j<3; j++){
			printf("==>i=%d, j=%d\n", i,j);
			if(a[i]>a[j]){
				int t=a[i];
				a[i]=a[j];
				a[j]=t;
			}
		}
	}
	//输出
	for(i=0; i<3; i++)
			printf("%d ", a[i]);
	printf("\n");
	return 0;
}

$ ./a.out 
please input 3 numbers, separated by comma
20,-10,300
==>i=0, j=1
==>i=0, j=2
==>i=1, j=2
-10 20 300 

其实一共比较了三次。
x,y 保证x小
x,z 保证x最小
y,z 保证y中间，z最大







6. 题目：用*号输出字母C的图案。
难度：简单

需要多大的相似度？
****
*
*
****

printf(" ****\n");
printf(" *\n");
printf(" *\n");
printf(" ****\n");







7.题目：古典问题（兔子生崽）：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？（输出前40个月即可）

程序分析：兔子的规律为数列1,1,2,3,5,8,13,21....，即下个月是上两个月之和（从第三个月开始）。

难度：**** 用到递归


#include<stdio.h>
static long arr[41]={0, 1,1,2};

long fib(int n){
	if(arr[n]!=0){
		return arr[n];
	}
	return fib(n-1)+fib(n-2);
}

int main(){
	int i=0;
	for(i=1; i<=40; i++){
		arr[i]=fib(i);
		printf("arr[%d]=%ld\n", i, arr[i]);
	}
	return 0;
}

输出:
arr[1]=1
arr[2]=1 
arr[3]=2 
arr[4]=3 
arr[5]=5 
arr[6]=8 
arr[7]=13 
arr[8]=21 
arr[9]=34
...
arr[36]=14930352
arr[37]=24157817
arr[38]=39088169
arr[39]=63245986
arr[40]=102334155












8. 题目：输出9*9口诀。
难度:*

#include<stdio.h>
int main(){
	int i,j;
	for(i=1; i<10; i++){
		for(j=1; j<=i; j++){
			//printf("%d*%d=%d\t", i,j,i*j);
			printf("%d*%d=%-3d",j,i,i*j); /*-3d表示左对齐，占3位*/
		}
		printf("\n");
	}
}

$ ./a.out 
1*1=1
1*2=2   2*2=4
1*3=3   2*3=6   3*3=9
1*4=4   2*4=8   3*4=12  4*4=16
1*5=5   2*5=10  3*5=15  4*5=20  5*5=25
1*6=6   2*6=12  3*6=18  4*6=24  5*6=30  6*6=36
1*7=7   2*7=14  3*7=21  4*7=28  5*7=35  6*7=42  7*7=49
1*8=8   2*8=16  3*8=24  4*8=32  5*8=40  6*8=48  7*8=56  8*8=64
1*9=9   2*9=18  3*9=27  4*9=36  5*9=45  6*9=54  7*9=63  8*9=72  9*9=81











9. 题目：判断101到200之间的素数。

程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除， 则表明此数不是素数，反之是素数。

#include<stdio.h>
#include <math.h>
int main(){
	int i, j, flag, n=1;
	for(i=101; i<200; i++){
		flag=1;
		for(j=2; j<i; j++){
			if(i % j ==0){
				flag=0;
				break;
			}
		}
		if(1==flag){
			printf("%d\t", i);
			n++;
			if(n%5==0) 
				printf("\n");
		}
	}
	printf("\n");
	return 0;
}

输出：
101     103     107     109     113
127     131     137     139     149
151     157     163     167     173
179     181     191     193     197
199






10. 水仙花数
题目：打印出所有的"水仙花数"，所谓"水仙花数"是指一个三位数，其各位数字立方和等于该数 本身。
例如：153是一个"水仙花数"，因为153=1的三次方＋5的三次方＋3的三次方。

难度：** 
知识点：整除

#include<stdio.h>
int cubic(int a){
	return a*a*a;
}
int main(){
	int i;
	for(i=100; i<=999; i++){
		int a,b,c;
		//a=i/100; //百位
		//b=i/10 - 10*a; //十位
		//c=i-10*b-100*a; //个位
		
		a=i%10; //个位
        b=i/10%10; //十位
        c=i/100%10; //百位
		
		if( i == cubic(a)+cubic(b)+cubic(c) ){
			printf("%d\t", i);
		}
	}
	printf("\n");
}

输出:
153	370	371	407









========================================
练习题 组2：数论(因式分解、质数、公约数)、分析
(n=10)
----------------------------------------

11. 将一个正整数分解质因数
题目：将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。

难度： *****

分析：怎么分解？怎么保证质数？
先给出质数列表
然后依次对质数列表求余数，如果余数为0，则循环，然后下一个质数。

比如第一个质数 2
90/2=45 余数0
45/2 余数不是0，则下一个质数 3
45/3=15
15/3=5
5/3 余数不是0，则下一个质数 5
5/5=1 余数是0，结果是1，则结束。
输出中间结果 90=2*3*3*5

#include<stdio.h>
#include<math.h>
// is return 0; not return -1;
int isPrimer(int x){
	if(x<=0){
		printf("Error: please ensure x>0 !\n");
		return -1;
	}
	for(int i=2; i< (sqrt(x)+1); i++){
		if(x%i == 0){
			return -1;
		}
	}
	return 0;
}

int getNextPrimer(int x){
	while(1){
		x++;
		if(0==isPrimer(x)){
			return x;
		}
	}
}

int main(){
	int num;
	printf("please input a number:");
	scanf("%d", &num);
	printf("%d=", num);
	
	int primer=2; //质数
	while(num != 1){ //商
		int resid = num % primer; //余数
		while(resid==0){
			printf("%d", primer);
			num=num/primer;
			resid = num % primer;
			if(num!=1)
				printf("*");
		}
		primer=getNextPrimer(primer); //获取下一个质数
	}
	printf("\n");
	return 0;
}


在gcc下用到数学函数，如sqrt。在gcc时要加上 -lm 参数，这样告诉编译器我要用到数学函数了 。
gcc a.c -o a -lm


$ ./a.out 
please input a number:90
90=2*3*3*5

$ ./a.out
please input a number:945
945=3*3*3*5*7




(2) 更简练版本
程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：
1)如果这个质数恰等于（小于的时候，继续执行循环）n，则说明分解质因数的过程已经结束，另外 打印出即可。
2)但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数n.重复执行第二步。
3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。

#include<stdio.h>
int main()
{
    int n,i;
    printf("请输入整数：");
    scanf("%d",&n);
	
    printf("%d=",n);
    for(i=2;i<=n;i++) //如果除以2的余数不为0，则除以4的余数更不会是0。
    {
        while(n%i==0) //如果余数为0，则继续除
        {
            printf("%d",i);
            n/=i;  //更新n
            if(n!=1) printf("*");
        }
    }
    
    printf("\n");
    return 0;
}







12. 题目：利用条件运算符的嵌套来完成此题：学习成绩>=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。
难度：* 

#include<stdio.h>
int main(){
	int x;
	printf("请输入分数： ");
	scanf("%d", &x);
	char grade=x>=90?'A':( x<60?'C':'B' );
	printf("score:%d, grade:%c\n", x, grade);
	return 0;
}






13. 最大公约数和最小公倍数
题目：输入两个正整数m和n，求其最大公约数和最小公倍数。

难度：*** 
难点：数学原理 辗转相除法。

程序分析：
（1）最小公倍数=输入的两个数之积除于它们的最大公约数，关键是求出最大公约数；
（2）求最大公约数用辗转相除法（又名欧几里德算法）

1）证明：设c是a和b的最大公约数，记为c=gcd(a,b),a>=b,
令r=a mod b
设a=kc，b=jc，则k，j互素，否则c不是最大公约数
据上，r=a-mb=kc-mjc=(k-mj)c
可知r也是c的倍数，且k-mj与j互素，否则与前述k，j互素矛盾,
由此可知，b与r的最大公约数也是c，即gcd(a,b)=gcd(b,a mod b)，得证。

2）算法描述：
第一步：a ÷ b，令r为所得余数 0≤r 
第二步：互换：置 a←b，b←r，并返回第一步。

#include<stdio.h>
int main(){
	int a,b, c;
	printf("input 2 numer, separate by blank:\n");
	scanf("%d %d", &a, &b);
	
	c=a*b;
	printf("(%d,%d)的最大公约数是", a,b);
	
	
	if(a<b){
		int t=a;
		a=b;
		b=t;
	}
	
	int r=a%b;
	while( 0 != r ){
		a=b;
		b=r;
		r=a%b;
	}
	printf("最大公约数是%d, 最小公倍数是%d\n", b, c/b);
}



$ ./a.out
input 2 numer, separate by blank:
16 10
(16,10)的最大公约数是最大公约数是 2, 最小公倍数是 80

(12,26)的最大公约数是最大公约数是 2, 最小公倍数是 156







14.题目：输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。
难度：*
要点：ascii码与字符的对应

分析： 
英文字母：大小写
空格：
数字：
其他：

//失败，scanf遇到空格会停止
#include<stdio.h>
int main(){
	char str[20];
	scanf("%s", str);
	
	printf("%s\n", str);
}


#include<stdio.h>
int main(){
	char c;
	int letter=0, blank=0, digits=0, other=0;
	while( (c=getchar())!='\n' ){
		if( (c>='a' && c<='z') || (c>='A' && c<='Z') ){
			letter++;
		}else if( c>='0' && c<='9' ){
			digits++;
		}else if( ' '==c ){
			blank++;
		}else
			other++;
	}
	
	printf("字符统计: \n 字母: %d\n 数字: %d\n 空格: %d\n 其他:%d\n", letter, digits, blank, other);
}

输出：
$ ./a.out
this is an book. That is 2 PCs!
字符统计: 
 字母: 21
 数字: 1
 空格: 7
 其他:2









15. 题目：求s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。

难度：***
难点：中间数据怎么保存？不保存!

分析： 
输入2个数字，第一个数字是a，第二个数字是n个。
使用指针，动态获取内存。


#include<stdio.h>
int getNum(int a, int n){
	int num=a;
	while(--n >0){
		num*=10;
		num+=a;
	}
	return num;
}

int main(){
	int a, n, i, sum=0;
	printf("input 2 number a and n, separate by blank\n");
	scanf("%d %d", &a, &n);
	
	for(i=1; i<=n; i++){
		int tmp=getNum(a, i);
		printf("%d\t", tmp);
		sum+=tmp;
	}
	printf(", sum is %d\n", sum);
	return 0;
}

$ ./a.out
input 2 number a and n, separate by blank
2 5
2	22	222	2222	22222	, sum is 24690








16. 题目：一个数如果恰好等于它的因子之和，这个数就称为"完数"。例如6=1＋2＋3.编程找出1000以内的所有完数。

分析： 因子，只要能整除就算。
看例子，包括1，不包括自己。

#include<stdio.h>
int main(){
	int i,j, sum;
	for(i=1; i<=1000; i++){
		sum=0;
		for(j=1; j<i; j++){
			if(i%j==0){
				sum+=j;
			}
		}
		if(sum==i){
			printf("%d\t", i);
		}
	}
	printf("\n");
	return 0;
}

输出:
6	28	496

一万以内的还能再多一个
6	28	496	8128











17.题目：一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？
难度：**

分析：
第一次落地时经过h=100米，反弹h/2=50米，
第二次落地时又经过 50*2米，反弹 h/2**2 = 25米，
第三次落地时又经过 25*2米，反弹 h/2**3 = 12.5米，
第n次落地时又经过 h/2**(n-1) *2米，反弹 h/2**n 米。

#include<stdio.h>
int main(){
	float h=100, sum=h;
	int i=0;
	h/=2;
	for(i=2; i<=10; i++){
		sum+= h *2;
		h /= 2;
	}
	printf("共经过 %3.2f 米， 第十次反弹高度 %f 米\n", sum, h);
	return 0;
}

输出：
共经过 299.61 米， 第十次反弹高度 0.097656 米









18.题目：猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个；第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。

难度：**
第10天，吃前剩下1个；
第9天，吃前剩下 (1+1)*2=4
第8天，吃前剩下 (4+1)*2=10个
...
第1天，吃前剩下 (n+1)*2 个 


#include<stdio.h>
int main(){
	int i=10, sum=1;
	printf("第 %d 天，吃前剩下 %d 个\n", i, sum);
	for(i=9; i>0; i--){
		sum=(sum+1)*2;
		printf("第 %d 天，吃前剩下 %d 个\n", i, sum);
	}
	return 0;
}

输出: 
$ ./a.out 
第 10 天，吃前剩下 1 个
第 9 天，吃前剩下 4 个
第 8 天，吃前剩下 10 个
第 7 天，吃前剩下 22 个
第 6 天，吃前剩下 46 个
第 5 天，吃前剩下 94 个
第 4 天，吃前剩下 190 个
第 3 天，吃前剩下 382 个
第 2 天，吃前剩下 766 个
第 1 天，吃前剩下 1534 个



问题: 上述代码中出现重复行，怎么优化掉？
#include<stdio.h>
int main(){
	int i=10, sum=1;
	for(i=10; i>0; i--){
		printf("第 %d 天，吃前剩下 %d 个\n", i, sum);
		sum=(sum+1)*2;
	}
	return 0;
}







19.题目：两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。

难度：***

分析：甲 a,b,c，乙 x,y,z
已知：
a not x 
c not x, not z
则 c-y, b-x, a-z;

这个貌似分析完就已经是最终结果了。
写代码的意义是什么？

//失败，结果不能输出我们推测的结果。
#include<stdio.h>
int main(){
	char g1[3]={'a', 'b', 'c'};
	char g2[3]={'x', 'y', 'z'};
	int i,j;
	for(i=0; i<3; i++){
		char c1=g1[i];
		for(j=0; j<3; j++){
			char c2=g2[j];
			if(c1=='a' && c2=='x') continue;
			if(c1=='c' && (c2=='x' || c2=='z') ) continue;
			printf("%c vs %c\n", c1, c2);
		}
	}
	return 0;
}

输出不对： 
a vs y
a vs z
b vs x
b vs y
b vs z
c vs y



## 看别人的答案：
a,b,c 固定，看怎么放x,y,z 

#include<stdio.h>
int main(){
	int i,j, k;
	for(i='x'; i<='z'; i++){
		for(j='x'; j<='z'; j++){
			if(i==j) continue; //保证不能重复
			for(k='x'; k<='z'; k++){
				if(i==k || j==k) continue; //保证不能重复
				//保证满足条件
				if(i=='x') continue;
				if(k=='x' || k=='z') continue;
				printf("a-%c, b-%c, c-%c\n", i,j,k);
				
			}
		}
	}
	return 0;
}

输出：a-z, b-x, c-y









20. 题目：打印出如下图案（菱形）。

   *
  ***
 *****
*******
 *****
  ***
   *
难度：***

分析：要分上下两部分。
程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重for循环，第一层控制行，第二层控制列。

上面是4行7列，
第1行，3个空格，1个星号；
第2行，2个空格，3个星号；
第3行，1个空格，5个星号；
第4行，0个空格，7个星号；

#include<stdio.h>
int main(){
	int i,j;
	for(i=0; i<5; i++){
		for(j=0; j<5-i; j++){
			printf(" ");
		}
		for(j=0; j< (2*i-1) ; j++){
			printf("*");
		}
		printf("\n");
	}
	//下半部分
	for(i=3; i>=0; i--){
		for(j=0; j<5-i; j++){
			printf(" ");
		}
		for(j=0; j< (2*i-1) ; j++){
			printf("*");
		}
		printf("\n");
	}
}








========================================
练习题 组3: 递归、
(n=10)
----------------------------------------

21. 题目：有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13...求出这个数列的前20项之和。

分析：fib数列

难度：**

#include<stdio.h>
static int arr[30]={1, 1,2,3,5,8,13, 21};

int fib(int n){
	if( 0 != arr[n] ){
		return arr[n];
	}
	return fib(n-1)+fib(n-2);
}

int main(){
	int i=0;
	for(i=5; i<23; i++){
		arr[i]=fib(i);
	}
	
	float sum=0;
	for(i=1; i<=20; i++){
		sum+= (float)arr[i+1]/(float)arr[i];
		printf("i=%d, %d/%d,  sum=%f\n", i, arr[i+1], arr[i], sum);
	}
	return 0;
}

输出： 
i=20, 17711/10946,  sum=32.660263







22. 题目：求1+2!+3!+...+20!的和。

难度：**
难点：各种数据类型的上限在哪里？会不会重复？

分析：求阶乘，不保存中间变量，直接加。

#include<stdio.h>
int main(){
	int i;
	long double sum=0, item=1;
	for(i=1; i<=20; i++){
		item*=i;
		sum+=item;
		printf("%2d!=%20.0Lf, sum=%20.0Lf\n",i, item, sum);
	}
	//printf("sum=%20.0Lf\n", sum);
	return 0;
}

$ ./a.out 
 1!=                   1, sum=                   1
 2!=                   2, sum=                   3
 3!=                   6, sum=                   9
 4!=                  24, sum=                  33
 5!=                 120, sum=                 153
 6!=                 720, sum=                 873
 7!=                5040, sum=                5913
 8!=               40320, sum=               46233
 9!=              362880, sum=              409113
10!=             3628800, sum=             4037913
11!=            39916800, sum=            43954713
12!=           479001600, sum=           522956313
13!=          6227020800, sum=          6749977113
14!=         87178291200, sum=         93928268313
15!=       1307674368000, sum=       1401602636313
16!=      20922789888000, sum=      22324392524313
17!=     355687428096000, sum=     378011820620313
18!=    6402373705728000, sum=    6780385526348313
19!=  121645100408832000, sum=  128425485935180313
20!= 2432902008176640000, sum= 2561327494111820313







23. 题目：利用递归方法求5!。
难度：*

#include<stdio.h>
long double fact(int x){
	if(x<=1)
		return 1;
	else
		return x*fact(x-1);
}

int main(){
	int n=5;
	for(int i=0; i<=n; i++){
		long double result=fact(i);
		printf("%d!=%5.0Lf\n", i, result);
	}
	return 0;
}


$ ./a.out 
0!=    1
1!=    1
2!=    2
3!=    6
4!=   24
5!=  120






24. 题目：利用递归函数调用方式，将所输入的5个字符，以相反顺序打印出来。
难度：***** 
难点：读不懂题目意思。
反向输出字符容易，但是怎么递归函数调用实现？

//错误实现，没用递归
#include<stdio.h>
int main(){
	char c[5];
	printf("请输入5个字符: ");
	for(int i=0; i<5; i++){
		c[i]=getchar();
	}
	for(int i=4; i>=0; i--){
		printf("%c", c[i]);
	}
	printf("\n");
	return 0;
}

$ ./a.out 
请输入5个字符: abcde
edcba


##==== 参考答案
#include <stdio.h>
void palin(int n);
int main(){
    int i=5;
    printf("请输入5个字符: ");
    palin(i);
    printf("\n");
	return 0;
}

void palin(int n){
    char next;
    if(n<=1) {
        next=getchar();
        printf("相反顺序输出结果: ");
        putchar(next);
    } else {
        next=getchar();
        palin(n-1);
        putchar(next);
    }
}

$ ./a.out 
请输入5个字符: abcde
相反顺序输出结果: edcba

递归流程：
i=5 五个字符，进入递归函数内部，（递归内部走v字形，逐层压入栈，再逐个从顶部弹出）
n=5走else, 获取一个输入a，
	递归n=4，走else，获取一个输入b,
		递归n=3，走else，获取一个输入c,
			递归n=2，走else，获取一个输入d,
				递归n=1，走if，获取一个输入e, 输出汉字，输出字符 e，
					返回上一层，输出d;
					返回上一层，输出c;
					返回上一层，输出b;
					返回上一层，输出a;
					递归函数结束。
返回主程序，换行。程序结束。







25. 题目：有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？

难度：*
分析：这是递归

#include<stdio.h>
int getAge(int n){
	if(n==1)
		return 10;
	else
		return getAge(n-1)+2;
}

int main(){
	for(int i=1; i<=5; i++){
		int age = getAge(i);
		printf("the %d th man's age: %d\n", i, age);
	}
	return 0;
}

$ ./a.out 
the 1 th man's age: 10
the 2 th man's age: 12
the 3 th man's age: 14
the 4 th man's age: 16
the 5 th man's age: 18



参考答案看不懂
旧语法：函数定义中，参数没有类型，参数类型在下一行定义的。
https://www.codenong.com/1585390 
https://stackoverflow.com/questions/1585390/c-function-syntax-parameter-types-declared-after-parameter-list

#include <stdio.h>
int age(n)
int n;
{
    int c;
    if(n==1) c=10;
    else c=age(n-1)+2;
    return(c);
}
int main(){
    printf("%d\n",age(5));
}

看不懂这个 int n 和函数并列什么意思？
但是运行正常，结果正确。

This is the so caller K&R style or old-style declaration.

Note, that this declaration is significantly different from the modern declaration. K&R declaration does not introduce a prototype for the function, meaning that it doesn't expose the types of the parameters to the outside code.









26. 题目：给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。

难度：*

#include<stdio.h>
int main(){
	int num0,num, i=0, j, arr[6];
	printf("please input a number, 1 to 1e6: ");
	scanf("%d", &num);
	if(num<=0){
		printf("Error: must positive!\n");
		return 1;
	}
	
	num0=num;
	while(num>0){
		arr[i]=num%10;
		i++;
		num/=10;
	}
	printf("%d 是 %d 位数，逆序打印出各位数字: ", num0, i);
	for(j=0; j<i; j++){
		printf("%d", arr[j]);
	}
	printf("\n");
	return 0;
}






27. 题目：回文数：一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。

难度：*
分析：一个数字拆开，再倒序组装回去，和原来一样，则是。
扩展一下，任意位数。10位以内吧。

#include<stdio.h>

//手写乘方运算
int power(int a, int n){
	int i, rs=1;
	for(i=0; i<n; i++){
		rs*=a;
	}
	return rs;
}

int main(){
	int i,j, num, num0, arr[20];
	printf("input a number, 10 to 1e10:");
	scanf("%d", &num);
	
	//获取长度和每位是什么，如 123 -> {3,2,1}
	num0=num;
	i=0;
	while(num>0){
		arr[i]=num%10;
		i++;
		num/=10;
	}
	//倒序组装回去
	num=0;
	for(j=0; j<i; j++){
		printf("%d ", arr[j]);
		num+=arr[j]*power(10, i-j-1);
	}
	
	printf("\nbefore:%d, after:%d\n", num0, num);
	if(num==num0){
		printf("是\n");
	}else{
		printf("不是\n");
	}
	return 0;	
}


$ ./a.out 
input a number, 10 to 1e10:123454321
1 2 3 4 5 4 3 2 1 
before:123454321, after:123454321
是

$ ./a.out 
input a number, 10 to 1e10:123210
0 1 2 3 2 1 
before:123210, after:12321
不是

$ ./a.out 
input a number, 10 to 1e10:12321
1 2 3 2 1 
before:12321, after:12321
是

还可以改进：
- 使用字符串方式，只需要一个for循环。
- 拆分成数字数组后，比较首尾是否一致，减少了复原运算，只需要比较一半。
- 使用更长的数据类型，可以容纳更大的数。unsigned long long input; 








28. 题目：请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。

难度：***
分析：怎么判断是否唯一？需要设立flag，第一遍测试全部编号，第二次缩小范围。

#include<stdio.h>
#include<string.h>
int main(){
	char *toDay[]={"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
	char input[5];
	int arr[7]={1,1,1,1,1,1,1}, n=7;
	printf("input from Monday to Sunday, any length is OK:");
	scanf("%s", input);
	
	//匹配
	int len=strlen(input), i=0, j=0;
	printf("your input is: %s, len=%d\n", input, len);
	while(len-- >0 ){
		if( 1==n ){
			break;
		}
		for(i=0; i<7; i++){
			if(arr[i]==0) continue;
			if( toDay[i][j] != input[j] ){
				arr[i]*=0;
				n--;
			}
		}
		j++;
	}
	//输出 
	printf("likely to be: ");
	for(i=0; i<7; i++){
		if(arr[i]>0){
			printf("%s\t", toDay[i]);
		}
	}
	printf("\n");
	return 0;
}

$ ./a.out 
input from Monday to Sunday, any length is OK:T
your input is: T, len=1
likely to be: Tuesday	Thursday


参考答案是使用 case 语句，更符合要求。









29. 题目：删除一个字符串中的指定字母，如：字符串 "aca"，删除其中的 a 字母。

难度：*
分析：输入字符串，然后输入要删除的字母

#include<stdio.h>
int main(){
	//输入
	char str[20], c, i=0;
	printf("please input a string:");
	//scanf("%s", str); getchar(); //吃掉回车键
	while( (c=getchar())!='\n' ){
		str[i]=c;
		i++;
	}
	str[i]='\0';
	
	char d;
	printf("please input a char you want to delete:");
	scanf("%c", &d);
	
	printf("str: %s, del: %c\n", str, d);
	
	//删除指定字符
	int n=i+1;
	for(int j=0; j<n; j++){
		if(str[j]==d){
			//后面的往前移动
			for(int i=j; i<n-1; i++){
				str[i]=str[i+1];
			}
			j--; //再次检查当前位置
		}
	}
	printf("after del %c, str: %s\n",d,  str);
	return 0;
}

输出：
$ ./a.out 
please input a string:this is a book
please input a char you want to delete:i
str: this is a book, del: i
after del i, str: ths s a book

$ ./a.out 
please input a string:this is a book!
please input a char you want to delete:o
str: this is a book!, del: o
after del o, str: this is a bk!

小结：要检查刚刚前进的那个字符是否需要删除。比如book删掉o。









30. 质数（素数）判断
题目：判断一个数字是否为质数。
程序分析：质数（prime number）又称素数，有无限个。一个大于1的自然数，除了1和它本身外，不能被其他自然数整除。

难度：*
分析：前面做过了

#include<stdio.h>

#include<math.h>
int isPrimer(int n){
	int i;
	for(i=2; i<= sqrt(1.0*n); i++){ //优化运算次数
		if(n%i==0){
			return 0;
		}
	}
	return 1;
}

int isPrimer2(int n){
	int i;
	for(i=2; i<n; i++){
		if(n%i==0){
			return 0;
		}
	}
	return 1;
}

int main(){
	int i, j=1;
	for(i=2; i<100; i++){
		if( 1==isPrimer(i) ){
			printf("%3d ", i);
			if(j++%20 ==0){
				printf("\n");
			}
		}
	}
	printf("\n");
	return 0;
}

$ gcc p30.c -lm
$ ./a.out 
  2   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59  61  67  71 
 73  79  83  89  97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 
179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 
283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 
419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 
547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 
661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 
811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 
947 953 967 971 977 983 991 997










========================================
练习题 组4: 倒置/排序/二分法/ static/auto/register/ 宏/ 位运算/
(n=15)
----------------------------------------

31. 题目：字符串反转，如将字符串 "www.abcd.com" 反转为 "moc.dcba.www"。

难度：***
难点：数组是按照值传递的。数组作为函数参数。对调内容。

#include<stdio.h>

void printArr(char arr[], int n){
	int i;
	for(i=0; i<n; i++){
		printf("%c", arr[i]);
	}
	printf("\n");
}

void reverse(char arr[], int n){
	int i, j, tmp;
	for(i=0; i<n/2; i++){
		j=n-1-i;
		tmp=arr[i];
		arr[i]=arr[j];
		arr[j]=tmp;
	}
}

int main(){
	char arrC[]="www.abcd.com";
	int len=sizeof(arrC) / sizeof(char); //传递前可以获取长度。 //todo why?
	printArr(arrC, len);
	reverse(arrC, len);
	printArr(arrC, len);
	return 0;
}


$ ./a.out 
www.abcd.com
moc.dcba.www









32. 排序：题目：对10个数进行排序。

难度：*
做过很多次了。

#include<stdio.h>

//选择法排序,选出最小的，放到最左边。
void selectSort(int arr[], int n){
	int i,j,index, tmp;
	for(i=0; i<n-1; i++){
		index=i; //最小值默认是第一个
		for(j=i; j<n; j++){
			if( arr[index]>arr[j] ){
				index=j;
			}
		}
		if(index!=i){
			tmp=arr[i];
			arr[i]=arr[index];
			arr[index]=tmp;
		}
	}
}

int main(){
	int n=10, i;
	int arr[]={0,17,-20,35,-42,59,-66,78,-81,92};
	selectSort(arr, 10);
	//打印结果
	for(i=0; i<n; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
	return 0;
}

$ ./a.out 
-81 -66 -42 -20 0 17 35 59 78 92

扩展：更多排序 https://www.runoob.com/cprogramming/c-exercise-example37.html
选择法、冒泡法、快速排序。









33. 题目：求一个3*3矩阵对角线元素之和
难度：*
分析：怎么表示矩阵？使用二维数组。

arr[3][3] 按行存储{ {},{},{} }

#include<stdio.h>
int main(){
	int arr[3][3]={
		{1, 20, 30}, 
		{2, 50, -90}, 
		{3, 30, 60}
		};
	int i,j, N=3, sum=0;
	for(i=0; i<N; i++){
		for(j=0; j<N; j++){
			if(i==j){
				sum+=arr[i][j];
			}
		}
	}
	printf("sum of diag = %d\n", sum);
	return 0;
}

$ ./a.out 
sum of diag = 111

扩展：nxn矩阵呢？









34. 题目：有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。

难度：***

分析：排过序了，加入一个数字。则用二分法。

#include<stdio.h>
int getPos(int arr[], int N, int num){
	//二分法找到前一个元素的位置
	int low=0, high=N-1, mid=(low+high)/2, oldMid=-1;
	while(low<high){
		if( num > arr[mid]){
			low=mid;
			mid=(low+high)/2;
		}else if(num <arr[mid]){
			high=mid;
			mid=(low+high)/2;
		}else{
			return mid;
		}
		//查看是否调整过位置
		if(oldMid==mid){
			return low;
		}else{
			oldMid=mid;
		}
	}
}

int main(){
	int arr[]={-81, -66, -42, -20, 0, 17, 35, 59, 78, 92};
	int N=10, num, i;
	printf("please input a numer, [-100, 100]:");
	scanf("%d", &num);
	
	// 获取前一个元素的位置
	int pos=getPos(arr, N, num);
	for(i=0; i<N; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
	//插入新元素
	for(i=0; i<N; i++){
		printf("%d ", arr[i]);
		if(i==pos){
			printf("%d ", num);
		}
	}
	printf("\n");
	return 0;
}


$ ./a.out 
please input a numer, [-100, 100]:-40
-81 -66 -42 -20 0 17 35 59 78 92 
-81 -66 -42 -40 -20 0 17 35 59 78 92

//todo: 有些情况例外。
-100 就不行，怎么办？
100也不行。


改进：原始数据为升序可以，原始数据为降序怎么修改？
有没有更简洁的写法？
https://www.runoob.com/cprogramming/c-exercise-example39.html









35. 题目：将一个数组逆序输出。
难度：*
之前做过了。首尾互换元素。

#include<stdio.h>
void reverse(int arr[], int n){
	int i,j;
	for(i=0; i<n/2; i++){
		j=n-1-i;
		int tmp=arr[i];
		arr[i]=arr[j];
		arr[j]=tmp;
	}
}

int main(){
	int arr[]={1,2,3,4,5};
	int n=5, i;
	reverse(arr, n);
	for(i=0; i<n; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}

$ ./a.out 
5 4 3 2 1 









36. 题目：学习static定义静态变量的用法。

难度：*
查看数值是否累加，及存放地址。

#include<stdio.h>

void test(int y){
	int i=0;
	static int i_static=0;
	i+=10;
	i_static+=10;
	printf("i=%d(%p), i_static=%d(%p), y=%d(%p)\n", i, &i, i_static, &i_static, y, &y);
}

int main(){
	int x;
	for(x=0; x<3; x++){
		test(x);
	}
	return 0;
}


$ ./a.out 
i=10(0x7ffcb1a97044), i_static=10(0x555a1fbc4014), y=0(0x7ffcb1a9703c)
i=10(0x7ffcb1a97044), i_static=20(0x555a1fbc4014), y=1(0x7ffcb1a9703c)
i=10(0x7ffcb1a97044), i_static=30(0x555a1fbc4014), y=2(0x7ffcb1a9703c)

可见，静态变量地址低，可能是堆。









37. 学习使用auto定义变量的用法。
难度：*
auto在声明变量的时候可根据变量初始值的数据类型自动为该变量选择与之匹配的数据类型。

#include <stdio.h>
int main(){
    int i,num;
    num=2;
    for(i=0;i<3;i++)    {
        printf("num = %d (%p) ", num, &num);
        num++;
		//花括号内变量的作用范围，离开失效。下次进来重新初始化
        {
            auto int num=1;
            printf("内置模块 num = %d (%p) \n",num, &num);
            num++;
        }
    }
    return 0;
}


$ ./a.out 
num 变量为 2 
内置模块 num 变量为 1 
num 变量为 3 
内置模块 num 变量为 1 
num 变量为 4 
内置模块 num 变量为 1


$ ./a.out 
num = 2 (0x7ffcf1dfdd9c) 内置模块 num = 1 (0x7ffcf1dfdda0) 
num = 3 (0x7ffcf1dfdd9c) 内置模块 num = 1 (0x7ffcf1dfdda0) 
num = 4 (0x7ffcf1dfdd9c) 内置模块 num = 1 (0x7ffcf1dfdda0)









38. 题目：学习使用static的另一用法。　
难度：*

#include <stdio.h>
int main(){
    int i,num;
    num=2;
    for(i=0;i<3;i++)    {
        printf("num = %d (%p) ", num, &num);
        num++;
		//花括号内变量的作用范围，离开失效。下次进来重新初始化
        {
            static int num=1;
            printf("内置模块 num = %d (%p) \n",num, &num);
            num++;
        }
    }
    return 0;
}

$ ./a.out 
num = 2 (0x7ffe7b9fb140) 内置模块 num = 1 (0x556c49b24010) 
num = 3 (0x7ffe7b9fb140) 内置模块 num = 2 (0x556c49b24010) 
num = 4 (0x7ffe7b9fb140) 内置模块 num = 3 (0x556c49b24010) 

小结： 静态变量，只初始化一次，在模块中也是。









39. 题目：学习使用register定义变量的方法。
难度：*


#include <stdio.h>
int main(){
    register int i;
    int tmp=0;
    for(i=1;i<=100;i++)
        tmp+=i;
    printf("总和为 %d, i=%d\n",tmp, i);
	//p39.c:7:5: error: address of register variable ‘i’ requested
    return 0;
}

https://www.cnblogs.com/kingqinwang/p/5097335.html
- 寄存器变量不在内存中，所以没有指针。
- 单一值，长度应该小于或者等于整型的长度。









40. 题目：宏#define命令练习。

#include<stdio.h>
#define TRUE 1
#define FALSE 0
#define SQ(x) (x)*(x)

int main(){
	int num;
	int again=1;
	while(again){
		printf("input a number, if larger than 50, the script will stop:");
		scanf("%d", &num);
		printf("该数字的平方为 %d \n",SQ(num));
		if(num>50)
			again=FALSE;
		else
			again=TRUE;
	}
}









41. 题目：宏#define命令练习2。

#include<stdio.h>
#define exchange(a,b) { int t;t=a;a=b;b=t;}//注意放在一行里
int main()
{
    int x=10;
    int y=20;
    printf("x=%d; y=%d\n",x,y);
    exchange(x,y);
    printf("x=%d; y=%d\n",x,y);
    return 0;
}









42. 题目：宏#define命令练习3。

#define LAG >
#define SMA <
#define EQ ==
#include <stdio.h>
int main()
{
    int i,j;
    printf("请输入两个数字：\n");
    scanf("%d %d",&i,&j);
    if(i LAG j)
        printf("%d 大于 %d \n",i,j);
    else if(i EQ j)
        printf("%d 等于 %d \n",i,j);
    else if(i SMA j)
        printf("%d 小于 %d \n",i,j);
    else
        printf("没有值。\n");
    return 0;
}









43. 题目：#if #ifdef和#ifndef的综合应用。


#include<stdio.h>
#define MAX
#define MAXIMUM(x,y)(x>y)?x:y
#define MINIMUM(x,y) (x>y)?y:x
int main()
{
    int a=10,b=20;
#ifdef MAX
    printf("更大的数字是 %d\n",MAXIMUM(a,b));
#else
    printf("更小的数字是 %d\n",MINIMUM(a,b));
#endif

#ifndef MIN
    printf("更小的数字是 %d\n",MINIMUM(a,b));
#else
    printf("更大的数字是 %d\n",MAXIMUM(a,b));
#endif

#undef MAX
#ifdef MAX
    printf("更大的数字是 %d\n",MAXIMUM(a,b));
#else
    printf("更小的数字是 %d\n",MINIMUM(a,b));
#endif

#define MIN
#ifndef MIN
    printf("更小的数字是 %d\n",MINIMUM(a,b));
#else
    printf("更大的数字是 %d\n",MAXIMUM(a,b));
#endif
    return 0;
}









44. 题目：#include 的应用练习。

$ cat test.h
#define LAG >
#define SMA <
#define EQ ==

$ cat p44.c
#include "test.h"  
#include <stdio.h>

int main()
{
    int i=10;
    int j=20;
    if(i LAG j)
        printf("%d 大于 %d \n",i,j);
    else if(i EQ j)
        printf("%d 等于 %d \n",i,j);
    else if(i SMA j)
        printf("%d 小于 %d \n",i,j);
    else
        printf("没有值。\n");
    return 0;
}









45. 题目：取一个整数 a 从右端开始的 4～7 位。
难度：*
分析：要几位就除以几，取余数。
我理解的是按十进制位，答案是按照二进制位，这有歧义。

#include<stdio.h>
int main(){
	int a=123456789;
	int b=a%10000000;
	printf("%d 取右边7位为 %d\n", a,b);
	
	//整除1000
	int c=b/1000;
	printf("%d 取左边3位为 %d\n", b, c);
	return 0;
}

输出：
123456789 取右边7位为 3456789
3456789 取左边3位为 3456



//看不懂 //todo
原文使用的是 位运算，不熟悉，学习一下。
#include <stdio.h>
int main()
{
    unsigned a,b,c,d;
    printf("请输入整数：\n");
    scanf("%d",&a);
	printf("=>输入的: a=%d\n", a);
	
	//右移4位则
    b=a>>4;
	printf("=>右移四位后: b= %d\n", b);
	
	//~0就是1111111，左移4位是 (1111111110000)2, 再取反是 (1111)2=8+4+2+1=15
    c=~(~0<<4);
	printf("=>取反，左移4位，取反: c=%d\n", c);
	
	//与运算，d就是只要b的右4位:  
    d=b&c;
	printf("=>b&c  %d & %d = %d\n", b,c, d);
	
    printf("a=%o\nd=%o\n",a,d);
    return 0;
}

输出：
请输入整数：
1234567
=>输入的: a=1234567
=>右移四位后: b= 77160
=>取反，左移4位，取反: c=15
=>b&c  77160 & 15 = 8
a=4553207
d=10












========================================
练习题 组5: /杨辉三角 /数组偏移 /结构体 /指针函数
(n=10)
----------------------------------------

46. 杨辉三角形。题目：打印出杨辉三角形（要求打印出10行）。
难度：****
分析：第一行是1，然后每个是顶上2个的和。
这是二项式展开的系数。
1
1 1
1 2 1
1 3 3 1

构建一个数列，首位始终为1，接着是上一行的两两和，最后一个1。


#include<stdio.h>
void printArr(int arr[], int N){
	int i;
	for(i=0; i<N; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}

int main(){
	int i, j, k, N=1;
	int arr[15]={1}, arr2[15];
	for(i=0; i<10; i++){
		printArr(arr, N);
		
		//生成新数组arr2，长度加1
		arr2[0]=1; //首位1
		for(j=1; j<N; j++){
			arr2[j] = arr[j-1] + arr[j];
		}
		arr2[N]=1;//末位1
		N++;
		
		//覆盖掉arr
		for(k=0; k<N; k++){
			arr[k]=arr2[k];
		}
	}
	return 0;
}


$ ./a.out 
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
1 6 15 20 15 6 1 
1 7 21 35 35 21 7 1 
1 8 28 56 70 56 28 8 1 
1 9 36 84 126 126 84 36 9 1 

参考答案使用二维数组，保证上下游关系。也很巧妙。
还有人使用排列组合公式的，系数等于C(n, k)=n!/ (k! *(n-k)!)









47. 题目：输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。
难度：*

#include<stdio.h>
void swap(int *x, int *y){
	int tmp=*x;
	*x=*y;
	*y=tmp;
}

void printArr(int arr[], int n){
	int i;
	for(i=0; i<n; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}

int main(){
	int i,j, n, arr[20];
	printf("设定数组长度(n<20):");
	scanf("%d", &n);
	
	printf("输入 %d 个数组元素\n", n);
	for(i=0; i<n; i++){
		scanf("%d", &arr[i]);
	}
	
	int iMax=0, iMin=0;
	for(i=1; i<n; i++){
		if( arr[iMax]<arr[i] ){
			iMax=i;
		}
		if( arr[iMin]>arr[i] ){
			iMin=i;
		}
	}
	
	//交换
	swap(&arr[iMax], &arr[0]);
	swap(&arr[iMin], &arr[n-1]);
	
	printArr(arr, n);
}


$ ./a.out 
设定数组长度(n<20):5
输入 5 个数组元素
2
-80
6
84
-10
84 -10 6 2 -80


也可以次输入全部数组元素
$ ./a.out 
设定数组长度(n<20):5
输入 5 个数组元素
2 -80 6 84 -10
84 -10 6 2 -80 









48. 题目：有 n个整数，使其前面各数顺序向后移 m 个位置，最后m个数变成最前面的 m 个数。
难度：*
分析：可能是循环输出。

#include<stdio.h>
void printArr(int arr[], int n){
	int i;
	for(i=0; i<n; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}

int main(){
	int N=10, i;
	int arr[]={10,-26,38,-41,53,-64,-75,80,-98,106};
	int arr2[10];
	int shift=0;
	printf("请输入后移量: ");
	scanf("%d", &shift);
	
	// 偏移位置
	for(i=0; i<N; i++){		
		arr2[i]=arr[ (N+i-shift) %N ];
	}
	
	printArr(arr, N);
	printArr(arr2, N);	
}

$ ./a.out 
请输入后移量: 2
10 -26 38 -41 53 -64 -75 80 -98 106 
-98 106 10 -26 38 -41 53 -64 -75 80 

$ ./a.out 
请输入后移量: 5
10 -26 38 -41 53 -64 -75 80 -98 106 
-64 -75 80 -98 106 10 -26 38 -41 53




方法2：参考答案有一步一步滚动的，一次滚动一位。单个数组实现。很精巧。

#include<stdio.h>
void printArr(int arr[], int n){
	int i;
	for(i=0; i<n; i++){
		printf("%d ", arr[i]);
	}
	printf("\n");
}
void move2(int arr[], int n, int shift){
	int i, last;
	while(shift--){
		last=arr[n-1];
		for(i=n-1; i>=0; i--){
			arr[i]=arr[i-1];
		}
		arr[0]=last;
	}
}

//滚动数组，指向最后一个元素 arr+n
void move(int array[],int n,int offset){
    int *p,*arr_end;
    arr_end=array+n;   //数组最后一个元素的下一个位置
    int last;
    
    //滚动直到偏移量为0
    while(offset)
    {
        last=*(arr_end-1);
        for(p=arr_end-1; p!=array; --p)   //向右滚动一位
            *p=*(p-1);
        *array=last;
        --offset;
    }
}


int main(){
	int N=10, i;
	int arr[]={10,-26,38,-41,53,-64,-75,80,-98,106};
	int shift=0;
	printf("请输入后移量: ");
	scanf("%d", &shift);
	
	printArr(arr, N);
	// 偏移位置
	move(arr, N, shift);
	printArr(arr, N);	
}

$ ./a.out 
请输入后移量: 2
10 -26 38 -41 53 -64 -75 80 -98 106 
-98 106 10 -26 38 -41 53 -64 -75 80 









49. 题目：有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。

难度：****
难点：动态分配内存。


分析：一圈首尾相连。
结束条件是剩下一个。

#include<stdio.h>
#include<stdlib.h>

void printArr(int *arr, int n){
	int i;
	for(i=0; i<n; i++){
		printf("%d ", *(arr+i));
	}
	printf("\n");
}

// 删除第j个元素，就是第j个元素被后一个元素覆盖
void delArr(int *arr, int n, int j){
	int i;
	for(i=j; i<n; i++){
		*(arr+i)=*(arr+i+1);
	}	
}

int main(){
	int counter=0, n, remain;
	printf("input the number of total people:");
	scanf("%d", &n);
	
	//输入总人数 n
	if(0==n)
		return 1;
	if(n<1){
		printf("Error: must >1\n");
		return 1;
	}
	remain=n;
	//分配一块内存
	int i, *arr0, *arr=malloc( sizeof(int)*n);
	arr0=arr;
	//初始化
	for(i=0; i<n; i++){
		*(arr+i)=(i+1);
	}
	
	int j;
	while(remain>1){
		printf("==> remain=%d (first element counter=%d)\n", remain, counter+1);
		printArr(arr, remain); //剩余元素
		//报数，遇到3的倍数，则
		for(j=0; j<remain; j++){
			counter++;
			counter=counter%3;
			if(counter==0){
				printf("删除元素: %d\n", arr[j]);
				delArr(arr, remain, j); //删除数组arr的第j个元素，后面的前移
				j--;
				remain--;
			}
		}
	}
	printf("剩下的元素是: %d\n", arr[0]);
	return 0;
}



输出:
$ ./a.out 
input the number of total people:8
==> remain=8 (first element counter=1)
1 2 3 4 5 6 7 8 
删除元素: 3
删除元素: 6
==> remain=6 (first element counter=3)
1 2 4 5 7 8 
删除元素: 1
删除元素: 5
==> remain=4 (first element counter=3)
2 4 7 8 
删除元素: 2
删除元素: 8
==> remain=2 (first element counter=1)
4 7 
==> remain=2 (first element counter=3)
4 7 
删除元素: 4
剩下的元素是: 7









50. 题目：写一个函数，求一个字符串的长度，在 main 函数中输入字符串，并输出其长度。

难度：*
做过。

#include<stdio.h>
int main(){
	char c, *str;
	int n=0;
	printf("请输入字符串, 回车结束: ");
	while( (c=getchar()) != '\n' ){
		n++;
	}
	printf("length=%d\n", n);
	return 0;
}









51. 题目：编写input()和output()函数输入，输出5个学生的数据记录。

难度：*
分析：不清楚题目意图，啥记录？从哪来的记录？
既然是学生，是不是要定义结构体？


//结构体.ele, 结构体指针->ele
#include<stdio.h>
#include<string.h>
struct Student{
	int id;
	char name[10];
	char gender;
};

void input(struct Student *s, int id, char name[], char gender){
	s->id=id;
	strcpy(s->name, name);
	s->gender=gender;
}

void output(struct Student *s){
	printf("Student info: \n id:%d,\t name:%s\t gender:%c\n", s->id, s->name, s->gender);
}

int main(){
	struct Student stus[5];
	printf("请输入一个学生的信息，按回车结束，类似 1 Tom M:");
	
	int i, id;
	char name[10];
	char gender;
	
	for(i=0; i<5; i++){
		scanf("%d %s %c", &id, name, &gender);
		input(&stus[i], id, name, gender);
	}
	for(i=0; i<5; i++){
		output(&stus[i]);
	}
	return 0;
}


 ./a.out 
请输入一个学生的信息，按回车结束，类似 1 Tom M:1 Jim M
2 Tom M
3 Lily F
4 Lilei M
5 Lee F
Student info: 
 id:1,	 name:Jim	 gender:M
Student info: 
 id:2,	 name:Tom	 gender:M
Student info: 
 id:3,	 name:Lily	 gender:F
Student info: 
 id:4,	 name:Lilei	 gender:M
Student info: 
 id:5,	 name:Lee	 gender:F









52. 题目：输入一个整数，并将其反转后输出。
难度：*
做过。 

分析：可以获取其每位。还有使用递归的。

#include<stdio.h>
#include<stdlib.h>
int power(int a, int n){
	int rs=1;
	while(n--){
		rs *= a;
	}
	return rs;
}

int main(){
	int num, num0;
	printf("输入一个整数:");
	scanf("%d", &num);
	num0=num;
	
	//获取长度
	int n=0;
	while(num >0){
		n++;
		num/=10;
	}
	
	//获取每一位
	int i, *pArr;
	pArr=malloc( sizeof(int)*n );
	num=num0;
	for(i=0; i<n; i++){
		*(pArr+i)=num%10;
		num /= 10;
	}
	//输出
	num=0;
	for(i=0; i<n; i++){
		num+=*(pArr+i)*power(10, n-1-i);
	}
	free(pArr);
	printf("%d 翻转后为 %d\n", num0, num);
	return 0;
}


$ ./a.out 
输入一个整数:12457
12457 翻转后为 75421




方法2：参考答案更精简，只用一个循环。很精巧。 

#include<stdio.h>
int main(){
	int num;
	printf("输入一个整数:");
	scanf("%d", &num);
	
	int reverse=0, remainder;
	while(num>0){
		remainder=num%10;
		reverse = reverse*10 + remainder;
		num/=10;
	}
	printf("翻转后: %d\n", reverse);
	return 0;
}

$ ./a.out 
输入一个整数:124578
翻转后: 875421









53. 题目：编写一个函数，输入n为偶数时，调用函数求1/2+1/4+...+1/n,当输入n为奇数时，调用函数1/1+1/3+...+1/n(利用指针函数)。

难度：*
分析：指针函数，还是函数，但是返回的是指针。
这里应该是说错了，应该是指向函数逇指针，或简称函数指针。

#include<stdio.h>
double addOdd(int n){
	printf("Odd\n");
	int i;
	double sum=0;
	for(i=1; i<=n; i+=2){
		sum += (double)1/i;
	}
	return sum;
}

double addEven(int n){
	printf("Even\n");
	int i;
	double sum=0;
	for(i=2; i<=n; i+=2){
		sum += (double)1/i;
	}
	return sum;
}

int main(){
	int num;
	printf("please input a number:");
	scanf("%d", &num);
	printf("num=%d\n", num);
	
	double sum=0;
	double (*pfunc)(int); //这是指向函数的指针
	if(0 == num%2){
		pfunc=addEven;
	}else{
		pfunc=addOdd;
	}
	sum=pfunc(num);
	printf("sum=%lf\n",sum);
	return 0;
}

$ ./a.out
please input a number:4
num=4
Even
sum=0.750000









54. 题目：字符串数组的指针都保存在什么位置？（指向指针的指针）。

难度：*
查看指针本身保存的位置。
要点： &a  获取a变量的地址； *p 获取指针p所指向地址的值(&p表示指针变量p本身保存的地址)
字符串数组，
	最外层是一系列指针构成的数组，指向每个字符串的首字母坐标；
	每个字符串又是一个字符数组。

#include<stdio.h>
int main(){
	char *words[]={"apple", "banana", "orange", "book"};
	char **ptr;
	int i;
	for(i=0; i<4; i++){
		ptr=&words[i]; //ptr 和 words[0] 是同一个东西，都是指向（字符数组的）指针的指针。
		printf("words[%d]: addr=%p->%p: %s\n", i, &words[i], words[i], words[i]);
		printf("  ptr[%d]: addr=%p->%p: %s\n", i, &ptr, *ptr, *ptr);
	}
}

输出
words[0]: addr=0x7ffe2d055de0->0x55c645b51834: apple
  ptr[0]: addr=0x7ffe2d055dd8->0x55c645b51834: apple
words[1]: addr=0x7ffe2d055de8->0x55c645b5183a: banana
  ptr[1]: addr=0x7ffe2d055dd8->0x55c645b5183a: banana
words[2]: addr=0x7ffe2d055df0->0x55c645b51841: orange
  ptr[2]: addr=0x7ffe2d055dd8->0x55c645b51841: orange
words[3]: addr=0x7ffe2d055df8->0x55c645b51848: book
  ptr[3]: addr=0x7ffe2d055dd8->0x55c645b51848: book


gdb调试，查看某些变量的内存地址：
(gdb) p &words  ## words本身保存在栈上，地址较大。是个指针构成的len=4的数组，里面的数组指向char字符串。
$1 = (char *(*)[4]) 0x7fffffffe010

(gdb) p words ## words 数组中都是指针，指向堆（编号较小）。
$2 = {0x555555554834 "apple", 0x55555555483a "banana", 0x555555554841 "orange", 0x555555554848 "book"}

(gdb) p &words[0] #数组元素本身保存的位置是栈上，在指针数组内连续保存。
$3 = (char **) 0x7fffffffe010
(gdb) p ptr
$4 = (char **) 0x7fffffffe010

(gdb) p words[0] #指针数组内的元素是指针，该指针指向字符串
$5 = 0x555555554834 "apple"
(gdb) p *ptr
$6 = 0x555555554834 "apple"

(gdb) x/8c 0x555555554834
0x555555554834:	97 'a'	112 'p'	112 'p'	108 'l'	101 'e'	0 '\000'	98 'b'	97 'a'









55. 题目：找到年龄最大的人，并输出。请找出程序中有什么问题。
#include<stdio.h>
#include<stdlib.h>
struct man{
    char name[20];
    int  age;
}
person[3]={"li",18,"wang",25,"sun",22}; //和前面的结构体是连写的。

int main(){
    struct man *q,*p;
    int i,m=0;
    p=person;
    for(i=0; i<3; i++){
        if(m< p->age){
            m=p->age; //记录年龄较大值
            q=p;  //记录指向这个人的指针
        }
        p++; //p开始指向起始位置，后面依次偏移
    }
    printf("%s %d\n",q->name,q->age);
    return 0;
}

难度：*

看不懂这个操作。
使用gdb调试。

$ gdb a.out
(gdb) p p
$1 = (struct man *) 0x555555755020 <person>

(gdb) p person
$2 = {{name = "li", '\000' <repeats 17 times>, age = 18}, {name = "wang", '\000' <repeats 15 times>, age = 25}, {name = "sun", '\000' <repeats 16 times>, age = 22}}









56. 题目：字符串排序。
难度：*













========================================
链表
(n=10)
----------------------------------------

52. 链表
创建链表 https://www.runoob.com/cprogramming/c-exercise-example72.html
反向输出一个链表。　73
连接两个链表。74






进度：ex39
ex70



























========================================
基于点阵的文字输出：多分辨率、多字符(大小写、数字、特殊符号)
----------------------------------------
1. 输出液晶状态的阿拉伯数字(5*3 最小分辨率)

难度：*****
难点：多维数组、指针操作数组、返回指针的函数、动态分配内存。

#include<stdio.h>
#include<stdlib.h>
//数字点阵
int digits[10][5][3] = { 
		{ {1,1,1},{1,0,1},{1,0,1},{1,0,1},{1,1,1} }, //0
		{ {0,1,0},{1,1,0},{0,1,0},{0,1,0},{1,1,1} }, //1
		{ {1,1,1},{0,0,1},{1,1,1},{1,0,0},{1,1,1} }, //2
		{ {1,1,1},{0,0,1},{1,1,1},{0,0,1},{1,1,1} }, //3
		{ {1,0,1},{1,0,1},{1,1,1},{0,0,1},{0,0,1} }, //4
		{ {1,1,1},{1,0,0},{1,1,1},{0,0,1},{1,1,1} }, //5
		{ {1,1,1},{1,0,0},{1,1,1},{1,0,1},{1,1,1} }, //6
		{ {1,1,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1} }, //7
		{ {1,1,1},{1,0,1},{1,1,1},{1,0,1},{1,1,1} }, //8
		{ {1,1,1},{1,0,1},{1,1,1},{0,0,1},{1,1,1} } //9
	};

//输入字符矩阵，打印
void printDigits(int *ptr, int nRow, int nCol){
	int i,j;
	for(i=0; i<nRow; i++){
		for(j=0; j<nCol; j++){
			char c = (0==*ptr)?' ':'*';
			printf("%c", c);
			ptr++;
		}
		printf("\n");
	}
}

//合并几个数字的点阵，间距是2列0.
int *combineDigits(int number, int spacer){
	//根据输入的数的长度，倒解连环
	int i=0, x[10], res;
	while(1){
		res=number % 10;
		x[i]=res;
		i++;
		number/=10;
		
		if(number<10){
			x[i]=number;
			break;
		}
	}
	//数组倒置
	for(int j=0; j< (i+1)/2; j++){
		int tmp=x[j], j2=i-j;
		x[j]=x[j2];
		x[j2]=tmp;
	}
	//逐个打印数组
	for(int j=0; j<=i; j++){
		printf("%d ", x[j]);
	}
	printf("\n");
	
	int n=i+1, nCol= 3*n+spacer*(n-1);
	//这个要注意返回的是最初的指针，而循环中指针一直在向后偏移。
	int *ptr0=malloc( sizeof(int)*5*nCol ), *ptr; 
	ptr=ptr0;
	for(int i=0; i<5; i++){
		for(int j=0; j<nCol; j++){
			int cur=x[j/(3+spacer)];
			
			int *digit= (int *)digits[cur];
			int r=j%(3+spacer);
			if( r<=2 ){
				*ptr=digit[i*3+r];
			}else{
				*ptr=0;
			}
			ptr++;
		}
	}
	return ptr0;
}


int main(int argc, char *argv[]){
	if(argc<2){
		printf("please provide a number [0, 9]\n");
		return 1;
	}
	//获取输入字符串，转为整数
	int num=atoi(argv[1]);
	printf("%d\n", num);
	
	if(num<0){
		printf("Error: x>=0\n");
		return 1;
	}else if(num<10){
		printDigits( (int *)digits[num], 5, 3 ); //传递参数时，要做指针类型转换
	}else if(num<1000*1000*1000){
		//2位到9位之间的
		int spacer=2;
		int *ptr=combineDigits(num, spacer);
		
		int n=0;
		while(num){
			n++;
			num/=10;
		}
		int nCol= 3*n+spacer*(n-1);
		printDigits( (int *)ptr, 5, nCol );
		free(ptr);
	}else{
		printf("Error: x<1e9\n");
		return 1;
	}
	return 0;
}


测试：
$ ./a.out 314649593
314649593
3 1 4 6 4 9 5 9 3 
***   *   * *  ***  * *  ***  ***  ***  ***
  *  **   * *  *    * *  * *  *    * *    *
***   *   ***  ***  ***  ***  ***  ***  ***
  *   *     *  * *    *    *    *    *    *
***  ***    *  ***    *  ***  ***  ***  ***

$ ./a.out 20210728
20210728
2 0 2 1 0 7 2 8 
***  ***  ***   *   ***  ***  ***  ***
  *  * *    *  **   * *    *    *  * *
***  * *  ***   *   * *    *  ***  ***
*    * *  *     *   * *    *  *    * *
***  ***  ***  ***  ***    *  ***  ***




改进：//todo
怎么增大分辨率？
怎么加入字母点阵?













### 剩下的在Ubuntu无法打印

1.题目：输出特殊图案，请在c环境中运行，看一看，Very Beautiful!
# 运行失败，跳过
程序分析：字符共有256个。不同字符，图形不一样。

#include<stdio.h>
int main()
{
    char a=176,b=219;
    printf("%c%c%c%c%c\n",b,a,a,a,b);
    printf("%c%c%c%c%c\n",a,b,a,b,a);
    printf("%c%c%c%c%c\n",a,a,b,a,a);
    printf("%c%c%c%c%c\n",a,b,a,b,a);
    printf("%c%c%c%c%c\n",b,a,a,a,b);
    return 0;
}


输出 字符。结果不好，跳过。
#include<stdio.h>
int main(){
	int i;
	char c;
    for(i=0; i<256; i++){
		printf("(%d)%c\t", i, i );
		if(i%16==0)
			printf("\n");
	}
	printf("\n");
	return 0;
}





9.题目：要求输出国际象棋棋盘。
# 效果不好，跳过。以后符号输出的都跳过
程序分析：国际象棋棋盘由64个黑白相间的格子组成，分为8行*8列。用i控制行，j来控制列，根据i+j的和的变化来控制输出黑方格，还是白方格。

#include<stdio.h>
int main(){
    int i,j;
    for(i=0;i<8;i++)
    {
        for(j=0;j<8;j++)
            if((i+j)%2==0)
                printf("%c%c",219,219);
            else printf("  ");
        printf("\n");
    }
    return 0;
}




31. 题目：练习函数调用。
难度：*

39. 题目：学习使用如何调用外部函数。
难度：*


题目：画图，学用circle画圆形。
https://www.runoob.com/cprogramming/c-exercise-example56.html






========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------


