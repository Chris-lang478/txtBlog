cpp_note
主要是为学习和使用 Rcpp 服务




cpp的精髓就在于转化和复现。因为快，所以可以时间来换空间，来弥补架构的缺陷。

各种层面的延时调用和抽象分发、汇聚，现在根本就没人懂，也不点赞。然后就没人写这类的文章和回答，结果cpp板块在知乎的搜索页上都消失了。2017年还好好的。






========================================
c++教程与知识天梯
----------------------------------------
1. 入门版
很多对于会的人是常识的东西，对于初学者就是无法理解、很难的概念。

文字: https://www.runoob.com/cplusplus/cpp-tutorial.html
	http://www.codebaoku.com/it-c/it-c-253771.html


视频: https://www.bilibili.com/video/BV1Tb411j7uM
	本人配合《C++ prime》看，看书感觉难懂的就来看视频，结果感觉效果十分显著
	黑马C/C++教程: 张涛老师Qt课程 https://www.bilibili.com/video/BV1jK4y1s73T?p=639
	黑马C++_13移动打车项目 https://www.bilibili.com/video/bv1G7411m7XQ


1)翁凯老师无论是 C、C++、Java 的视频都讲得非常深入浅出，只能说水平越是高的人讲的课越容易明白。
	https://study.163.com/course/introduction/271005.htm
	本课程以C++语言来介绍面向对象程序设计的原理和方法，
	内容包括面向对象程序设计基本原理和C++特有的语言特性。
	大致的章节包括基本理论、类与对象、构造与清除、函数、引用、继承与多态、拷贝构造、运算符重载、异常、模板和流等。
	本课程不涉及具体的C++开发环境，也不会涉及图形程序设计和网络程序设计等。

2)侯捷老师的八部曲：
侯捷C++ 标准 11 -14
侯捷STL 和 泛型编程
侯捷C++ 内存管理
侯捷C++面向对象高级开发
侯捷STL与泛型编程
侯捷 C++ Startup 揭密：C++ 程序的生前和死后

陈硕第三套、Linux CC++网络编程实践-陈硕


3) 书籍推荐
https://github.com/itwanger/toBeBetterJavaer/blob/master/docs/xuexiluxian/ccc.md
学习 C++ 语法，首推《C++ Primer 第五版》



(2) 经典书单
C++
《A Tour of C++》
《Accelerated C++》
《C++ primer》  # 注意:《C++ primer plus》是一本垃圾，讲的是一个披着 c++ 外衣的C语言。
《STL源码解析》
《Effective C++》
《深度探索C++对象模型》
《C++设计与演化》






2. 核心知识点 第一层
(1) 第一层，通识
共同的、最基本的那些概念：变量、常量、类型、循环、判断、数组、字符串、对象、输入输出等

然后还有 C++ 中一些特有的东西，比如命名空间 namespace、引用、模板等。

以及如何使用一些 STL 中的类库，比如 string、vector、find 之类的东西。

然后就是辅以大量的练习。
	就那种 C++ 教程的课后练习题就足够了，类似水仙花数、四则运算计算器之类的东西。


(2) 第一层，cpp入门
到这里，你对 C++ 包含了哪些知识点大概有了一个整体的印象。并且能够写上百行左右的程序，但是还是很难写出一个优秀的类。

接下来需要进行全面和深入的学习，算是真正的入门：
《Accelerated C++》（美国斯坦福大学的经典教材）  
《C++ Primer》（大而全）  
《The C++ Programming Language》（C++之父 Bjarne Stroustrup 所著） 
这三本，其实各有优缺点，第一本优点是简短，仅仅两三百页，只有最为核心和主干的知识点。
而后两本则都是大而全，尤其是《The C++ Programming Language》。
这两本区别在于，一个是 C++ 大师所著，一本是 C++ 之父所著。

网上有人说 《C++Primer》是目前市面上唯一一本真正的从入门到精通的书，适合初学者；
《C++ Programming language》 是C++专家自学指南，顾名思义，适合有较深厚 C++ 功底的读者。
所以我推荐的顺序是：《Accelerated C++》->《C++ Primer》->《The C++ Programming Language》


对于这种上前页大部头我推荐的阅读方式是，以主题为划分，比如 C++ Primer 就明确的分为了：
	C++ 基础
	C++ 标准库
	类设计者的工具
	高级主题

如果有一定的基础的话，可以看着目录，看一些自己感兴趣的章节，完全没有必要从第一页开始挨着挨着读。

入门结束你应该掌握以下内容：
	基础语言
	类与面向对象
	输入输出
	字符串处理（类库和正则表达式）
	容器类库
	泛型算法

看着只有几个关键字，实际上每个展开都有很多内容需要学习。
学习过程中把后面的每一个练习题都自己敲一遍，自己多思考对比一下。
多用代码去验证自己的想法，尤其是指针、引用、构造、析构这些地方。
学习 C++ 以及日常开发一定要记得这几个网站，可以随时查阅一些语法的用法和标准库：
	cppreference
	cplusplus
	isocpp





更细的颗粒度:

C++ 基础语法: 数据类型与声明，标识符与关键字，常量与变量，运算符(算术/关系/逻辑)，初等表达式/lambda 表达式;
C++ 基本词法: 
	最基本容器--数组 
	指针: const 指针, 	函数指针, 	各类指针分析, 	避免野指针
	防止内存泄漏，智能指针的使用
	C++内存分配方式，字符串，Redis项目字符串处理
C++ 基本句法: 
	赋值、判断与循环
	函数基础，内联函数，递归函数的本质，枚举类型，
	结构体：包容一切
	联合体：高效组合
	类与面向对象
	命名空间
C++ 高级语法:
	类型转换
	异常 exception
	IO 最难设计的模块
	文件操作
	多线程-C++新标准的应用
	模板编程应用
C++ 编程思想进阶：
	再议class
	运算符重载 
	深拷贝与浅拷贝
	面向对象的思想、误区
	常见面向对象设计模式
	模板编程：C++精髓
C++ 高效编程进阶：
	STL常见容器：顺序容器、关联容器
	算法 Algorithm
	函数对象 Function Objects 
	迭代器 Iterators
	生成器 Allocators
	C++ 的内存分配问题
	STL 的整体架构和思想
	更安全使用字符串： STL string
	C++ 的 stream
	C++ 的瑞士军刀: boost 库
	C++ 最新标准/陷阱和经验
	C++ 中常见的编程范式


项目：实现一个屏幕矩阵截图功能。目标是 PicPick
	https://blog.csdn.net/hhy321/article/details/121548612




浏览菜鸟教程，没记住的部分：
	特殊字符常量需要加反斜杠 \\ 表示 \, \? 表示?
	
	Lambda 函数与表达式 cpp-functions.html

	C++ 随机数 cpp-numbers.html
	C++ 指针 cpp-pointers.html
	C++ 引用 cpp-references.html
	日期和时间 cpp-date-time.html
	输入和输出(错误和日志流) cpp-basic-input-output.html
	结构体(结构体作为函数参数、指向结构体的指针): cpp-data-structures.html
	
	
	类和对象: cpp-classes-objects.html
	










3. 怎么精通？C++是不是落伍了？
C++在刚毕业的年轻人简历里都是精通，工作两年后就是略懂了
写了十几年我都只敢熟练



CPP 现在招聘真没限制年龄。 就是后继无人。 使用起来比其他语言繁琐多了。
那是你不了解现代c++,特别是加上boost已经非常强了


c++已经过时了，十年才能入门的语言早该被淘汰了，十个小时就能入门的语言才是好语言。
卷就是这么卷起来的，其次现在新的那些语言很难用于大型实时游戏和一些驱动，运行效率确实太慢


游戏底层还有c++ 最后一块地

既然都说到"底层"了，有哪个不是C++？操作系统，编译器，浏览器，驱动，图形，图像……
整个底层都没人做了






========================================
|-- C++初学者必看的50个建议 绝对经典
----------------------------------------

1.把C++当成一门新的语言学习（和C没啥关系！真的。）；
2.看《Thinking In C++》，不要看《C++编程思想》；
3.看《The C++ Programming Language》和《Inside The C++ Object Model》,不要因为他们很难而我们自己是初学者所以就不看；
4.不要被VC、BCB、BC、MC、TC等词汇所迷惑——他们都是集成开发环境，而我们要学的是一门语言；
5.不要放过任何一个看上去很简单的小编程问题——他们往往并不那么简单，或者可以引伸出很多知识点；
6.会用Visual C++，并不说明你会C++；

7.学class并不难，template、STL、generic programming也不过如此——难的是长期坚持实践和不遗余力的博览群书；
8.如果不是天才的话，想学编程就不要想玩游戏——你以为你做到了，其实你的C++水平并没有和你通关的能力一起变高——其实可以时刻记住：学C++是为了编游戏的；

9.看Visual C++的书，是学不了C++语言的；

10.浮躁的人容易说：XX语言不行了，应该学YY；——是你自己不行了吧！？
11.浮躁的人容易问：我到底该学什么；——别问，学就对了；
12.浮躁的人容易问：XX有钱途吗；——建议你去抢银行；
13.浮躁的人容易说：我要中文版！我英文不行！——不行？学呀！
14.浮躁的人容易问：XX和YY哪个好；——告诉你吧，都好——只要你学就行；
15.浮躁的人分两种：a)只观望而不学的人；b)只学而不坚持的人；

16.把时髦的技术挂在嘴边，还不如把过时的技术记在心里；
17.C++不仅仅是支持面向对象的程序设计语言；
18.学习编程最好的方法之一就是阅读源代码；
19.在任何时刻都不要认为自己手中的书已经足够了；
20.请阅读《The Standard C++ Bible》(中文版：标准C++宝典)，掌握C++标准；
21.看得懂的书，请仔细看；看不懂的书，请硬着头皮看；
22.别指望看第一遍书就能记住和掌握什么——请看第二遍、第三遍；
23.请看《Effective C++》和《More Effective C++》以及《Exceptional C++》；

24.不要停留在集成开发环境的摇篮上，要学会控制集成开发环境，还要学会用命令行方式处理程序；
25.和别人一起讨论有意义的C++知识点，而不是争吵XX行不行或者YY与ZZ哪个好；
26.请看《程序设计实践》，并严格的按照其要求去做；
27.不要因为C和C++中有一些语法和关键字看上去相同，就认为它们的意义和作用完全一样；

28.C++绝不是所谓的C的“扩充”——如果C++一开始就起名叫Z语言，你一定不会把C和Z语言联系得那么紧密；
29.请不要认为学过XX语言再改学C++会有什么问题——你只不过又在学一门全新的语言而已；
30.读完了《Inside The C++ Object Model》以后再来认定自己是不是已经学会了C++；
31.学习编程的秘诀是：编程，编程，再编程；

32.请留意下列书籍：《C++面向对象高效编程（C++ Effective Object-Oriented Software Construction）》《面向对象软件构造(Object-Oriented Software Construction)》《设计模式（Design Patterns）》《The Art of Computer Programming》；

33.记住：面向对象技术不只是C++专有的；
34.请把书上的程序例子亲手输入到电脑上实践，即使配套光盘中有源代码；
35.把在书中看到的有意义的例子扩充；

36.请重视C++中的异常处理技术，并将其切实的运用到自己的程序中；

37.经常回顾自己以前写过的程序，并尝试重写，把自己学到的新知识运用进去；
38.不要漏掉书中任何一个练习题——请全部做完并记录下解题思路；
39.C++语言和C++的集成开发环境要同时学习和掌握；
40.既然决定了学C++,就请坚持学下去，因为学习程序设计语言的目的是掌握程序设计技术，而程序设计技术是跨语言的；
41.就让C++语言的各种平台和开发环境去激烈的竞争吧，我们要以学习C++语言本身为主；
42.当你写C++程序写到一半却发现自己用的方法很拙劣时，请不要马上停手；请尽快将余下的部分粗略的完成以保证这个设计的完整性，然后分析自己的错误并重新设计和编写（参见43）；

43.别心急，设计C++的class确实不容易；自己程序中的class和自己的class设计水平是在不断的编程实践中完善和发展的；
44.决不要因为程序“很小”就不遵循某些你不熟练的规则——好习惯是培养出来的，而不是一次记住的；
45.每学到一个C++难点的时候，尝试着对别人讲解这个知识点并让他理解——你能讲清楚才说明你真的理解了；
46.记录下在和别人交流时发现的自己忽视或不理解的知识点；
47.请不断的对自己写的程序提出更高的要求,哪怕你的程序版本号会变成Version 100.XX；
48.保存好你写过的所有的程序——那是你最好的积累之一；
49.请不要做浮躁的人；
50.请热爱C++!








========================================
环境搭建与 hello world 编译
----------------------------------------
2. 运行环境
(1) win7 本
忘了啥时候安装的了，看输出信息，是 Strawberry perl 自带的。
如果未安装 GCC，那么请按照 http://gcc.gnu.org/install/ 上的详细说明安装 GCC。

打开 git bash
$ g++ --version
g++.exe (x86_64-posix-seh, Built by strawberryperl.com project) 7.1.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

$ g++ -v
Using built-in specs.
COLLECT_GCC=C:\Strawberry\c\bin\g++.exe
COLLECT_LTO_WRAPPER=C:/Strawberry/c/bin/../libexec/gcc/x86_64-w64-mingw32/7.1.0/lto-wrapper.exe
Target: x86_64-w64-mingw32
Configured with: ../../../src/gcc-7.1.0/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=posix --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --enable-libstdcxx-filesystem-ts=yes --disable-libstdcxx-pch --disable-libstdcxx-debug --disable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=nocona --with-tune=core2 --with-libiconv --with-system-zlib --with-gmp=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-mpfr=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-mpc=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-isl=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-pkgversion='x86_64-posix-seh, Built by strawberryperl.com project' CFLAGS='-O2 -pipe -fno-ident -I/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/include -I/opt/build/prerequisites/x86_64-zlib-static/include -I/opt/build/prerequisites/x86_64-w64-mingw32-static/include' CXXFLAGS='-O2 -pipe -fno-ident -I/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/include -I/opt/build/prerequisites/x86_64-zlib-static/include -I/opt/build/prerequisites/x86_64-w64-mingw32-static/include' CPPFLAGS=' -I/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/include -I/opt/build/prerequisites/x86_64-zlib-static/include -I/opt/build/prerequisites/x86_64-w64-mingw32-static/include' LDFLAGS='-pipe -fno-ident -L/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/lib -L/opt/build/prerequisites/x86_64-zlib-static/lib -L/opt/build/prerequisites/x86_64-w64-mingw32-static/lib '
Thread model: posix
gcc version 7.1.0 (x86_64-posix-seh, Built by strawberryperl.com project)








3. 运行示例

(1) 最简单的程序
$ cat main.cpp 
#include <iostream>
using namespace std;
int main()
{
    cout << "Hello, world!" << endl;
    return 0;
}

(2)编译
$ gcc main.cpp -lstdc++ -o main

最简单的编译方式：
$ g++ main.cpp

由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：
$ ./a.exe
Hello, world!



(3) 指定输出文件 -o
通常我们使用 -o 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：
$ g++ helloworld.cpp -o helloworld

执行 helloworld:
$ ./helloworld.exe
Hello, world!



(4) 如果是多个 C++ 代码文件，如 xx1.cpp、xx2.cpp，编译命令如下：

$ g++ xx1.cpp xx2.cpp -o xx
生成一个 xx 可执行文件。


(5) g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：
$ g++ -g -Wall -std=c++11 main.cpp









========================================
|-- 非root权限安装新版 gcc
----------------------------------------
发布标准:
C++98
C++03
C++11
C++17
C++20

C++没有GC 垃圾回收。


1. 搜索 c++ 11 对应的gcc版本
gcc 4.7 之后，才支持c11.

$ gcc --version
gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)
Copyright (C) 2015 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

貌似我的 CentOS7.9 默认版本已经支持了。

$ ls -lth  /usr/lib/gcc/x86_64-redhat-linux/4.8.5/
total 5.0M
lrwxrwxrwx. 1 root root   30 Jun 24 21:16 libobjc.so -> ../../../../lib64/libobjc.so.4
drwxr-xr-x. 3 root root 4.0K Jun 24 21:16 include
drwxr-xr-x. 2 root root 4.0K Jun 24 21:16 32
lrwxrwxrwx. 1 root root   37 Jun 24 21:06 libstdc++.so -> ../../../../lib64/libstdc++.so.6.0.19
drwxr-xr-x. 2 root root   86 Jun 24 21:06 finclude
...

$ vim demo.cpp 
#include<iostream>
int main(){
	printf("this is c++\n");
	return 0;
}

$ ls xx
ls: cannot access xx: No such file or directory
$ echo $?
2

$ ls 
01  v1
$ echo $?
0


$ g++ -g -Wall -std=c++11 demo.cpp
$ ./a.out 
this is c++







2. 最新版 gcc 12.1.0
https://www.programmerall.com/article/32361000992/

(1) 下载
http://ftp.gnu.org/gnu/gcc/
http://ftp.gnu.org/gnu/gcc/gcc-12.1.0/

$ wget http://ftp.gnu.org/gnu/gcc/gcc-12.1.0/gcc-12.1.0.tar.gz
$ tar zxvf gcc-12.1.0.tar.gz


(2) 安装
这里由于没有root权限，需要把 --prefix=后的路径改成自己路径，如/home/users/liqiang/gcc-9.3.0

$ cd gcc-12.1.0
$ ./configure --prefix=/home/wangjl/software/gcc-12.1.0 --enable-shared --enable-threads=posix --enable-languages=c,c++,fortran --disable-multilib

报错: configure: error: Building GCC requires GMP 4.2+, MPFR 3.1.0+ and MPC 0.8.0+.

$ ./contrib/download_prerequisites

gmp-6.2.1.tar.bz2: OK
mpfr-4.1.0.tar.bz2: OK
mpc-1.2.1.tar.gz: OK
isl-0.24.tar.bz2: OK
All prerequisites downloaded successfully.


前面的句子是否有用?
$ mkdir build
$ cd build
$ ../configure --prefix=/home/wangjl/software/gcc-12.1.0 --enable-shared --enable-threads=posix --enable-languages=c,c++,fortran --disable-multilib
$ make -j64 #多线程，否则巨慢！ 20:25-->20:45
### -j6 十分耗时 20:00-->20:24 ctrl+C改为64核

$ make install

Libraries have been installed in:
   /home/wangjl/software/gcc-12.1.0/lib/../lib64




(3) 加入环境变量
打开.bashrc
$ vim ~/.bashrc

添加以下三条，需要把路径改成自己的
export PATH=~/software/gcc-12.1.0/bin:$PATH
export LD_LIBRARY_PATH=~/software/gcc-12.1.0/lib:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=~/software/gcc-12.1.0/lib64:$LD_LIBRARY_PATH

激活环境
$ source ~/.bashrc

查看版本
$ gcc --version

gcc (GCC) 12.1.0
Copyright (C) 2022 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.



使用老版本的gcc:
$ whereis gcc
gcc: /usr/bin/gcc /usr/lib/gcc /usr/libexec/gcc /data/jinwf/wangjl/software/gcc-12.1.0/bin/gcc /usr/share/man/man1/gcc.1.gz

$ /usr/bin/gcc --version
gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)
Copyright (C) 2015 Free Software Foundation, Inc.


(4) 清理
$ cd ../..
$ mv gcc-12.1.0 gcc-12.1.0-Can-Delete
过几天没啥异常，这个就可以删除了。


(5) 测试
源码文件
$ cat main.cpp 
#include <iostream>
using namespace std;
int main()
{
    cout << "Hello, world! from c++" << endl;
    return 0;
}


使用c++11标准编译，两个版本的编译器都正常工作。
$ /usr/bin/g++ -g -Wall -std=c++11 main.cpp
$ ./a.out 
Hello, world! from c++

$ g++ -g -Wall -std=c++11 main.cpp
$ ./a.out 
Hello, world! from c++



使用c++17标准，只有新的g++可以编译:
$ /usr/bin/g++ -g -Wall -std=c++17 main.cpp
g++: error: unrecognized command line option ‘-std=c++17’

$ g++ -g -Wall -std=c++17 main.cpp
$ ./a.out 
Hello, world! from c++



https://www.csdn.net/tags/MtjaUg5sODMyODItYmxvZwO0O0OO0O0O.html








========================================
|-- 15个最常用的GCC编译器参数 //todo
----------------------------------------
https://colobu.com/2018/08/28/15-Most-Frequently-Used-GCC-Compiler-Command-Line-Options/







========================================
|-- vsCode 配置 C++
----------------------------------------
1. 已经安装过 Strawberry perl 自带的一套 g++ 编译器。

其实，最后选择的ssh链接服务器，是利用 server 的g++环境。
$ g++ --version
g++ (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.



2. 安装插件
点击左侧 插件图标，搜索并安装: 第一个是vscode推荐的，剩下两个是看博客推荐的。
	C/C++ Extension Pack  | v1.2.0
	code Runner  | v0.11.7 跑代码
	C/C++  | v1.7.1 代码提示




3. 写代码 
$ pwd
/home/wangjl/data/project/linux_C/cpp

在编辑器中写，有自动提示补齐。
$ cat cpp/a1.cpp
#include<iostream>
using namespace std;

int main(){
    cout << "Welcome to my vscode C++ world!" << endl;
    return 0;
}




4. 点右上角 三角 Run code 
底下控制台输出3行:
[Running] cd "/home/wangjl/data/project/linux_C/cpp/" && g++ a1.cpp -o a1 && "/home/wangjl/data/project/linux_C/cpp/"a1
Welcome to my vscode C++ world!

[Done] exited with code=0 in 0.314 seconds






5. 我们用objdump -t c1.o命令来查看一下c1.o的符号表

$ objdump -t c1.out

c1.out:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000318 l    d  .interp	0000000000000000              .interp
0000000000000338 l    d  .note.gnu.property	0000000000000000              .note.gnu.property
0000000000000358 l    d  .note.gnu.build-id	0000000000000000              .note.gnu.build-id
000000000000037c l    d  .note.ABI-tag	0000000000000000              .note.ABI-tag
00000000000003a0 l    d  .gnu.hash	0000000000000000              .gnu.hash
00000000000003c8 l    d  .dynsym	0000000000000000              .dynsym
0000000000000470 l    d  .dynstr	0000000000000000              .dynstr
00000000000004f4 l    d  .gnu.version	0000000000000000              .gnu.version
...




6. gcc 编译器的选项

g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：

$ g++ -g -Wall -std=c++11 main.cpp



g++ 常用命令选项
选项	解释
-ansi	只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。
-c	只编译并生成目标文件。
-DMACRO	以字符串"1"定义 MACRO 宏。
-DMACRO=DEFN	以字符串"DEFN"定义 MACRO 宏。
-E	只运行 C 预编译器。
-g	生成调试信息。GNU 调试器可利用该信息。
-IDIRECTORY	指定额外的头文件搜索路径DIRECTORY。
-LDIRECTORY	指定额外的函数库搜索路径DIRECTORY。
-lLIBRARY	连接时搜索指定的函数库LIBRARY。
-m486	针对 486 进行代码优化。
-o	FILE 生成指定的输出文件。用在生成可执行文件时。
-O0	不进行优化处理。
-O	或 -O1 优化生成代码。
-O2	进一步优化。
-O3	比 -O2 更进一步优化，包括 inline 函数。
-shared	生成共享目标文件。通常用在建立共享库时。
-static	禁止使用共享连接。
-UMACRO	取消对 MACRO 宏的定义。
-w	不生成任何警告信息。
-Wall	生成所有警告信息。






========================================
头文件的作用与用法
----------------------------------------

xx.h 文件
	可以定义数据类型，保证一致性
	节省代码，提高效率
	保密和代码重用: 只给用户提供头文件和二进制库。


引用方式:
	系统提供的 #include <iostream.h> 新标准是省略.h后缀: #include <iostream>
	自己编写的 #include "xx.h"


防止被重复包含，可以在 .h 文件中使用 
#ifndef HEADER_NAME
#define HEADER_NAME
//... some macros
#endif




1. 第一个版本，函数和输出写到一个文件
$ vim a1.c
#include<stdio.h>
int add(int a, int b){
	return a+b;
}

int main(){
	int a=add(3,5);
	printf("result=%d\n", a);
}

$ g++ a1.c -o a1.out
$ ./a1.out 
result=8



2. 第二个版本：函数和调用写到2个文件中
注意：调用函数前，必须要有函数声明。

$ vim b1.c
#include<stdio.h>
int add(int a, int b);

int main(){
	int a=add(20,5);
	printf("result=%d\n", a);
}

$ vim b2_fun.c
int add(int a, int b){
	return a+b;
}


编译和调用
$ g++ b1.c b2_fun.c -o b1.out
$ ./b1.out 
result=25





3. 第三个版本：函数和头文件分别写，调用文件引用头文件

$ vim c1.c 
#include<stdio.h>
#include "c1.h"

int main(){
	int a=add(20,5); //调用函数1
	a=del(a, 7);  //调用函数2
	printf("result=%d\n", a);
}


头文件
$ vim c1.h 
#define PI 3.14
int add(int a, int b);
int del(int a, int b);


函数文件
$ vim c1_fun.c 
int add(int a, int b){
	return a+b;
}


int del(int a, int b){
	return a-b;
}


(1) 一般的编译
$ g++ c1.c c1_fun.c -o c1.out
执行
$ ./c1.out 
result=18



(2) 保密编译方式 

先把机密代码 c1_fun.c 编译成中间文件 c1_fun.o
$ g++ -c c1_fun.c -o c1_fun.o

这时把 c1_fun.o 和 c1.h 给用户，用户可以查看 c1.h 调用该二进制库，并进行二次编译:
$ g++ c1.c c1_fun.o -o c1.out2
$ ./c1.out2
result=18



ref: https://zhuanlan.zhihu.com/p/387773355





========================================
** cpp 项目: 屏幕截图功能 //todo
----------------------------------------


搜索: https://so.csdn.net/so/search?q=c%2B%2B%20%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7&t=blog&u=&spm=1035.2249.3001.8104

相关的: 
	https://blog.csdn.net/chenlycly/article/details/121197726







========================================
入门篇
----------------------------------------
https://www.runoob.com/cplusplus/cpp-stl-tutorial.html
https://github.com/0voice/cpp_new_features





========================================
|-- 变量名、注释、数据类型、变量定义、变量作用域、常量、存储类
----------------------------------------

1. 变量名
字母或下划线开头，后面可以是字母、下划线、数字。

2. 注释
/*多行注释*/
// 单行注释



3. 数据类型 

(1)内置7种基本数据类型

类型	关键字
布尔型	bool
字符型	char
整型	int
浮点型	float
双浮点型	double
无类型	void
宽字符型	wchar_t

一些类型可以加修饰符
signed
unsigned
short
long

怎么查询数据类型占了多少字符？
cout << "sizeof short:" << sizeof(short) << endl; //2


还有其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等。



(2) typedef 给已有类型取别名
typedef type newname; 


(3) 枚举类型 
枚举类型的一般形式为：enum enum-name { list of names } var-list; 


enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;



如：定义只能使用这几种颜色。color 是变量类型，变量名是c，第二行c的值是 blue。
	enum color { red, green, blue } c;
	c = blue;
	cout << "c=" << c << endl; //2
	//再定义一个变量
    Color c2=red;
    cout << "c2=" << c2 << endl; //0

enum-name 是枚举类型的名称。
list of names 是逗号分隔的名称，默认情况下第一个名称的值是0，第二个名称的值是1，类推。
但是可以定义初始值


enum color { red, green=5, blue };
在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。



枚举的作用就是防止输错，并且名称有意义。比如星期、月份就很适合使用枚举类型。
    //定义值的枚举，前面的值不变，后面默认比前面递增1
    enum Week {Mon, Tue, Wed=13, Thu, Fri, Sat, Sun};
    Week w1=Mon, w2=Fri;
    cout << "\nw1=" << w1 << endl; //0
    cout << "w2=" << w2 << endl; //15
	cout << "size of enum:" << sizeof(w2) << endl; //4 看这个大小，还是当 int 存储的



4. 变量定义

如何定义、声明和使用各种类型的变量。

(1) 变量定义
告诉编译器 变量的类型，变量的名字。
type variable_list;
type variable_name = value; //赋初始值

实例: 
int i, j, k=3;


(2) extern 关键字
当您使用多个文件且只在其中一个文件中定义变量时, 使用 extern 关键字在任何地方声明一个变量。

extern int d = 3, f = 5;    // d 和 f 的声明 

可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。
//todo 声明 定义 啥区别？ 看例子:

#include<iostream>
using namespace std;

//变量声明，可以多次声明，在多个文件种声明
extern int a,b;
extern float f;

int main(){
    //变量定义，只能在某一个文件被定义一次
    int a,b;
    float f;

    //实际初始化
    a=10;
    b=20;
    f=10.1/3.0;

    cout << a+b << endl;
    cout << f << endl;

    return 0;
}

变量声明：用于向程序表明变量的类型和名字。
变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。
定义也是声明：当定义变量时我们声明了它的类型和名字。




5. 函数声明
开头声明函数，而函数定义可以在任何地方。

#include<iostream>
using namespace std;

//函数声明
int add(int x, int y); //如果不提前声明，就要在使用前定义。

int main(){
    cout<< add(10, 8) << endl;

    return 0;
}

//函数定义
int add(int a, int b){
    return a+b;
}




6. 变量作用域
在函数或一个代码块内部声明的变量，称为局部变量。
	它们只能被函数内部或者代码块内部的语句使用。

在所有函数外部声明的变量，称为全局变量。
	全局变量的值在程序的整个生命周期内都是有效的。

在函数参数的定义中声明的变量，称为形式参数。

先来讲解声明是局部变量和全局变量。

在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。


(2) 初始化
当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。
定义全局变量时，系统会自动初始化为下列值：
数据类型	初始化默认值
int	0
char	'\0'
float	0
double	0
pointer	NULL

正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。




7. 常量
常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。
常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。
常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

使用 #define 预处理器。
使用 const 关键字。强烈推荐 const。

#define WIDTH 25  //不是c++语句，编译前预处理掉了，不加分号结尾
const int HEIGHT = 4; //加分号结尾

请注意，把常量定义为大写字母形式，是一个很好的编程实践。




8. 存储类

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：
auto  默认。auto 只能修饰局部变量。
register 
static
extern
mutable

(2)
register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

(3) static 存储类

static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。

#include<iostream>
using namespace std;

// 全局静态变量
static int count = 10;

void func1(void){
    static int i=2; //局部静态变量
    i++;
    cout << "i=" <<i << 
        ", count=" << count << endl; //内部可以使用全局变量
}

int main(){
    while(count--){
        func1();
    }
    //cout << "i=" << i << endl; //报错 i 未声明。局部变量只能用在局部: 函数内或块内
    return 0;
}


(4) extern 是用来在另一个文件中声明一个全局变量或函数。
extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候.
可以修饰变量声明或函数声明。

(5) mutable 存储类
mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。
它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。





========================================
|-- 运算符 //todo
----------------------------------------


http://www.codebaoku.com/cpp/cpp-operators.html











========================================
读书笔记：重述《Effective C++》 //好难，走马观花过一遍，然后就知道打基础的重要性了
----------------------------------------
https://normaluhr.github.io/2020/12/31/Effective-C++/

共55条意见和建议。


1. 让自己习惯 c++
(1) c++ 是一个联邦语言。分4大块，有些使用习惯并不一致。

(2),(3) 尽可能使用 const 而不是 #define 来定义常量。

太复杂，先跳过3. //todo 指针、类、引用

(4) 使用前要初始化。//todo 构造函数的初始化、赋值 的区别。



2. 构造/析构/赋值运算
(5) 


















========================================
----------------------------------------



========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------



========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------


