cpp_note
主要是为学习和使用 Rcpp 服务




cpp的精髓就在于转化和复现。因为快，所以可以时间来换空间，来弥补架构的缺陷。

各种层面的延时调用和抽象分发、汇聚，现在根本就没人懂，也不点赞。然后就没人写这类的文章和回答，结果cpp板块在知乎的搜索页上都消失了。2017年还好好的。



========================================
c++教程与知识天梯
----------------------------------------
1. 入门版
很多对于会的人是常识的东西，对于初学者就是无法理解、很难的概念。

文字: https://www.runoob.com/cplusplus/cpp-tutorial.html

视频: https://www.bilibili.com/video/BV1Tb411j7uM
	本人配合《C++ prime》看，看书感觉难懂的就来看视频，结果感觉效果十分显著
	黑马C/C++教程: 张涛老师Qt课程 https://www.bilibili.com/video/BV1jK4y1s73T?p=639
	黑马C++_13移动打车项目 https://www.bilibili.com/video/bv1G7411m7XQ


1)翁凯老师无论是 C、C++、Java 的视频都讲得非常深入浅出，只能说水平越是高的人讲的课越容易明白。
	https://study.163.com/course/introduction/271005.htm
	本课程以C++语言来介绍面向对象程序设计的原理和方法，
	内容包括面向对象程序设计基本原理和C++特有的语言特性。
	大致的章节包括基本理论、类与对象、构造与清除、函数、引用、继承与多态、拷贝构造、运算符重载、异常、模板和流等。
	本课程不涉及具体的C++开发环境，也不会涉及图形程序设计和网络程序设计等。

2)侯捷老师的八部曲：
侯捷C++ 标准 11 -14
侯捷STL 和 泛型编程
侯捷C++ 内存管理
侯捷C++面向对象高级开发
侯捷STL与泛型编程
侯捷 C++ Startup 揭密：C++ 程序的生前和死后

陈硕第三套、Linux CC++网络编程实践-陈硕






(2) 经典书单
C++
《A Tour of C++》
《Accelerated C++》
《C++ primer》  # 注意:《C++ primer plus》是一本垃圾，讲的是一个披着 c++ 外衣的C语言。
《STL源码解析》
《Effective C++》
《深度探索C++对象模型》
《C++设计与演化》






2. 核心知识点 第一层
(1) 第一层，通识
共同的、最基本的那些概念：变量、常量、类型、循环、判断、数组、字符串、对象、输入输出等

然后还有 C++ 中一些特有的东西，比如命名空间 namespace、引用、模板等。

以及如何使用一些 STL 中的类库，比如 string、vector、find 之类的东西。

然后就是辅以大量的练习。
	就那种 C++ 教程的课后练习题就足够了，类似水仙花数、四则运算计算器之类的东西。


(2) 第一层，cpp入门
到这里，你对 C++ 包含了哪些知识点大概有了一个整体的印象。并且能够写上百行左右的程序，但是还是很难写出一个优秀的类。

接下来需要进行全面和深入的学习，算是真正的入门：
《Accelerated C++》（美国斯坦福大学的经典教材）  
《C++ Primer》（大而全）  
《The C++ Programming Language》（C++之父 Bjarne Stroustrup 所著） 
这三本，其实各有优缺点，第一本优点是简短，仅仅两三百页，只有最为核心和主干的知识点。
而后两本则都是大而全，尤其是《The C++ Programming Language》。
这两本区别在于，一个是 C++ 大师所著，一本是 C++ 之父所著。

网上有人说 《C++Primer》是目前市面上唯一一本真正的从入门到精通的书，适合初学者；
《C++ Programming language》 是C++专家自学指南，顾名思义，适合有较深厚 C++ 功底的读者。
所以我推荐的顺序是：《Accelerated C++》->《C++ Primer》->《The C++ Programming Language》


对于这种上前页大部头我推荐的阅读方式是，以主题为划分，比如 C++ Primer 就明确的分为了：
	C++ 基础
	C++ 标准库
	类设计者的工具
	高级主题

如果有一定的基础的话，可以看着目录，看一些自己感兴趣的章节，完全没有必要从第一页开始挨着挨着读。

入门结束你应该掌握以下内容：
	基础语言
	类与面向对象
	输入输出
	字符串处理（类库和正则表达式）
	容器类库
	泛型算法

看着只有几个关键字，实际上每个展开都有很多内容需要学习。
学习过程中把后面的每一个练习题都自己敲一遍，自己多思考对比一下。
多用代码去验证自己的想法，尤其是指针、引用、构造、析构这些地方。
学习 C++ 以及日常开发一定要记得这几个网站，可以随时查阅一些语法的用法和标准库：
	cppreference
	cplusplus
	isocpp





更细的颗粒度:

C++ 基础语法: 数据类型与声明，标识符与关键字，常量与变量，运算符(算术/关系/逻辑)，初等表达式/lambda 表达式;
C++ 基本词法: 
	最基本容器--数组 
	指针: const 指针, 	函数指针, 	各类指针分析, 	避免野指针
	防止内存泄漏，智能指针的使用
	C++内存分配方式，字符串，Redis项目字符串处理
C++ 基本句法: 
	赋值、判断与循环
	函数基础，内联函数，递归函数的本质，枚举类型，
	结构体：包容一切
	联合体：高效组合
	类与面向对象
	命名空间
C++ 高级语法:
	类型转换
	异常 exception
	IO 最难设计的模块
	文件操作
	多线程-C++新标准的应用
	模板编程应用
C++ 编程思想进阶：
	再议class
	运算符重载 
	深拷贝与浅拷贝
	面向对象的思想、误区
	常见面向对象设计模式
	模板编程：C++精髓
C++ 高效编程进阶：
	STL常见容器：顺序容器、关联容器
	算法 Algorithm
	函数对象 Function Objects 
	迭代器 Iterators
	生成器 Allocators
	C++ 的内存分配问题
	STL 的整体架构和思想
	更安全使用字符串： STL string
	C++ 的 stream
	C++ 的瑞士军刀: boost 库
	C++ 最新标准/陷阱和经验
	C++ 中常见的编程范式


项目：实现一个屏幕矩阵截图功能。目标是 PicPick
	https://blog.csdn.net/hhy321/article/details/121548612




浏览菜鸟教程，没记住的部分：
	枚举类型 https://www.runoob.com/cplusplus/cpp-data-types.html
	变量类型 cpp-variable-types.html
	特殊字符常量需要加反斜杠 \\ 表示 \, \? 表示?
	关键字 extern int a;
	C++ 修饰符类型 cpp-modifier-types.html
	C++ 存储类 cpp-storage-classes.html
	
	Lambda 函数与表达式 cpp-functions.html

	C++ 随机数 cpp-numbers.html
	C++ 指针 cpp-pointers.html
	C++ 引用 cpp-references.html
	日期和时间 cpp-date-time.html
	输入和输出(错误和日志流) cpp-basic-input-output.html
	结构体(结构体作为函数参数、指向结构体的指针): cpp-data-structures.html
	
	
	类和对象: cpp-classes-objects.html
	










3. 怎么精通？C++是不是落伍了？
C++在刚毕业的年轻人简历里都是精通，工作两年后就是略懂了
写了十几年我都只敢熟练



CPP 现在招聘真没限制年龄。 就是后继无人。 使用起来比其他语言繁琐多了。
那是你不了解现代c++,特别是加上boost已经非常强了


c++已经过时了，十年才能入门的语言早该被淘汰了，十个小时就能入门的语言才是好语言。
卷就是这么卷起来的，其次现在新的那些语言很难用于大型实时游戏和一些驱动，运行效率确实太慢


游戏底层还有c++ 最后一块地

既然都说到"底层"了，有哪个不是C++？操作系统，编译器，浏览器，驱动，图形，图像……
整个底层都没人做了






========================================
环境搭建与 hello world 编译
----------------------------------------
2. 运行环境
(1) win7 本
忘了啥时候安装的了，看输出信息，是 Strawberry perl 自带的。
如果未安装 GCC，那么请按照 http://gcc.gnu.org/install/ 上的详细说明安装 GCC。

打开 git bash
$ g++ --version
g++.exe (x86_64-posix-seh, Built by strawberryperl.com project) 7.1.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

$ g++ -v
Using built-in specs.
COLLECT_GCC=C:\Strawberry\c\bin\g++.exe
COLLECT_LTO_WRAPPER=C:/Strawberry/c/bin/../libexec/gcc/x86_64-w64-mingw32/7.1.0/lto-wrapper.exe
Target: x86_64-w64-mingw32
Configured with: ../../../src/gcc-7.1.0/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=posix --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --enable-libstdcxx-filesystem-ts=yes --disable-libstdcxx-pch --disable-libstdcxx-debug --disable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=nocona --with-tune=core2 --with-libiconv --with-system-zlib --with-gmp=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-mpfr=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-mpc=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-isl=/opt/build/prerequisites/x86_64-w64-mingw32-static --with-pkgversion='x86_64-posix-seh, Built by strawberryperl.com project' CFLAGS='-O2 -pipe -fno-ident -I/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/include -I/opt/build/prerequisites/x86_64-zlib-static/include -I/opt/build/prerequisites/x86_64-w64-mingw32-static/include' CXXFLAGS='-O2 -pipe -fno-ident -I/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/include -I/opt/build/prerequisites/x86_64-zlib-static/include -I/opt/build/prerequisites/x86_64-w64-mingw32-static/include' CPPFLAGS=' -I/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/include -I/opt/build/prerequisites/x86_64-zlib-static/include -I/opt/build/prerequisites/x86_64-w64-mingw32-static/include' LDFLAGS='-pipe -fno-ident -L/opt/build/x86_64-710-posix-seh-rt_v502/mingw64/opt/lib -L/opt/build/prerequisites/x86_64-zlib-static/lib -L/opt/build/prerequisites/x86_64-w64-mingw32-static/lib '
Thread model: posix
gcc version 7.1.0 (x86_64-posix-seh, Built by strawberryperl.com project)





3. 运行示例

(1) 最简单的程序
$ cat main.cpp 
#include <iostream>
using namespace std;
int main()
{
    cout << "Hello, world!" << endl;
    return 0;
}

(2)编译
$ gcc main.cpp -lstdc++ -o main

最简单的编译方式：
$ g++ main.cpp

由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：
$ ./a.exe
Hello, world!



(3) 指定输出文件 -o
通常我们使用 -o 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：
$ g++ helloworld.cpp -o helloworld

执行 helloworld:
$ ./helloworld.exe
Hello, world!



(4) 如果是多个 C++ 代码文件，如 xx1.cpp、xx2.cpp，编译命令如下：

$ g++ xx1.cpp xx2.cpp -o xx
生成一个 xx 可执行文件。


(5) g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：
$ g++ -g -Wall -std=c++11 main.cpp






========================================
|-- vsCode 配置 C++
----------------------------------------
1. 已经安装过 Strawberry perl 自带的一套 g++ 编译器。

其实，最后选择的ssh链接服务器，是利用 server 的g++环境。
$ g++ --version
g++ (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.



2. 安装插件
点击左侧 插件图标，搜索并安装: 第一个是vscode推荐的，剩下两个是看博客推荐的。
	C/C++ Extension Pack  | v1.2.0
	code Runner  | v0.11.7 跑代码
	C/C++  | v1.7.1 代码提示




3. 写代码 
$ pwd
/home/wangjl/data/project/linux_C/cpp

在编辑器中写，有自动提示补齐。
$ cat cpp/a1.cpp
#include<iostream>
using namespace std;

int main(){
    cout << "Welcome to my vscode C++ world!" << endl;
    return 0;
}




4. 点右上角 三角 Run code 
底下控制台输出3行:
[Running] cd "/home/wangjl/data/project/linux_C/cpp/" && g++ a1.cpp -o a1 && "/home/wangjl/data/project/linux_C/cpp/"a1
Welcome to my vscode C++ world!

[Done] exited with code=0 in 0.314 seconds






5. 我们用objdump -t c1.o命令来查看一下c1.o的符号表

$ objdump -t c1.out

c1.out:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000318 l    d  .interp	0000000000000000              .interp
0000000000000338 l    d  .note.gnu.property	0000000000000000              .note.gnu.property
0000000000000358 l    d  .note.gnu.build-id	0000000000000000              .note.gnu.build-id
000000000000037c l    d  .note.ABI-tag	0000000000000000              .note.ABI-tag
00000000000003a0 l    d  .gnu.hash	0000000000000000              .gnu.hash
00000000000003c8 l    d  .dynsym	0000000000000000              .dynsym
0000000000000470 l    d  .dynstr	0000000000000000              .dynstr
00000000000004f4 l    d  .gnu.version	0000000000000000              .gnu.version
...




6. gcc 编译器的选项

g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件：

$ g++ -g -Wall -std=c++11 main.cpp



g++ 常用命令选项
选项	解释
-ansi	只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。
-c	只编译并生成目标文件。
-DMACRO	以字符串"1"定义 MACRO 宏。
-DMACRO=DEFN	以字符串"DEFN"定义 MACRO 宏。
-E	只运行 C 预编译器。
-g	生成调试信息。GNU 调试器可利用该信息。
-IDIRECTORY	指定额外的头文件搜索路径DIRECTORY。
-LDIRECTORY	指定额外的函数库搜索路径DIRECTORY。
-lLIBRARY	连接时搜索指定的函数库LIBRARY。
-m486	针对 486 进行代码优化。
-o	FILE 生成指定的输出文件。用在生成可执行文件时。
-O0	不进行优化处理。
-O	或 -O1 优化生成代码。
-O2	进一步优化。
-O3	比 -O2 更进一步优化，包括 inline 函数。
-shared	生成共享目标文件。通常用在建立共享库时。
-static	禁止使用共享连接。
-UMACRO	取消对 MACRO 宏的定义。
-w	不生成任何警告信息。
-Wall	生成所有警告信息。






========================================
头文件的作用与用法
----------------------------------------

xx.h 文件
	可以定义数据类型，保证一致性
	节省代码，提高效率
	保密和代码重用: 只给用户提供头文件和二进制库。


引用方式:
	系统提供的 #include <iostream.h> 新标准是省略.h后缀: #include <iostream>
	自己编写的 #include "xx.h"


防止被重复包含，可以在 .h 文件中使用 
#ifndef HEADER_NAME
#define HEADER_NAME
//... some macros
#endif




1. 第一个版本，函数和输出写到一个文件
$ vim a1.c
#include<stdio.h>
int add(int a, int b){
	return a+b;
}

int main(){
	int a=add(3,5);
	printf("result=%d\n", a);
}

$ g++ a1.c -o a1.out
$ ./a1.out 
result=8



2. 第二个版本：函数和调用写到2个文件中
注意：调用函数前，必须要有函数声明。

$ vim b1.c
#include<stdio.h>
int add(int a, int b);

int main(){
	int a=add(20,5);
	printf("result=%d\n", a);
}

$ vim b2_fun.c
int add(int a, int b){
	return a+b;
}


编译和调用
$ g++ b1.c b2_fun.c -o b1.out
$ ./b1.out 
result=25





3. 第三个版本：函数和头文件分别写，调用文件引用头文件

$ vim c1.c 
#include<stdio.h>
#include "c1.h"

int main(){
	int a=add(20,5); //调用函数1
	a=del(a, 7);  //调用函数2
	printf("result=%d\n", a);
}


头文件
$ vim c1.h 
#define PI 3.14
int add(int a, int b);
int del(int a, int b);


函数文件
$ vim c1_fun.c 
int add(int a, int b){
	return a+b;
}


int del(int a, int b){
	return a-b;
}


(1) 一般的编译
$ g++ c1.c c1_fun.c -o c1.out
执行
$ ./c1.out 
result=18



(2) 保密编译方式 

先把机密代码 c1_fun.c 编译成中间文件 c1_fun.o
$ g++ -c c1_fun.c -o c1_fun.o

这时把 c1_fun.o 和 c1.h 给用户，用户可以查看 c1.h 调用该二进制库，并进行二次编译:
$ g++ c1.c c1_fun.o -o c1.out2
$ ./c1.out2
result=18



ref: https://zhuanlan.zhihu.com/p/387773355







========================================
入门篇
----------------------------------------
https://www.runoob.com/cplusplus/cpp-stl-tutorial.html
https://github.com/0voice/cpp_new_features





========================================
** cpp 项目: 屏幕截图功能 //todo
----------------------------------------


搜索: https://so.csdn.net/so/search?q=c%2B%2B%20%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7&t=blog&u=&spm=1035.2249.3001.8104

相关的: 
	https://blog.csdn.net/chenlycly/article/details/121197726






========================================
----------------------------------------




========================================
----------------------------------------



========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------



========================================
----------------------------------------





========================================
----------------------------------------



========================================
----------------------------------------


