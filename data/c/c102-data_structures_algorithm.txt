数据结构与算法(Python 版)



算法与数据结构 是程序的灵魂，你丢弃了算法也就等于抛弃了优秀程序员的称号
c语言版 https://www.kancloud.cn/digest/linuxzhang/121697



========================================
资料书
----------------------------------------
1. 数据结构与算法分析：C语言描述（原书第2版）是《data structures and algorithm analysis in c》一书第2版的简体中译本。
https://www.cnblogs.com/Ivyli4258/p/7851953.html

原书曾被评为20世纪顶尖的30部计算机著作之一，作者mark allen weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。

在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过c程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。

数据结构与算法分析：C语言描述（原书第2版） PDF下载：http://pan.baidu.com/s/1pJ59aMv （本人是从这里下载的，感谢原博主）


全书特点如下：
●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法
●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树
●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构
●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容
●合并了堆排序平均情况分析的一些新结果


目录
出版者的话
专家指导委员会
译者序
前言
第1章 引论
第2章 算法分析
第3章 表、栈和队列
第4章 树
第5章 散列
第6章 优先队列（堆）
第7章 排序
第8章 不相交集ADT
第9章 图论算法
第10章 算法设计技巧
第11章 摊还分析
第12章 高级数据结构及其实现索引


(2) 算法入门书籍
https://github.com/CodingDocs/awesome-cs-books



(3) 网页教程
https://www.zhihu.com/question/356351510/answer/1844573129
	贪心算法
	双指针
	二分查找
	各种排序
	深度优化搜索
	动态规划
	分而治之
	巧解数学问题
	神奇的位运算
	妙用数据结构

	




2. 视频教程
数据结构与算法Python版-北京大学-中国大学MOOC(慕课) 
https://www.bilibili.com/video/BV1QJ411w7bB?p=2 消失了
https://www.icourse163.org/course/0809PKU068-1206307812










========================================
数据结构和算法关系
----------------------------------------
数据结构：数据与数据之间的结构关系（数组、队列、树、图等结构）

算法：解决问题的步骤

总结：
1、程序 = 数据结构 + 算法 。数据是程序的中心。数据结构和算法两个概念间的逻辑关系贯穿了整个程序世界，首先二者表现为不可分割的关系。没有数据间的有机关系，程序根本无法设计。

2、数据结构与算法关系：数据结构是底层，算法高层。数据结构为算法提供服务。算法围绕数据结构操作。

3、解决问题（算法）需要选择正确的数据结构。例如：算法中经常需要对数据进行增加和删除用链表数据结构效率高，数组数据结构因为增加和删除需要移动数字每个元素所有效率低。

4、数据结构特点：每种数据结构都具有自己的特点。例如：队列：先进先出。栈：先进后出。等等

5、算法的特性：算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。

6、数据结构应用：数据结构往往同高效的检索算法、索引技术、排序算法有关

7、数据结构（逻辑数据结构）通过计算机语言来实现数据结构（存储数据结构）。例如：树型数据结构：通过计算机语言中的数组（节点）和指针（指向父节点）来实现。

8、存储结构：逻辑数据结构的实现。存储结构通过计算机语言实现。  例如：堆数据结构，堆是一棵完全二叉树，所以适宜采用顺序存储结构（顺序存储：数组），这样能够充分利用存储空间。

9、算法目的：算法是为数据结构服务。例如：数据结构通常伴随有查找算法、排序算法等

10、数据结构的优劣：一种数据结构的优劣是在实现其各种运算的算法中体现的。

 

二、数据结构：分为逻辑数据结构和存储数据结构两种
（1）顺序存储方法（顺序存储结构） 
（2）链接存储方法（链式存储结构） 
同一种逻辑结构可采用不同的存储方法（以上两种之一或组合），这主要考虑的是运算方便及算法的时空要求。


https://www.cnblogs.com/Ivyli4258/p/7838675.html


========================================
关于计算的数学模型
----------------------------------------
https://www.bilibili.com/video/BV1QJ411w7bB?p=3

1.图灵机 Turing Machine是一个思想模型







========================================
Maximum Subarray（连续子数组的最大和问题）
----------------------------------------


除了暴力法，其他没看懂: 暴力法、动态规划法





ref
https://blog.csdn.net/lw_power/article/details/80892362
https://blog.csdn.net/weixin_41931602/article/details/82891149



========================================
随机算法
----------------------------------------


========================================
|-- 洗牌算法: 神一样的公平随机化
----------------------------------------
1.问题
给一套扑克牌，请给出公平的随机化排序方法。
公平: 每个位置出现每张牌的概率都相同。

当然尽量简洁，减少运算量。

这个算法就是大名鼎鼎的 Knuth-Shuffle，即 Knuth 洗牌算法





2. 参考答案
总体思路: 随机的取两张，互换位置。然后交换k次即可。请问k取多少合适呢？10,100,1000,...?


for(int i = n - 1; i >= 0 ; i -- )
    swap(arr[i], arr[rand() % (i + 1)])
# 为什么能做到保证：对于生成的排列，每一个元素都能等概率的出现在每一个位置了。


用js实现一下:

arr=[0,1,2,3,4]

n=arr.length
for(var i=n-1; i>=0; i--){
	var r=Math.round( Math.random()*n ) % (i+1);
	console.log('i=',i, '; r=', r, '; arr=', arr)
	var tmp=arr[i]
	arr[i]=arr[r]
	arr[r]=tmp;
}
arr //[3, 0, 4, 2, 1]

n=5;
第一个循环 i=n-1=4, 从前面几个随机挑选一个和最后一个(第4位)交换位置，也即是任何数字出现在最后一位的概率是 1/5;
第二个循环 i=3, 从0-3随机挑选一个数字放到第3位，则数字3出现的概率: 逃过第一个循环 4/5 * 第二次选中 1/4=1/5;
以此类推。


优点:
- 整个算法的复杂度是 O(n) 的。
- 从后向前简化代码。（因为生成 [0, i] 范围的随机数比生成 [i, n) 范围的随机数简单，直接对 i+1 求余就好了。）




3. 更多用法
在很多随机的地方，都能使用。

比如，扫雷生成随机的盘面。我们可以把扫雷的二维盘面先逐行连接，看作是一维的。之后，把 k 颗雷依次放在开始的位置。

算法从来不是枯燥的逻辑堆砌，而是神一样的逻辑创造。

尽管这个世界很复杂，但竟也如此的简洁，优雅。






ref:
https://www.jianshu.com/p/4be78c20095e



========================================
五大常用算法一(回溯,随机化,动态规划)
----------------------------------------
https://www.jianshu.com/p/dec9a453573f

递归
回溯




贪心法
分治法

搜索算法
二叉树链表



========================================
|-- 动态规划 Dynamic Programming
----------------------------------------
1. 简介
(1)
动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果



(2) 基本思想
动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。

动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。

具体的动态规划算法多种多样，但它们具有相同的填表格式。


(3) 什么样的问题适合使用动态规划
- 求最大值/最小值
- 求可不可行
- 求方案总数
以上三个问题，90%的概率是使用DP来求解的。
说明: 如果让求出“所有的”方案和结果，肯定不是使用DP。






2. 入门
https://www.zhihu.com/question/39948290

"So you didn't need to recount because you remembered there were eight!
Dynamic Programming is just a fancy way to say 'remembering stuff to save time later'"

DP is just a kind of smart recursion
动态规划就是记忆化搜索

取决于该问题是否能用动态规划解决的是这些“小问题”会不会被被重复调用。


三大步骤:
- 建立状态转移方程: 一个状态和之前状态的等式关系
	大概长这样
		* f[i][j] = f[i - 1][j] + f[i][j - 1]
		* f[i] = max{f[j] if j &lt; i and …} + 1
		* f[i][j] = f[0][j - 1] &amp;&amp; judge(1,i) || f[1][j - 1] &amp;&amp; judge(2,i) || …
		
- 缓存并复用以往的结果
- 按顺序从小往大算






##########
例1: 有n个阶梯，一个人每一步只能跨一个台阶或是两个台阶，问这个人一共有多少种走法？

首先要对这个问题进行抽象，n个阶梯，每个阶梯都代表一个“位置”， 就像是图论中的一个“点”，然后这些n个不同位置之间会有一些桥梁把它们连起来：


简化: 假设有10个台阶。
抽象化，就是node1到node10有几种不同的路可以走。

如果我在计算出从5到10的路径数，这个路径可以保存下来。
因为要复用。无论从3还是4过来，走到5后，都有用到，保存下来，避免重复计算。

如果暴力遍历，
从3->10 需要计算5->10，
而4->10 需要计算5->10，

我们创建一个数组a[]，专门来存放位点x到10的所有可能路径数，初始值记为0，
然后每当要计算x到10的路径数时，先检测一下该路径数的值是不是大于0，如果大于0，就表示计算过了。
如果等于0，则计算，并保存到a[x]中。

那么我们有递推关系:
a[x] = a[x+1] + a[x+2]

a[10]=1
a[9]=1

a[8]=a[9]+a[10]=2
a[7]=a[8]+a[9]=2+1=3

现在要解决x[0]=?
使用python编码

#DP 动态规划

# max=10
def dp(n):
    results=[0]*11
    for j in range(10):
        i=10-j
        #print('>>i=', i, results)
        if i>= (10-1):
            results[i]=1
        else:
            results[i]=results[i+1]+results[i+2]
        if i==n:
            break;
    return results[n]
# test
for j in range(10):
    i=10-j
    print('i=%d, steps=%d' % (i, dp(i) ) )
#结果
i=10, steps=1
i=9, steps=1
i=8, steps=2
i=7, steps=3
i=6, steps=5
i=5, steps=8
i=4, steps=13
i=3, steps=21
i=2, steps=34
i=1, steps=55







##########
例2: 在一个7x3的网格中，左上角格子是入口，一次只能向下、或向左移动一次，问移动到右下角格子有几种不同的路径？

解答:
(1)如下方格3只能由1和2过来，所以 f(i,j)=f(i-1,j)+f(i, j-1)
   [1]
[2][3]

初始化 
f(1,1)=0, f(1,2)=1, 
f(2,1)=1, f(2,2)=2, 


(2) 
实现1:
def walk(m,n):
    results=[[1 for i in range(n)] for j in range(m)] #[[1]*n]*m
    
    for i in range(1,m):
        for j in range(1,n):
            if results[i][j] == 1: #如果是初始值，则更新
                results[i][j]=results[i-1][j] + results[i][j-1]
            print('>> i=%d, j=%d' %(i,j),results)
    return results[-1][-1]
# test
walk(7,3)
# i=6, j=2 [[1, 1, 1], [1, 2, 3], [1, 3, 6], [1, 4, 10], [1, 5, 15], [1, 6, 21], [1, 7, 28]]


实现2:
import numpy as np
def walk(m,n):
    results=np.ones( (m,n) )
    
    for i in range(1,m):
        for j in range(1,n):
            if results[i][j]==1: #如果是初始值，则更新
                results[i][j]=results[i-1][j] + results[i][j-1]
            print('>> i=%d, j=%d \n' %(i,j),results)
    return results[-1][-1]
# test
walk(7,3)

#>> i=6, j=2 
 [[ 1.  1.  1.]
 [ 1.  2.  3.]
 [ 1.  3.  6.]
 [ 1.  4. 10.]
 [ 1.  5. 15.]
 [ 1.  6. 21.]
 [ 1.  7. 28.]]
#







##########
例3: 正则表达式匹配的实现 [地狱级]
给定字符串string和一个字符规律pattern，请实现一个支持"."和"*"的正则表达式匹配。
说明: 
. 匹配任意 单个 字符
* 匹配0个或多个前面的那个字符。

解答:
https://www.zhihu.com/question/39948290
还没看懂...








3. 动态规划与其说是一个算法，不如说是一种方法论。该方法论主要致力于将 合适 的问题拆分成三个子目标一一击破：

- 建立状态转移方程
- 缓存并复用以往结果
- 按顺序从小往大算


更多练习:
https://www.lintcode.com/problem/?tag=dynamic-programming






========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

