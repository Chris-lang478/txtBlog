数据结构与算法(Python 版)



算法与数据结构 是程序的灵魂，你丢弃了算法也就等于抛弃了优秀程序员的称号
c语言版 https://www.kancloud.cn/digest/linuxzhang/121697



========================================
资料书
----------------------------------------
1. 数据结构与算法分析：C语言描述（原书第2版）是《data structures and algorithm analysis in c》一书第2版的简体中译本。
https://www.cnblogs.com/Ivyli4258/p/7851953.html

原书曾被评为20世纪顶尖的30部计算机著作之一，作者mark allen weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。

在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过c程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。

数据结构与算法分析：C语言描述（原书第2版） PDF下载：http://pan.baidu.com/s/1pJ59aMv （本人是从这里下载的，感谢原博主）


全书特点如下：
●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法
●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树
●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构
●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容
●合并了堆排序平均情况分析的一些新结果


目录
出版者的话
专家指导委员会
译者序
前言
第1章 引论
第2章 算法分析
第3章 表、栈和队列
第4章 树
第5章 散列
第6章 优先队列（堆）
第7章 排序
第8章 不相交集ADT
第9章 图论算法
第10章 算法设计技巧
第11章 摊还分析
第12章 高级数据结构及其实现索引



2. 视频教程
数据结构与算法Python版-北京大学-中国大学MOOC(慕课) 
https://www.bilibili.com/video/BV1QJ411w7bB?p=2



========================================
数据结构和算法关系
----------------------------------------
数据结构：数据与数据之间的结构关系（数组、队列、树、图等结构）

算法：解决问题的步骤

总结：
1、程序 = 数据结构 + 算法 。数据是程序的中心。数据结构和算法两个概念间的逻辑关系贯穿了整个程序世界，首先二者表现为不可分割的关系。没有数据间的有机关系，程序根本无法设计。

2、数据结构与算法关系：数据结构是底层，算法高层。数据结构为算法提供服务。算法围绕数据结构操作。

3、解决问题（算法）需要选择正确的数据结构。例如：算法中经常需要对数据进行增加和删除用链表数据结构效率高，数组数据结构因为增加和删除需要移动数字每个元素所有效率低。

4、数据结构特点：每种数据结构都具有自己的特点。例如：队列：先进先出。栈：先进后出。等等

5、算法的特性：算法具有五个基本特征：输入、输出、有穷性、确定性和可行性。

6、数据结构应用：数据结构往往同高效的检索算法、索引技术、排序算法有关

7、数据结构（逻辑数据结构）通过计算机语言来实现数据结构（存储数据结构）。例如：树型数据结构：通过计算机语言中的数组（节点）和指针（指向父节点）来实现。

8、存储结构：逻辑数据结构的实现。存储结构通过计算机语言实现。  例如：堆数据结构，堆是一棵完全二叉树，所以适宜采用顺序存储结构（顺序存储：数组），这样能够充分利用存储空间。

9、算法目的：算法是为数据结构服务。例如：数据结构通常伴随有查找算法、排序算法等

10、数据结构的优劣：一种数据结构的优劣是在实现其各种运算的算法中体现的。

 

二、数据结构：分为逻辑数据结构和存储数据结构两种
（1）顺序存储方法（顺序存储结构） 
（2）链接存储方法（链式存储结构） 
同一种逻辑结构可采用不同的存储方法（以上两种之一或组合），这主要考虑的是运算方便及算法的时空要求。


https://www.cnblogs.com/Ivyli4258/p/7838675.html


========================================
关于计算的数学模型
----------------------------------------
https://www.bilibili.com/video/BV1QJ411w7bB?p=3

1.图灵机 Turing Machine是一个思想模型







========================================
Maximum Subarray（连续子数组的最大和问题）
----------------------------------------


除了暴力法，其他没看懂: 暴力法、动态规划法





ref
https://blog.csdn.net/lw_power/article/details/80892362
https://blog.csdn.net/weixin_41931602/article/details/82891149



========================================
随机算法
----------------------------------------


========================================
|-- 洗牌算法: 神一样的公平随机化
----------------------------------------
1.问题
给一套扑克牌，请给出公平的随机化排序方法。
公平: 每个位置出现每张牌的概率都相同。

当然尽量简洁，减少运算量。

这个算法就是大名鼎鼎的 Knuth-Shuffle，即 Knuth 洗牌算法





2. 参考答案
总体思路: 随机的取两张，互换位置。然后交换k次即可。请问k取多少合适呢？10,100,1000,...?


for(int i = n - 1; i >= 0 ; i -- )
    swap(arr[i], arr[rand() % (i + 1)])
# 为什么能做到保证：对于生成的排列，每一个元素都能等概率的出现在每一个位置了。


用js实现一下:

arr=[0,1,2,3,4]

n=arr.length
for(var i=n-1; i>=0; i--){
	var r=Math.round( Math.random()*n ) % (i+1);
	console.log('i=',i, '; r=', r, '; arr=', arr)
	var tmp=arr[i]
	arr[i]=arr[r]
	arr[r]=tmp;
}
arr //[3, 0, 4, 2, 1]

n=5;
第一个循环 i=n-1=4, 从前面几个随机挑选一个和最后一个(第4位)交换位置，也即是任何数字出现在最后一位的概率是 1/5;
第二个循环 i=3, 从0-3随机挑选一个数字放到第3位，则数字3出现的该率: 逃过第一个循环 4/5 * 第二次选中 1/4=1/5;
以此类推。


优点:
- 整个算法的复杂度是 O(n) 的。
- 从后向前简化代码。（因为生成 [0, i] 范围的随机数比生成 [i, n) 范围的随机数简单，直接对 i+1 求余就好了。）




3. 更多用法
在很多随机的地方，都能使用。

比如，扫雷生成随机的盘面。我们可以把扫雷的二维盘面先逐行连接，看作是一维的。之后，把 k 颗雷依次放在开始的位置。

算法从来不是枯燥的逻辑堆砌，而是神一样的逻辑创造。

尽管这个世界很复杂，但竟也如此的简洁，优雅。






ref:
https://www.jianshu.com/p/4be78c20095e



========================================
五大常用算法一(回溯,随机化,动态规划)
----------------------------------------
https://www.jianshu.com/p/dec9a453573f



========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

