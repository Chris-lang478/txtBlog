linux文本处理

linux shell文本处理三大利器：
grep 查找
sed 行编辑器
awk 列文本处理工具
一行指令，轻松搞定。

========================================
概述与资源
----------------------------------------
gerp 查找, awk 根据内容分析并处理, sed 编辑.
(1)grep, egrep, fgrep, rgrep - print lines matching a pattern 打印匹配模式的行。
(2)awk(关键字:分析&处理) 一行一行的分析处理。
mawk - pattern scanning and text processing language模式扫描与文本处理语言。
(3)sed(关键字: 编辑) 以行为单位的文本编辑工具 
sed - stream editor for filtering and transforming text 用于过滤和转换文本的流编辑器。特色是该编辑器能用于pipeline中。

awk和sed简明教程：
	http://agetouch.blog.163.com/blog/static/228535090201732824532207/

AWK 简明教程: http://coolshell.cn/articles/9070.html
sed 简明教程: http://coolshell.cn/articles/9104.html
三十分钟学会AWK: https://segmentfault.com/a/1190000007338373


========================================
grep 查找与正则表达式
----------------------------------------
正则规则：http://blog.csdn.net/newthinker_wei/article/details/8219293

1.grep(关键字: 截取) 文本搜集工具, 结合正则表达式非常强大。
一般格式： grep 正则 fileName
比如： $ grep 'wangjl' /etc/passwd #查找并返回passwd文件中包含wangjl的行。

主要参数 []
	-c : 只输出匹配的行
	-I : 不区分大小写
	-h : 查询多文件时不显示文件名
	-l : 查询多文件时, 只输出包含匹配字符的文件名
	-n : 显示匹配的行号及行
	-v : 显示不包含匹配文本的所有行
	
基本工作方式: grep 要匹配的内容 文件名
例如:
grep 'test' d* 显示所有以d开头的文件中包含test的行
grep 'test' aa bb cc 显示在 aa bb cc 文件中包含test的行
grep '[a-z]\{5}\' aa 显示所有包含字符串至少有5个连续小写字母的串


2.正则表达式分类：
1)基本的正则表达式（Basic Regular Expression 又叫 Basic RegEx  简称 BREs）
2)扩展的正则表达式 -E（Extended Regular Expression 又叫 Extended RegEx 简称 EREs）
3)Perl 的正则表达式 -P（Perl Regular Expression 又叫 Perl RegEx 简称 PREs）
 说明：只有掌握了正则表达式，才能全面地掌握 Linux 下的常用文本工具（例如：grep、egrep、GUN sed、 Awk 等） 的用法
注意：linux的正则支持有三种，其中perl兼容的是功能最强大的。
默认的是基本的正则，不支持数字元字符，但是加上-P指定Perl兼容的正则，就支持数字元字符了。

$ grep -P '\d' /etc/passwd #任何带数字的行
		\d: 任何数字 [0-9] grep默认不支持
		\D: 任何非数字[^0-9] grep默认不支持


3.正则表达式的数量词
正则表达式可能被以下重复修饰符中的一个修饰：
    ?      {0,1}The preceding item is optional and matched at most once.
    *      {0,}The preceding item will be matched zero or more times.
    +      {1,}The preceding item will be matched one or more times.
    {n}    The preceding item is matched exactly n times.
    {n,}   The preceding item is matched n or more times.
    {,m}   The  preceding  item  is matched at most m times.  This is a GNU extension.
    {n,m}  The preceding item is matched at least n  times,  but  not  more than m times.
比如：$ grep 'ro*t' /etc/passwd   # {0,}表示0个或多个o。


$ cd /etc
$ grep 'ro+t' passwd   #啥也没有
$ grep -P 'ro+t' passwd #使用Perl兼容的可以-P
root:x:0:0:root:/root:/bin/bash

$ grep 'ro\+t' passwd #或者使用转义字符\
root:x:0:0:root:/root:/bin/bash

4.正则的分组()
使用小括号()，默认需要加转义字符\(text\)
如果加入-P参数，则可以直接输入(text)

$ grep -P '(34)+' passwd #带有1个及以上34的行


5.范围
[]表示范围，比如
	[0-9]表示任意一位数字，等价于\d
	[a-z]任意一个小写字母，
	[A-Z]任意大写字母，
	[a-zA-Z]任意字母
[]内的^表示否定。
$ grep -P "[0-9]{4,6}" passwd # 含4到6个数字的行
$ grep -P "[^0-9]" passwd #匹配含有非数字的行
$ grep -P "[^0-9a-zA-Z]" passwd #匹配含有非数字、非大小写字母的行


6.位置界定^$
 ^首位
 $结尾
$ grep '^c.*e$' passwd #找c开头，e结尾的行


7.任意字符串 .* # .在[]外表示任意字符，*表示前面字符任意多个，加起来.*就是任意字符串了。
$ grep -P '^r.*' passwd #r开头，后面跟着任意字符
$ grep -P 'm.*c' passwd #m后面有c的行，默认贪婪匹配，匹配尽量后的c

如果想使用非贪婪匹配，找到最近的c就停止匹配，可以首尾加上分隔符\b 
$ grep -P '\bm.*c\b' passwd


8.贪婪匹配
更好的非贪婪匹配是量词后加上?
当"?"字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o?”将匹配所有“o”。

注：非贪婪只对量词有效果，如 * + {1，9} 等。
默认是贪婪模式；在量词后面直接加上一个问号？就是非贪婪模式。

$ grep -P 'm.*?c' passwd #从每行的m开始，找到第一个c停止
$ echo 12,23,24|grep -P '([0-9]\d{1,})' 
$ echo 12,23,24|grep -P '([0-9]\d{1,}?)' 

9.其他细节
\s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。
\S	匹配任何非空白字符。等价于[^ \f\n\r\t\v]。





========================================
awk(关键字:分析&处理) 一行一行的分析处理
----------------------------------------
1.定义与作用
mawk - pattern scanning and text processing language模式扫描与文本处理语言。
An AWK program is a sequence of pattern {action} pairs and user function definitions.

典型用途：使用AWK可以做很多任务，下面是其中一些
	文本处理
	输出格式化的文本报表
	执行算数运算
	执行字符串操作等等

2.工作流
要成为AWK编程专家，你需要先知道它的内部实现机制，AWK遵循了非常简单的工作流 - 读取，执行和重复，下图描述了AWK的工作流。
(1)BEGIN block: BEGIN {awk-commands} #可选
(2)Read a line from input stream
(3)Execute AWK commands on a line: /pattern/ {awk-commands}
(4)Repeat if it is not End of file,GOTO(2)
(5)END block: END {awk-commands} #可选

awk的处理流程是:
1) 读第一行, 将第一行资料填入变量 $0, $1... 等变量中
2) 依据条件限制, 执行动作
3) 接下来执行下一行



3.一般格式：$ awk 'pattern1{动作1}pattern2{动作2}' filename
	awk 也可以读取来自前一个指令的 standard input。
	相对于sed常常用于一整行处理, awk则比较倾向于一行当中分成数个"字段"(区域)来处理, 默认的分隔符是空格键或tab键

示例文件marks.txt
$ cat marks.txt
1)  Amit    Physics  80
2)  Rahul   Maths    90
3)  Shyam   Biology  87
4)  Kedar   English  85
5)  Hari    History  89

(1)可以用 $ awk '{print}' marks.txt 来代替cat命令，查看文件内容。

awk可以接受标准输入的数据，例如:$ last -n 5 | awk '{print $1 "\t" $3}'  #输入最后5次登陆，只显示用户名和ip。
这里大括号内$1"\t"$3 之间不加空格也可以, 不过最好还是加上个空格, 另外注意"\t"是有双引号的, 因为本身这些内容都在单引号内
$0 代表整行 $1代表第一个区域, 依此类推

#打印第3和4列，用制表符隔开:
$ awk '{print $3 "\t" $4}' marks.txt
Physics 80
Maths   90
Biology 87
English 85
History 89

所以, AWK一次处理是一行, 而一次中处理的最小单位是一个区域。

$ awk '/a/{print $0}' marks.txt 可以简化为
$ awk '/a/{print}' marks.txt 可以进一步简化为
$ awk '/a/' marks.txt 没有制定操作，就是默认打印匹配到的整行。
2)  Rahul   Maths    90
3)  Shyam   Biology  87
4)  Kedar   English  85
5)  Hari    History  89



(2)另外还有3个变量, 
	NF: 当前行的第几个字段(number of fields in the current record). 每个字段保存在$1, $2, ..., $NF中.  The built-in variable NF is set to the number of fields.
	NR 目前处理到第几行(current record number in the total input stream).
	FS 目前的分隔符(input record separator, initially = "\n").

	逻辑判断 > < >= <= == !== , 赋值直接使用=
	
例 $ cat /etc/passwd | awk '{FS=":"} $3<10 {print $1 "\t" $3}'
首先定义分隔符为:, 
然后判断, 注意看, 判断没有写在{}中, 
然后执行动作, 
FS=":"这是一个动作, 赋值动作, 不是一个判断, 所以写在{}中

例$ awk '/linux/ {print NR}' out.txt #将带有linux的行的行号打印出来, 注意//之间可以使用正则表达式
wangjl@ubt16:~/str$ cat out.txt
this is a linux system.
line2
Ubuntu is a release of linux.
wangjl@ubt16:~/str$ awk '/linux/ {print NR}' out.txt
1
3

(3)
BEGIN END , 给程序员一个初始化和收尾的工作, BEGIN之后列出的操作在{}内将在awk开始扫描输入之前执行, 而END{}内的操作, 将在扫描完输入文件后执行.

例：通过BEGIN给文本marks.txt添加表头
$ awk 'BEGIN{printf "Sr No\tName\tSub\tMarks\n"}{print}' marks.txt
Sr No   Name    Sub     Marks
1)  Amit    Physics  80
2)  Rahul   Maths    90
3)  Shyam   Biology  87
4)  Kedar   English  85
5)  Hari    History  89

例： prints all lines that start with an AWK identifier.打印开头符合identifier的行。
$ head /etc/passwd | awk 'BEGIN { identifier = "ro*t" } $0 ~ "^" identifier' /etc/passwd 
（r开头，后面若干个0，接着是t的）

(4)awk {}内, 可以使用 if else ,for(i=0;i<10;i++), i=1 while(i<NF)
可见, awk的很多用法都等同于C语言, 比如"\t" 分隔符, print的格式, if, while, for 等等。

例：计数文件中独特单词的个数。count the number of unique "real words".
1)把模式写入文件$ cat cmd.awk
    BEGIN { FS = "[^A-Za-z]+" }
    { for(i = 1 ; i <= NF ; i++)  word[$i] = "" }
    END { delete word[""]
          for ( i in word )  cnt++
          print cnt
    }

$ cat out.txt
this is a linux system.
line2
Ubuntu is a release of linux.

2)对文件out.txt使用以上规则计数
$ awk -f cmd.awk out.txt #-f表示从文件中读取pattern。
9

awk 是相当复杂的工具, 真正使用时, 再细看man awk吧. 




4.awk标准选项

-v 变量赋值选项
该选项将一个值赋予一个变量，它会在程序开始之前进行赋值。
$ awk -v name=Jimmy 'BEGIN{printf "Name = %s\n", name}'
Name=Jimmy




5.内置变量与自定义变量
(1)内置变量参考[$ man awk 的 7. Builtin-variables]
内置变量 FILENAME 表示当前文件名：
$ awk 'END {print FILENAME}' marks.txt
marks.txt


(2)
自定义变量统计含有a的行数：
$ awk '/a/{++cnt} END {print "Count=", cnt}' marks.txt
Count= 4

使用语句打印出来哪些行：
$ awk '/r/{++cnt; print} END {print "Count=", cnt}' marks.txt
4)  Kedar   English  85
5)  Hari    History  89
Count= 2



6.内置函数与自定义函数
打印超过18个字符的行












========================================
sed(关键字: 编辑) 以行为单位的文本编辑工具 
----------------------------------------
sed - stream editor for filtering and transforming text 用于过滤和转换文本的流编辑器。特色是该编辑器能用于pipeline中。

sed可以直接修改档案, 不过一般不推荐这么做, 可以分析 standard input

基本工作方式: sed [-nef] '[动作]' [输入文本]
	-n : 安静模式, 一般sed用法中, 来自stdin的数据一般会被列出到屏幕上, 如果使用-n参数后, 只有经过sed处理的那一行被列出来.
	-e : 多重编辑, 比如你同时又想删除某行, 又想改变其他行, 那么可以用 sed -e '1,5d' -e 's/abc/xxx/g' filename
	-f : 首先将 sed的动作写在一个档案内, 然后通过 sed -f scriptfile 就可以直接执行 scriptfile 内的sed动作。
	-i : 直接编辑, 这回就是真的改变文件中的内容了, 别的都只是改变显示. (不推荐使用)
	
动作:
	a 新增, a 后面可以接字符串, 而这个字符串会在新的一行出现. (下一行)
	c 取代, c 后面的字符串, 这些字符串可以取代 n1,n2之间的行
	d 删除, 后面不接任何东西
	i 插入, 后面的字符串, 会在上一行出现
	p 打印, 将选择的资料列出, 通常和 sed -n 一起运作 sed -n '3p' 只打印第3行
	s 取代, 类似vi中的取代, 1,20s/old/new/g

例： $ echo "this is a book" | sed 's/is/was/g'
thwas was a book

	[line-address]q 退出, 匹配到某行退出, 提高效率
	[line-address]r 匹配到的行读取某文件(注意是文件名) 例如: sed '1r qqq.txt' abc , 注意, 写入的文本是写在了第1行的后边, 也就是第2行
	[line-address]w file, 匹配到的行写入某文件  例如: sed -n '/m/w qqq' abc , 从abc中读取带m的行写到qqq文件中, 注意, 这个写入带有覆盖性.


举例:
sed '1d' abc 删除 abc 档案里的第一行, 注意, 这时会显示除了第一行之外的所有行, 因为第一行已经被删除了(实际文件并没有被删除,而只是显示的时候被删除了)

sed -n '1d' abc 什么内容也不显示, 因为经过sed处理的行, 是个删除操作, 所以不显示.

sed '2,$d' abc 删除abc中从第二行到最后一行所有的内容, 注意, $符号正则表达式中表示行末尾, 但是这里并没有说那行末尾, 就会指最后一行末尾, ^开头, 如果没有指定哪行开头, 那么就是第一行开头

sed '$d' abc 只删除了最后一行, 因为并没有指定是那行末尾, 就认为是最后一行末尾

sed '/test/d' abc 文件中所有带 test 的行, 全部删除

sed '/test/a RRRRRRR' abc 将 RRRRRRR 追加到所有的带 test 行的下一行 

sed '1,5c RRRRRRR' abc 从1到5行被 RRRRRRR 替换

sed '/test/c RRRRRRR' abc 将 RRRRRRR 替换所有带 test 的行, 当然, 这里也可以是通过行来进行替换, 比如 sed '1,5c RRRRRRR' abc







========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


