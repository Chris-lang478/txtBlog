linux文本处理

linux shell文本处理三大利器：
grep 查找
sed 行编辑器
awk 列文本处理工具
一行指令，轻松搞定。

========================================
学习资源
----------------------------------------
awk和sed简明教程：
	http://agetouch.blog.163.com/blog/static/228535090201732824532207/

AWK 简明教程: http://coolshell.cn/articles/9070.html
sed 简明教程: http://coolshell.cn/articles/9104.html
三十分钟学会AWK: https://segmentfault.com/a/1190000007338373


========================================
grep 查找与正则表达式
----------------------------------------
正则规则：http://blog.csdn.net/newthinker_wei/article/details/8219293

1.一般格式： grep 正则 fileName
比如： $ grep 'wangjl' /etc/passwd #查找并返回passwd文件中包含wangjl的行。


2.正则表达式分类：
1)基本的正则表达式（Basic Regular Expression 又叫 Basic RegEx  简称 BREs）
2)扩展的正则表达式 -E（Extended Regular Expression 又叫 Extended RegEx 简称 EREs）
3)Perl 的正则表达式 -P（Perl Regular Expression 又叫 Perl RegEx 简称 PREs）
 说明：只有掌握了正则表达式，才能全面地掌握 Linux 下的常用文本工具（例如：grep、egrep、GUN sed、 Awk 等） 的用法
注意：linux的正则支持有三种，其中perl兼容的是功能最强大的。
默认的是基本的正则，不支持数字元字符，但是加上-P指定Perl兼容的正则，就支持数字元字符了。

$ grep -P '\d' /etc/passwd #任何带数字的行
		\d: 任何数字 [0-9] grep默认不支持
		\D: 任何非数字[^0-9] grep默认不支持

3.正则表达式的数量词
正则表达式可能被以下重复修饰符中的一个修饰：
    ?      {0,1}The preceding item is optional and matched at most once.
    *      {0,}The preceding item will be matched zero or more times.
    +      {1,}The preceding item will be matched one or more times.
    {n}    The preceding item is matched exactly n times.
    {n,}   The preceding item is matched n or more times.
    {,m}   The  preceding  item  is matched at most m times.  This is a GNU extension.
    {n,m}  The preceding item is matched at least n  times,  but  not  more than m times.
比如：$ grep 'ro*t' /etc/passwd   # {0,}表示0个或多个o。


$ cd /etc
$ grep 'ro+t' passwd   #啥也没有
$ grep -P 'ro+t' passwd #使用Perl兼容的可以，{1,}
root:x:0:0:root:/root:/bin/bash
$ grep 'ro\+t' passwd #或者使用转义字符\，{1,}
root:x:0:0:root:/root:/bin/bash

4.正则的分组()
使用小括号()，默认需要加转义字符\(text\)
如果加入-P参数，则可以直接输入(text)

$ grep -P '(34)+' passwd #带有1个及以上34的行

[]表示范围，比如
	[0-9]表示任意一位数字，等价于\d
	[a-z]任意一个小写字母，
	[A-Z]任意大写字母，
	[a-zA-Z]任意字母
[]内的^表示否定。
$ grep -P "[0-9]{4,6}" passwd # 含4到6个数字的行
$ grep -P "[^0-9]" passwd #匹配含有非数字的行
$ grep -P "[^0-9a-zA-Z]" passwd #匹配含有非数字、非大小写字母的行


5.位置界定^$
 ^首位
 $结尾
$ grep '^c.*e$' passwd #找c开头，e结尾的行


6.任意字符串 .* # .在[]外表示任意字符，*表示前面字符任意多个，加起来.*就是任意字符串了。
$ grep -P '^r.*' passwd #r开头，后面跟着任意字符
$ grep -P 'm.*c' passwd #m后面有c的行，默认贪婪匹配，匹配尽量后的c

如果想使用非贪婪匹配，找到最近的c就停止匹配，可以首尾加上分隔符\b 
$ grep -P '\bm.*c\b' passwd


7.贪婪匹配
更好的非贪婪匹配是量词后加上?
当"?"字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o?”将匹配所有“o”。

注：非贪婪只对量词有效果，如 * + {1，9} 等。
默认是贪婪模式；在量词后面直接加上一个问号？就是非贪婪模式。

$ grep -P 'm.*?c' passwd #从每行的m开始，找到第一个c停止
$ echo 12,23,24|grep -P '([0-9]\d{1,})' 
$ echo 12,23,24|grep -P '([0-9]\d{1,}?)' 

8.其他细节
\s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。
\S	匹配任何非空白字符。等价于[^ \f\n\r\t\v]。



========================================
awk列处理
----------------------------------------













