csapp



========================================
怎么阅读 CSAPP(3e)?
----------------------------------------
1. 写作业

* 只需要几分钟。几乎不需要编程
** 20min; 测试代码、考试题
*** 1~2h。测试大量代码
**** 一个实验作业，需要大概 10 个小时


所有源码: https://csapp.cs.cmu.edu/
第二版: http://csapp.cs.cmu.edu/2e/home.html
最新的第三版pdf 目录: http://csapp.cs.cmu.edu/3e/pieces/preface3e.pdf
	第三版中文 775 页





2. 视角

Students should be introduced to computer systems from the perspective of a programmer, rather from the more traditional perspective of a system implementer. What does this mean?
Students should get a view of the complete system, comprising the hardware, operating system, compiler, and network.
Students learn best by developing and evaluating real programs that run on real machines.


第三版采用 x86-64 指令集，涉及 Interl Core i7 的虚拟地址结构、SSD 磁盘、IPv6等新技术内容。

第三版更加强调并发，增加了较大篇幅讨论信号处理与主程序间并发时的正确性保障。

基于 x86 的linux操作系统，采用C语言编程。这个组合经受住了时间的考验。


本书会探究编译器、计算机体系结构、操作系统、嵌入式系统、网络互联和网络安全等高级话题。


ISC: 
	(10周课程)硬件、操作系统、编译系统对应用程序的性能和正确性的影响。
	系统级I/O、网络编程、并发编程
	(其他书中找) 守护进程(daemon)、终端控制、Unix IPC(进程间通信)
		异步信号安全、协议无关的网络编程。



3. 共12个章节
	1 系统漫游
	2 数据表示
	3 机器语言
	4 处理器体系结构
	5 代码优化
	6 存储器层次结构
	7 链接
	8 异常控制流
	9 虚拟内存
	10 系统级I/O 
	11 网络编程 
	12 并发编程



4. 本书的实验

(1) 数据实验
仅适用位运算，是按简单的逻辑运算和算术运算。

(2) 二进制炸弹实验
提供一个目标文件。
运行时提示: 用户输入6个不同的字符串，如果任何一个不准确，炸弹会“爆炸”，打印出一条错误信息。
练习适用调试器，找到这6个字符。


(3) 缓冲区溢出实验
缓冲区溢出攻击的代码的危险性。

(4) 体系结构实验
- 修改处理器的HCL描述
- 增加新的指令
- 修改分支预测策略
- 增加、删除胖录路径和寄存器端口

(5) 性能试验
优化应用程序的核心函数(比如卷积积分或矩阵转置)的性能。
高速缓存的特性。


(6) cache 实验。
编写通用高速缓存模拟器，并优化小型矩阵转置的核心函数，
类似性能实验。
以最小化对模拟的高速缓存的不命中次数。
使用 Valgrind 为矩阵转置核心函数生成真实的地址访问记录。

(7) shell 实验
实现带有作业控制的 Unix shell 程序，包括 Ctrl+C和 ctrl+Z按键，fg、bg和jobs命令。
第一次接触并发，了解 Unix 的进程控制、信号和信号处理。


(8) malloc 实验。
实现自己的 malloc、free 和 realloc(可选)版本。
清晰的理解数据的布局和组织，并评估时间和空间效率的各种权衡和折中。

(9) 代理实验。
实现一个位于浏览器和万维网其他部分之间的并行web代理。
理解web客户端和服务器主题，练习概念：字节顺序、文件I/O、进程控制、信号、信号处理、内存映射、套接字和并发。





========================================
1 系统漫游
----------------------------------------

1. 信息就是位+上下文

8 bit 位 == 1byte 字节。
每个字节都有一个整数值，对应于某些字符。
每个字节对应 ascii 中的一个char字符。

由 ascii 字符构成的文件称为 文本文件，其他称为 二进制文件。

不同上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。


(1) C语言
起源于贝尔实验室。
ANSI C: K&R 书，全书 261 页。

C语言是系统级编程的首选，也非常适用于应用级程序的编写。
C语言的指针是很多程序员困惑和程序错误的原因。
C语言缺乏对非常有用的抽象的显式支持，例如 类、对象和异常。
C++和Java解决了这些问题。



2. 程序被翻译为不同的格式

(1) gcc 编译的过程分为 4个阶段

$ cat hello.c 
#include<stdio.h>
int main(){
	printf("hello, world!\n");
	return 0;
}

$ gcc -o hello hello.c 


编译系统（compilation system）
	预处理器(cpp): 处理#开头的命令，结果得到.i文件； 
	编译器(ccl): 包含汇编语言程序，把C指令翻译成汇编 .s文件。汇编为不同高级语言的不同编译器提供了通用的输出语言。
	汇编器(as): 把.s汇编语言翻译为机器语言指令 .o文件，二进制文件。
	链接器(ld): 把 printf.o 和 hello.o 合并为可执行文件(.out), 可被加载到内存中，由系统执行。





3. 了解编译系统如何工作的有什么用？

- 优化程序性能
- 理解链接时出现的错误
- 避免安全漏洞





4. 处理器读并解释存储在内存中的指令

$ ./hello 
hello, world!
$ 

如果该命令行的第一个单词不是一个内置的 shell 命令，那么shell将会假设这是一个可执行文件的名字，它将加载并运行这个文件。

(1) 系统的硬件组成
总线: 按字长(word) 传输内容，64位是8字节
I/O设备
主存
处理器：程序计数器(PC)、算术/逻辑单元(ALU)、寄存器文件(register file)
	CPU在指令的要求下可能会执行的操作:
		加载：从主存复制一个字节或一个字到寄存器，覆盖寄存器原来的内容
		存储: 寄存器赋值一个字节或一个字到主存，覆盖掉原来的内容
		操作: 把2个寄存器的内容复制到ALU，ALU对2个字做算术运算，并将结果放到一个寄存器中，覆盖掉原来的内容
		跳转: 从指令本身中抽取一个字，复制到程序计数器(PC)中，覆盖掉PC中原来的值


(2) 运行 hello world 程序






5. 高速缓存至关重要


6. 存储设备形成层次结构


7. OS 管理硬件

(1) 操作系统位于 硬件 和 应用程序之间

应用程序
OS 操作系统
硬件: 处理器、主存、I/O设备

(2) OS的基本功能

- 防止硬件被失控的应用程序滥用
- 向应用程序提供简单一致的机制来控制复杂而通常大不相同的低级硬件设备。

(3) OS 通过几个抽象概念来实现这2个功能
文件: 是对 IO设备的抽象表示
虚拟内存: 是对主存和磁盘IO设备的抽象表示
进程则是对处理器、主存和IO设备的抽象表示。



(4) Unix 的很多思想来自于 Multics 系统，只不过在一个更小、更简单的程序包中实现
	层次文件系统
	作为用户级进程的shell概念

后来厂商太多，互不兼容， IEEE 开始努力标准化 Unix 的开发，命名为 Posix 标准。
	Unix 系统调用的C语言接口
	shell程序和工具
	线程及网络编程
现在已经基本没有差异了。




(5) 几个概念
1) 进程 

假象：系统只运行 hello 程序，它独占的使用硬件。
	这个假象是通过进程的概念来实现的。

进程是 操作系统对一个正在运行的程序的一种抽象。
	一个系统可以同时运行多个进程，而每个进程都好像在独占地使用硬件。

并发运行，一个进程的指令和另一个进程的指令是交错执行的。

无论是单核还是多核系统，一个CPU看上去都像是在并发的执行多个进程，这是通过处理器的进程间切换来实现的。
	操作系统实现这种交错执行的机制称为 上下文切换。



内核 kernel: OS 代码常驻内存的部分。
	内核不是一个独立的进程。
	它是系统管理全部进程所用代码和数据结构的集合。

应用程序需要OS的某些操作时，比如读写文件，他就会执行一条特殊的系统调用(system call)指令，将控制权传递给内核。
然后内核执行被请求的操作并返回应用程序。

实现进程这个抽象概念需要低级硬件和OS之间的紧密合作。
	第八章将揭示这项工作的原理，及应用程序如何创建和控制他们的进程。


2) 线程 

现代OS中，一个进程实际上可以有多个称为 线程 的执行单元组成，
	每个线程都运行在 进程的上下文中，并共享同样的代码和全局数据。


由于网络服务器中对并行处理的需求，线程称为越来越重要的编程模型，因为
	1 多线程之间比多进程之间更容易共享数据。
	2 线程一般比进程更高效。
	当多处理器可用的时候，多线程也是一种使得程序可以运行的更快的方法。第12章，并发概念，及如何写线程化的程序。


3) 虚拟内存
虚拟内存是一个抽象概念，他为每个进程提供了一个假象，即每个进程都在独占的使用主存。

每个进程看到的内存都是一致的，称为 虚拟地址空间。

不1-13 进程的虚拟地址空间
	图中地址是从下往上增大的
	[用户代码不可见内存] 地址空间的最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样的。
	最底部区域存放用户进程定义的代码和数据。
	
从低地址开始，看虚拟地址空间
	- 程序代码和数据: 代码和数据区是直接按照可执行文件的内容初始化的。第7章研究链接和加载，会有地址空间的内容。
	- 堆: 代码和数据区后紧随着是 运行时堆。当调用 malloc 和 free 这些C标准库函数时，堆可以在运行时动态的扩展和收缩。第9章管理虚拟内存，研究堆。
	- 共享库: 大约地址空间的中间部分，放C标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。第7章介绍动态链接时，学习共享库如何工作。
	- 栈: 位于用户虚拟地址空间顶部的是 用户栈，编译器用它来实现函数调用。每调用一个函数，栈就会增长；从一个函数返回，栈就会收缩。第3章学习编译器是如何使用栈的。
	- 内核虚拟内存: 地址空间顶部的区域是为内核保留的。不允许应用程序读写该区域的内容或者直接调用内核代码定义的函数。


虚拟内存的运作需要硬件和OS的机密复杂的交互，包括对处理器生成的每个地址的硬件翻译。
	基本思想是：把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。第9章解释虚拟内存，及对现代OS的重要性。



4) 文件 

文件就是字节序列，仅此而已。
每个IO设备，包括磁盘、键盘、显示器、网络，都可以看成是文件。



(6) linux系统

起点是 Minix。
通过与 GNU 项目的力量结合，Linux 项目发展成一个完整的、符合 Posix 标准的 Unix 操作系统的版本，包括内核和所有支撑的基础设置。
Linux从手持设备到大型计算机，都得到了应用。








8. 系统之间利用网络通信

网络可以视为一个IO设备。

当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是本地磁盘驱动器。

系统也可以读取其他机器发送来的数据，并复制到自己的主存。


网络应用：电子邮件、即时通信、万维网、FTP和telnet等。





9. 重要主题

(1) Amdahl 定律

要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

一个有趣的特殊情况：60%的系统能够优化到不花时间的程度，整个系统的净加速比仍然只有 1/0.4=2.5X.



(2) 表示相对性能
比例 Told/Tnew, Told表示原始系统所需时间，Tnew为修改后的系统所需时间。
如果有所改进，比值大于1。用后缀X表示比例，比如 2.2X，读作 2.2倍。

更传统的是用百分比法，这种方法适用于变化小的情况，但其定义是模糊的。
	应该等于 100*(Told - Tnew)/ Tnew，还是 100*(Told - Tnew)/Told 还是其他值？
	他对较大的变化也没有太大意义。
	与简单的说性能提升 2.2X 相比，“性能提升了120%”更难理解。





(3) 并发和并行

计算机的2个动力：做的更多、做的更快。

当CPU同时做更多事情时，这两个因素都会改进。

并发(concurrency)是一个通用的概念，指一个同时具有多个活动的系统。
并行(parallelism)指的是用并发来使一个系统运行的更快。

并行可以在计算机的多个抽象层次上运用。

1) 线程级并发
通过在不同进程间快速切换来实现的，这种并发是 模拟 出来的。

随着 多核 + 超线程(hyperthreading) 的出现， => 多处理器系统变得普遍了。

图1-17 4核CPU，每个核都有自己的 L1 和L2 高速缓存。
	其中L1高速缓存分为2个部分: 一个保存最近取到的指令，一个存放数据。
	这些核共享更高层次的高速缓存(L3)，以及到主存的接口。


超线程，也叫 同时多线程(simultaneous multi-threading)，是一项允许一个CPU执行多个控制流的技术。
	Interl Core i7 处理器可以让每个核执行2个线程，所以4核的系统实际上可以并行执行8个线程。


多好处理器从2个方面提高系统新能：
	1. 减少了执行多个任务时模拟并发的需求。
	2. 可以并行让应用程序运行的更快
	第12章 并发。



2) 指令级并行
在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为 指令级并发。

一个时钟周期执行一条指令。超过1条指令，则称为超标量(super scalar)处理器。


3) 单指令、多数据并行: SIMD并行
多是为了提高处理影像、声音和视频数据应用的执行速度。





(4) 计算机系统中抽象的重要性

抽象 的使用是计算机科学中最为重要的概念之一。
	例如，为一组函数规定一个简单的应用程序接口API就是一个很好的编程习惯，程序员无需了解它的内部细节便可以工作。
	不同的编程语言提供了不同形式和等级的抽象支持，例如 Java类的声明和C语言的函数原型。


已经介绍的几个抽象：
	文件，是IO设备的抽象
	虚拟内存，是主存+IO设备的抽象
	指令集架构，提供了对实际处理器硬件的抽象。
		使用这个抽象，机器代码程序表现的就好像运行在一个一次只执行一条指令的处理器上。
		底层的硬件远比抽象描述的要复杂精细，它并行地执行多条指令，但又总是与那个简单有序的模型保持一致。
		只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同的开销和性能。
	虚拟机，是IO设备+主存+处理器+操作系统的抽象。

计算机系统中一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性。


学习OS时，我们介绍了三个抽象：
	文件是对IO设备的抽象
	虚拟内存是对程序存储器的抽象
	进程是对正在运行的程序的抽象。
	新增：虚拟机，提供对整个计算机的抽象，包括操作系统、处理器、程序。
		虚拟机的思想是IBM在20世纪60年代提出来的，但最近才显示出其管理计算机方式上的优势。
		因为一些计算机必须能够运行为不同操作系统或同一OS的不同版本设计的程序。






========================================
第一部分 程序结构和执行
----------------------------------------
计算机由处理器和存储器子系统组成。





========================================
2 信息的表示和处理
----------------------------------------
1.
无符号(unsigned)编码基于传统的二进制表示法，大于或等于0的数字。
补码(two's-complement)编码是表示有符号整数的最常见的方式：正或负。
浮点数(floating-point) 编码是表示实数的科学计数法的以2为基数的版本。

当结果太大不能表示时，某些运算就会溢出（overflow）

$ cat a1.c 
#include<stdio.h>
int main(){
	int a=200*300*400*500;
	printf("a=%d\n", a);
}

$ gcc a1.c 
a1.c: In function ‘main’:
a1.c:3:19: warning: integer overflow in expression of type ‘int’ results in ‘-884901888’
...

$ ./a.out 
a=-884901888



浮点数过小也不行。
整数的表示虽然有范围，但是是精确表示。
浮点数的表示范围更大，但是只是近似表示。

$ cat a2.c 
#include<stdio.h>
int main(){
	double a1=(3.14+1e20)-1e20;
	double a2=3.14+(1e20-1e20);
	printf("a1=%f\n", a1);
	printf("a2=%f\n", a2);
}

$ gcc a2.c
$ ./a.out 
a1=0.000000
a2=3.140000



这是因为 double 的最值
$ cat a3.c 
#include<stdio.h>
#include <float.h>
int main(){
	//DBL_MAX：double型的最大值
	//DBL_MIN：double型的最小值
	double m1=DBL_MAX;
	double m2=DBL_MIN;
	printf("size(double) = %ld\n", sizeof(double));
	printf("max=%le, addr:%p\n", m1, &m1);
	printf("min=%le, addr:%p\n", m2, &m2);
}

$ gcc a3.c
$ ./a.out 
size(double) = 8
max=1.797693e+308, addr:0x7ffc05877878
min=2.225074e-308, addr:0x7ffc05877880


$ cat a3.cpp 
#include<iostream>
#include <cfloat>
using namespace std;
int main(){
	double m1=DBL_MAX;
	double m2=DBL_MIN;
	cout << "size(double) = " << sizeof(double) << endl;
	cout << "max=" << m1 << ", addr:" << &m1 << endl;;
	cout << "min=" << m2 << ", addr:" << &m2 << endl;
}

$ g++ a3.cpp 
$ ./a.out 
size(double) = 8
max=1.79769e+308, addr:0x7ffdad776f28
min=2.22507e-308, addr:0x7ffdad776f30



(1). 信息存储
二进制与16进制的转换：4个二进制位 对应 一个16进制位

当值x是2的非负整数n次幂时，即x=2^n，则x写成二进制就是 1后面跟着n个0。
	16进制0 代表4个二进制0
	当n=i+4j, 0<=i<=3 的形式时，x写成16进制数就是 1(i=0), 2(i=1), 4(i=2) 或者 8(i=3)，后面跟着j个16进制的0.
		比如 2048=2^11，我们有 n=11=3+4*2，从而得到其16进制表示为 0x800



(2). 字长

对于一个字长为w的机器，其虚拟地址的范围为 0 ~ 2^w -1，程序最多访问 2^w 个字节，也即是支持的最大内存大小。

32位的系统，最多支持4k兆字节(4GB)。
64位的系统，最多支持 2^64/1024**3 = 17179869184 GB = 17179869184/1024**3 EB=16 EB = 1.84e19 bit
16

> 2**32/1024**3
4

> 2**64/1024**3
17179869184

> 2**64/1e19
1.8446744073709551


$ gcc -m32 prog.c #可以在32位机器运行，也能在 64 位机器运行
$ gcc -m64 prog.c #只能在 64 位机器运行




(3). 寻址

对象的地址为所使用字节中最小的地址。

最低有效字节在前面(地址低位)的，称为 小端法(little endian), 常用的 intel PC 就是。
	最常用的OS: Android 和 iOS 却只能运行于小端模式。
	小端逻辑合理：数字的低位放在内存的低位，数字的高位放在内存的高位。
最高有效字节在前面(地址高位)的，称为 大端法(big endian)
	IBM和Oracle的大多数机器使用大端模式。
	大端符合书写习惯，从地址低位到高位，依次是数字的高位到低位，和书写顺序一致。


一个机器不用关心这个问题。
多个变量之间也不用关心。
大小端是一个变量内的排列方式。

但是
i) 不同类型机器通过网络传输二进制数据时，字里的字节成了反序。
	避免方法：网络应用的编写必须遵守已建立的关于字节顺序的规则，发送前转为网络标准，接收后转为内部表示。
ii) 阅读整数数据的字节序列时，字节顺序也很重要。
	检查机器级程序时，看16进制。
ii) 编写规避正常的类型系统的程序时。
强制类型转换(cast) 或 联合(union) 允许一种数据类型引用一个对象，而这种数据类型与创建这个对象时定义的数据类型不同。
	这对高级编程来说非常有用，甚至是必需的。



2) 测试程序
#include<stdio.h>

// csapp P32 字节表示的示例
typedef unsigned char *byte_ptr;
// 使用 typedef 给数据命名，能极大的提高代码的可读性。因为深度嵌套的类型声明很难读懂。


void show_bytes(byte_ptr start, size_t len){
    size_t i;
    for(i=0; i<len; i++){
        printf(" %.2x", start[i]); //todo??
    }
    printf("\n");
}

//显示int的二进制：从地址低位到高位
void show_int(int x){
    show_bytes( (byte_ptr) &x, sizeof(int) );
}

//显示float的二进制：
void show_float(float x){
    show_bytes( (byte_ptr) &x, sizeof(float) );
}

void show_pointer(void *x){
    show_bytes( (byte_ptr) &x, sizeof(void *) );
}

//测试 
void test_show_bytes(int val){
    int ival = val;
    float fval=(float)val;
    int *pval=&ival;
    show_int(val); //39 30 00 00
    show_float(fval);
    show_pointer(pval);
}

int main(){
    int y=12345;
    printf("y=%d, 0x%X\n", y, y); //y=12345, 0x3039
    test_show_bytes(y);

    return 0;
}
/*
y=12345, 0x3039
 39 30 00 00
 00 e4 40 46
 98 a6 4a 7e ff 7f 00 00
数字的最低位 39 最先打印出来，说明该机器是小端法。
指针与众不同，是8位的。
*/

Tips: $ man asciii # 显示一张 ASCII 字符码的表



(4) 表示字符串 

#include<stdio.h>
#include<string.h>
void show_bytes(unsigned char * start, size_t len){
    size_t i;
    for(i=0; i<len; i++){
        printf(" %.2x", start[i]); //todo??
    }
    printf("\n");
}

void test1(){
	char p[] ={'1', '2', '3', '4', '5', '\0'};
    printf("%s\n", p);
    show_bytes( (unsigned char *) p, sizeof(p) ); //获取数组的长度 = 字符串长度+1
}

void test2(){
	const char *p ="12345";
    printf("%s\n", p);
    show_bytes( (unsigned char *) p, strlen(p)+1 );//实际占用长度 = 字符串长度 + 1
}

void test3(){
	const char *p ="abcdef";
    printf("%s\n", p);
    show_bytes( (unsigned char *) p, strlen(p)+1 );
}

int main(){
    test1();
	test2();
	test3();
	
	return 0;
}

输出:
12345
 31 32 33 34 35 00
12345
 31 32 33 34 35 00
abcdef
 61 62 63 64 65 66 00

注意：使用 ASCII 码作为字符码的任何系统都能得到相同的结果，与字节顺序和字节大小无关。
因此，文本数据比二进制数据具有更强的平台独立性。



(5) 表示代码

不同机器类型使用不同且不兼容的指令和编码方式。

二进制代码是不兼容的。


(6) 布尔代数简介

~ 表示 NOT
& 表示 AND
| 表示 OR
^ 表示 Exclusive-or 相同为0，不同为1


位向量掩码，有选择的屏蔽一些信号，其中某一位上为1时，表示信号i是有效的；而0表示屏蔽该信号。
	这个掩码表示的就是设置为 有效信号 的集合。






















========================================
logs && cur: P73/775
----------------------------------------
使用程序库: 
	Yi /data/wangjl/project/linux_C
	https://github.com/miostudio/linux_C

logs:
2022.10.17 P61 ->P73








========================================
// todo chapter
----------------------------------------
	3 机器语言
	4 处理器体系结构
	5 代码优化
	6 存储器层次结构




========================================
第二部分 在系统上运行程序
----------------------------------------





========================================
7 链接
----------------------------------------

	8 异常控制流
	9 虚拟内存


========================================
第三部分 程序间的交互和通信
----------------------------------------


========================================
10 系统级I/O 
----------------------------------------

========================================
11 网络编程 
----------------------------------------


========================================
12 并发编程
----------------------------------------








========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------






========================================
----------------------------------------


