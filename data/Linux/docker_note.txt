docker笔记

http://www.imooc.com/video/14623

下面开始本教程。
本教程能让你了解docker最基本的概念和操作。更细节的还需要看文档。

准备：
你需要熟悉基本的linux命令，同时有一个用于练习的用root权限的linux系统。可以是：
1.一个能登陆联网的ubuntu16.04服务器的终端。终端可以使linux命令行、windows下的git bash、windows下的putty等。服务器可以是虚拟机、物理主机、云主机。
2.或者 一台安装有ubuntu1604的联网电脑。


这个网页版测试挺好玩的 https://labs.play-with-docker.com/

docker image 仓库:
	https://quay.io/
	https://hub.docker.com/


========================================
docker 权威书籍
----------------------------------------
https://github.com/eduleboss/the-best-docker-books


一、《Docker: Up & Running》2015
https://www.oreilly.com/library/view/docker-up/9781491917565/

1. Learn how Docker simplifies dependency management and deployment workflow for your applications
简化依赖和部署流程

2. Start working with Docker images, containers, and command line tools
镜像、容器、命令行工具

3. Use practical techniques to deploy and test Docker-based Linux containers in production
生产环境下部署和测试docker容器

4. Debug containers by understanding their composition and internal processes
通过理解他们的构成和内部过程，调试容器

5. Deploy production containers at scale inside your data center or cloud environment
批量部署生产容器，在数据中心或云环境

6. Explore advanced Docker topics, including deployment tools, networking, orchestration, security, and configuration
docker高级话题： 部署工具，网络，编排，安全性和配置。




========================================
日常使用docker
----------------------------------------
1.常用语句
(1). 列举主机上的镜像 $ docker images

(2). 当你运行一个容器时，你可以这样指定一个带标签的镜像：
$ docker run -t -i ubuntu:14.04 /bin/bash
如果你想运行一个ubuntu 12.04镜像，你可以使用
$ docker run -t -i ubuntu:12.04 /bin/bash
不指定tag则默认使用 ubuntu:latest 镜像

(3). 获得一个新的镜像 $ docker pull centos

(4). 查找镜像 $ docker search sinatra
docker公司提供或建立、验证和支持的。这类镜像可以用一个单词识别，比如 ubuntu
用户创建的镜像，有创建者的用户名前缀识，比如 training/sinatra 

查询标签
其实有更简单的v1 API，这个输出信息比较少，结果可以直接肉眼看。
$ curl -L -s https://registry.hub.docker.com/v1/repositories/biocontainers/vcftools/tags
[{"layer": "", "name": "0.1.14"}, {"layer": "", "name": "0.1.15"}, {"layer": "", "name": "v0.1.14_cv1"}, {"layer": "", "name": "v0.1.14_cv2"}, {"layer": "", "name": "v0.1.15_cv1"}, {"layer": "", "name": "v0.1.15_cv2"}, {"layer": "", "name": "v0.1.16-1-deb_cv1"}]
==> chrome 浏览器 F12 console:
> t2=[...]
> for(var i=0; i<t2.length; i++){console.log(t2[i].name)}
结果
v0.1.16-1-deb_cv1
v0.1.14_cv2
v0.1.15_cv2
v0.1.14_cv1
v0.1.15_cv1
0.1.14
0.1.15


(5). 拉取镜像 $ docker pull training/sinatra
默认是下载 training/sinatra:latest 
最好是指定标签。


(6). 运行镜像 $ docker run -t -i training/sinatra /bin/bash
root@a8cb6ce02d85:/#


(7)从主机中移除镜像  $ docker rmi training/sinatra
注意：从host中移除镜像，请确认没有基于该镜像的容器处于激活状态。







2.启动故障排查
https://askubuntu.com/questions/977961/unit-docker-service-could-not-be-found
报错
$ sudo docker ps
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?

查2点：
1)该sock文件是否是docker组？不是的话设置是。
srw-rw---- 1 root docker 0 Sep 12 23:13 /var/run/docker.sock

2)当前用户是否为docker组？不是的话加进去
$ id
uid=1001(wangjl) gid=1001(wangjl) groups=1001(wangjl),1004(docker)

$ sudo groupadd docker #添加docker用户组
$ sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中
Adding user wangjl to group docker

$ newgrp docker #更新用户组
$ groups #or $ id


3) 重启一下服务
$ sudo snap services
Service         Startup  Current   Notes
docker.dockerd  enabled  inactive  -

$ sudo snap start docker
Started.

$ sudo snap services
Service         Startup  Current  Notes
docker.dockerd  enabled  active   -






3.被断电重启工作站后，怎么恢复docker服务？
$ docker ps -a
$ docker start 72d
$ docker start b06

然后进入docker内部，启动apache 服务
$ sudo docker exec -it 72d bash
# service apache2 restart 
# exit



========================================
|-- docker中使用bioconductor的R包  
----------------------------------------
R包的镜像资源：
https://hub.docker.com/r/bioconductor/
http://bioconductor.org/help/docker/


下载镜像（耗时步骤）
$ docker pull dawneve/bioconductor_core2
也可以下载官方镜像
下载的镜像可以改名字，比如nginx名字太长，改简单点。
# docker tag hub.c.163.com/library/nginx dawneve/nginx


查看镜像
$ docker images



##
To open a Bash shell on the container:
$ docker run -ti dawneve/bioconductor_core2 bash
Note: The docker run command is very powerful and versatile. For full documentation, type docker run --help or visit the help page.


To run R from the command line:
$ docker run -ti dawneve/bioconductor_core2 R


一般需要做个地址映射：
$ docker run -ti -v /home/wangjl/:/home/wangjl/ dawneve/bioconductor_core2 bash





##
To run RStudio Server:
$ docker run -it -p 8080:8787 -v /home/wangjl/docker_R:/home/wangjl/ -d dawneve/bioconductor_core2
然后使用主机的IP进行访问 http://IP:8080
-p端口映射  -p 实体机器:镜像内
-v文件映射  -v 实体机器:镜像内




##
进入已经运行的docker容器：
先查找容器ID
$ docker ps
CONTAINER ID        IMAGE                        COMMAND             CREATED             STATUS              PORTS               NAMES
7639e26e324a        dawneve/bioconductor_core2   "bash"              4 hours ago         Up 4 hours          8787/tcp            lucid_poincare

$ docker exec -it 7639e26e324a /bin/bash
或者简写为
$ docker exec -it 7639e bash #id可以用前几个字符，只要不产生歧义

直接 ctrl + d 或者直接输入 exit 退出即可。





##
here are two ways to modify these images:
	1. Making changes in a running container and then committing them using the docker commit command.
	2. Using a Dockerfile to declare the changes you want to make.
The second way is the recommended way. Both ways are documented here.
https://docs.docker.com/get-started/




========================================
|-- 安装docker版的wordpress (做文件和端口映射)
----------------------------------------
https://hub.docker.com/r/library/wordpress/


1.拉取镜像 
$ sudo docker pull wordpress:latest



2.准备数据库

登录上述docker版的mysql数据库
G:\xampp\mysql\bin> mysql -h y.biomooc.com -P 7070 -u root -p

新建 wordpress数据库；
> create database wordpress;

如果你想允许用户wp从ip为任何的主机连接到mysql服务器，并使用123456作为密码
> GRANT ALL PRIVILEGES ON *.* TO 'wp'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;
> flush privileges;



3.启动wordpress容器
$ sudo docker run -it --name some-wordpress -e WORDPRESS_DB_HOST=y.biomooc.com:7070 -e WORDPRESS_DB_USER=root -e WORDPRESS_DB_PASSWORD=123456 -p 8080:80 -d wordpress
秒退。

$ sudo docker ps #发现这些容器都刚运行就退出了
$ sudo docker ps -a|grep Exited #查询容器ID
批量删除Docker中已停止的容器
$ sudo docker ps -a|grep Exited | cut -d" " -f 1 | xargs sudo docker rm

最后加一个长期执行的命令就可以了，bash：
$ sudo docker run -it --name some-wordpress -e WORDPRESS_DB_HOST=y.biomooc.com:7070 -e WORDPRESS_DB_USER=root -e WORDPRESS_DB_PASSWORD=123456 -p 8080:80 -d wordpress bash

进入docker内部
$ sudo docker exec -it 716c bash
启动apache服务器
# service apache2 restart 

# pwd
/var/www/html
# rm -rf *
# cp -r /usr/src/wordpress/* . #复制wordpress文件到www目录

浏览器打开 y.biomooc.com:8080

填写数据库信息：
DB: wordpress
usr: root 
psw: xxx
host: 192.168.2.120:7070
table_prefix:wp_





进入docker内部，使用head/tail/cat命令修改 wp-config.php中数据库一行，改为：
define('DB_HOST', 'p:192.168.2.120:7070');

可以正常访问web页面。











************
* 以下部分可以不看
************
4.排错
(1)使用p解决频繁链接失败的问题。
https://stackoverflow.com/questions/3210270/php-mysqli-connection-randomly-fails-with-cannot-assign-requested-address

<?php
$link = mysqli_connect('p:192.168.2.120:7070', 'wp', '123456');
if (!$link) {
die('Could not connect: ' . mysqli_error());
}
echo 'Connected successfully';
mysqli_close($link);
?>



(2)ERR_CONNECTION_RESET 连接已重置
https://blog.csdn.net/y472360651/article/details/79127285

尝试修改 C:\windows\system32\drivers\etc\hosts

加上服务器ip 域名，例如 
74.125.39.99 chrome.google.com
然后，访问就没问题了！





5.设置wordpress的尝试过程
进入docker内部
$ sudo docker exec -it 0e027 bash

(1)# find / -name "*wordpress*" 2>/dev/null
/usr/src/wordpress
...

(2)# find / -name "*apache*" 2>/dev/null
/etc/apache2
/etc/apache2/apache2.conf
...


(3)# service apache2 status #原来是apache服务没开
# service apache2 restart

再次访问y.biomooc.com:8080 ，提示
Forbidden
You don't have permission to access / on this server.
Apache/2.4.25 (Debian) Server at y.biomooc.com Port 8080

然后用cat命令新建一个/var/www/html/index.html文件，访问y.biomooc.com:8080显示该index.html文件。


(4)docker系统竟然没有文本编辑器，也安装不上去，有博客说需要更新系统
https://www.cnblogs.com/zr520/p/6083436.html

# apt-get update #这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。等更新完毕以后再敲命令：apt-get install vim
总是更新失败。
没办法，用head和cat命令编辑文件吧。。。

文件在本机读写出现问题，所以不能文件映射！//todo




========================================
谁在用docker? 怎么用？
----------------------------------------
1.docker是什么？
docker打包了代码及其运行环境，像虚拟机但更轻量化、更方便移植。
可用于可重复性研究，持续集成等。
免安装，拉取过来即可运行。解决了“在你电脑上能运行，在我的电脑上为什么运行不来啊？”的痛点。


2.有paper已经在推荐docker： 
Nature Biotechnology 2017 
Reproducibility of computational workflows is automated using continuous analysis: 
https://www.nature.com/articles/nbt.3780
"Docker, a container technology akin to virtual machines"

3.bioconductor发布的一直有docker镜像。
Bioconductor is also available as an AMI (Amazon Machine Image) and a series of Docker images.

http://www.bioconductor.org/help/docker/


4.我的docker主页: https://hub.docker.com/u/dawneve/



========================================
|-- docker简介、目的、原理、关键词
----------------------------------------
1.
docker作用
http://www.imooc.com/video/14609
docker在京东、淘宝、腾讯都有大规模应用。
docker和git的命令很相似。


2.
什么是docker

2010 dotCloud PAAS
2013 docker开源
2014.6 Docker1.0
2014.7 C轮 $4 000万
2015.4 D轮 $9 500万
至今 Docker 1.13

docker是一个装应用和环境的容器。构建、迁移、运行。
https://www.docker.com/
官网介绍: Docker is the world’s leading software container platform. 

download: https://download.docker.com/linux/ubuntu/dists/
代码托管在github： https://github.com/docker/docker-ce

跨平台，支持win,linux,Mac.


3.
理解docker

docker思想体现在docker的logo上。
docker思想：
	集装箱;
	标准化(运输方式/存储方式/API接口);
	隔离(比虚拟机更快，数秒启动)

docker解决的问题：
	我本地运行没问题啊?!: 打包环境和代码。
	系统好卡，哪个哥们写死循环了?!: docker是隔离的，只影响自己。
	双11来了，服务器撑不住了?!: 1台扩展成上万台很容易。

docker的原理: 单独的带有namespace的进程，该进程直接在物理机上跑；


4.docker是未来吗？Container War in 2016, docker VS Rocket:  
	docker注册了自己的商标，使用该名词都很麻烦。
	spec (specification:规范) 都是自己定义的。趋向于封闭。  
	docker将要做成容器类的github。  
	openStock?


5.总结
集装箱、标准化、隔离
镜像、容器、仓库(build ship run)
docker命令pull,build,run,stop,restart,exec...



========================================
|-- 走进docker的hello world
----------------------------------------
1.
docker的三个核心词汇： build(集装箱),ship(码头),run(运行的镜像就是容器).

docker镜像(image): 就是一系列文件，包括应用和环境。
	保存到本地了。linux下的联合文件系统(unifss)
	文件分层，底层镜像image都是只读的，顶层container才是可写的。
	构建镜像的目的，是为了方便在其他机器上运行。
docker容器(container):如果需要修改底层数据，则先拷贝到顶层，修改。而查找都是从上到下的，所以以后找到的都是修改过的最新部分。
	容器是可以修改的，而镜像不能修改，决定着镜像是稳定的。
docker仓库(repo): 先把镜像传到仓库，再在其他机器从仓库拉这个镜像。
	hub.docker.com，下载着很慢。
		浏览镜像： https://hub.docker.com/explore/
		我的仓库：https://hub.docker.com/r/dawneve/
	国内镜像： 
		c.163.com 网易蜂巢找不到镜像中心的问题：
			需要登陆，然后输入地址：https://c.163.com/hub#/m/home/
		https://www.docker-cn.com/registry-mirror
		https://www.zhihu.com/question/55135855
		http://mirrors.aliyun.com/
#


2. 实例
(1)ubuntu国内的安装，docker本身在ubuntu下开发的。
检查内核版本
# uname -r
4.10.0-28-generic

(2)系统自带安装，可能不是最新版本
#apt-get install docker 

最新版的安装
#curl -s https://get.docker.com | sh 

(3)安装好后查看版本
#docker version
Client:
 Version:      17.06.0-ce
 API version:  1.30
 Go version:   go1.8.3
 Git commit:   02c1d87
 Built:        Fri Jun 23 21:23:31 2017
 OS/Arch:      linux/amd64

Server:
 Version:      17.06.0-ce
 API version:  1.30 (minimum version 1.12)
 Go version:   go1.8.3
 Git commit:   02c1d87
 Built:        Fri Jun 23 21:19:04 2017
 OS/Arch:      linux/amd64
 Experimental: false

 
(4)拉取第一个docker镜像
#docker pull[option] NAME[:TAG] 拉取镜像
# docker pull hello-world
# docker pull dawneve/ping:latest
latest: Pulling from dawneve/ping
271134aeb542: Already exists
bb8612de0ef8: Pull complete
Digest: sha256:4ce09a01b4193e90d1314b470fc30e670ed619de5b5deb6d148294f10ae76446
Status: Downloaded newer image for dawneve/ping:latest


(5)#docker images [options] [repository][:tag] 查看本地多少镜像
# docker images
REPOSITORY       TAG     IMAGE ID	    CREATED	     SIZE
ubuntu	   latest  14f60031763d	2 weeks ago	 120MB
busybox	  latest  efe10ee6727f	2 weeks ago	 1.13MB
bioconductor/release_core2   latest  75b1bf6ef48b	3 weeks ago	 1.71GB
hello-world      latest  1815c82652c0	7 weeks ago	 1.84kB
learn/tutorial   latest  a7876479f1aa	4 years ago	 128MB

dawneve/ping	latest	5bd062e39404	17 months ago	139MB


(6)运行第一个docker容器
# docker run [options] IMAGE[:TAG] [COMMAND][ARG...]
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon. |客户端连接daemon
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.|daemon本地找不到，就从docker仓库拉取
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading. |daemon用该镜像创建容器，产生该文本
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.|daemon把信息输出给客户端，也就是那你的终端。

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

参数说明：
 -i : –interactive，交互界面。
 -t : –tty，伪终端界面。


Share images, automate workflows, and more with a free Docker ID:
 https://cloud.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/engine/userguide/


还可以在容器内运行命令
# docker run dawneve/ping
hi
# docker run dawneve/ping ping baidu.com #测试ping命令
PING baidu.com (123.125.114.144) 56(84) bytes of data.
64 bytes from 123.125.114.144: icmp_req=1 ttl=54 time=5.51 ms

# docker run dawneve/ping uname -r #打印容器内系统的内核版本号
4.10.0-28-generic



========================================
|-- 推送与拉取镜像
----------------------------------------

1.
想推送需要有一个hub.docker.com账号。先去注册。


$ sudo apt install gnupg2 pass 先安装包，否则登录失败。
## https://stackoverflow.com/questions/50151833/cannot-login-to-docker-account/50569553


# docker login -u dawneve -p yourPassWord #登陆

# docker ps #查看容器
# docker commit 36279 dawneve/tomcat #提交一个新镜像

# docker images #查看镜像
root@ubt16:/home/wangjl# docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
dawneve/bioconductor_core2   latest              5b8c5f497247        4 days ago          1.78GB
dawneve/jpress               latest              1159f08345b2        4 days ago          313MB
dawneve/tomcat               latest              b226d7ee3462        5 days ago          292MB
dawneve/nginx                latest              46102226f2fd        3 months ago        109MB
dawneve/mysql                latest              9e64176cd8a2        3 months ago        407MB


# 推送到docker hub 
# docker push dawneve/mysql
The push refers to a repository [docker.io/dawneve/mysql]

打开 hub.docker.com/u/dawneve 即可看到刚推送的镜像。






2.
拉取镜像不需要账号，只需要网络好即可。

其他地方想用该镜像，只需要拉取即可：
# docker pull dawneve/mysql 
而
# docker run -it xxx 时，如果本地找不到xxx镜像，则自动到hub.docker.com上拉取并运行该镜像。





3.当执行push或pull操作时，会为镜像生成摘要。
$ docker images --digests | head  #查看摘要
create, run, rmi以及Dockerfile的FROM镜像参考中使用摘要。比如按照摘要pull下来镜像
$ docker pull ouruser/sinatra@sha256:cbbf2f9a99b47fc460d422812b6a5adff7dfee951d8fa2e4a98caa0382cfbdbf



========================================
|-- 保存docker镜像到文件，及文件导入镜像的方法
----------------------------------------
1. 镜像的迁移，一个方法是传到仓库(公共或本地)，另一个是使用文件。

使用Docker save和Docker load命令来存储和载入镜像。




2. 保存镜像为文件

$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
rocker/rstudio      latest              9e22c8cd092b        11 days ago         1.95GB

命令 docker save -o 要保存的文件名  要保存的镜像
$ docker save -o rstudio.docker.tar  9e22c8cd092b

$ ls -lth
-rw------- 1 wangjl wangjl 1.9G Mar  3 14:19 rstudio.docker.tar


(2) 更多测试

1)或者生成gz压缩
$ docker save -o rstudio.docker.tar.gz  rocker/rstudio:latest
$ docker save -o rstudio.docker2.tar.gz  9e22c8cd092b

$ ls -lt
total 8122792
-rw------- 1 wangjl wangjl 1967693824 Mar  3 14:24 rstudio.docker2.tar.gz
-rw------- 1 wangjl wangjl 1967694848 Mar  3 14:21 rstudio.docker.tar.gz
-rw------- 1 wangjl wangjl 1967693824 Mar  3 14:19 rstudio.docker.tar

结论: 使用tag的比使用sha1的略大，而文件名是否gz结尾对大小没影响。


2) 尝试解压
$ tar zxvf rstudio.docker2.tar.gz 
gzip: stdin: not in gzip format
tar: Child returned status 1
tar: Error is not recoverable: exiting now
不能解压，说明不是个压缩文件。

# 尝试解包
$ tar -xvf rstudio.docker2.tar.gz 
解压到本文件夹内一堆数字开头的文件夹，说明就是一个tar文件，那就不要加gz结尾。

不过可以再压缩成gz文件
$ gzip -c rstudio.docker.tar > rstudio.docker0.tar.gz #-c保留原始文件

# 这下体积小了一半。
-rw-rw-r-- 1 wangjl wangjl 531M Mar  3 14:32 rstudio.docker0.tar.gz




3) 最佳实践: 
- 生成的tar，压缩后得到gz文件，方便保存和传输。
- 使用tag备份，而不是image id。
$ docker save 9e22c8cd092b | gzip -c > rstudio.docker3.tar.gz  #导入时丢失tag信息
$ docker save rocker/rstudio:latest | gzip -c > rstudio.docker4.tar.gz  #最佳。带tag信息。

-rw-rw-r-- 1 wangjl wangjl 531M Mar  3 14:40 rstudio.docker3.tar.gz
-rw-rw-r-- 1 wangjl wangjl 531M Mar  3 14:59 rstudio.docker4.tar.gz

结论：docker save 的tar文件就可以gz压缩后备份到硬盘，或者复制到其他主机，解压后直接导入了。





3. 从文件载入镜像

docker load --input 文件
或者
docker load < 文件名
此时会导入镜像以及相关的元数据信息等。


首先使用SSH工具将文件上传到另一台服务器。

如果压缩过，则解压
$ gunzip -c rstudio.docker3.tar.gz > rstudio.docker3.tar

-rw-rw-r-- 1 wangjl wangjl 1967693824 Mar  3 14:44 rstudio.docker3.tar


############
我在本机操作的，所以先备份原来的镜像，然后删掉老镜像
$ docker tag rocker/rstudio:latest rocker/rstudio:old
$ docker rmi rocker/rstudio:latest
Untagged: rocker/rstudio:latest
$ docker images # 查看已经删掉了 rocker/rstudio      latest              9e22c8cd092b        11 days ago         1.95GB
############

然后通过命令载入镜像：
$ docker load < rstudio.docker3.tar
Loaded image ID: sha256:9e22c8cd092b6289d0765e08b682e2517cb7cef579baa871eec2362c9e43960d

docker images 没有发现新的镜像。主要是备份镜像的id是不变的。

如果彻底删除掉同id的image，再导入
$ docker images -a
<none>              <none>              9e22c8cd092b        11 days ago         1.95GB

$ 改名字
$ docker tag 9e22c8cd092b dawneve/rstudio
$ docker images




(2) 使用tag备份的文件导入呢？
$ docker load --input rstudio.docker.tar.gz #这个是直接导出的伪gz文件，本质是tar文件。
Loaded image: rocker/rstudio:latest

$ docker images
rocker/rstudio      latest              9e22c8cd092b        11 days ago         1.95GB

结论：看来使用tag备份最好！虽然略大了一点。






========================================
|-- docker中运行Nginx服务、修改docker镜像名字
----------------------------------------
(1)实践前奏：
	持久运行的容器
	前台挂起&后台运行
	进入容器内部

(2)复习命令
docker images 查看本地镜像。
docker pull 拉取镜像。
docker run 运行镜像

(3)找到并下载nginx镜像
# docker pull hub.c.163.com/library/nginx:latest

(4)查看本地镜像 
# docker images #又多了一行镜像信息
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hub.c.163.com/library/nginx   latest              46102226f2fd        3 months ago        109MB

(5)前台运行镜像
# docker run hub.c.163.com/library/nginx
发现没有任何反应。

查看后台运行的容器
新开一个终端，输入#docker ps
# docker ps
CONTAINER ID        IMAGE                         COMMAND                  CREATED              STATUS              PORTS               NAMES
3c2c46733af3        hub.c.163.com/library/nginx   "nginx -g 'daemon ..."   About a minute ago   Up About a minute   80/tcp              cranky_aryabhata
表明nginx确实在运行。

在第一个终端ctrl+C终止掉nginx后，再次docker ps查看，发现没有结果。

说明nginx最好在后台运行。

(6)后台运行容器
查看帮助文档 docker run --help
发现  -d, --detach   Run container in background and print container ID
于是，这样运行nginx容器：

# docker run -d hub.c.163.com/library/nginx
9319a08b6fd22e470c95cd80997409568f7c3b0bdf95281ab29c07208123e131
#
# docker ps
CONTAINER ID        IMAGE                         COMMAND                  CREATED             STATUS              PORTS               NAMES
9319a08b6fd2        hub.c.163.com/library/nginx   "nginx -g 'daemon ..."   5 seconds ago       Up 4 seconds        80/tcp              nostalgic_morse
root@ubt16:/home/wangjl#

发现容器id是一样的。

(7)进入容器内部 
#docker exec --help
Usage:  docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
Run a command in a running container 在一个运行的容器内运行一条命令。
Options:
  -d, --detach               Detached mode: run command in the background
      --detach-keys string   Override the key sequence for detaching a container
  -e, --env list             Set environment variables
      --help                 Print usage
  -i, --interactive交互         Keep STDIN open even if not attached
      --privileged           Give extended privileges to the command
  -t, --tty 伪终端                  Allocate a pseudo-TTY
  -u, --user string          Username or UID (format: <name|uid>[:<group|gid>])
#docker exec 9319a08b6fd2 ls
# docker exec 9319a08b6fd2 service nginx status
nginx is running.

如果想长时间待在容器内部，则可以使用-it参数的如下命令：
root@ubt16:/home/wangjl# docker exec -it 9319a bash
root@9319a08b6fd2:/# ls #注意用户名已经变了。

查找nginx位置
root@9319a08b6fd2:~# which nginx
/usr/sbin/nginx

查看nginx服务是否运行
root@9319a08b6fd2:/# ps -ef
bash: ps: command not found
root@9319a08b6fd2:/# service nginx status
[ ok ] nginx is running.

退出容器# exit 

(8)停止镜像
# docker stop 931
931
# docker ps #已经没有运行的容器了。


(9)重新运行一个停止的容器/启动一个已经停止的容器实例
1) docker ps -a #找到停止的容器的id
2) docker start cea58c #重新运行该容器

docker ps 可以查看运行状态的容器。



(10)修改docker镜像名字
refer:https://stackoverflow.com/questions/25211198/docker-how-to-change-repository-name-or-rename-image
nginx名字太长，改简单点。
# docker tag hub.c.163.com/library/nginx dawneve/nginx
# docker images
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
hello-world                   latest              1815c82652c0        7 weeks ago         1.84kB
dawneve/nginx                 latest              46102226f2fd        3 months ago        109MB
hub.c.163.com/library/nginx   latest              46102226f2fd        3 months ago        109MB





========================================
|-- docker的网络和端口映射-p参数
----------------------------------------
(1)docker网络
	pid namespace用来隔离进程用的，
	network namespace用来隔离网络的。
	网络类型：bridge有独立IP，host模式和主机一样，none时没有网络通信。
	端口映射: ech0是主机的网卡。端口映射是对bridge模式来说的。
		host模式时容器直接连接主机网卡；
		bridge模式时，容器虚拟网卡eth0与docker0网桥连接，网桥和主机eth0连；

$ ip addr
3: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:e1:d7:48:56 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:e1ff:fed7:4856/64 scope link 
       valid_lft forever preferred_lft forever
这是 docker 自己虚拟出来的网卡。


(2)查找端口映射的命令参数
# docker run --help  #参数太多，用port过滤一下
# docker run --help | grep port
      --expose list         Expose a port or a range of ports
      --health-retries int  Consecutive failures needed to report unhealthy
  -p, --publish list        Publish a container's port(s) to the host 开容器的一个端口到主机
  -P, --publish-all         Publish all exposed ports to random ports 容器所有端口到主机随机端口
都试试吧。

(3)尝试-p端口映射
root@ubt16:~# docker run -d -p 8080:80 dawneve/nginx # -p 主机端口:容器端口
a43468841f4280139b021ec320377a3d232b8e3c9a5c085c59b0c0e58d5a4814
root@ubt16:~# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
a43468841f42        dawneve/nginx       "nginx -g 'daemon ..."   15 seconds ago      Up 14 seconds       0.0.0.0:8080->80/tcp   mystifying_murdock

查看端口，发现主机已经监听8080端口。
root@ubt16:~# netstat -na|grep 8080
tcp6       0      0 :::8080                 :::*                    LISTEN

在浏览器中输入主机IP(ubuntu下查ip用ifconfig命令)加上8080端口号，可以访问容器中的nginx服务了。
http://172.16.112.86:8080/
Welcome to nginx!

If you see this page, the nginx web server is successfully installed and working. Further configuration is required.

For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.

Thank you for using nginx.

停止docker容器
# docker stop a43 
再次访问http://172.16.112.86:8080/，已经不能访问了。

(4)尝试-P端口映射
root@ubt16:~# docker run -d -P dawneve/nginx
245a25cc79ed2c3bd00d17a0509c7c51cf8989e4c9da2a69143a30bed86b2676
root@ubt16:~# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
245a25cc79ed        dawneve/nginx       "nginx -g 'daemon ..."   4 seconds ago       Up 3 seconds        0.0.0.0:32768->80/tcp   romantic_colden
#可见，docker随机在主机开一个32768映射到容器的80端口。

访问 http://172.16.112.86:32768/ ，可以看到nginx欢迎页面。




(5) 启动一个 tomcat 服务
$ docker pull tomcat:8.5.41 
$ docker run -d -p 81:8080 --name tom2 tomcat:8.5.41
使用浏览器查看，网页正常显示: http://192.168.2.120:81/

查看日志
$ docker container logs tom2
## Apache Tomcat/10.0.11

进入容器内部
$ docker exec -it tom2 bash
root@8b4b9bb40009:/usr/local/tomcat# 
# cd webapps/ROOT/
# mv index.jsp index.jsp2
# echo 'hello' >index.html
再看网页 http://192.168.2.120:81/ 显示 hello。
说明修改生效了。




========================================
|-- 运行和使用 docker版的mysql(文件映射-v)
----------------------------------------
1. 运行docker版的mysql
https://c.163.com/hub#/m/repository/?repoId=2955
# docker pull hub.c.163.com/library/mysql:latest #下载

查看网易页面上的帮助
Starting a MySQL instance is simple:
$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag
... where some-mysql is the name you want to assign to your container, my-secret-pw is the password to be set for the MySQL root user and tag is the tag specifying the MySQL version you want. See the list above for relevant tags.
-e是指定环境变量

# docker run --name some-mysql3 -e MYSQL_ROOT_PASSWORD=123456 -d hub.c.163.com/library/mysql:latest

# docker ps #最后的NAMES和设定的一样some-mysql3。
CONTAINER ID        IMAGE                                COMMAND                  CREATED             STATUS              PORTS                    NAMES
00df8c0d6559        hub.c.163.com/library/mysql:latest   "docker-entrypoint..."   13 seconds ago      Up 11 seconds       3306/tcp                 some-mysql3
f3a05abb2f2e        dawneve/jpress                       "catalina.sh run"        27 minutes ago      Up 27 minutes       0.0.0.0:8888->8080/tcp   sharp_bassi
root@ubt16:/home/wangjl/Documents#

#docker stop 00d #关掉mysql，做端口映射

# docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d hub.c.163.com/library/mysql:latest
c130260481b50c03880ee034d6dafd01ca1cb72298c08e260ccb7016bf018a46

忘了创建数据库了，关掉，重启
# docker stop c1
# docker run -p 3306:3306 -e MYSQL_DATABASE=jpress_db -e MYSQL_ROOT_PASSWORD=123456 -d hub.c.163.com/library/mysql:latest

# docker run -p 3306:3306 -e MYSQL_DATABASE=jpress_db -e MYSQL_ROOT_PASSWORD=123456 -d hub.c.163.com/library/mysql:latest
2ff32e902b5f01710f947eba7900511b5695cae793b55a4ab7698a592928237e
# docker ps
CONTAINER ID        IMAGE                                COMMAND                  CREATED             STATUS              PORTS                    NAMES
2ff32e902b5f        hub.c.163.com/library/mysql:latest   "docker-entrypoint..."   3 seconds ago       Up 2 seconds        0.0.0.0:3306->3306/tcp   nostalgic_jennings
f3a05abb2f2e        dawneve/jpress                       "catalina.sh run"        39 minutes ago      Up 39 minutes       0.0.0.0:8888->8080/tcp   sharp_bassi

#netstat -na|grep 3306 # 端口正常
tcp6       0      0 :::3306                 :::*                    LISTEN






2. 在windows上练习数据库。

1)启动ubuntu上docker中的数据库
$ sudo docker run -p 7070:3306 -d -it -e MYSQL_ROOT_PASSWORD=123456 dawneve/mysql
ee96cc19c63f5247d327b4d0010b8d0583f75a93cb1188a576339c65506e0064

解释:
 -p 是做端口映射，把主机的7070端口映射到docker上的3306.
 -d 后台运行 
 -it 进入容器内部
 -e 传入环境参数
 最后返回sha1码



2)windows下登陆数据库：
G:\xampp\mysql\bin>mysql -h y.biomooc.com -P 7070 -u root -p
解释：
 -h 是host名
 -P是指定port
 -u是mysql用户名
 -p是回车后输入密码


新建数据库wang，新建表user。
MySQL [(none)]> create database wang;
Query OK, 1 row affected (0.60 sec)

> use wang;
Database changed
> \s
...
> create table user(
    id int(4) not null primary key auto_increment,
    name char(20) not null,
    sex int(4) not null default '0',
    degree double(16,2));
Query OK, 0 rows affected (0.06 sec)

> show tables;
> desc user;

> insert into user values(1,'Tom',1,96.45),(2,'Joan',1,82.99), (3,'Wang',0, 96.59);
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0

> select * from user;
+----+--- ---+-----+- -------+
| id | name | sex | degree |
+----+--- ---+-----+- -------+
|  1 | Tom  |   1 |  96.45 |
|  2 | Joan |   1 |  82.99 |
|  3 | Wang |   0 |  96.59 |
+----+--- ---+-----+-- ------+
3 rows in set (0.03 sec)
重复n次如下语句，造数据。没特殊要求就重复1次好了。
> insert user(name,sex,degree) select name,sex,degree from user;


3)在ubuntu上重启该docker，则数据被重置，想保存数据，就需要做目录映射，把docker中的读写保存到ubuntu主机上。


在ubuntu上查看运行的docker的编号
$ sudo docker ps
CONTAINER ID        IMAGE
ee96cc19c63f        dawneve/mysql
进入docker文件内部，查看mysql文件：/opt/mysql_data  
$ sudo docker exec -it ee96 bash
root@ee96cc19c63f:/# find . -name "*wang*" | grep wang
./var/lib/mysql/wang
root@ee96cc19c63f:/var/lib/mysql/wang# ls -lth
total 112K
-rw-r----- 1 mysql mysql  96K Sep  6 08:36 user.ibd #2建立表格，插入数据，该文件增大。
-rw-r----- 1 mysql mysql 8.5K Sep  6 08:36 user.frm #2建立表格
-rw-r----- 1 mysql mysql   65 Sep  6 08:26 db.opt #1只有数据库时




4) docker cp命令可以实现docker容器内外文件的复制。
详情本页的专题。

$ docker cp outer.html ed7ee9:/var/www/html/  #外部文件复制到docker容器内
$ docker cp ed7ee90e50de:/var/www/html/index.html . #容器内文件复制到外部




5) 做文件映射(-v 主机目录:docker地址)吧
$ sudo docker stop ee96 
然后刚才创建的数据库数据全部消失了。

$ sudo docker run -p 7070:3306 -d -it -e MYSQL_ROOT_PASSWORD=123456 -v /home/wangjl/dockerFile:/var/lib/mysql dawneve/mysql
3d08b2ab56277e32765d41e128dfa60b5cb1b8ffbf5ce371af5768d541818f14





6) 然后登陆mysql创建表格。同上述步骤2);
进入docker：
$ sudo docker exec -it 3d08 bash
docker内部能看到数据库文件：
root@3d08b2ab5627:/# cd /var/lib/mysql
root@3d08b2ab5627:/var/lib/mysql# ls -lth

在ubuntu主机上 /home/wangjl/dockerFile 也有很多数据库文件，这就是docker使用的文件。
这些文件保存在ubuntu主机上，不会随着docker的关闭或重启而消失。

我们重启 docker。
$ sudo docker restart 3d08
数据库中数据确实还在。




========================================
|-- 文件映射 -v参数
----------------------------------------
如果容器停止，则所有运行期间的数据就丢失了。
为了保存mysql运行期间的数据，可以把数据库文件映射到宿主主机上。



可以支持多个文件夹映射，映射之间用分号隔开，或者使用多个-v参数
$ docker run -p8080:80 -v /encoder/:/encoder/;/pyt_models/:/pyt_models/;/dataset/:/dataset/ -it actit_mount:latest

$ docker run -p8080:80 \ 
  -v $(pwd)/encoder/:/Docker/encoder/ \
  -v $(pwd)/pyt_models/:/Docker/pyt_models/ \
  -v $(pwd)/dataset/:/Docker/dataset/ \
  -it actit_mount:latest
#



(1)做文件映射 
# docker run -e MYSQL_ROOT_PASSWORD=123456 -d -p3306:3306 -v /opt/mysql_data:/var/lib/mysql hub.c.163.com/library/mysql

ubuntu下mysql的文件夹位置和权限：http://blog.csdn.net/wang794686714/article/details/39273385

(2)创建数据库
可以用宿主机ip登陆mysql。

mysql> create database wjl;
Query OK, 1 row affected (0.33 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| wjl                |
+--------------------+
5 rows in set (0.01 sec)

发现在宿主机器上多了个wjl文件夹
root@ubt16:/opt/mysql_data# ls -tl
total 188480
drwxr-x--- 2 vboxadd vboxsf     4096 8月   6 06:16 wjl
root@ubt16:/opt/mysql_data# ls wjl
db.opt

(3)创建数据表
mysql> use wjl;
Database changed
mysql> create table goods(id int(10), name varchar(20));
Query OK, 0 rows affected (0.07 sec)

mysql> show tables;
+---------------+
| Tables_in_wjl |
+---------------+
| goods         |
+---------------+
1 row in set (0.00 sec)

在宿主机器上可见：
root@ubt16:/opt/mysql_data# ls wjl
db.opt  goods.frm  goods.ibd

(4)插入数据
mysql> insert into goods values(1,'pen');
Query OK, 1 row affected (0.01 sec)

mysql> insert into goods values(2,'apple');
Query OK, 1 row affected (0.04 sec)

mysql> select * from goods;
+------+-------+
| id   | name  |
+------+-------+
|    1 | pen   |
|    2 | apple |
+------+-------+
2 rows in set (0.72 sec)

宿主机
# ls wjl
db.opt  goods.frm  goods.ibd
root@ubt16:/opt/mysql_data# ls wjl -lt
total 112
-rw-r----- 1 vboxadd vboxsf 98304 8月   6 06:21 goods.ibd
-rw-r----- 1 vboxadd vboxsf  8586 8月   6 06:19 goods.frm
-rw-r----- 1 vboxadd vboxsf    65 8月   6 06:16 db.opt

添加一条记录
mysql> insert into goods values(3,'pie');
Query OK, 1 row affected (0.17 sec)

文件大小没变?!
root@ubt16:/opt/mysql_data/wjl# ls -lt
total 112
-rw-r----- 1 vboxadd vboxsf 98304 8月   6 06:24 goods.ibd
-rw-r----- 1 vboxadd vboxsf  8586 8月   6 06:19 goods.frm
-rw-r----- 1 vboxadd vboxsf    65 8月   6 06:16 db.opt



mysql文件简介
	ibdata是innodb引擎使用的
	如果是使用myisam引擎 则于ibdata无关  只是用frm myi myd
#



========================================
|-- 文件挂载 --mount type=bind,source=/tmp/eedqjde6,target=/TfavYp
----------------------------------------
1. 正常写法
$ docker \
    run \
    -it \
    --mount=type=bind,source=/tmp/eedqjde6,target=/TfavYp \
    --mount=type=bind,source=/tmp/3yyw1atf,target=/tmp \
    --mount=type=bind,source=/home/wangjl/test/cwl_test/Hello.java,target=/var/lib/cwl/stg0b1649c3-91bc-411e-b5d8-523aaab07ffc/Hello.java,readonly \
    --workdir=/TfavYp \
    --read-only=true \
    --user=1001:1001 \
    --rm \
    --cidfile=/tmp/bmuzwb7g/20210910161633-044329.cid \
    --env=TMPDIR=/tmp \
    --env=HOME=/TfavYp \
    openjdk:9.0.1-11-slim bash


另一种写法，效果一样
--mount type=bind,source=/data,target=/data


(2) -v 和 --mount 的区别
https://docs.docker.com/storage/bind-mounts/

1) --mount 支持挂载文件。
2) 如果宿主机上不存在某个文件夹， -v 会自动创建该文件夹，而 --mount 则直接报错。

If you use -v or --volume to bind-mount a file or directory that does not yet exist on the Docker host, -v creates the endpoint for you. It is always created as a directory.

If you use --mount to bind-mount a file or directory that does not yet exist on the Docker host, Docker does not automatically create it for you, but generates an error.

https://stackoverflow.com/questions/61316142/invalid-mount-config-for-type-bind-bind-mount-source-path-does-not-exist-ho






========================================
|-- 【debug】 docker 挂载报错: bind source path does not exist: 不要用 snap 装 docker，用 apt-get
----------------------------------------
1. 配置
$ docker --version
Docker version 20.10.8, build 3967b7d

## Ubuntu 18.04.5 LTS (GNU/Linux 4.15.0-147-generic x86_64) 

https://github.com/common-workflow-language/common-workflow-language/issues/927

(2) 其他同样的报错

https://stackoverflow.com/questions/64775609/docker-bind-source-path-does-not-exist-even-though-it-does
I fixed it by mounting the drive in a mount point in /mnt/. 
me: 可能临时文件夹不能是软链接？实验证明，可以。


https://stackoverflow.com/questions/48971065/getting-invalid-mount-config-for-type-bind-bind-source-path-does-not-exist-in

https://github.com/docker-archive/for-aws/issues/74
https://github.com/moby/moby/issues/34237
https://github.com/pterodactyl/panel/issues/1381
https://github.com/docker/docker.github.io/issues/4709


https://stackoverflow.com/questions/61316142/invalid-mount-config-for-type-bind-bind-mount-source-path-does-not-exist-ho
use -v instead of --mount





2. 我的报错 
(1) biomooc.com/linux/cwl_guide.html
$ cwl-runner arguments.cwl arguments-job.yml

INFO /home/wangjl/.local/bin/cwl-runner 3.1.20210825140344
INFO Resolved 'arguments.cwl' to 'file:///home/wangjl/test/cwl_test/arguments.cwl'
INFO [job arguments.cwl] /tmp/h6zf06_5$ docker \
    run \
    -i \
    --mount=type=bind,source=/tmp/h6zf06_5,target=/nxObrk \
    --mount=type=bind,source=/tmp/p23ipdh9,target=/tmp \
    --mount=type=bind,source=/home/wangjl/test/cwl_test/Hello.java,target=/var/lib/cwl/stg72616065-58f2-4277-a941-1a51cc29d7f0/Hello.java,readonly \
    --workdir=/nxObrk \
    --read-only=true \
    --user=1001:1001 \
    --rm \
    --cidfile=/tmp/8e1ay904/20210911105237-468410.cid \
    --env=TMPDIR=/tmp \
    --env=HOME=/nxObrk \
    openjdk:9.0.1-11-slim \
    javac \
    -d \
    /nxObrk \
    /var/lib/cwl/stg72616065-58f2-4277-a941-1a51cc29d7f0/Hello.java
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /tmp/h6zf06_5. 
See 'docker run --help'.
这里报错：说这个文件不存在。

^CTraceback (most recent call last):
  File "/home/wangjl/.local/bin/cwl-runner", line 11, in <module>
    sys.exit(main())
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/main.py", line 1249, in main
    tool, initialized_job_order_object, runtimeContext, logger=_logger
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/executors.py", line 59, in __call__
    return self.execute(process, job_order_object, runtime_context, logger)
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/executors.py", line 148, in execute
    self.run_jobs(process, job_order_object, logger, runtime_context)
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/executors.py", line 255, in run_jobs
    job.run(runtime_context)
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/job.py", line 852, in run
    self._execute(runtime, env, runtimeContext, monitor_function)
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/job.py", line 343, in _execute
    default_stderr=runtimeContext.default_stderr,
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/job.py", line 992, in _job_popen
    monitor_function(sproc)
  File "/home/wangjl/.local/lib/python3.6/site-packages/cwltool/job.py", line 869, in docker_monitor
    time.sleep(1)
KeyboardInterrupt



(2) 测试表明，该文件夹存在，但是 docker 不认
$ ls /tmp/h6zf06_5
$ 
$ ls /tmp/h6zf06_56
ls: cannot access '/tmp/h6zf06_56': No such file or directory

$ docker run -it \
    --mount type=bind,source=/tmp/h6zf06_5,target=/eMzMyO \
    --rm \
    --env=TMPDIR=/tmp \
    openjdk:9.0.1-11-slim bash
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /tmp/h6zf06_5.
See 'docker run --help'.

$ docker run -it \
    --mount type=bind,source=/tmp,target=/eMzMyO \
    --rm \
    openjdk:9.0.1-11-slim bash #OK

# 难道是权限问题？
$ ls /tmp/ -lth | grep h6z
drwx------ 2 wangjl  wangjl  4.0K Sep 11 10:52 h6zf06_5 #ok

$ ls -lth / | head
drwxrwxrwt 138 root root 228K Sep 11 14:21 tmp #not OK



(3) 【不要轻易尝试这个】而使用-v 挂载则可以。可以后再用 --mount 也可以了
$ docker run -it \
    -v /tmp/h6zf06_5:/eMzMyO \
    --rm \
    --env=TMPDIR=/tmp \
    openjdk:9.0.1-11-slim bash
root@272c68f92492:/# ls /eMzMyO/

但是可以后 docker 内外的文件不能共享，ls都看不到！






3. 更多测试 
结论：只有自己的家目录可以，其他目录不行，指向其他目录的软链接也不行。

2)测试更多目录呢？
$ docker run -it --mount type=bind,source=/home/wangjl/test/cwl_test,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok
$ docker run -it --mount type=bind,source=/home/wangjl/test/,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok
$ docker run -it --mount type=bind,source=/home/wangjl/,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok
$ docker run -it --mount type=bind,source=/home/,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok
$ docker run -it --mount type=bind,source=/,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok 

$ docker run -it     --mount type=bind,source=/tmp/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #ok
$ docker run -it     --mount type=bind,source=/var/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #ok

$ df -h | grep sd
/dev/sda2       234G  202G   20G  92% /
/dev/sda1       511M  6.5M  505M   2% /boot/efi
/dev/sdb        3.6T  2.5T  922G  74% /data

目前 / 的正常，试试 /boot/
$ docker run -it     --mount type=bind,source=/boot/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #ok
为什么只有 /data/ 不行呢？
$ docker run -it     --mount type=bind,source=/data/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /data/.
See 'docker run --help'.

检查权限
/home/wangjl/test/cwl_test
drwxrwxr-x 4 wangjl wangjl 4.0K Sep 11 11:45 cwl_test
drwxrwxr-x 10 wangjl wangjl 4.0K Sep  9 16:53 test
drwxr-xr-x 60 wangjl  wangjl   68K Sep 11 14:23 wangjl

drwxr-xr-x   9 root root 4.0K Sep  3 15:36 home
drwxr-xr-x  10 root root 4.0K Sep  3 16:37 data # no, but same as /home


3)测试一个包含软链接的目录呢? /data/ 下都不行
$ docker run -it --mount type=bind,source=/home/wangjl/data/test/testCWL,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash
报错：docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /home/wangjl/data/test/testCWL.
See 'docker run --help'.

$ ls -lth /home/wangjl/
lrwxrwxrwx  1 wangjl wangjl   12 Nov 12  2020 data -> /data/wangjl

使用绝对路径本身呢？也报错
$ docker run -it --mount type=bind,source=/data/wangjl,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /data/wangjl.
See 'docker run --help'.

4) 另一个软链接呢？
lrwxrwxrwx  1 wangjl wangjl   19 Aug 19  2020 index -> /var/www/html/index

$ docker run -it     --mount type=bind,source=/var/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #ok
$ docker run -it     --mount type=bind,source=/var/www/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #no

drwxr-xr-x  15 root root 4.0K Jul 20  2018 var     #ok 
drwxr-xr-x  3 root root     4.0K Jul 20  2018 www #no

$ docker run -it --mount type=bind,source=/var/www/html/index,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /var/www/html/index.
See 'docker run --help'.

$ docker run -it --mount type=bind,source=/home/wangjl/index,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /home/wangjl/index.
See 'docker run --help'.


指向自己的 软链接呢？
$ cd ~
$ docker run -it     --mount type=bind,source=/home/wangjl/test,target=/eMzMyO --rm openjdk:9.0.1-11-slim bash #ok
$ ln -s /home/wangjl/test/ newLinks
lrwxrwxrwx  1 wangjl wangjl   18 Sep 11 14:31 newLinks -> /home/wangjl/test/

$ docker run -it     --mount type=bind,source=/home/wangjl/newLinks,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #ok
奇怪了，这个软链接也可以！
$ rm newLinks

$ cd ~/data
$ ln -s /home/wangjl/test/ /data/wangjl/newLinks
$ docker run -it     --mount type=bind,source=/data/wangjl/newLinks,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #No
只要在 /data 的都不行。



4. 难道是说有些磁盘格式不适合？
$ df -h | grep sd
/dev/sda1              511M  5.7M  506M   2% /boot/efi
/dev/sda2              234G  205G   18G  93% /
/dev/sdb               3.6T  2.5T  922G  74% /data

$ sudo fdisk -l >tmp.txt
$ grep -n sd tmp.txt
49:Disk /dev/sda: 238.5 GiB, 256060514304 bytes, 500118192 sectors
57:/dev/sda1     2048   1050623   1048576  512M EFI System
58:/dev/sda2  1050624 500117503 499066880  238G Linux filesystem
61:Disk /dev/sdb: 3.7 TiB, 4000787030016 bytes, 7814037168 sectors

Disk /dev/sda: 238.5 GiB, 256060514304 bytes, 500118192 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disklabel type: gpt
Disk identifier: 50C196AA-2E44-4E72-8B08-D469A451AC0B

Device       Start       End   Sectors  Size Type
/dev/sda1     2048   1050623   1048576  512M EFI System
/dev/sda2  1050624 500117503 499066880  238G Linux filesystem

Disk /dev/sdb: 3.7 TiB, 4000787030016 bytes, 7814037168 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes

也就是说 sdb 没有分区，没有文件系统？

$ lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0 238.5G  0 disk 
├─sda1   8:1    0   512M  0 part /boot/efi
└─sda2   8:2    0   238G  0 part /
sdb      8:16   0   3.7T  0 disk /data

$ df -lhT #看第二列，都是 ext4 格式的。
Filesystem     Type      Size  Used Avail Use% Mounted on
udev           devtmpfs   16G     0   16G   0% /dev
tmpfs          tmpfs     3.2G  4.5M  3.2G   1% /run
/dev/sda1      vfat      511M  5.7M  506M   2% /boot/efi
/dev/sda2      ext4      234G  205G   18G  93% /
/dev/sdb       ext4      3.6T  2.5T  922G  74% /data


5. 尝试不行的位置，使用 -v 
$ docker run -it     --mount type=bind,source=/data/,target=/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #No

$ docker run -it     -v /data/:/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #No
docker: Error response from daemon: error while creating mount source path '/data': mkdir /data: read-only file system.

$ docker run -it     -v /data/wangjl:/eMzMyO     --rm     openjdk:9.0.1-11-slim bash #No
docker: Error response from daemon: error while creating mount source path '/data/wangjl': mkdir /data: read-only file system.





6. 用 nsenter 进 dockerd 进程的 mount namespace 看看，/data 是否存在
【学霸】17-软件╰Jian 22:28:53 QQ群高手指教。

(1) 如果存在的话还不能访问那可能是 docker 的问题
不存在的话再看

$ ps -aux | grep docker
root        1032  0.2  0.2 2157984 91868 ?       Ssl  19:54   0:25 dockerd --group docker --exec-root=/run/snap.docker --data-root=/var/snap/docker/common/var-lib-docker --pidfile=/run/snap.docker/docker.pid --config-file=/var/snap/docker/796/config/daemon.json
root        1411  0.3  0.1 1946568 48316 ?       Ssl  19:54   0:38 containerd --config /run/snap.docker/containerd/containerd.toml --log-level error
root        1517  0.0  0.2 2048712 77528 ?       Ssl  19:54   0:04 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
wangjl     73749  0.0  0.0   6432  2656 pts/1    S+   22:37   0:00 grep --color=auto docker


$ sudo nsenter -m -t1032
-bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
root@sustc-HG:/# ls /data
ls: cannot access '/data': No such file or directory
root@sustc-HG:/# ls /home
chengww  hgyi  linuxbrew  wangjl  wuxc  yinch  zxl
root@sustc-HG:/# exit
logout

果然找不到 /data 目录。












7. 重装 docker 
(1) $ docker --version
Docker version 20.10.8, build 3967b7d

1) 卸载
如何干净卸载 docker: https://www.cnblogs.com/shmily3929/p/12085163.html

$ sudo apt remove docker
$ sudo apt-get autoremove docker docker-ce docker-engine  docker.io  containerd runc
$ docker --version
-bash: /usr/bin/docker: No such file or directory

$ sudo apt-get remove docker docker-engine docker.io containerd runc



2) 重新安装（这个就是snap安装步骤，不能用！）
$ sudo apt-get update

$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common

$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -

$ sudo apt-key fingerprint 0EBFCD88
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) <docker@docker.com>
sub   rsa4096 2017-02-22 [S]

$ sudo add-apt-repository \
   "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/ \
  $(lsb_release -cs) \
  stable"


$ whereis docker
docker: /etc/docker /snap/bin/docker.compose /snap/bin/docker.machine /snap/bin/docker /snap/bin/docker.help

版本太古老：
$  /snap/bin/docker --version
Docker version 19.03.13, build cd8016b6bc

## 卸载 snap 安装的 Docker
$ sudo snap remove docker






3) apt 安装 
$ sudo apt-get update
$ sudo apt-get install docker-ce docker-ce-cli containerd.io 

$ docker --version
Docker version 20.10.8, build 3967b7d

$ sudo service docker status #active

$ ps -aux | grep docker
root       97273  0.4  0.2 1974732 77952 ?       Ssl  23:13   0:00 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
wangjl     97587  0.0  0.0   6432   668 pts/1    S+   23:14   0:00 grep --color=auto docker

$ whereis docker
docker: /usr/bin/docker /etc/docker /usr/libexec/docker /usr/share/man/man1/docker.1.gz

$ /usr/bin/docker --version
Docker version 20.10.8, build 3967b7d

Docker的命名空间中可以找到该硬盘
$ ps -aux | grep docker
root       97273  0.3  0.2 1975672 85152 ?       Ssl  23:13   0:01 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
wangjl     98355  0.0  0.0   6432   664 pts/1    R+   23:19   0:00 grep --color=auto docker
wangjl@sustc-HG:~$ sudo nsenter -m -t97273
root@sustc-HG:/# ls /data
chengww  hgyi  lost+found  public  wangjl  wuxc  yinch  zxl
root@sustc-HG:/# ls /home
chengww  hgyi  linuxbrew  wangjl  wuxc  yinch  zxl


$ docker pull hub.c.163.com/library/node:slim
$ docker run -it     -v /data/:/eMzMyO     --rm     hub.c.163.com/library/node:slim bash #ok







8. 清理残留文件 https://www.cnblogs.com/etoumao/p/12688286.html

注意到 docker images 显示的镜像是不一样的。
也就是 snap 安装的 docker，和 apt 安装的 docker 不共享镜像文件。
他们的文件夹在哪里呢？

//todo 






###############
使用 ubuntu16 虚拟机测试一下：snap 安装的 docker 只能挂载 $HOME 目录。
$ sudo snap install docker



$ sudo fdisk -l
[sudo] password for george: 
Disk /dev/sda: 50 GiB, 53687091200 bytes, 104857600 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x82602f22

Device     Boot     Start       End   Sectors Size Id Type
/dev/sda1  *         2048 100663295 100661248  48G 83 Linux
/dev/sda2       100665342 104855551   4190210   2G  5 Extended
/dev/sda5       100665344 104855551   4190208   2G 82 Linux swap / Solaris

$ df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            971M     0  971M   0% /dev
tmpfs           200M   12M  189M   6% /run
/dev/sda1        48G  5.4G   40G  12% /
tmpfs           997M  272K  997M   1% /dev/shm
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           997M     0  997M   0% /sys/fs/cgroup
00              243G  5.5G  237G   3% /media/sf_00
tmpfs           200M   72K  200M   1% /run/user/1000
/dev/sr0         56M   56M     0 100% /media/george/VBox_GAs_5.2.8











ref:
不能使用 snap 安装Docker，要用 apt-get 安装 https://github.com/moby/moby/issues/34427
https://github.com/docker/docker.github.io/issues/4709 跟帖
https://github.com/docker/docker.github.io/issues/13503 又开了一个帖










========================================
|-- docker cp 命令： Docker与外部主机互传文件
----------------------------------------
前置条件：一个已经运行的nginx容器，做过端口映射



1.把外部文件复制到docker容器中
http://qa.supermap.com/23274?show=23274

docker cp 本地主机文件路径 容器id://usr/share/nginx/html

(1)查正在运行的容器id
$ docker ps
CONTAINER ID IMAGE COMMAND  CREATED        STATUS         PORTS                    NAMES
ed7ee90e50de 9376e "bash"   12 minutes ago Up 12 minutes  0.0.0.0:7000->80/tcp     tender_meninsky

(2) 在容器内新建文件路径，现有路径可以直接用
$ docker exec -it ed7ee90 bash
# mkdir -p /var/www/html/
# exit

(3) 将外部文件拷贝到容器
$ docker cp outer.html ed7ee9:/var/www/html/

访问 http://y.biomooc.com:7000/outer.html 可以看到内容。



(4)此时，可以对容器进行提交，生成一个新的镜像，该镜像将包含添加到nginx里面的outer.html页面。
示例命令：docker commit -m '注释' 容器id 自定义镜像名
完整命令：docker commit -m 'a new nginx container with outer.html' ed7ee90e50de george/static_web:addOuterFile
sha256:1222d23b39e9a5fa9b8f7d7ae71

还有参数 -a "auther name"

(5)使用docker images列出所有的容器，可以看到容器first-nginx在其中。
$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
george/static_web   addOuterFile        1222d23b39e9        46 seconds ago      151MB
george/static_web   latest              9376e822266c        2 hours ago         151MB






2.将外部主机文件拷贝到Docker容器

将nginx容器中的文件复制到本地需要调换一下参数位置。

示例命令：docker cp nginx容器id://usr/share/nginx/html/index.html 本地主机文件路径
完整命令：
$ docker cp ed7ee90e50de:/var/www/html/index.html .





========================================
|-- docker 单行运行 shell命令、指定工作目录
----------------------------------------
1. 如果是简单的一条命令，可以通过在docker run的最后写上命令的方式运行：
$ docker run -ti --network=host --name mc_controller IMAGE_NAME python3 src/controller.py


2. 如果要运行多条shell命令：
$ docker run -ti --network=host --name mc_controller IMAGE_NAME /bin/sh -c  'cd src && python controller.py'

注意最后的命令形式 bash -c 'cmd1 && cdm3'


例子:
在容器中编译java 
$ docker run -v /home/wangjl/test/cwl_test:/home/wangjl/ openjdk:9.0.1-11-slim bash -c 'cd /home/wangjl/ && javac Hello.java'



3. 更好的方法是指定工作目录  --workdir=/var/spool/cwl \

$ docker run --rm \
--volume=/home/wangjl/:/home/tom/:rw \
--volume=/data/wangjl/test/testCWL/Hello.java:/home/tom/Hello.java:ro \
--workdir=/home/tom/ \
openjdk:9.0.1-11-slim \
javac Hello.java







========================================
|-- 理解 docker 容器中的 uid 和 gid
----------------------------------------

1. 默认是使用 root 进入容器的
$ docker run --name test1 --rm -it -d -v /home/wangjl/:/home/test ubuntu:20.04 bash

$ docker exec -it test1 bash
root@1b4df2d5d33e:/# cd /home/test
root@1b4df2d5d33e:/home/test# touch 001.txt
root@1b4df2d5d33e:/home/test# exit
exit
可见，容器内使用root登录了。

$ ls -lth
total 136K
-rw-r--r--  1 root   root      0 Oct 19 10:46 001.txt
容器内创建的文件，在宿主机中查看权限，也是 root。


停止容器
$ docker stop test1






2. 怎么使用宿主机用户登录呢？添加 -u 参数
(1) 查询宿主机当前登录用户 wangjl, uid=1001
$ id
uid=1001(wangjl) gid=1001(wangjl) groups=1001(wangjl),1004(docker)

(2) 添加参数 -u 
# docker run --user 0 -d test
-u, --user string        Username or UID (format: <name|uid>[:<group|gid>])

$ docker run --name test1 -u 1001:1001 --rm -it -d -v /home/wangjl/:/home/test ubuntu:20.04 bash

$ docker exec -it test1 bash #测试表明，这里加不加 -u 1001:1001 效果一样。
I have no name!@84d106c3f8dd:/$ cd /home/test/
I have no name!@84d106c3f8dd:/home/test$ touch 002.txt
I have no name!@84d106c3f8dd:/home/test$ exit
exit

宿主机文件权限正常了
-rw-r--r--  1 wangjl wangjl    0 Oct 19 11:00 002.txt






3. 风险: docker 理论上能修改主机上的任何文件

(1) 容器内的 root 用户和宿主机上的 root 用户是同一个吗？
答案是：是的，它们对应的是同一个 uid。原因我们在前面已经解释过了：整个系统共享同一个内核，而内核只管理一套 uid 和 gid。
而且即便容器内外只共享uid和gid，不共享用户名，组名。权限是依赖id的，也就是说可以使用容器修改一些普通用户无法修改的内容。

docker run -u 可以指定宿主机运行docker命令的用户， -u指定的uid就是docker实际运行的进程拥有者。



(2) 一个 docker 组的用户，在 docker 内部修改 /etc/sudoers 文件。

$ docker run --name test1 --rm -it -v /etc/:/home/test ubuntu:20.04 bash
root@06095e8b8e4d:/# cd /home/test/
root@06095e8b8e4d:/home/test# echo "#test this" >> sudoers
root@06095e8b8e4d:/home/test# exit
exit
$ sudo tail -n 1 /etc/sudoers
#test this


完整测试了一下，把新人加入docker组，他自己确实可以拿到sudo。https://blog.csdn.net/wangjunliang/article/details/120842914
如何解决该风险？




4. 应用

(1) 这样安装在本地的文件所有者是 root ，普通用户无法删除、更新等。
$ docker run -it --rm  --name ryan  \
-v `pwd`:`pwd`  \
-w `pwd`  node \ 
npm install --registry=https://registry.npm.taobao.org

加上 -u 1001:1001 ，前面是 id wangjl 查到的uid，冒号后面是 gid，则使用该用户进入容器内部，一切正常。








ref:
https://blog.csdn.net/zhu7478848/article/details/88824064
https://www.cnblogs.com/woshimrf/p/understand-docker-uid.html






========================================
|-- 指定工作目录 -w / --workdir
----------------------------------------
-w, --workdir string      Working directory inside the container


1. 不指定工作目录
$ docker run --rm -it -v /home/wangjl/:/home/test ubuntu:20.04 bash
root@7bc3e4457e06:/# pwd
/
root@7bc3e4457e06:/# exit
exit



2.指定工作目录后，进入容器就自动切换到工作目录

$ docker run --rm -it -v /home/wangjl/:/home/test \
-w /home/test \
ubuntu:20.04 bash

root@840d01943c9d:/home/test# pwd
/home/test


(2) 为了易读性，可以使用参数全拼
$ docker run --rm -it -v /home/wangjl/:/home/test \
--workdir /home/test \
ubuntu:20.04 bash







========================================
制作自己的docker镜像: Dockerfile文件
----------------------------------------
有两种方法更新和创建镜像：commit 变动的容器获得新镜像，或者通过Dockerfile 从现有镜像(特别是官方镜像)创建新镜像。

- commit命令是一个相当简单的扩展一个镜像的方式，但是很笨重，而且不容易在团队中分享开发进程。替代方案是使用新的命令，docker build，抓取建立镜像。
- Dockerfile是docker构建镜像的基础，也是docker区别于其他容器的重要特征，正是有了Dockerfile，docker的自动化和可移植性才成为可能。
不论是开发还是运维，学会编写Dockerfile几乎是必备的，这有助于你理解整个容器的运行。




FROM , 从一个基础镜像构建新的镜像
FROM ubuntu 

MAINTAINER , 维护者信息
MAINTAINER William <wlj@nicescale.com>

ENV , 设置环境变量
ENV TEST 1

RUN , 非交互式运行shell命令
RUN apt-get -y update 
RUN apt-get -y install nginx

ADD , 将外部文件拷贝到镜像里,src可以为url
ADD http://nicescale.com/  /data/nicescale.tgz

WORKDIR /path/to/workdir, 设置工作目录
WORKDIR /var/www

USER , 设置用户ID
USER nginx

VULUME <#dir>, 设置volume
VOLUME ['/data']

EXPOSE , 暴露哪些端口
EXPOSE 80 443 

ENTRYPOINT ['executable', 'param1', 'param2']执行命令，不会被覆盖，总是执行。
ENTRYPOINT ["/usr/sbin/nginx"]

CMD ["param1","param2"] 只有最后一个cmd会生效，是启动容器后执行的。会被 docker run 最后跟着的命令覆盖。
CMD ["start"]

docker创建、启动container时执行的命令，如果设置了ENTRYPOINT，则CMD将作为参数？？





Dockerfile最佳实践
 - 尽量将一些常用不变的指令放到前面
 - CMD和ENTRYPOINT尽量使用json数组方式

通过Dockerfile构建image: $ docker build csphere/nginx:1.7 .

镜像仓库Registry: 镜像从Dockerfile build生成后，需要将镜像推送(push)到镜像仓库。企业内部都需要构建一个私有docker registry，这个registry可以看作二进制的scm，CI/CD也需要围绕registry进行。

部署registry
$ mkdir /registry
$ docker run -p 80:5000 -e STORAGE_PATH=/registry -v /registry:/registry registry:2.0


推送镜像保存到仓库
假设192.168.1.2是registry仓库的地址：
$ docker tag  csphere/nginx:1.7 192.168.1.2/csphere/nginx:1.7
$ docker push 192.168.1.2/csphere/nginx:1.7






========================================
|-- Dockerfile建立nginx镜像实例( ADD/COPY, / RUN / EXPOSE )
----------------------------------------
1. 实例1：
https://dockerbook.com/TheDockerBook_sample.pdf

(1)新建文件夹
$ mkdir static_web
$ cd static_web
$ touch Dockerfile


(2) 编写内容
# Version: 0.0.1
FROM ubuntu:18.04
LABEL maintainer="george@example.com"
RUN apt-get update; apt-get install -y nginx
RUN echo 'Hi, I am in your container' \
	>/var/www/html/index.html

#添加本地文件到镜像内
ADD outer.html /var/www/html/

#暴露80端口
EXPOSE 80



解释说明：
每条指令都有一个大写的前缀声明： INSTRUCTION statement
#后的是注释。
第一行总是 指令FROM， 指明镜像来源，是ubuntu:18.04版，没有作者，表明是官方来源。
指令MAINTAINER指定维护者。
RUN指令执行一个镜像内部命令，比如安装一个包。

ADD 和 COPY 都是把文件放到新镜像中，
区别：
	ADD: 会把压缩包解压。支持来源是url的文件。



(3)docker build 建立镜像，用-t指定名字（查看帮助 docker build --help）
$ cd static_web
$ docker build -t george/static_web .  ##默认tag是latest，注意最后有一个点号

说明：
1)尽量加上-t设置镜像名字，方便后续操作；
2)镜像名字可加上标签tag: docker build -t "george/static_web:v2" .
-t表明我们的新镜像属于用户george，仓库名static_web，标签v2。

3)最后一个点号，表示在当前位置找Dockerfile，也可以指定在github上找:
## docker build -t "george/static_web:v1" github.com/turnbullpress/docker-static_web
4)Docker 1.5.0及之后，可以用-f参数指定文件路径，而且该文件可以不命名为Dockerfile了，例如
## docker build -t "george/static_web" -f /path/to/file


以下是一堆输出：
Sending build context to Docker daemon  2.048kB
Step 1/5 : FROM ubuntu:18.04
 ---> 3556258649b2
...省略
Successfully built 9376e822266c
Successfully tagged george/static_web:latest


从输出第一行看，docker首先上传build上下文：基本上就是你正在build的文件夹。
做这些是因为docker守护进程需要本地上下文来build镜像。

接下来根据 Dockerfile 的指令一步一步执行。每步提交变化，并删掉中间容器。

注意：不管什么样的存储驱动，一个镜像都不能超过127层。这个限制是全局的，以鼓励优化镜像的总体尺寸。


更多指令可以查看官方文档。为了帮助你写一个清晰、可读、可维护的Dockerfile，我们写了一个《Dockerfile最佳实践指南》。
https://docs.docker.com/develop/develop-images/dockerfile_best-practices/


(4)查看镜像，多了一个基础镜像ubuntu:18.04和一个新构建的george/static_web:latest镜像：
$ docker images
REPOSITORY         TAG     IMAGE ID      CREATED        SIZE
george/static_web  latest  9376e822266c  33 seconds ago 151MB
ubuntu             18.04   3556258649b2  2 weeks ago    64.2MB


可以在commit或build之后，给每一个已经存在的镜像添加标签。docker tag命令就可以做到。现在，为镜像george/static_web添加一个标签。
$ docker tag 9376e822266c george/static_web:devel
$ docker images
REPOSITORY         TAG     IMAGE ID      CREATED      SIZE
george/static_web  devel   9376e822266c  4 hours ago  151MB
george/static_web  latest  9376e822266c  4 hours ago  151MB

结果就是同一个image id，但是有好几个tag。
删掉旧的tag呢？
$ docker rmi george/static_web:latest
Untagged: george/static_web:latest 
该image id只剩下一个了。






(5)运行该镜像
$ sudo docker run -p 7000:80 -it 9376e /bin/bash
-i 表示交互式
-t 表示获取一个终端
-p 做端口映射，格式 物理机端口:虚拟机端口

root@01896f11caac:/# service nginx start
root@01896f11caac:/# service nginx status

使用浏览器查看主机的7000端口
http://y.biomooc.com:7000/
Hi, I am in your container

root@01896f11caac:/# exit
再访问，服务就不存在了。


#####
要想在退出容器shell后继续后台运行，可以添加-d参数。
$ docker run -it -p 7000:80 -d 9376e bash
8e4c5eb0
查看容器id: $ docker ps
进入容器
$ docker exec -it 8e4c bash
开启nginx服务
# service nginx start
# exit
访问该网址，服务还在。


(6)关闭容器
查看启动的容器id ： 运行命令 docker container ls 或 docker ps
关闭容器 ：运行命令 docker stop 容器id



容器退出后，依旧可以查其容器id: docker ps -a 
删除一个容器: docker rm 容器id

查看镜像: docker images 
删除一个镜像: docker rmi 镜像id








2. 实例2: 测试 ADD 和 COPY 的功能。
(1) 测试基础
$ docker --version
Docker version 20.10.7, build 20.10.7-0ubuntu1~18.04.1

使用小镜像
ubuntu       20.04           fb52e22af1b0   2 weeks ago   72.8MB

(2) 造压缩文件
$ echo "hello, test2" >t2.txt
$ tar -cf all.tar t2.txt
$ gzip t2.txt

$ echo "hello, test3" >t3.txt
$ tar -czf txt.tar.gz *txt

-rw-rw-r-- 1 wangjl wangjl  10K Sep 18 10:26 all.tar
-rw-rw-r-- 1 wangjl wangjl   40 Sep 18 10:26 t2.txt.gz

-rw-rw-r-- 1 wangjl wangjl  134 Sep 18 10:27 txt.tar.gz


(3) 测试 ADD 指令
$ cat Dockerfile
FROM ubuntu:20.04

WORKDIR /app
ADD all.tar /app/
ADD t2.txt.gz /app/
ADD txt.tar.gz /app/

生成镜像，镜像名字必须小写
$ docker build -t "img2:add" .

$ docker images
REPOSITORY   TAG             IMAGE ID       CREATED          SIZE
img2         add             be0653dd83c7   4 seconds ago    72.8MB

运行并查看
$ docker run --rm -it img2:add ls
t2.txt	t2.txt.gz  t3.txt

只解压tar包。
如果源文件是个归档文件（压缩文件，比如 .tar, tar.gz文件），则docker会自动帮解压。
但是.txt.gz文件是不会自动解压的。


(4) 测试 COPY 指令
COPY all.tar /app/
COPY t2.txt.gz /app/
COPY txt.tar.gz /app/

$ docker build -t "img2:copy" .
$ docker run --rm -it img2:copy ls
all.tar  t2.txt.gz  txt.tar.gz



(5) 试试下载
尝试下载百度首页吧:
$ wget www.baidu.com/index.html -O b1.html
-rw-rw-r-- 1 wangjl wangjl 2.4K Sep 18 10:13 b1.html

$ cat Dockerfile 
FROM ubuntu:20.04

WORKDIR /app
ADD t2.txt.gz /app/
ADD all.tar /app/
ADD http://www.baidu.com/index.html B1.html

$ docker build -t "img2:url" .
$ docker run --rm img2:url ls -lth
total 312K
-rw-rw-r-- 1 1000 1000   13 Sep 18 01:52 t2.txt
-rw-rw-r-- 1 root root   40 Sep 18 01:52 t2.txt.gz
-rw------- 1 root root 302K Jan  1  1970 B1.html

这个docker下载的文件好大，是wget下载的150倍。








========================================
|-- 基于tomcat镜像的Jpress展示站点: 使用 COPY 把自定义文件加入到docker镜像中
----------------------------------------
(8) 怎么把自己的文件加入到docker中？从本地或者github都行。
https://www.cnblogs.com/20143605--pcx/p/10305680.html


1.实例1 
(1)制作自己的镜像
	dockerfile
	docker build 
	Jpress: http://jpress.io/ 做演示，先下载war包。
		放到Dockerfile所在文件夹，$ cp /home/wangjl/Public/jpress-web-newest.war .
	基础镜像：登陆 https://c.163.com/hub#/m/home/
		搜索tomcat，https://c.163.com/hub#/m/search/?keyword=tomcat
		下载docker版的 https://c.163.com/hub#/m/repository/?repoId=3105
		# docker pull hub.c.163.com/library/tomcat:latest
		改个短名字# docker tag hub.c.163.com/library/tomcat dawneve/tomcat
		因为tomcat依赖jdk，所以不用担心jdk问题了。
(2)写dockerfile
网易tomcat文件的dockerfile：
https://github.com/docker-library/tomcat/blob/a227157792e94c669148c3c2a09072fb317070e0/7/jre7/Dockerfile
dockerfile命令总结：http://blog.csdn.net/yeasy/article/details/40041707


#vim Dockerfile	 #简单写一个dockerfile
#指定基础镜像
from dawneve/tomcat
#所有者
MAINTAINER Jimmy JimmyMall@live.com 

#复制本地文件到基础镜像的文件夹中(参照该镜像文档 CATALINA_HOME:   /usr/local/tomcat)
COPY jpress-web-newest.war /usr/local/tomcat/webapps

(3)建立镜像
# docker build .
Sending build context to Docker daemon   20.8MB
Step 1/3 : FROM dawneve/tomcat
 ---> b226d7ee3462
Step 2/3 : MAINTAINER Jimmy JimmyMall@live.com
 ---> Using cache
 ---> 189049f0dac0
Step 3/3 : COPY jpress-web-newest.war /usr/local/tomcat/webapps
 ---> 1159f08345b2
Removing intermediate container 1eb46d2a6ce8
Successfully built 1159f08345b2




(4)docker images查看到一个没有名字的镜像。
# docker images
REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE
<none>                         <none>              1159f08345b2        31 seconds ago      313MB
dawneve/tomcat                 latest              b226d7ee3462        15 hours ago        292MB


(5)重新构建，用-t指定名字（查看帮助 docker build --help）
# docker build . -t dawneve/jpress:latest
Sending build context to Docker daemon   20.8MB
Step 1/3 : FROM dawneve/tomcat
 ---> b226d7ee3462
Step 2/3 : MAINTAINER Jimmy JimmyMall@live.com
 ---> Using cache
 ---> 189049f0dac0
Step 3/3 : COPY jpress-web-newest.war /usr/local/tomcat/webapps
 ---> Using cache
 ---> 1159f08345b2
Successfully built 1159f08345b2
Successfully tagged dawneve/jpress:latest
# docker images #名字正常
REPOSITORY       TAG     IMAGE ID            CREATED             SIZE
dawneve/jpress   latest  1159f08345b2        8 minutes ago       313MB
dawneve/tomcat   latest  b226d7ee3462        15 hours ago        292MB



(6)运行该容器
# docker run -d -p 8888:8080 dawneve/jpress
f3a05abb2f2e64164aaf70cfd07e423e985e0a43b09840065c6c215584a9ba75

# docker ps
CONTAINER ID IMAGE          COMMAND             CREATED        STATUS        PORTS                   NAMES
f3a05abb2f2e dawneve/jpress "catalina.sh run"   6 seconds ago  Up 4 seconds  0.0.0.0:8888->8080/tcp  sharp_bassi

#netstat -na|grep 8888
tcp6       0      0 :::8888                 :::*                    LISTEN



(7)访问主机的IP:8888查看效果
http://172.16.112.86:8888/
出现tomtat欢迎页面：Apache Tomcat/8.5.16。但是访问jpress页面报错。
原来url路径名要和war包同名
http://172.16.112.86:8888/jpress-web-newest/install
发现要安装jpress还需要数据库。
能不能用docker运行一个mysql呢？



(8)开启一个mysql服务
参考 运行和使用 docker版的mysql 的第一部分。


(9)回到jpress web安装页面，填写mysql信息。

数据库名: jpress_db 将JPress安装到哪个数据库？
用户名: root 您的MySQL用户名
密码:123456 …及其密码
数据库主机:172.16.112.86 如果localhost不能用，您通常可以从网站服务提供商处得到正确的信息。
端口号:3306 Mysql默认是3306
表前缀: jpress_ 如果您希望在同一个数据库安装多个JPress，请修改前缀。

点击下一步后，设置jpress管理员用户名和密码
网站名称： jpress in docker 
admin/admin


JPress安装向导
安装完成。
安装完成！稍等几秒后自动刷新。若一直停留在此页面，请重启你的web容器。

看来需要重启web容器了。
# docker restart f3a
f3a

http://172.16.112.86:8888/jpress-web-newest/
可以访问了。
后面加admin就可以访问后台了。用户名和密码刚才设置过。







========================================
|-- 怎么实现启动docker时自动启动服务呢？ //todo
----------------------------------------
https://www.jb51.net/article/147645.htm


在 Dockerfile 最后一行加上
# 容器默认启动命令
ENTRYPOINT ["service","nginx","start"]
好像不起作用！！！





========================================
制作自己的docker镜像:commit命令
----------------------------------------
对于运行的容器，如果有文件有变动，则可以使用commit命令提交为新的镜像。
推荐用Dockerfile文件建立镜像。因为该方法更可重复。

# find ID of your running container:
docker ps

# create image (snapshot) from container filesystem
docker commit 12345678904b5 mysnapshot
完整形式：docker commit 12345678904b5 myusername/mysnapshot:mytag
还可以加上注释 -m。
# docker commit -m'comments here' 242 myu/myimg:testTag
sha256:edb24adf0dd2c4d9c056c62cd38ab89951c0c12a0b5c0cc53ee4f4324d8997e1

#查看新提交的镜像
# docker images
REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE
myu/myimg                    testTag             edb24adf0dd2        12 seconds ago      120MB

# explore this filesystem using bash (for example)
docker run -t -i mysnapshot /bin/bash

#删除镜像
如果有基于该镜像的容器在运行或停止运行，需要加上-f参数 docker rmi -f IMGidOrName。
# docker rmi myu/myimg
Error response from daemon: No such image: myu/myimg:latest
root@ubt16:/home/wangjl# docker rmi myu/myimg:testTag
Untagged: myu/myimg:testTag
Deleted: sha256:edb24adf0dd2c4d9c056c62cd38ab89951c0c12a0b5c0cc53ee4f4324d8997e1






========================================
docker不同容器间的通信 //todo
----------------------------------------
https://blog.csdn.net/lao_pei/article/details/79157712
https://blog.csdn.net/wucong60/article/details/83757813





========================================
|-- docker 版的php: --link下容器间的通信 (现在不提倡使用)
----------------------------------------
https://www.runoob.com/docker/docker-install-php.html

不提倡使用文档: https://docs.docker.com/network/links/
The --link flag is a legacy feature of Docker. It may eventually be removed. Unless you absolutely need to continue using it, we recommend that you use user-defined networks to facilitate communication between two containers instead of using --link.
建议使用用户自定义网络来实现容器之间的通信。
--link 特有的功能是共享环境变量。但是也有替代途径：


1. 下载php镜像 
$ docker search php
NAME                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
php                            While designed for web development, the PHP …   6167      [OK]       
phpmyadmin/phpmyadmin          A web interface for MySQL and MariaDB.          1137                 [OK]

搜标签
$ curl -L -s https://registry.hub.docker.com/v1/repositories/php/tags > tmp
查了一下本地版本: 5.6.33

$ docker pull php:5.6-fpm #大版本
$ docker pull php:5.6.33-fpm #或这个
php          5.6.33-fpm   aaf299648ff3   3 years ago   367MB


(2) 找说明书，写的不清楚
https://hub.docker.com/
https://hub.docker.com/_/php

$ docker run -p 80:80 --rm -it  php:5.6.33-fpm bash
root@6b7f9515ae3a:/var/www/html# pwd
/var/www/html
root@6b7f9515ae3a:/var/www/html# which php
/usr/local/bin/php

一句话打印版本号:
$ docker run -p 80:80 --rm -it  php:5.6.33-fpm php -version
PHP 5.6.33 (cli) (built: Feb 17 2018 03:00:42) 
Copyright (c) 1997-2016 The PHP Group
Zend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies


单行执行指定php脚本
$ cat a.php
<?php
echo "hello, from php\n";

$ docker run -p 80:80 --rm -it -v ~/:/var/www/html/  php:5.6.33-fpm php a.php
hello, from php






(3) 启动 php docker:
$ mkdir -p ~/nginx/www
$ docker run --name  myphp-fpm -v ~/nginx/www:/www  -d php:5.6.33-fpm

参数解释：
--name myphp-fpm : 将容器命名为 myphp-fpm。
-v ~/nginx/www:/www : 将宿主机中的 ~/nginx/www 挂载到容器的 /www

$ docker ps -a
CONTAINER ID   IMAGE            COMMAND                  CREATED          STATUS          PORTS      NAMES
a98cb5ebbe61   php:5.6.33-fpm   "docker-php-entrypoi…"   58 seconds ago   Up 56 seconds   9000/tcp   myphp-fpm
默认使用的是9000端口。


(4) 创建 ~/nginx/conf/conf.d 目录：

$ mkdir -p ~/nginx/conf/conf.d 
在该目录下添加 ~/nginx/conf/conf.d/test-php.conf 文件，内容如下：

server {
    listen       80;
    server_name  localhost;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm index.php;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    location ~ \.php$ {
        fastcgi_pass   php:9000;
        fastcgi_index  index.php;
        fastcgi_param  SCRIPT_FILENAME  /www/$fastcgi_script_name;
        include        fastcgi_params;
    }
}

解释：
php:9000: 表示 php-fpm 服务的 URL，下面我们会具体说明。
/www/: 是 myphp-fpm 中 php 文件的存储路径，映射到本地的 ~/nginx/www 目录。




(5) 启动 nginx
查版本号
$ docker run --rm -it  nginx nginx -version
nginx version: nginx/1.21.3


$ docker run --name test2-php-nginx -p 8083:80 -d \
    -v ~/nginx/www:/usr/share/nginx/html:ro \
    -v ~/nginx/conf/conf.d:/etc/nginx/conf.d:ro \
    --link myphp-fpm:php \
    nginx

参数解释：
-p 8083:80: 端口映射，把 nginx 中的 80 映射到本地的 8083 端口。
~/nginx/www: 是本地 html 文件的存储目录，/usr/share/nginx/html 是容器内 html 文件的存储目录。
~/nginx/conf/conf.d: 是本地 nginx 配置文件的存储目录，/etc/nginx/conf.d 是容器内 nginx 配置文件的存储目录。

--link myphp-fpm:php: 把 myphp-fpm 的网络并入 nginx，并通过修改 nginx 的 /etc/hosts，把域名 php 映射成 127.0.0.1，让 nginx 通过 php:9000 访问 php-fpm。
// todo 这个不懂


#######
--link <name or id>:alias
其中，name和id是源容器的name和id，alias是源容器在link下的别名。
--link list                      Add link to another container

探究一下怎么实现的：
进入nginx容器
$ docker exec -it test2-php-nginx /bin/bash
root@f178011c167d:/# env | grep -i php     
PHP_NAME=/test2-php-nginx/php
PHP_PORT_9000_TCP_ADDR=172.17.0.2
PHP_ENV_PHP_CFLAGS=-fstack-protector-strong -fpic -fpie -O2
PHP_PORT_9000_TCP_PROTO=tcp
PHP_ENV_GPG_KEYS=0BD78B5F97500D450838F95DFE857D9A90D90EC1 6E4F6AB321FDC07F2C332E3AC2BF0BC433CFC8B3
PHP_PORT_9000_TCP=tcp://172.17.0.2:9000
PHP_ENV_PHP_MD5=
PHP_ENV_PHP_VERSION=5.6.33
PHP_ENV_PHP_SHA256=9004995fdf55f111cd9020e8b8aff975df3d8d4191776c601a46988c375f3553
PHP_ENV_PHP_URL=https://secure.php.net/get/php-5.6.33.tar.xz/from/this/mirror
PHP_ENV_PHP_EXTRA_CONFIGURE_ARGS=--enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data
PHP_PORT_9000_TCP_PORT=9000
PHP_ENV_PHP_INI_DIR=/usr/local/etc/php
PHP_ENV_PHP_LDFLAGS=-Wl,-O1 -Wl,--hash-style=both -pie
PHP_ENV_PHPIZE_DEPS=autoconf 		dpkg-dev 		file 		g++ 		gcc 		libc-dev 		make 		pkg-config 	   re2c
PHP_ENV_PHP_ASC_URL=https://secure.php.net/get/php-5.6.33.tar.xz.asc/from/this/mirror
PHP_PORT=tcp://172.17.0.2:9000
PHP_ENV_PHP_CPPFLAGS=-fstack-protector-strong -fpic -fpie -O2


可见，确实有名为 PHP_NAME=/test2-php-nginx/php 的环境变量存在。




(6) 接下来我们在 ~/nginx/www 目录下创建 index.php，代码如下：

<?php
echo phpinfo();
?>


(7) 查看
$ docker ps
CONTAINER ID   IMAGE            COMMAND                  CREATED         STATUS         PORTS                                   NAMES
f178011c167d   nginx            "/docker-entrypoint.…"   2 minutes ago   Up 2 minutes   0.0.0.0:8083->80/tcp, :::8083->80/tcp   test2-php-nginx
a98cb5ebbe61   php:5.6.33-fpm   "docker-php-entrypoi…"   6 minutes ago   Up 6 minutes   9000/tcp                                myphp-fpm

浏览器打开 http://宿主机ip:8083/index.php，显示 php版本详细信息。

$ tree nginx/
nginx/
├── conf #放配置文件
│   └── conf.d
│       └── test-php.conf
└── www #放网页文件
    ├── index2.php
    └── index.php





========================================
进一步学习docker
----------------------------------------
docker inspect imageID #查看分层Layers

docker 镜像的位置 
root@ubt16:/var/lib/docker/containers# pwd
/var/lib/docker/containers


Dockerfile是一个重点，有很多细节，
Dockerfile reference：https://docs.docker.com/engine/reference/builder/



1.使用容器
当你能在Docker容器中运行你的应用的时候，你就学会怎么管理那些容器了。学习怎么检查、监视和管理你的容器：
Go to Working With Containers.

2.使用docker镜像
你学完怎么使用docker，就应该进行下一步了，学习使用docker构建你自己的应用。
Go to Working with Docker Images.


3.联网的容器
目前为止你看到怎么在docker容器中构建私人应用。现在学习怎么使用docker网络构建整个应用栈。
Go to Networking Containers.


4.管理容器中的数据
现在你知道了怎么把众多docker容器连接起来，下一步就是学习怎么管理这些容器内部的数据、容量和挂载。
Go to Managing Data in Containers.


# Getting help
	- [Docker homepage](https://www.docker.com/)
	- [Docker Hub](https://hub.docker.com/)
	- [Docker blog](https://blog.docker.com/)
	- [Docker documentation](https://docs.docker.com/)
	- [Docker Getting Started Guide](https://docs.docker.com/mac/started/)
	- [Docker code on GitHub](https://github.com/docker/docker)
	- [Docker mailing list](https://groups.google.com/forum/#!forum/docker-user)
	- Docker on IRC: irc.freenode.net and channel #docker
	- [Docker on Twitter](https://twitter.com/docker)
	- Get [Docker help](https://stackoverflow.com/search?q=docker) on StackOverflow
	- [Docker.com](https://www.docker.com/)









========================================
|-- 容器之间的通信: 容器端口映射
----------------------------------------
端口映射的指令是什么？docker指令：docker run -p ip:hostPort:containerPort redis

ref: https://yeasy.gitbooks.io/docker_practice/network/port_mapping.html#映射到指定地址的指定端口
使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。
$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py




1. 通过sudo docker ps 查看当前的进程


2. 通过 sudo docker inspect <id> ；例如我上面的例子 sudo docker inspect 4efcb2f82953
找到这个ip 

"Ports": {
	"3306/tcp": [ #2.那么容器的这个端口来响应
		{
			"HostIp": "0.0.0.0", #1.这里是如果用户访问宿主机IP和端口
			"HostPort": "7070"
		}
	]
},
...
"IPAddress": "172.17.0.2", ##就是这一行




3. 第三步：设置端口映射  
$ sudo  docker run -d -p 172.17.0.2::9090 training/webapp python app.py
注意红色字体(172.17.0.2)前面是docker容器的ip地址，后面是我们需要映射的端口号(9090)

绑定 已有容器172.17.0.2 的任意端口绑定到 将要新建的容器的9090端口，已有容器会自动分配一个端口。



4. sudo docker ps 查看当前是不是映射成功

出现0.0.0.0:7070->3306/tcp表示宿主机的7070端口映射到了虚拟机的3306端口。




5. 也可以使用docker port NAME查看端口映射情况。
$ sudo docker port agitated_hawking
红色字体(agitated_hawking)指的是当前端口号的name。


$ sudo docker port 740
3306/tcp -> 0.0.0.0:7070

表示虚拟机的3306端口映射到了主机的7070端口。
如果没有任何回复，表示端口映射失败。




https://blog.csdn.net/taowuhua0505/article/details/88255773




========================================
|-- 为运行中的容器添加端口映射
----------------------------------------
简单的说，2种。
- iptables 端口转发；
- commit 容器为一个images，重新运行一个新的容器


1.方法1：不需要重启容器。

(1) 获得容器IP：将container_name 换成实际环境中的容器名
$ docker inspect `container_name` | grep IPAddress
	"IPAddress": "172.17.0.3",

(2) iptable转发端口
将容器的8000端口映射到docker主机的8001端口
$ sudo iptables -t nat -A  DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.3:8000



(3) // 下面没看懂，先留着: 
修改容器的json文件：
暂停容器，
修改容器映射时只需要 修改hostconfig.json的PortBindings , 增加容器映射时还需要改config.v2.json的ExposedPorts

重新运行容器。









2.方法2 容器打包成镜像，重新运行该镜像时添加端口映射

$ docker ps
$ docker commit containerid foo/aaa

$ docker run -it --name web_demo -p 8000:80  foo/aaa:v1  /bin/bash  # 添加了端口映射

$ docker run -it --name web_demo -p 8000:80  foo/aaa:v1  bash











========================================
|-- 镜像存放地点 Where are Docker Images Stored? Docker Container Paths Explained
----------------------------------------
Docker has been widely adopted and is used to run and scale applications in production. Additionally, it can be used to start applications quickly by executing a single Docker command.


1. docker 的设置 
$ docker info #ubuntu
...
 Storage Driver: overlay2
 Docker Root Dir: /var/lib/docker
...

# for CentOS
$ docker info | grep -i driver
 Storage Driver: overlay2
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
$ docker info | grep -i root
 Docker Root Dir: /var/lib/docker




2. 镜像文件和容器文件都存放在哪里？
The storage location of Docker images and containers

(1) 查询1：docker info 
Ubuntu, CentOS: /var/lib/docker/


(2) 查询2：
$ docker inspect openjdk:9.0.1-11-slim
...
"LowerDir": "/var/lib/docker/overlay2/d255fe736b2b73ff06eaa6e39d1bbf39fcd51655daf1ea99da13b4d8a85624be/diff:/var/lib/docker/overlay2/113c46fa2fc7e81949801027acf7f40219a1c89a162f1f625caceadd7a52df4a/diff:/var/lib/docker/overlay2/61608abb333f641a522fffc6fff3ed0ab80dc5dfbe8fde7e5ea69f71ee898dbf/diff:/var/lib/docker/overlay2/0fa09106e20aeda8d68048cb925975e3e060f3aac8b22fc1e6cbd9fbe289d1a3/diff",
...
"UpperDir": "/var/lib/docker/overlay2/b34001780d1952d1645477b2ba42d6a360085e7e4914fedc299c4056cb7d8b06/diff",
...

查看这些文件
$ sudo ls -lah /var/lib/docker/overlay2/d255fe736b2b73ff06eaa6e39d1bbf39fcd51655daf1ea99da13b4d8a85624be
total 32K
drwx-----x  4 root root 4.0K Sep 12 23:36 .
drwx-----x 59 root root  12K Sep 13 09:37 ..
-rw-------  1 root root    0 Sep 12 23:36 committed
drwxr-xr-x  2 root root 4.0K Sep 12 23:36 diff
-rw-r--r--  1 root root   26 Sep 12 23:36 link
-rw-r--r--  1 root root   86 Sep 12 23:36 lower
drwx------  2 root root 4.0K Sep 12 23:36 work


(3). Docker 根目录的结构
The internal structure of the Docker root folder

$ sudo ls -la /var/lib/docker
total 64
drwx--x--x 14 root root  4096 Sep 12 23:13 .
drwxr-xr-x 89 root root  4096 Sep 12 19:48 ..
drwx------  2 root root  4096 Jan 13  2020 builder
drwx--x--x  4 root root  4096 Sep  3 16:25 buildkit
drwx-----x  5 root root  4096 Sep 13 09:37 containers #容器文件
drwx------  3 root root  4096 Jan 13  2020 image
drwxr-x---  3 root root  4096 Jan 13  2020 network
drwx-----x 59 root root 12288 Sep 13 09:37 overlay2  #镜像文件
drwx------  4 root root  4096 Jan 13  2020 plugins
drwx------  2 root root  4096 Sep 12 23:13 runtimes
drwx------  2 root root  4096 Jan 13  2020 swarm
drwx------  2 root root  4096 Sep 12 23:36 tmp
drwx------  2 root root  4096 Jan 13  2020 trust
drwx-----x  3 root root  4096 Sep 12 23:13 volumes


(4) 容器及其ID
$ sudo ls -lth /var/lib/docker/containers
total 12K
drwx------ 4 root root 4.0K Sep 12 23:13 375c2cb65a97a2fc884ba97fa70afaec95764f3b6197ad2f9a28a7350d81d69d
drwx------ 4 root root 4.0K Sep 12 23:13 b919662117ccf799921f0e667a63645b4ba4eae404227ae52233e9aab7e681da
drwx------ 4 root root 4.0K Sep 12 23:13 e2957a0e8b196caffc17fdc12287730bf9a213465ee8680c921575d42d6d6c99

$ docker ps -a
CONTAINER ID   IMAGE                      COMMAND                  CREATED        STATUS                      PORTS                    NAMES
375c2cb65a97   dawneve/rstudio:monocle3   "/init"                  4 months ago   Exited (255) 3 months ago   0.0.0.0:5000->8787/tcp   strange_wu
e2957a0e8b19   dawneve/rstudio:Seurat     "/init"                  6 months ago   Exited (0) 4 months ago                              friendly_borg
b919662117cc   dawneve/mysql              "docker-entrypoint.s…"   6 months ago   Exited (255) 3 months ago   0.0.0.0:7070->3306/tcp   peaceful_shtern
都能对上号。


(5) 镜像及存放地点
$ sudo ls -lth /var/lib/docker/overlay2
这里面装了很多镜像的层。所以总数会超过镜像个数。

$ docker images
REPOSITORY                   TAG             IMAGE ID       CREATED        SIZE
dawneve/rstudio              monocle3        8893c1f83058   6 months ago   2.58GB
dawneve/rstudio              Seurat          0ccae6079dad   6 months ago   2.09GB
dawneve/rstudio              latest          9e22c8cd092b   6 months ago   1.95GB
satijalab/seurat             4.0.0           32b06bd197c7   7 months ago   3.64GB
openjdk                      9.0.1-11-slim   5149033ba93d   3 years ago    374MB
hub.c.163.com/library/node   slim            914ef9e2ccb0   4 years ago    227MB
dawneve/mysql                latest          9e64176cd8a2   4 years ago    407MB

$ sudo du -sh /var/lib/docker/
7.8G	/var/lib/docker/
以上镜像size加起来大于这个数字，说明有共用部分。


$ sudo ls -lth /var/lib/docker/image/overlay2/imagedb/content/sha256
total 56K
-rw------- 1 root root 3.9K Sep 12 23:36 5149033ba93d3d1b6fc97a9bfb7cd56ec4b442e430ac36723f588bdf897f8e4a
-rw------- 1 root root 6.0K Sep 12 23:22 914ef9e2ccb047ed9a243a38a84b0285ca14e83afc1a35077a79560c185ec7c8
-rw------- 1 root root 7.3K Mar  3  2021 9e22c8cd092b6289d0765e08b682e2517cb7cef579baa871eec2362c9e43960d
-rw------- 1 root root 7.6K Mar  2  2021 8893c1f83058683401060f258f9cb693ec83154ce5a677bf7e8086eb1e89348d
-rw------- 1 root root 7.4K Mar  1  2021 0ccae6079dadb8cad8b05efb11a07f9f7fe6b3fd5634c87f7c2008025bfb9f81
-rw------- 1 root root 9.8K Mar  1  2021 32b06bd197c7868cf7b24fe578b53dc8b83ea997af9e5a626707a51750e598b6
-rw------- 1 root root 6.6K Jan 13  2020 9e64176cd8a206f88336506fe52cd8f87423147dc197d0250175dddc39465e90
这只是sha256码，文件在哪里呢？


$ docker inspect openjdk:9.0.1-11-slim |tail  -n 24 | head -n 9
$ docker image inspect 5149 |tail  -n 24 | head -n 9
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/d255fe736b2b73ff06eaa6e39d1bbf39fcd51655daf1ea99da13b4d8a85624be/diff:/var/lib/docker/overlay2/113c46fa2fc7e81949801027acf7f40219a1c89a162f1f625caceadd7a52df4a/diff:/var/lib/docker/overlay2/61608abb333f641a522fffc6fff3ed0ab80dc5dfbe8fde7e5ea69f71ee898dbf/diff:/var/lib/docker/overlay2/0fa09106e20aeda8d68048cb925975e3e060f3aac8b22fc1e6cbd9fbe289d1a3/diff",
                "MergedDir": "/var/lib/docker/overlay2/b34001780d1952d1645477b2ba42d6a360085e7e4914fedc299c4056cb7d8b06/merged",
                "UpperDir": "/var/lib/docker/overlay2/b34001780d1952d1645477b2ba42d6a360085e7e4914fedc299c4056cb7d8b06/diff",
                "WorkDir": "/var/lib/docker/overlay2/b34001780d1952d1645477b2ba42d6a360085e7e4914fedc299c4056cb7d8b06/work"
            },
            "Name": "overlay2"
        },
#
The LowerDir contains the read-only layers of an image. The read-write layer that represents changes are part of the UpperDir.
LowerDir: 镜像的仅可读部分。
UpperDir: 镜像可读可写部分。


$ sudo ls -lth /var/lib/docker/overlay2/ | grep d255fe73
drwx-----x 4 root root 4.0K Sep 12 23:36 d255fe736b2b73ff06eaa6e39d1bbf39fcd51655daf1ea99da13b4d8a85624be

$ sudo ls -lth /var/lib/docker/overlay2/d255fe736b2b73ff06eaa6e39d1bbf39fcd51655daf1ea99da13b4d8a85624be
total 16K
-rw------- 1 root root    0 Sep 12 23:36 committed
drwxr-xr-x 2 root root 4.0K Sep 12 23:36 diff
-rw-r--r-- 1 root root   26 Sep 12 23:36 link
-rw-r--r-- 1 root root   86 Sep 12 23:36 lower
drwx------ 2 root root 4.0K Sep 12 23:36 work



(6) 挂载到虚拟机的目录
$ docker run --name nginx_container -it --rm -v /var/log dawneve/nginx bash
root@c4cd8406733e:/# ls /var/log
alternatives.log  apt  bootstrap.log  btmp  dpkg.log  faillog  lastlog	nginx  wtmp

另一个终端查看 Mounts - Destination 中的内容
$ docker inspect nginx_container
        "Mounts": [
            {
                "Type": "volume",
                "Name": "fe73d0f3dcb76672c33e5a3542afc992598f4fc64180a9c569ae202b6e0381a5",
                "Source": "/var/lib/docker/volumes/fe73d0f3dcb76672c33e5a3542afc992598f4fc64180a9c569ae202b6e0381a5/_data",
                "Destination": "/var/log",
                "Driver": "local",
                "Mode": "",
                "RW": true,
                "Propagation": ""
            }
        ],
#

对比下文例子可知，-v只提供一个参数，则是docker内部的地址，外部地址是随机生成的sha256字符那个目录。
$ ls -lah /var/lib/docker/volumes/fe73d0f3dcb76672c33e5a3542afc992598f4fc64180a9c569ae202b6e0381a5/_data
total 168K
drwxr-xr-x 4 root root 4.0K Sep 13 14:21 .
drwx-----x 3 root root 4.0K Sep 13 14:21 ..
-rw-r--r-- 1 root root 1.7K Apr 25  2017 alternatives.log
drwxr-xr-x 2 root root 4.0K Sep 13 14:21 apt
-rw-r--r-- 1 root root  34K Apr 25  2017 bootstrap.log
-rw-rw---- 1 root utmp    0 Apr 25  2017 btmp
-rw-r--r-- 1 root root  74K Apr 26  2017 dpkg.log
-rw-r--r-- 1 root root 3.2K Apr 26  2017 faillog
-rw-rw-r-- 1 root utmp  30K Apr 26  2017 lastlog
drwxr-xr-x 2 root root 4.0K Sep 13 14:21 nginx
-rw-rw-r-- 1 root utmp    0 Apr 25  2017 wtmp





(7) 完整的目录映射方式
$ docker run --name nginx_container -it --rm -v /var/log:/home/wangjl/ dawneve/nginx bash 
root@f32ff5a624d8:/# ls /home/wangjl/
Xorg.0.log		alternatives.log.3.gz

另一个终端查看：
$ ls /var/log
alternatives.log        alternatives.log.7.gz 

$ docker inspect nginx_container
...
        "Mounts": [
            {
                "Type": "bind",
                "Source": "/var/log",
                "Destination": "/home/wangjl",
                "Mode": "",
                "RW": true,
                "Propagation": "rprivate"
            }
...
source 是宿主机， dest 是 docker 内部。


(8) Clean up space used by Docker
It is recommended to use the Docker command to clean up unused containers. Container, networks, images, and the build cache can be cleaned up by executing:

$ sudo ls /var/lib/docker/overlay2 | wc #60

$ docker system prune -a
WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all images without at least one container associated to them
  - all build cache

Are you sure you want to continue? [y/N] N
杀伤力太大了，不敢用。



remove unused volumes by executing:
$ docker volume prune
WARNING! This will remove all local volumes not used by at least one container.
Are you sure you want to continue? [y/N] y
Deleted Volumes:
f0c2c51bc9aded986ca956fabb7a6fe15711e3e571cee4a0e44cef4d3a61b860
9118a1d173a6f4da12835bc16dd14385d31b0e1e04b2b98247518ecc5d195ed2

Total reclaimed space: 207MB




(9) 查询自己安装的包
$ apt show docker #这个不是我们期望的 docker 
$ apt show docker.io  #这个才是

不要用 snap 命令安装docker，否则使用中会出错。
$ snap info docker







###### 这是因为有两份吗？
$ sudo tree /var/lib/docker/ > docker_file_str.txt
$ cat docker_file_str.txt  | grep -n openjdk
45482:│   │   │   │   ├── java-11-openjdk
59085:│   │   │       │   │   │   ├── openjdk-11-jre-headless:amd64.list
59086:│   │   │       │   │   │   ├── openjdk-11-jre-headless:amd64.postrm
59397:│   │   │   │   ├── java-11-openjdk
72983:│   │   │       │   │   │   ├── openjdk-11-jre-headless:amd64.list
72984:│   │   │       │   │   │   ├── openjdk-11-jre-headless:amd64.postrm


$ cat docker_file_str.txt | head -n 45492 | tail -n 20
$ cat docker_file_str.txt | head -n 59407 | tail -n 20






ref: https://www.freecodecamp.org/news/where-are-docker-images-stored-docker-container-paths-explained/






========================================
把用户添加到docker组
----------------------------------------
1.查看自己是否在docker分组
$ cat /etc/group | grep docker # 查找 docker 组，确认其是否存在
## docker:x:978:hou,rqfu



2.添加自己到docker组
groups # 列出自己的用户组，确认自己在不在 docker 组中

# 如果 docker 组不存在，则添加之：
sudo groupadd docker

# 将当前用户添加到 docker 组
sudo gpasswd -a ${USER} docker

# 重启服务
sudo service docker restart
systemctl daemon-reload


重新登录才能看到组的变动
$ su wangjl



# 切换一下用户组（刷新缓存）
newgrp - docker;
newgrp - `groups ${USER} | cut -d' ' -f1`; # TODO：必须逐行执行，不知道为什么，批量执行时第二条不会生效
# 或者，注销并重新登录
pkill X




http://www.markjour.com/article/docker-no-root.html
不一定好使。





========================================
故障排除 troubleshooting
----------------------------------------



========================================
|-- mysql 从容器外连不上怎么办？
----------------------------------------
有人说改这个，没改，/etc/mysql/mysql.conf.d
(1)在mysqld下添加skip-name-resolve
(2)In my.cnf file, add:
connect_timeout = 10
table_open_cache = 900
Restart MySQL.

(3)It might be the firewall problem or maybe because the MySQL server is bound to the loop-back IP (127.0.0.1 / localhost) which effectively cuts you off from connecting from “outside”.



感觉问题不在容器及内部的服务，在宿主机的端口不可访问，证据如下： 



1. docker是正常运行的
$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
740797493b8c        dawneve/mysql       "docker-entrypoint.s…"   8 weeks ago         Up 9 minutes        0.0.0.0:7070->3306/tcp   loving_engelbart



进入docker可以登录mysql，
$ docker exec -it 740 bash
root@740797493b8c:/# mysql -u root -p 
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3

也就是docker提供的mysql服务一直在，一直正常运行！





2. 但是在docker外部怎么都无法连接mysql

$ mysql -h 127.0.0.1 -P7070 -uroot -p
Enter password: 
ERROR 2013 (HY000): Lost connection to MySQL server at 'reading initial communication packet', system error: 0


$ mysql -h192.168.2.120 -P 7070 -uroot -p
Enter password: 
ERROR 2003 (HY000): Can't connect to MySQL server on '192.168.2.120' (111)







3. 使用telnet看端口，直接连不上。
$ telnet y.biomooc.com 7070
Trying 10.20.46.143...
telnet: Unable to connect to remote host: Connection refused




4.nmap扫描的结果是 filtered，
$ sudo nmap -sS -p 7000-8000 192.168.2.120

Starting Nmap 7.60 ( https://nmap.org ) at 2019-12-05 22:20 CST
Nmap scan report for sustc-HG.lan (192.168.2.120)
Host is up (0.000015s latency).
Not shown: 998 closed ports
PORT     STATE    SERVICE
7000/tcp open     afs3-fileserver
7070/tcp filtered realserver
8000/tcp open     http-alt

什么意思？
(1)https://blog.csdn.net/lee244868149/article/details/39177669
filtered(被过滤的)
由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。这样的端口让攻击者感觉很挫折，因为它们几乎不提供 任何信息。有时候它们响应ICMP错误消息如类型3代码13 (无法到达目标: 通信被管理员禁止)，但更普遍的是过滤器只是丢弃探测帧， 不做任何响应。 这迫使Nmap重试若干次以访万一探测包是由于网络阻塞丢弃的。 这使得扫描速度明显变慢。

难道是防火墙？

(2)
https://blog.csdn.net/m0_37268841/article/details/80234365
Filtered（过滤的）：由于报文无法到达指定的端口，nmap不能够决定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致的。当nmap收到icmp报文主机不可达报文（例如：type为3，code为13（communication administratively prohibit）报文）或者目标主机无应答，常常会将目标主机的状态设置为filtered。

那么，我修改端口总可以吧？




5. 监听端口
http://www.kbase101.com/question/16413.html

(1)
$ sudo tcpdump -A 'udp and port 7070' -w tcpdump.out
[sudo] password for wangjl: 
tcpdump: listening on docker0, link-type EN10MB (Ethernet), capture size 262144 bytes
^C0 packets captured
0 packets received by filter
0 packets dropped by kernel

现在停止转储并检查是否有任何数据包在tcpdump.out中被捕获或者没有使用wireshark。


(2)
$ nc y.biomooc.com -u 7070
如果没有捕获数据包，这意味着某些中间设备（防火墙）阻止了通信。否则，如果捕获，请检查服务器给出的回复以回复请求。如果它是带有某些错误代码的任何类型的ICMP回复，则表示存在一些阻塞的本地防火墙。


那就是防火墙问题了？





6. 关掉防火墙
(1)
$ sudo iptables -F
清空iptables设置。


(2)
$ service ufw status
$ service ufw stop

$ netstat | grep 7070
tcp        0      1 sustc-HG.lan:54550      10.20.46.143:7070       SYN_SENT   
tcp        0      1 sustc-HG.lan:54548      10.20.46.143:7070       SYN_SENT


这个用的 centos: https://blog.csdn.net/Blog_inG/article/details/88963043


(3)
关闭ubuntu的防火墙 ufw disable 
开启防火墙 ufw enable
https://www.jb51.net/article/138876.htm

$ sudo ufw disable
这个有用了。可以连接mysql了。
不知道是不是因为这个？


Ubuntu 防火墙更多命令：
sudo ufw allow 80 允许外部访问80端口
sudo ufw delete allow 80 禁止外部访问80 端口
sudo ufw allow from 192.168.1.1 允许此IP访问所有的本机端口





7.回测：
步骤4和5的结果还是一样，没变化。

步骤3 telnet端口，结果是：
$ telnet y.biomooc.com 7070
Trying 10.20.46.143...
Connected to y.biomooc.com.
Escape character is '^]'.
J
5.7.B8  1g<.rDA43X#r:mysql_native_password

^CConnection closed by foreign host.






8.更多端口查看方法
(1)
$ netstat -an|grep 7070
tcp6       0      0 :::7070                 :::*                    LISTEN 


(2)
服务端查看所有开放端口：$ netstat -luntp

$ netstat -luntp | head
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 127.0.0.1:43917         0.0.0.0:*               LISTEN      9690/python


$ netstat -luntp | grep 7070
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp6       0      0 :::7070                 :::*                    LISTEN      -    



(3)
$ ss -tnl

(4)
$ curl -i http://y.biomooc.com:7070
$ wget http://y.biomooc.com:7070




9. 又不行了，感觉是间歇性的。切换到局域网内部。改端口试试？
$ sudo docker run -p 7071:3306 -d -it -e MYSQL_ROOT_PASSWORD=123456 -v /home/wangjl/dockerFile:/var/lib/mysql dawneve/mysql

$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
a1e0c7438e6d        dawneve/mysql       "docker-entrypoint.s…"   3 seconds ago       Up 2 seconds        0.0.0.0:7071->3306/tcp   lucid_shaw

$ mysql -h192.168.2.120 -P7071 -uroot -p
Enter password: 
ERROR 2003 (HY000): Can't connect to MySQL server on '192.168.2.120' (111)

还是连不上。

1)看iptables被加了这么一行
wangjl@sustc-HG:~$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         

Chain DOCKER (0 references)
target     prot opt source               destination         
ACCEPT     tcp  --  anywhere             172.17.0.2           tcp dpt:mysql

2)能ping通:
$ ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.079 ms


3)但是就是连不上:
$ mysql -h 172.17.0.2 -uroot -p
Enter password: 
ERROR 2003 (HY000): Can't connect to MySQL server on '172.17.0.2' (111)

$ mysql -h 172.17.0.2 -P3306 -uroot -p
一样不行。


4)
$ sudo nmap -sS -p 3300-8000 172.17.0.2

Starting Nmap 7.60 ( https://nmap.org ) at 2019-12-27 10:03 CST
Nmap scan report for 172.17.0.2
Host is up (0.000064s latency).
All 4701 scanned ports on 172.17.0.2 are closed
MAC Address: 02:42:AC:11:00:02 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 82.19 seconds


$ sudo nmap -sS -p 0-3300 172.17.0.2

Starting Nmap 7.60 ( https://nmap.org ) at 2019-12-27 10:09 CST
Nmap scan report for 172.17.0.2
Host is up (0.000015s latency).
All 3301 scanned ports on 172.17.0.2 are closed
MAC Address: 02:42:AC:11:00:02 (Unknown)

Nmap done: 1 IP address (1 host up) scanned in 3.25 seconds
这就奇怪了，都ping通了，但是不知道是哪个端口？



5) 端口还是不通。
$ telnet 192.168.2.120 8000
Trying 192.168.2.120...
Connected to 192.168.2.120.
Escape character is '^]'.
^C^C^C^C^C
Connection closed by foreign host.

$ telnet 192.168.2.120 7071
Trying 192.168.2.120...
telnet: Unable to connect to remote host: Connection refused


6) 换随机端口呢？
$ sudo docker run -P -d -it -e MYSQL_ROOT_PASSWORD=123456 -v /home/wangjl/dockerFile:/var/lib/mysql dawneve/mysql

$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                     NAMES
02ebf4e44db2        dawneve/mysql       "docker-entrypoint.s…"   3 seconds ago       Up 2 seconds        0.0.0.0:32768->3306/tcp   eager_snyder

$ telnet 192.168.2.120 32768
Trying 192.168.2.120...
telnet: Unable to connect to remote host: Connection refused

$ mysql -h 192.168.2.120 -P32768 -uroot -p
通过了！！

再启动7070端口的容器，也正常了。
麻蛋，问题还是没有解决。这个间歇性bug，又白白耽误我8个小时。



10. 升级docker试试
感觉docker内部mysql没问题，就是外部端口映射出的问题。
(1)
可能是主机端口耗尽了？怎么查？


(2)
1) 查看老版本
$ docker --version
Docker version 18.09.9, build 1752eb3

升级 docker，需要sudo权限
$ curl -fsSL https://get.docker.com/ | sh

升级失败，需要获取google服务器上的代码包。
W: Failed to fetch https://packages.cloud.google.com/apt/dists/cloud-sdk/InRelease  Could not connect to packages.cloud.google.com:443 (2404:6800:4008:801::200e), connection timed out Could not connect to packages.cloud.google.com:443 (172.217.160.110), connection timed out







========================================
|-- docker 报错，可能是升级失败导致的
----------------------------------------
$ docker ps
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?


然后老docker也不能用了，没办法，只好重装docker了。


2)docker的安装和升级
1.删除docker  
sudo apt-get purge docker.io
sudo rm -rf /etc/docker/
sudo apt-get autoremove

2. 安装docker
sudo apt-get update
sudo apt-get upgrade
curl -sSL https://get.docker.com/ | sh

https://blog.csdn.net/Blog_inG/article/details/88963043



3)docker国内镜像源
https://www.daocloud.io/mirror

curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io



4)Ubuntu 使用阿里云 apt仓库安装 docker
如果你已经添加过官网的源 请在/etc/apt/sources.list 最后那几行删掉（有一个是那刚才添加的国外deb源 不然你每次apt update 都会爆一个蛋疼的错Failed to fetch https://apt.dockerproject.org/repo/dists/ubun），然后执行下面的阿里云安装源

$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
## OK 

$ sudo add-apt-repository \
     "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \
     $(lsb_release -cs) \
     stable"
#


5) 可行。又回来了。相当于没有升级。
$ sudo apt-get install docker

$ docker version
Client:
 Version:           18.09.9
#

$ docker --version
Docker version 18.09.9, build 1752eb3



========================================
|-- docker images 存储空间在哪里？占了多大？
----------------------------------------
1. 位置
$ docker info | grep "Docker Root Dir"
WARNING: No swap limit support
 Docker Root Dir: /var/lib/docker

$ cd /var/lib/docker
$ sudo ls -lth


$ sudo ls -lth image/overlay2/imagedb/content/sha256
$ docker images #可看到image id，和上一条一样。

$ sudo ls -aShl overlay2/


2. 怎么查看实际磁盘占有大小？
$ du -s /var/lib/docker/overlay2的最后一行。
或者 $ du -sh /var/lib/docker/overlay2。

或者更human readable的，根据文件大小排序 $ du -sh * | sort -h



ref:https://www.cnblogs.com/allen2333/p/11645140.html





========================================
|-- docker pull 下载不下来怎么办？怎么加速？
----------------------------------------
1. 使用国内镜像
(1)vim /etc/docker/daemon.json文件中加入，这里我加入的是阿里云还有七牛云：
{
  "registry-mirrors": [
  "https://registry.cn-hangzhou.aliyuncs.com",
  "https://reg-mirror.qiniu.com/"
  ]
}

然后重启守护进程
$ systemctl daemon-reload




(2)阿里云-控制台-容器镜像服务：
镜像加速器 
加速器地址 https://cgwjlyc8.mirror.aliyuncs.com


配置镜像加速器
您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器

sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://cgwjlyc8.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker






2. 好用的镜像链接如下：
科大镜像：https://docker.mirrors.ustc.edu.cn/
网易：https://hub-mirror.c.163.com/
阿里云：https://<你的ID>.mirror.aliyuncs.com
七牛云加速器：https://reg-mirror.qiniu.com参考链接：



3. 登录后下载，成功率大增
$ docker login -u 用户名  -p 密码  
$ docker pull ubuntu





4. 下载一个 gcc 编译器的镜像
$ docker pull gcc
$ docker run --rm gcc gcc --version
gcc (GCC) 11.2.0
Copyright (C) 2021 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


$ cat Hello.c
#include<stdio.h>
int main(){
  printf("hello, c!\n");
}


$ docker run --rm -v /home/wangjl/test/cwl_test:/home/wangjl/  gcc gcc /home/wangjl/Hello.c -o /home/wangjl/Hello.out
$ ./Hello.out 
hello, c!


(2) 也可以直接一步执行多个shell语句: bash -c "cmd1 && cmd2"
$ docker run --rm -it ubuntu:20.04 bash -c "cd /etc  && cat hostname"
c802bd5d2030

$ docker run --rm -v /home/wangjl/test/cwl_test:/app/ --workdir=/app  gcc \
bash -c "gcc Hello.c -o a.out && ./a.out"
## hello, c!

-rwxr-xr-x 1 root   root    16K Sep 17 21:51 a.out









========================================
singularity 简介与安装: for HPC
----------------------------------------
1. 简介

(1).Singularity是劳伦斯伯克利国家实验室专门为大规模、跨节点HPC和DL工作负载而开发的容器化技术。具备轻量级、快速部署、方便迁移等诸多优势，且支持从Docker镜像格式转换为Singularity镜像格式。

适合不给 root 权限的环境。

官方文档 https://sylabs.io/docs/
	https://sylabs.io/guides/3.5/user-guide/
仓库 https://singularity-hub.org/
代码 https://github.com/hpcng/singularity
	https://singularity.hpcng.org/

PKU教程: http://hpc.pku.edu.cn/_book/guide/soft_env/Singularity.html




(2).优缺点
https://zhuanlan.zhihu.com/p/126682747

1) Singularity 的优势
Singularity拥有容器技术所包含的大多数优势，例如启动迅速、资源开销小、轻松的迁移和扩展等等。除此之外，相较于Docker这样的容器技术，它还有一些独特的优势：

更加轻松的环境打包迁徙：Singularity所依赖的东西都在镜像文件中，不需要再单独打包 / 导入，直接拷贝走镜像即可。没有复杂的缓存机制，并且该镜像已经过压缩，只需占用非常少的磁盘空间。

和现有系统无缝整合：系统用户权限、网络等均直接继承宿主机配置，并且无需进入某个镜像后再执行命令，可以直接在外部调用镜像内的指令，就像执行一个本地安装的指令一样。

无需运行 daemon 进程：Singularity提供的完全是一个运行时的环境，在不使用时不需要单独的进程，不占用任何资源。不由 daemon 进程代为执行指令，资源限制和权限问题也得以解决。


官网说的优点：https://sylabs.io/singularity/
- A secure, single-file based container format: 一个单文件的镜像格式。
- Support for data-intensive workloads: 架起了HPC与AI、DL/ML、预测分析的桥梁。
- Extreme mobility: 使用标准文件和对象复制工具来 转移、共享、分发Singularity 容器。每个Singularity 终端都可以运行该容器。
- Compatibility: 兼容几乎任何环境
- Simplicity: 如果可以使用 Linux，就可以使用 Singularity
- Security: 屏蔽容器内权限提升，使用不可修改的单文件镜像格式来做签名和验证。
	allowing untrusted users to run untrusted containers in a trusted way.
- User groups: 
	https://github.com/sylabs
	https://groups.google.com/g/singularity-ce
	https://join.slack.com/t/singularityce/shared_invite/zt-t28zjurl-UnsNlmoggF7DcpMrKSR7Fw



2) Singularity 的缺点
上面提到了很多优势，但 singularity 也并非绝对完美的。

缺少网络虚拟化的支持
目前未实现 PID Namespace
认知度较低
由于众所周知的原因在国内下载镜像比较困难








2. 安装 (挺不好安装的)
(0) 安装 try1 尝试失败
## 安装依赖
$ sudo apt-get install -y build-essential libseccomp-dev pkg-config squashfs-tools cryptsetup
## $ sudo yum install -y gcc libuuid-devel squashfs-tools openssl-devel

## Install Golang 安装go (我安装过了)
export VERSION=1.13 OS=linux ARCH=amd64   
wget https://dl.google.com/go/go$VERSION.$OS-$ARCH.tar.gz 
tar -C /usr/local -xzvf go$VERSION.$OS-$ARCH.tar.gz
rm -f go$VERSION.$OS-$ARCH.tar.gz 
echo 'export PATH=/usr/local/go/bin:$PATH' >> /etc/profile
source /etc/profile

## 安装Singularity，这里的安装版本为3.5.2
$ git clone https://github.com/singularityware/singularity.git
$ cd singularity
$ git checkout v3.8.0  #现在的稳定版，查官网 https://sylabs.io/docs/

## ./configure --prefix=/usr/local --sysconfdir=/etc
$ ./mconfig
$ cd builddir
$ make  ## 很慢 21:12 --> IO超时

GEN GO DEP /data/wangjl/soft/singularity/builddir/starter.d
go: github.com/AdamKorcz/go-fuzz-headers@v0.0.0-20210319161527-f761c2329661: Get https://proxy.golang.org/github.com/%21adam%21korcz/go-fuzz-headers/@v/v0.0.0-20210319161527-f761c2329661.mod: dial tcp 172.217.24.17:443: i/o timeout
安装失败！！ //todo

$ sudo make install
$ cd ../..
$ rm -rf singularity*
可以删除刚才下载的安装文件夹了。
singularity version




(1) try2: 使用虚拟机中的 ubuntu20.04 再次安装
$ wget https://github.com/sylabs/singularity/releases/download/v3.8.3/singularity-ce-3.8.3.tar.gz
-rw-rw-r--  1 wangjl wangjl 8.1M Sep  2 01:25 singularity-ce-3.8.3.tar.gz

$ tar zxvf singularity-ce-3.8.3.tar.gz 
$ cd singularity-ce-3.8.3/
$ vim README.md 
安装请看 INSTALL.md
$ vim INSTALL.md


1)安装开发工具和包
$ sudo apt-get update

$ sudo apt-get install -y build-essential \
  libseccomp-dev pkg-config squashfs-tools cryptsetup

报错:The following information may help to resolve the situation:

The following packages have unmet dependencies:
 build-essential : Depends: libc6-dev but it is not going to be installed or
                            libc-dev
                   Depends: g++ (>= 4:7.2) but it is not going to be installed
                   Depends: dpkg-dev (>= 1.17.11) but it is not going to be installed
 libseccomp-dev : Depends: libseccomp2 (= 2.5.1-1ubuntu1~18.04.1) but 2.5.1-1ubuntu1~20.04.1 is to be installed
E: Unable to correct problems, you have held broken packages.  ##这是个啥？

虚拟机恢复Ubuntu20.04到出厂设置，使用原版源安装一切正常。
莫名其妙... 可能是源在同步中？之前的源是tsinghua，现在是默认cn.ubuntu源。


2) 安装Go语言 install and configure golang: https://golang.org/doc/install
$ sudo apt install golang-go

$ which go
/usr/bin/go

$ go version
go version go1.13.8 linux/amd64

3) 回去安装
$ cd singularity-ce-3.8.3/
$ ./mconfig && \
  cd ./builddir && \
  make  ##特别耗时，30min?
$ sudo make install #也耗时很久

4) 检查版本号
$ singularity --version
singularity-ce version 3.8.3

表示安装成功。



(2) 查看帮助
$ singularity --version
singularity-ce version 3.8.3

$ singularity
$ singularity --help
Linux container platform optimized for High Performance Computing (HPC) and Enterprise Performance Computing (EPC)
Usage: singularity [global options...]
Description:
  Singularity containers provide an application virtualization layer enabling mobility of compute via both application and environment portability. 
	Singularity 容器提供了一个应用程序虚拟化层，通过应用程序和环境的可移植性来支持计算的可移植性。
  With Singularity one is capable of building a root file system that runs on any other Linux system where Singularity is installed.
	我们可以用Singularity建立一个根文件系统，然后在所有安装Singularity的linux下运行。

Available Commands:
  build       Build a Singularity image
  pull        Pull an image from a URI
  run         Run the user-defined default command within a container
  inspect     Show metadata for an image
  exec        Run a command within a container
  search      Search a Container Library for images
  sif         Manipulate Singularity Image Format (SIF) images
For additional help or support, please visit https://www.sylabs.io/docs/








========================================
|-- singularity 使用方法和镜像构建
----------------------------------------
3. 使用 
(1) 一个很小的镜像 ubuntu:20.04 | OK
https://blog.csdn.net/kongxx/article/details/97965609

$ docker pull ubuntu:20.04


1) 生成 sif 镜像
获取预编译镜像 （会在当前目录下下载 ubuntu_<tag>.sif 文件）
$ singularity pull docker://ubuntu:20.04  #虽然docker下过，还要下载

从 Docker Hub build 镜像
$ singularity -d build ubuntu.sif docker://ubuntu:20.04 #很多屏的输出，没看出是否下载

从本地缓存生成 镜像
$ singularity build ubuntu_20.04-v2.sif docker-daemon://ubuntu:20.04


从镜像tar文件开始
$ docker save ubuntu:20.04 -o ubuntu20.04.tar
-rw------- 1 wangjl wangjl  72M Sep 16 15:15 ubuntu20.04.tar

$ singularity build ubuntu_20.04-v3.sif docker-archive://ubuntu20.04.tar




结果4个文件 大小一样，md5互不一样。
-rwxr-xr-x 1 wangjl wangjl  27M Sep 16 10:55 ubuntu.sif
-rwxrwxr-x 1 wangjl wangjl  27M Sep 16 10:53 ubuntu_20.04.sif
-rwxr-xr-x 1 wangjl wangjl  27M Sep 16 15:10 ubuntu_20.04-v2.sif
-rwxr-xr-x 1 wangjl wangjl  27M Sep 16 15:16 ubuntu_20.04-v3.sif





2) 交互模式运行 singularity shell
  shell       Run a shell within a container

$ singularity shell ubuntu_20.04.sif
Singularity> pwd
/home/wangjl
Singularity> id
uid=1000(wangjl) gid=1000(wangjl) groups=1000(wangjl),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare),134(docker)

Singularity> vim ReadMe 
bash: vim: command not found
Singularity> ping baidu.com
bash: ping: command not found
Singularity> exit
exit

怎么看着就是宿主机呢？目录是，用户也是。
宿主的命令ping, vim, 内部没有。
难道只是虚拟的命令环境，但是文件系统还是宿主机的？如果这样，就特别适合做 java/C的编译了!



3) 执行一个命令并退出 singularity exec
  exec        Run a command within a container

$ singularity exec ubuntu.sif bash -c  "pwd && id" 
/usr/bin/bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
/home/wangjl
uid=1000(wangjl) gid=1000(wangjl) groups=1000(wangjl),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare),134(docker)
$


4)运行一个容器 singularity run，感觉和 shell 一样，只不过最后不用放命令了。
  run         Run the user-defined default command within a container

$ singularity run ubuntu.sif
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
Singularity> pwd
/home/wangjl
Singularity> groups
wangjl adm cdrom sudo dip plugdev lpadmin lxd sambashare docker
Singularity> exit
exit
$ 


在内部写一个文件 01.txt
$ singularity run ubuntu.sif
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
Singularity> echo "line1">01.txt
Singularity> exit
exit
$ cat 01.txt 
line1

$ ls -lth
total 184M
-rw-rw-r-- 1 wangjl wangjl    6 Sep 16 11:11 01.txt


5) 后台运行容器实例
  instance    Manage containers running as services

启动实例
$ singularity instance start ubuntu.sif test1
$ singularity instance start ubuntu.sif test2

查看实例：只有IP，没有端口列 (类似于docker ps)
$ singularity instance list
INSTANCE NAME    PID      IP    IMAGE
test1            62541          /home/wangjl/ubuntu.sif
test2            62581          /home/wangjl/ubuntu.sif

操作实例
可以通过 shell, exec, run 命令来连到容器中运行命令

使用 shell 命令连入容器
$ singularity shell instance://test1
Singularity> cat 01.txt 
line1
Singularity> exit
exit

使用 exec 执行命令
$ singularity exec instance://test2 cat 01.txt
line1

停止实例
$ singularity instance stop test1
$ singularity instance stop test2
关闭（并删除）容器，更像是 docker stop + docker rm，所以轻易不要stop，只用 exit 就行了。



6) 绑定目录 -B 
在 Singularity 中也可以在 shell, run, instance.start 等命令中通过 “-B” 选项来实现 Docker 中 “-v” 选项提供挂载卷的功能，比如：
$ singularity shell -B /apps:/apps ubuntu.sif

挂在多个用逗号隔开：  -B /home/tom:/home/tom,/home/tom/dataset:/home/dataset \


$ singularity shell --help
Run a shell within a container

  -B, --bind strings           a user-bind path specification.  
		spec has the format src[:dest[:opts]], where src and dest are outside and inside paths.  路径内外的映射？
		If dest is not given, it is set equal to src. 
		Mount options ('opts') may be specified as 'ro' (read-only) or 'rw' (read/write, which is the default). Multiple bind paths can be given by a comma separated list.

$ singularity shell -B /tmp:/apps ubuntu.sif
Singularity> ls -lth /apps #虚拟的目录
total 48K
drwx------ 2 wangjl wangjl 4.0K Sep 16 11:11 tracker-extract-files.1000
Singularity> exit
exit

$ ls -lth /tmp #宿主机的目录
total 48K
drwx------ 2 wangjl wangjl 4.0K Sep 16 11:11 tracker-extract-files.1000




7) --fakeroot 啥意思？在容器内有root权限
The --fakeroot option is available with the following singularity commands:
shell
exec
run
instance start
build

$ singularity exec --fakeroot docker://ubuntu:20.04 ls -lth








(2) 运行一个试试 mysql 镜像 | ok，不支持端口映射
https://uh.edu/rcdc/resources/software/Singularity.php

1) Get the docker image and convert it to singularity image,
$ singularity pull docker://dawneve/mysql  #不好，singularity 没法做端口映射
INFO:    Converting OCI blobs to SIF format
INFO:    Starting build...
Getting image source signatures
Copying blob d08a2c3112d4 done 
...
Writing manifest to image destination
Storing signatures
2021/09/16 10:13:20  info unpack layer: sha256:d08a2c3112d431c43e02458a285501d289333380438e760962619c8672bcbe0b
...
INFO:    Creating SIF file...

$ ls -lth
total 131M
-rwxrwxr-x 1 wangjl wangjl 131M Sep 16 10:17 mysql_latest.sif


2) To open an interactive shell inside the container,
$ singularity shell mysql_latest.sif
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
Singularity> mysql -V
mysql  Ver 14.14 Distrib 5.7.18, for Linux (x86_64) using  EditLine wrapper

Note: The project directory by default mounts to /mnt instead of /project
貌似不适合这种带端口映射的情况。

3) To directly execute a command inside your container environment,
## singularity exec shub://singularityhub/ubuntu cat /etc/os-release

$ pwd 
/home/wangjl/data/dbFile

$ mkdir -p ${PWD}/mysql/var/lib/mysql ${PWD}/mysql/run/mysqld
$ singularity instance start --bind ${HOME} \
    --bind ${PWD}/mysql/var/lib/mysql/:/var/lib/mysql \
    --bind ${PWD}/mysql/run/mysqld:/run/mysqld \
    mysql_latest.sif mysql
## INFO:    instance started successfully

$ singularity instance list
INSTANCE NAME    PID     IP    IMAGE
mysql            3115          /home/wangjl/data/dbFile/mysql_latest.sif


$ singularity run instance://mysql #报错
error: database is uninitialized and password option is not specified 
  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD
这个报错怎么解决？
docker的-e参数，这里是什么？是 --env 
$ singularity run --env MYSQL_ROOT_PASSWORD=123456  instance://mysql


4) 连接该数据库，并新建库和表
$ ifconfig #查宿主机的ip
192.168.2.242
不支持端口映射，那就是 3306 端口本身了。

$ mysql -h 192.168.2.242 -P 3306 -uroot -p
mysql> create database wang;
mysql> use wang;
Database changed

CREATE TABLE `think_weibo` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `uid` int(20) NOT NULL,
  `content` text,
  `add_time` varchar(30) DEFAULT NULL,
  `cid` int(10) DEFAULT NULL,
  `archive` int(10) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into think_weibo values(1,101,"ctx1", "20210901",1, 0),(2,202,"ctx2", "20210902",2, 1);

mysql> select * from think_weibo;
+----+-----+---------+----------+------+---------+
| id | uid | content | add_time | cid  | archive |
+----+-----+---------+----------+------+---------+
|  1 | 101 | ctx1    | 20210901 |    1 |       0 |
|  2 | 202 | ctx2    | 20210902 |    2 |       1 |
+----+-----+---------+----------+------+---------+
2 rows in set (0.00 sec)

mysql> exit
Bye


查看文件
$ ls -lth dbFile/mysql/var/lib/mysql/wang
total 112K
-rw-r----- 1 wangjl wangjl  96K Sep 16 16:32 think_weibo.ibd
-rw-r----- 1 wangjl wangjl 8.6K Sep 16 16:29 think_weibo.frm
-rw-r----- 1 wangjl wangjl   65 Sep 16 16:28 db.opt


5) 退出该容器
$ singularity instance stop mysql
INFO:    Stopping mysql instance of /home/wangjl/data/dbFile/mysql_latest.sif (PID=3115)










(3) 再试试 java 的镜像 | ok
#############
先安装一个 docker 
$ sudo apt install docker.io
$ docker --version
Docker version 20.10.7, build 20.10.7-0ubuntu1~20.04.1

$ sudo groupadd docker #添加docker用户组
$ sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中
Adding user wangjl to group docker

$ newgrp docker #更新用户组
$ groups 

$ sudo vim /etc/docker/daemon.json 
{
  "registry-mirrors": [
    "http://hub-mirror.c.163.com",
    "https://registry.cn-hangzhou.aliyuncs.com"
  ]
}

$ sudo systemctl daemon-reload #重启守护进程
$ sudo systemctl restart docker

$ docker login -u dawneve 
输入密码，登录。
$ docker pull openjdk:9.0.1-11-slim

$ docker images
REPOSITORY   TAG             IMAGE ID       CREATED       SIZE
openjdk      9.0.1-11-slim   5149033ba93d   3 years ago   374MB

$ pwd
/home/wangjl/test

$ cat Hello.java
public class Hello { 
	public static void main(String args[])  {    
		System.out.println("Hello world, from Java!");  
	}
}

$ docker run --rm -v /home/wangjl/test:/test/ openjdk:9.0.1-11-slim bash -c 'cd /test/ && javac Hello.java && java Hello'
Hello world, from Java!
#############


1) 从本地缓存的镜像构建 sif 文件
$ singularity build openjava9-v1.sif docker-daemon://openjdk:9.0.1-11-slim
注意：从原来的docker变成了docker-daemon；必须加tag标签；

报错：是不是也是空间不够？很可能是临时文件夹不够大
INFO:    Creating SIF file...
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0xa8 pc=0x5631607d5e9a]


防止撑爆 /tmp 临时文件夹:
$ TMPDIR=$PWD singularity build openjava9-v1.sif docker-daemon://openjdk:9.0.1-11-slim
INFO:    Build complete: openjava9-v1.sif


2) 从 tar 文件生成 sif 
$ docker save openjdk:9.0.1-11-slim -o jdk9.tar
$ singularity build openjdk9-v2.sif docker-archive://jdk9.tar

生成的文件大小一样，md5不同
-rwxr-xr-x 1 wangjl wangjl 174M Sep 16 15:40 openjava9-v1.sif
-rwxr-xr-x 1 wangjl wangjl 174M Sep 16 15:36 openjdk9-v2.sif

编译和运行
$ singularity run -B /home/wangjl/test:/app/  openjava9-v1.sif bash
Singularity> cd /app
Singularity> javac Hello.java
Singularity> java Hello 
Hello world, from Java!
Singularity> exit
exit

$ ls -lht #注意所有人和组的区别
total 12K
-rw-rw-r-- 1 wangjl wangjl 427 Sep 16 15:45 Hello.class #在 Singularity 中生成的
-rw-r--r-- 1 root   root   427 Sep 16 14:58 Hello.class2 #在docker中生成的，改名2


或者执行一行命令
$ singularity exec -B /home/wangjl/test:/app/ --workdir=/app openjava9-v1.sif bash -c "cd /app && ls -lth"
/usr/bin/bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
total 12K
-rw-rw-r-- 1 wangjl wangjl 427 Sep 16 15:45 Hello.class
-rw-r--r-- 1 root   root   427 Sep 16 14:58 Hello.class2
-rw-rw-r-- 1 wangjl wangjl 134 Sep 16 14:57 Hello.java













4. 生成 sif 镜像的方法

(1) build可以生成两种不同格式的容器，具体如下。
- 适用于生产环境使用的压缩只读Singularity Image File (SIF) 格式 (默认)
- 适用于交互式开发的根目录可写的沙盒 (–sandbox)



(2) Singularity可以方便地处理Docker镜像
https://singularity.hpcng.org/user-docs/master/build_a_container.html
https://blog.csdn.net/weixin_44843824/article/details/119715691


方式1：从docker uri开始
$ singularity pull docker://godlovedc/lolcow # 下载pre-built image，如果没有呢？和下一个一样
$ singularity build mylolcow_latest.sif docker://godlovedc/lolcow # 下载后再build成镜像


方式2：从本地缓存的docker image开始
假设本地有godlovedc/lolcow镜像
$ sudo docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
godlovedc/lolcow    latest              577c1fe8e6d8        16 months ago

$ singularity build lolcow_from_docker_cache.sif docker-daemon://godlovedc/lolcow:latest
注意: 从原来的docker变成了docker-daemon；



方式3：从镜像tar文件开始
首先需要将docker镜像转成tar文件：
先查看当前的docker镜像
$ sudo docker images
REPOSITORY           TAG              IMAGE ID       CREATED        SIZE  
hello-world          latest           d1165f221234   5 months ago   13.3kB

使用如下命令将hello-world镜像转成tar文件，这里save后面的参数就是IMAGE ID，即上面输出的第三列
$ sudo docker save d1165f221234 -o hello_world.tar
这样当前目录下面就出现了hello_world.tar文件。

接着，将该tar文件转成singularity镜像，命令与输出如下：
$ singularity build hello_world.sif docker-archive://hello_world.tar
INFO:    Build complete: hello_world.sif

原本的docker://换成了docker-archive://，方式2里面是docker-daemon://；
这里用的是tar文件，singularity也可以处理tar.gz文件。




(3) 从定义文件构建

1) 定义文件
$ cat nginx.def
Bootstrap: docker
From: nginx
Includecmd: no

%startscript
   nginx

执行构建：
$ sudo singularity build nginx.sif nginx.def #必须使用root权限
-rwxr-xr-x 1 wangjl wangjl  50M Sep 16 16:54 nginx.sif


2)测试 
$ singularity instance start --writable-tmpfs nginx.sif web 
$ curl localhost
curl: (7) Failed to connect to localhost port 80: Connection refused
#网页不能访问，curl也不行，可能默认的80端口被封了？测试发现，加sudu就好了。

$ singularity instance list
INSTANCE NAME    PID     IP    IMAGE
web              3578          /home/wangjl/data/nginx.sif
$ singularity instance stop web


3) 修改配置文件，改端口，再次测试
查配置文件的位置
$ singularity shell nginx.sif 
Singularity> cat /etc/nginx/conf.d/default.conf | grep -i root
        root   /usr/share/nginx/html;
Singularity> exit
exit


自定义配置文件：
$ cat nginx.config 
server {
    listen       8008;
    listen  [::]:8008;
    server_name  localhost;
    #access_log  /var/log/nginx/host.access.log  main;
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
		
        # list files
        autoindex on; 
        autoindex_exact_size on; 
        autoindex_localtime on; 
    }
}

不加sudo访问不了。可能是网络、端口是系统资源，必须特权用户才能调用。
$ sudo singularity instance start -B /home/wangjl/data/nginx.config:/etc/nginx/conf.d/default.conf --writable-tmpfs nginx.sif web 

$ sudo singularity instance list
INSTANCE NAME    PID     IP    IMAGE
web              4457          /data/wangjl/nginx.sif
$ sudo singularity instance stop web








5. 生信常用的镜像
(1) 从github 上找
https://singularityhub.github.io/singularity-hpc/

https://github.com/pscedu/singularity-bowtie2
https://github.com/pscedu/singularity-samtools
https://singularityhub.github.io/singularity-hpc/r/biocontainers-samtools/


(2) 命令行搜索
$ singularity search samtools
Found 15 container images for amd64 matching "samtools":

	library://alesr13/default/samtools_bwa_picard:v0.1
		Signed by: 6e23de6eac622dd1d96f304af7b50e57f44404e7

	library://btmiller/default/testimg-bowtie2-samtools:latest

	library://daanjg98/rnaseq/samtools:1.11

从搜索结果中选一个靠谱的，建立sif镜像
$ TMPDIR=$PWD singularity build samtools.sif library://daanjg98/rnaseq/samtools:1.11
INFO:    Build complete: samtools.sif
-rwxr-xr-x 1 wangjl wangjl 170M Sep 16 17:43 samtools.sif


查看版本号:
$ singularity exec samtools.sif samtools --version
samtools 1.11
Using htslib 1.11
Copyright (C) 2020 Genome Research Ltd.

据说还能这样执行：
$ ./samtools.sif samtools --version
samtools 1.11
Using htslib 1.11
Copyright (C) 2020 Genome Research Ltd.


拷贝过来一个 bam 文件 

不认识其他目录，只认识 $HOME 目录。
$ ls /data
lost+found  wangjl

$ singularity exec samtools.sif bash
bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
Singularity> cd /data
bash: cd: /data: No such file or directory
Singularity> ls /|grep data

Singularity> cd ~/test
Singularity> samtools view cgm-90.sort.bam | wc
  57814  994108 22848219
Singularity> exit
exit


容器启动时所在的工作目录
$ singularity exec samtools.sif pwd 
/home/wangjl

完整运行模式: 要使用完整路径:
$ singularity exec samtools.sif samtools view ~/test/cgm-90.sort.bam | wc -l #57814

一句话运行
$ ./samtools.sif samtools view ~/test/cgm-90.sort.bam | wc -l  #57814






6. 疑难杂症：
(1) 临时文件夹 /tmp 装不下怎么办？
$ TMPDIR=$PWD singularity build openjdk9-V2.sif docker-archive://jdk9.tar #能改变临时文件夹位置的命令









ref:
http://hpc.pku.edu.cn/_book/guide/soft_env/Singularity.html
经典常用命令[推荐] https://blog.csdn.net/kongxx/article/details/97965609
构建镜像 https://zhuanlan.zhihu.com/p/138806519
https://biocorecrg.github.io/ELIXIR_containers_nextflow/singularity.html

官方服务文档 https://singularity.hpcng.org/user-docs/master/running_services.html#nginx-hello-world-in-singularity





========================================
|-- 使用 docker 生成 singularity 镜像
----------------------------------------
使用场景：
对于不支持 docker 的机器，怎么获取 sif 镜像呢？
可以在另一台主机上生成，由于 singularity 安装很困难，如果仅安装 docker 怎么生成 sif 文件呢？


1. 搜了一下 
$ docker search singularity
NAME                                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
singularityware/docker2singularity             docker2singularity                              4                    [OK]
singularityware/singularity                    docker base images to provide release versio…   2                    [OK]
arcts/singularity-util                         A multi-purpose Docker based container that …   2                    [OK]
alfpark/singularity                            Singularity Images                              1                    [OK]

貌似第一个可以试试，看一下可用的tag有哪些
$ curl -L -s https://registry.hub.docker.com/v1/repositories/singularityware/docker2singularity/tags
==> chrome F12 console:
t2=[...] curl 输出的结果。
for(var i=0; i<t2.length; i++){console.log(t2[i].name)}
输出:
1.10
1.11
1.12
1.13
v2.3
v2.4
v2.5
v2.6
v2.6.0
v3.1
v3.2.1
v3.3.0
v3.4.0
latest

为了保证可重复性，我们就下载最新的版本号
$ docker pull singularityware/docker2singularity:v3.4.0

在下载一个 nginx，mysql，并尝试生成其sif文件
$ docker pull nginx 

$ docker images
REPOSITORY                           TAG       IMAGE ID       CREATED        SIZE
nginx                                latest    ad4c705f24d3   9 days ago     133MB
mysql                                latest    0716d6ebcc1a   2 weeks ago    514MB
dawneve/rstudio                      latest    9e22c8cd092b   7 months ago   1.95GB
singularityware/docker2singularity   v3.4.0    9506680afdf6   2 years ago    350MB




(1) docker导出为tar文件，看来不需要这一步了。
$ docker save nginx:latest -o nginx.tar
-rw-------    1 root     root      131.2M Sep 19 07:46 nginx.tar




(2) 尝试转换
找到官方教程: 说这个docker过期了，官方不让他们再放新镜像了。可能是竞争。
https://hub.docker.com/r/singularityware/docker2singularity

$ docker run \
-v /var/run/docker.sock:/var/run/docker.sock \
-v /root/wangjl:/output \
--privileged -t --rm \
singularityware/docker2singularity \
nginx:latest

生成一个 simg 镜像文件，是一个老的格式。





(3) 最新的在哪里呢？转到一个新的网站了
https://quay.io/repository/singularity/docker2singularity
https://quay.io/repository/singularity/docker2singularity?tab=tags 最新的版本是 v3.8.3

$ docker pull docker pull quay.io/singularity/docker2singularity

$ docker tag quay.io/singularity/docker2singularity dawneve/docker2singularity
$ docker rmi quay.io/singularity/docker2singularity

试试这个最新版
$ docker run \
-v /var/run/docker.sock:/var/run/docker.sock \
-v /root/wangjl:/output \
--privileged -t --rm \
dawneve/docker2singularity \
nginx:latest

产出的文件:
-rwxr-xr-x    1 root     root       49.3M Sep 19 08:07 nginx_latest-2021-09-09-5f214b8ed419.sif

$ mv nginx_latest-2021-09-09-5f214b8ed419.sif nginx.sif


如果是windows，这样写: -v D:\host\path\where\to\output\singularity\image:/output \




(4) 运行 sif 文件
$ docker pull quay.io/singularity/singularity:v3.8.3
$ docker run --rm -it -v /root/wangjl/:/app --workdir=/app quay.io/singularity/singularity:v3.8.3 version
3.8.3

$ docker run --rm -it -v /root/wangjl/:/app --workdir=/app quay.io/singularity/singularity:v3.8.3 instance list 
INSTANCE NAME    PID    IP    IMAGE


报错:
$ docker run --rm -it -v /root/wangjl/:/app --workdir=/app quay.io/singularity/singularity:v3.8.3 run nginx.sif pwd











####################################
带远程桌面的镜像 Desktop as a Container
https://quay.io/repository/rarm_sa/daac
$ docker pull quay.io/rarm_sa/daac
$ docker tag quay.io/rarm_sa/daac daac

https://github.com/snowjet/DaaC
不知道怎么用。










========================================
容器编排： Kubernetes(k8s) 简介 与 CRI //todo
----------------------------------------
前置知识: Linux和Docker基本使用熟练掌握，一门后端语言 Java or Python.


1. 简介

Kubernetes是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。

Kubernetes一个核心的特点就是能够自主的管理容器来保证云平台中的容器按照用户的期望状态运行着（比如用户想让apache一直运行，用户不需要关心怎么去做，Kubernetes会自动去监控，然后去重启，新建，总之，让apache一直提供服务），管理员可以加载一个微型服务，让规划器来找到合适的位置，同时，Kubernetes也系统提升工具以及人性化方面，让用户能够方便的部署自己的应用（就像canary deployments）。


(2) K8s 只能与 CRI 运行时通信。
K8s 是通过 docker-shim 作为桥接服务，将 CRI 转换为 Docker API，然后与 Dokcer 进行通信的。
CRI 运行时是啥？我们暂可以简单的将 Ta 理解为与 Docker 同等的存在（另外一个容器容器运行时）。
	CRI（Container Runtime Interface）是 K8s 定义的一组与容器运行时进行交互的接口，用于将 K8s 平台与特定的容器实现解耦。
在 K8s 早期的版本中，对于容器环境的支持是通过 hard code 方式直接调用 Docker API 的，后来为了支持更多的容器运行时和更精简的容器运行时，K8s 提出了CRI。

实际对容器的操作最终还是要交给 OCI，CRI 也只是个中转。





2. 课程与教程

(1) 文字版

1) Kubernetes 是用于自动部署，扩展和管理容器化应用程序的开源系统。
https://kubernetes.io/zh/
它将组成应用程序的容器组合成逻辑单元，以便于管理和服务发现。Kubernetes 源自Google 15 年生产环境的运维经验，同时凝聚了社区的最佳创意和实践


2)
https://www.kubernetes.org.cn/k8s
https://www.kubernetes.org.cn/



(2) 视频版
1) https://coding.imooc.com/class/198.html
聚焦Kubernetes和Docker，精讲服务编排
以循序渐进带入的方式，解决kubernetes“入门门槛高、学习曲线陡”的难题

## Docker官方支持Kubernetes， Kubernetes是容器编排最大赢家
Kubernetes 以其高效、简便、高水平的可移植性等优势占领了绝大部分市场，江湖一哥地位毋庸置疑
脱胎于谷歌的成熟的Borg，围绕Kubernetes的生态正不断完善
容器编排Kubernetes是最有未来的，要学就学它




========================================
理解OCI（Open Container Initiative）及docker的OCI实现
----------------------------------------
1. 今天看到 htop 中有一个 root 运行的 run init 命令。
搜了一下，貌似与容器有关。


(2) runC是一个遵循OCI标准的用来运行容器的命令行工具(CLI Tool)，它也是一个Runtime的实现。尽管你可能对这个概念很陌生，但实际上，你的电脑上的docker底层可能正在使用它。至少在笔者的主机上是这样。


$ sudo docker info
...
 Runtimes: runc
 Default Runtime: runc
 Init Binary: docker-init
...

(3) runC由Go语言实现。






2. OCI定义了容器运行时标准，runC是Docker按照开放容器格式标准（OCF, Open Container Format）制定的一种具体实现。

runC是从Docker的libcontainer中迁移而来的，实现了容器启停、资源隔离等功能。Docker默认提供了docker-runc实现，事实上，通过containerd的封装，可以在Docker Daemon启动的时候指定runc的实现。

我们可以通过启动Docker Daemon时增加--add-runtime参数来选择其他的runC 实现。

containerd向上为Docker Daemon提供了gRPC接口，使得Docker Daemon屏蔽下面的结构变化，确保原有接口向下兼容。向下通过containerd-shim结合runC，使得引擎可以独立升级，避免之前Docker Daemon升级会导致所有容器不可用的问题。

Docker一开始就一家独大，并且并不是一种开放的态姿态在做，所以很早之前Google就投资了CoreOS来做竞争的容器--Rocket。那时是三家鼎立：Docker/Rocket/Warden，为了避免惨烈的竞争，大家终于统一意见，决定成立OCI做统一的容器运行时---RunC，OCI成立后加入了大约50家厂商。出于对Docker封闭化商业式发展的担心，OCI商讨出这种方案：以RunC为核心重新构建生态圈，并且通过插件来弱化容器在CaaS生态圈的重要性。



(2) 官网解释 Open Container Initiative
https://opencontainers.org/
该标准是为了
	- 创建容器格式 image-spec
	- 运行时格式 runtime-spec

The Open Container Initiative is an open governance structure for the express purpose of creating open industry standards around container formats and runtimes.

Established in June 2015 by Docker and other leaders in the container industry, the OCI currently contains two specifications: the Runtime Specification (runtime-spec) and the Image Specification (image-spec). The Runtime Specification outlines how to run a “filesystem bundle” that is unpacked on disk. At a high-level an OCI implementation would download an OCI Image then unpack that image into an OCI Runtime filesystem bundle. At this point the OCI Runtime Bundle would be run by an OCI Runtime.









ref:
探索runC (上) https://segmentfault.com/a/1190000017543294
探索runC (下) https://blog.csdn.net/weixin_33744141/article/details/88705609





========================================
使用nsenter进入docker容器的命名空间
----------------------------------------
1. 背景和作用
docker exec 是进入容器内部。
nsenter 是一个可以用来进入到目标程序所在 namespace 中运行命令的工具，一般可以用于在容器外 debug 容器中运行的程序。

一个最典型的用途就是进入容器的网络命令空间。
容器一般比较简化，没有网络调试工具，比如说ip address，ping，telnet，ss，tcpdump等等命令，可以使用 nsenter 进入容器所在命名空间，使用宿主机的命令进行调试。

此外，nsenter也可以进入mnt, uts, ipc, pid, user命令空间，以及指定根目录和工作目录。


(2) 安装
util-linux 是一个开放源码的软件包，是一个对任何 Linux 系统的基本工具套件。含有一些标准 Unix 工具，如 login。
util-linux 软件包包含许多工具。其中比较重要的是加载、卸载、格式化、分区和管理硬盘驱动器，打开 tty 端口和得到内核消息。

$ sudo yum install -y util-linux


我忘了ubuntu是怎么安装的了，版本
$ nsenter --version
nsenter from util-linux 2.34





2. 使用

$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
ubuntu       latest    fb52e22af1b0   3 weeks ago   72.8MB

$ docker run --rm -it -d ubuntu bash
2e7529

$ docker run --rm -it -d ubuntu bash
cc1ff


(1) 查看帮助
$ nsenter --help
Usage:
 nsenter [options] [<program> [<argument>...]]
Run a program with namespaces of other processes.

Options:
 -a, --all              enter all namespaces
 -t, --target <pid>     target process to get namespaces from
 -m, --mount[=<file>]   enter mount namespace
 -u, --uts[=<file>]     enter UTS namespace (hostname etc)
 -i, --ipc[=<file>]     enter System V IPC namespace
 -n, --net[=<file>]     enter network namespace
 -p, --pid[=<file>]     enter pid namespace
 -C, --cgroup[=<file>]  enter cgroup namespace
 -U, --user[=<file>]    enter user namespace
 -S, --setuid <uid>     set uid in entered namespace
 -G, --setgid <gid>     set gid in entered namespace
     --preserve-credentials do not touch uids or gids
 -r, --root[=<dir>]     set the root directory
 -w, --wd[=<dir>]       set the working directory
 -F, --no-fork          do not fork before exec'ing <program>
 -Z, --follow-context   set SELinux context according to --target PID

 -h, --help             display this help
 -V, --version          display version


(2) 简单实例
在使用nsenter命令之前需要获取到docker容器的进程，然后再使用nsenter工具进去到docker容器中
每一个容器都有.State.Pid，所以这个命令除了容器的id需要我们根据docker ps -a去查找，其他的全部为固定的格式

$ docker inspect -f {{.State.Pid}} 容器名或者容器id 

比如: 
$ docker inspect -f {{.State.Pid}} 2e7529
24226

$ ps -aux | grep 24226
root       24226  0.0  0.1   4116  3360 pts/0    Ss+  20:39   0:00 bash

输入该命令便进入到容器中
$ nsenter --target 上面查到的进程id --mount --uts --ipc --net --pid 
解释nsenter指令中进程id之后的参数的含义： 
-mount参数是进去到mount namespace中  （文件系统）
-uts参数是进入到uts namespace中  （主机名与域名）
-ipc参数是进入到System V IPC namaspace中  （信号量、消息队列和共享内容）
-net参数是进入到network namespace中   （网络设备、网络栈、端口）
-pid参数是进入到pid namespace中    （进程编号）
-user参数是进入到user namespace中 （用户和用户组）

$ sudo nsenter --target 24226 --mount --uts --ipc --net --pid 
root@2e7529203bbb:/# ls /data
ls: cannot access '/data': No such file or directory
root@2e7529203bbb:/# exit
logout
$ ls /data
lost+found  wang

说明在容器内部无法访问 /data 目录。

进入进程的命名空间了，就可以愉快的抓包了。 how?




(3) docker隔离应用应用涉及到的六大名称空间
1)、pid 命名空间(进程ID)
不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为 Docker 进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。

2)、net 命名空间(网络)
有了 pid 命名空间，每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备，IP 地址，路由表，/proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。

3)、ipc 命名空间(进程间通信)
容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC)， 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。

4)、mnt 命名空间(挂载文件系统)
类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。

5)、UTS 命名空间(主机名/域名)
UTS("UNIX Time-sharing System") 命名空间允许每个容器拥有独立的 hostname 和 domain name， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。

6)、user 命名空间(用户)
每个容器可以有不同的用户和组 id， 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。





(4) 查看docker的连接
由于使用DOCKER的时候，ESTABLISHED连接不会出现在netstat中，在运行中的docker容器中列出打开的套接字的方法 ,查找docker的进程号 ：

$ docker inspect -f'{{.State.Pid}}' <containerid>  
$ docker inspect -f'{{.State.Pid}}' 2e75 
24226

查看连接： 
$ sudo nsenter -t <pid> -n netstat | grep ESTABLISHED 
$ sudo nsenter -t 24226 -n netstat | grep ESTABLISHED 
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags       Type       State         I-Node   Path



只进入网络命名空间，这样可以利用主机上的命令来测试
可以看到，在之前测试时，容器内是没有ip 这个命令的，现在只挂网络命名空间后，就可以通过主机上的ip命令执行了。而执行的结果是容器内的。

$ sudo nsenter -t 24226 -n ifconfig 
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)
        RX packets 43  bytes 4702 (4.7 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

$ sudo nsenter -t 24226 -n ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
6: eth0@if7: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever


$ sudo nsenter -t 24226 -n ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)
...





(5) Linux的每个进程都具有命名空间，可以在/proc/PID/ns目录中看到命名空间的文件描述符。

$ sudo ls -lth /proc/24226/ns
total 0
lrwxrwxrwx 1 root root 0 Sep 26 21:39 cgroup -> 'cgroup:[4026531835]'
lrwxrwxrwx 1 root root 0 Sep 26 21:39 pid_for_children -> 'pid:[4026532396]'
lrwxrwxrwx 1 root root 0 Sep 26 21:39 time -> 'time:[4026531834]'
lrwxrwxrwx 1 root root 0 Sep 26 21:39 time_for_children -> 'time:[4026531834]'
lrwxrwxrwx 1 root root 0 Sep 26 21:39 user -> 'user:[4026531837]'
lrwxrwxrwx 1 root root 0 Sep 26 20:42 mnt -> 'mnt:[4026532393]'
lrwxrwxrwx 1 root root 0 Sep 26 20:42 pid -> 'pid:[4026532396]'
lrwxrwxrwx 1 root root 0 Sep 26 20:42 uts -> 'uts:[4026532394]'
lrwxrwxrwx 1 root root 0 Sep 26 20:41 ipc -> 'ipc:[4026532395]'
lrwxrwxrwx 1 root root 0 Sep 26 20:39 net -> 'net:[4026532398]'




显示父pid
$ ps -ef | head
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 Sep24 ?        00:00:06 /sbin/init splash
root           2       0  0 Sep24 ?        00:00:00 [kthreadd]









ref:
http://www.huilog.com/?p=1145#more-1145
https://www.junmajinlong.com/virtual/namespace/ns_overview/
https://tencentcloudcontainerteam.github.io/tke-handbook/tke-skill/using-nat-gateway-visit-internet.html




========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


