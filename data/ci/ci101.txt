ci3框架学习笔记

========================================
1.MVC入门
----------------------------------------
C主要是路由功能，访问正确的控制器和动作；
M主要是获取数据，return数据即可，来自于数据库或配置文件；
V是视图，负责显示


========================================
2.CI的MVC架构
----------------------------------------
直接访问 http://wjl.com/ci3/，可以知道2条有效信息：
1.如果想修改该页面，请查看application/views/welcome_message.php
2.相应的控制器在：application/controllers/Welcome.php


可以知道ci3下的文件结构：
|-index.php	入口文件
|-system	框架所在目录，不要框架的修改任何代码！
|-application 应用程序所在目录，用户根据需要编写

========================================
3.URL模式
----------------------------------------
常用的是pathinfo模式。

http://wjl.com/ci3/index.php/welcome/test
url/入口文件/控制器/方法名


========================================
4.ci3中的控制器
----------------------------------------
1.不需要加后缀；不同于thinkPHP、yii
2.控制器一般小写；为了防止用户访问时出错
3.所有的控制器，直接或间接的继承自CI_Controller类；ci的类是以CI_开头的；
4.控制器中的方法能被浏览器访问的条件：
	- 必须public，
	- 不能用下划线_开头；
	
	如public function _test()不能被浏览器访问，但是可以内部访问。
5.如何修改默认为index控制器？
	新建一个Index控制器，添加一个index方法：
<?php
class Index extends CI_Controller {

	public function index()
	{
		echo 'from Index->index()<hr>';
	}
}

结果访问 http://wjl.com/ci3/index.php/index/index时，字符打印了两遍，为什么呢？
	from Index->index()
	from Index->index()
因为与类同名函数会被当做构造函数，直接执行一次，调用时又执行一次。

解决办法：
	- 不使用和类同名的方法【推荐】；
	- 添加一个__construct空方法：
	
	//防止类同名函数被当做构造函数提前执行
	public function __construct(){
		parent::__construct();
	}
	

	
	
========================================
ci3中的视图
----------------------------------------
建立application/Controller/User.php控制器：
<?php
class User extends CI_Controller {

	public function index()
	{
		//echo 'from User->index()<hr>';
		//$this->load->view('User_index');//访问views文件夹下的User_index.php文件
		$this->load->view('User/index');//访问views/User文件夹下的index.php文件
	}
}

建立application/Views/User/index.php视图文件：
<?php 
echo 'text from user->index view';

访问：http://wjl.com/ci3/index.php/user/index
显示：text from user->index view


小结：
1.在控制器中如果加载视图，直接写视图名字，不写扩展名；

2.视图中，直接使用原生php：
	//分配一般变量：
	public function index2()
	{
		$this->load->vars('title','这是标题');
		$this->load->view('User/index2');
	}
视图中可以直接使用php代码：
	<?php 
	echo "<h2>$title</h2>";


	
	分配关联数组：

	//分配关联数组	
	public function index3()
	{
		$list=array(
			array('id'=>1, 'name'=>'javascript'),
			array('id'=>2, 'name'=>'php'),
			array('id'=>3, 'name'=>'linux'),
			array('id'=>4, 'name'=>'python'),
		);
		$data['title']='标题1';
		$data['list']=$list;
		$this->load->vars($data);
		//$data分配之后消失，直接使用内部信息。
		
		$this->load->view('User/index3');
	}
	
	视图文件index3.php 
	<meta charset='utf8'>
	<?php 
	echo "<h1>".$title."</h1>";

	foreach($list as $item){
		echo $item['id'] . ' - ' .$item['name'] .'<br>';
	}
	?>

	<h2>推荐显示方法（少用echo会更简洁）：</h2>
	<?php foreach($list as $item):?>
		<?=$item['id']?> - <?=$item['name']?> <br>
	<?php endforeach;?>

	访问后显示：
	标题1
1 - javascript
2 - php
3 - linux
4 - python

推荐显示方法（少用echo会更简洁）：
1 - javascript 
2 - php 
3 - linux 
4 - python 

	
	

	
3.推荐使用<?=$item['id']?>类似的短标签；
	<?php foreach($list as $item):?>
		<?=$item['id']?>
		<?=$item['name']?>
		<?=$item['title']?>
	<?endforeach;?>
	
4.可以在一个方法中多次调用视图；

========================================
ci超级对象中的load加载器
----------------------------------------
1.我们在任意控制器方法中使用var_dump打印this，看ci为我们做了什么？
	public function index4(){
		echo '<pre>';
		var_dump($this);
	}
	
访问 http://wjl.com/ci3/index.php/user/index4显示好几十屏幕内容：
object(User)#12 (12) {
  ["benchmark"]=>
  &object(CI_Benchmark)#1 (1) {
    ["marker"]=>
    array(4) {
      ["total_execution_time_start"]=>
      float(1455096738.0121)
      ["loading_time:_base_classes_start"]=>
      float(1455096738.0121)
      ["loading_time:_base_classes_end"]=>
      float(1455096738.0865)
      ["controller_execution_time_( User / index4 )_start"]=>
      float(1455096738.092)
    }
  }
  ["hooks"]=>
... ...


2.$this有一个load方法，我们看一下细节：
	public function index5(){
		echo '<pre>';
		var_dump($this->load);
	}

访问http://wjl.com/ci3/user/index5，可见一屏幕细节：
object(CI_Loader)#13 (10) {
  ["_ci_ob_level":protected]=>
  int(1)
  ["_ci_view_paths":protected]=>
  array(1) {
    ["D:\xampp\htdocs\ci3\application\views\"]=>
    bool(true)
  }
  ["_ci_library_paths":protected]=>
  array(2) {
    [0]=>
    string(32) "D:\xampp\htdocs\ci3\application\"
    [1]=>
    string(27) "D:/xampp/htdocs/ci3/system/"
  }
  ["_ci_model_paths":protected]=>
  ...
  
 由第一行object(CI_Loader)可知，$this->load是CI_Loader的是一个实例。
 
	$this->load
		装载器类（system/core/Loader.php中的class CI_Loader 类）的实例
		CI_Loader定义了很多方法，上文用过view和vars两个。
		- view()	装载视图
		- vars	分配变量到视图
		- database() 装载数据库操作对象 system/database文件夹下
		- model()	装载模型对象
		- helper()	辅助类	system/helpers文件夹下
 
[?]ci会在某个地方自动实例化一个CI_Loader对象，放到超级对象的属性中：
	$obj=new CI_Loader(); 
	$this->load=$obj;
	//然后以后调用CI_Loader中的方法时，
	$this->load->view();//表明load确实是ci装载器的一个实例


3.$this有一个url方法，我们看一下细节：
 
	public function index6(){
		echo '<pre>';
		var_dump($this->uri);
	}
访问：http://wjl.com/ci3/user/index6，输出：
 object(CI_URI)#6 (6) {
  ["keyval"]=>
  array(0) {
  }
  ["uri_string"]=>
  string(11) "user/index6"
  ["segments"]=>
  array(2) {
    [1]=>
    string(4) "user"
    [2]=>
    string(6) "index6"
  }
 ...
 
 从第一行object(CI_URI)可知，
 
 $this->uri
	是CI_URI类（system/core/URI.php中）的一个实例。
	提供的方法是url相关的方法，作用是Parses URIs and determines routing。
	
	- segment()	用于获取url中的第n个参数，基于分段获取
		index.php/控制器/操作/参数1/参数2/参数3/...
		
	
例1：使用segment()方法获取参数。
使用url获取参数的例子：
	//获取id
	public function get(){
		echo $_GET['id'];
	}
访问 http://wjl.com/ci3/user/get?id=20 会显示20；
	
与tp框架不同，使用 http://wjl.com/ci3/user/get/id/20 会报错：未定义id。
	原因是ci和其他框架不同，pathinfo模式取值使用的是分段获取。我们重新设置服务器url:ci.com指向ci3的根目录，重启apache生效。

控制器中：
	//获取id，分段获取
	public function get2(){
		echo $this->uri->segment(4);
		//http://ci.com/user/get2/id/5
	}
	
访问：
http://wjl.com/ci3/user/get2/id/5
http://ci.com/user/get2/id/5
都可以正常打印出数字。
说明ci的解析器写的很牛！相对于index.php对字段进行分段，1号是user，2号是get2，3号是id，4号是5.
这样写3号字段就有点不必要了，不过保留着更语义化，不保留更简洁。

分段获取参数使路由更灵活了，可以让程序员自由选择简洁或语义化。


例2：使用方法直接获取参数
	//获取id，分段获取，从参数获取
	public function get3($id,$name){
		echo 'id:' . $id, ', name: '. $name;
	}
访问：http://ci.com/user/get3/1/dawn
显示： id:1, name: dawn

========================================
移除url中的index.php
----------------------------------------

1. Apache 服务器启用 mod_rewrite； 
2. 在根目录添加一个.htaccess 文件，其中使用了 "否定条件" 来排除某些不需要重定向的项目：

RewriteEngine On
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule ^(.*)$ index.php/$1 [L]

在上面的例子中，除已存在的目录和文件，其他的 HTTP 请求都会经过你的 index.php 文件。

注意：确保使用上面的规则排除掉你希望能直接访问到的资源。

测试：
访问http://wjl.com/ci3/user/index3 输出正常。


添加 URL 后缀
在你的 config/config.php 文件中你可以指定一个后缀。
如：.html ，这样页面可以同时被如下url访问：
http://wjl.com/ci3/user/index3
http://wjl.com/ci3/user/index3.html



========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

