<div class='content'>
	<h2>php函数和类</h2>
	<ul>
		<li>递归</li>
	</ul>
	
	
	<h2>函数</h2>
	<h3>递归</h3>
<pre>
//例子来源 http://tieba.baidu.com/p/4262397578
1. 递归是很强大的，但是一定要避免无限递归！要留有出口。
2. 在PHP中，必须要在递归调用函数时加上return(这也算PHP递归函数的Bug，时间太长就变成特性了。)

function reverse_r($str){
	if (strlen($str)>0){
		reverse_r(substr($str,1));
	}
	echo substr($str,0,1);
	return;
}
reverse_r('hello');

这个递归实现了字符串的首尾翻转，那么他是如何工作的呢、每一步返回什么呢？

1.搞清楚函数作用
echo substr('abc',1);//'bc' 去掉首字母后的字符串
echo substr('abc',0,1);//'a' 相当于输出首字母

2.递归调用先入后出：
以次调用如下：
f1('hello')
-f2('ello')
--f3('llo')
---f4('lo')
----f5('o')
-----f6('') //这里可以省略一步，就是改为 if (strlen($str)>1)
倒着弹出首字母：
olleh

<b>思考题1：分析如下阶乘函数的每一步堆栈细节：</b>
//阶乘的递归
function fn($i){ 
	if($i==1){
		return 1; 
	}
	return $i*fn($i-1);
} 

echo fn(5);

思考题2：试用return改造字符串颠倒函数，最后返回完整的颠倒后的字符串。
参考答案：
function reverse_r2($str){
	if (strlen($str)>0){
		return  reverse_r2(substr($str,1)) . substr($str,0,1);
	}
	return;
}
echo reverse_r2('hello');


</pre>
	
	
	<h2>类</h2>
<pre>
&lt;?php

//利用反射调用对象的方法

//定义类
class Person{
	private $name;
	function __construct($name=''){
	   $this->name=$name;
	}
    function say(){
        return 'I am ' . $this->name;
    }
    
    function run($addr, $speed = 0){
        return $this->name . " is runing at ".$addr." now, and the speed is ".$speed;
    }
}

function br(){echo '&lt;br>';}

/*
//常规调用
$p=new Person('Jim');
echo $p->say(); br();
echo $p->run(100);
*/

//使用反射实现对象调用方法
$tom=new Person('Tom');
//没有参数时
$method=new ReflectionMethod($tom, 'say');
echo $method->invoke($tom);br();

//有参数时
$method2=new ReflectionMethod($tom, 'run');
echo $method2->invoke($tom, '河源西路',255); br();
echo $method2->invokeArgs($tom, array('河源东路',133));


更多的，可以根据一个实例，反射得到其所属类的方法信息，是否公开，是否有该方法等。

</pre>


<pre>
本文首次添加：13:37 2016/1/11
</pre>
</div>
