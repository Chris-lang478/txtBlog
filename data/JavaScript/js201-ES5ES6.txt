js201-ES5ES6

ES6 入门教程 https://es6.ruanyifeng.com/




========================================
Promise 对象
----------------------------------------

详情看repo: github.com/dawneve/jsLecture
其中的ajax/ 部分



========================================
var V.S. let const
----------------------------------------
之前只有var，后来的let和const

作用域不同： var 函数作用域；let、const 块作用域
var 在变量声明之前访问提示 undefined，let 则直接提示 ReferenceError
	ReferenceError、TypeError：引用错误和类型错误区别
	作用域区别：ReferenceError在作用域中找不到；TypeError在作用域中找到了但是做了它不可能做的事情

var let 的使用场景
	var 全局作用域 + 函数作用域
	let 块作用域(es6)



1. let是为了提供块级作用域。之前只能闭包实现。

<ul>
	<li>1</li>
	<li>2</li>
	<li>3</li>
	<li>4</li>
</ul>

<script>
window.onload = function(){
    var aLi = document.getElementsByTagName('li');
    for (let i=0;i<aLi.length;i++){
        aLi[i].onclick = function(){
            alert(i);
        }
    };     
}
</script>





2. 作用域是局部的
<script>
var log=console.log;
for(let i=0; i<5; i++){ //使用let则出for就不存在该变量了
	log(i)
}
log(i)
</script>





========================================
箭头函数 ()=>
----------------------------------------

ES6标准新增了一种新的函数：Arrow Function（箭头函数）。

1. 示例：1个参数时
x => x * x

上面的箭头函数相当于：

function (x) {
    return x * x;
}



2. 其他参数

// 两个参数:
(x, y) => x * x + y * y

// 无参数:
() => 3.14

// 可变参数:
(x, y, ...rest) => {
    var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}



3. 好处：箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：

var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};

obj.getAge(); // 25

如果使用箭头函数，以前的那种hack写法：
var that = this;
就不再需要了。



(2)
由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：

var obj = {
    birth: 1990,
    getAge: function (year) {
        var b = this.birth; // 1990
        var fn = (y) => y - this.birth; // this.birth仍是1990
        return fn.call({birth:2000}, year);
    }
};
obj.getAge(2015); // 25



ref: https://www.liaoxuefeng.com/wiki/1022910821149312/1031549578462080


========================================
虚拟DOM: Virtual DOM
----------------------------------------
目前最流行的两大前端框架，React和Vue，都不约而同的借助Virtual DOM技术提高页面的渲染效率。
下文中，Virtual DOM 简称vd。


1. 本质上来说，VD只是一个简单的JS对象，并且最少包含tag、props和children三个属性。

不同的框架对这三个属性的命名会有点差别，但表达的意思是一致的。它们分别是标签名（tag）、属性（props）和子元素对象（children）。下面是一个典型的VD对象例子：

{
    tag: "div",
    props: {},
    children: [
        "Hello World", 
        {
            tag: "ul",
            props: {},
            children: [{
                tag: "li",
                props: {
                    id: 1,
                    class: "li-1"
                },
                children: ["第", 1]
            }]
        }
    ]
}

VD跟dom对象有一一对应的关系，上面的VD是由以下的HTML生成的

<div>
    Hello World
    <ul>
        <li id="1" class="li-1">
            第1
        </li>
    </ul>
</div>

一个dom对象，比如li，由tag(li), props({id: 1, class: "li-1"})和children(["第", 1])三个属性来描述。



2.为什么需要VD

VD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。

此外，在进行页面更新的时候，借助VD，DOM 元素的改变可以在内存中进行比较，再结合框架的事务机制将多次比较的结果合并后一次性更新到页面，从而有效地减少页面渲染的次数，提高渲染效率。

页面的呈现会分以下3个阶段：
	JS计算
	生成渲染树
	绘制页面

通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。至于如何基于VD更有效率的更新dom，是一个很有趣的话题，日后有机会将另写一篇文章介绍。



3. 如何实现VD与真实DOM的映射

我们先从如何生成VD说起。借助JSX编译器，可以将文件中的HTML转化成函数的形式，然后再利用这个函数生成VD。看下面这个例子：

function render() {
    return (
        <div>
            Hello World
            <ul>
                <li id="1" class="li-1">
                    第1
                </li>
            </ul>
        </div>
    );
}

这个函数经过JSX编译后，会输出下面的内容：

function render() {
    return h(
        'div',
        null,
        'Hello World',
        h(
            'ul',
            null,
            h(
                'li',
                { id: '1', 'class': 'li-1' },
                '\u7B2C1'
            )
        )
    );
}



这里的h是一个函数，可以起任意的名字。这个名字通过babel进行配置：

// .babelrc文件
{
  "plugins": [
    ["transform-react-jsx", {
      "pragma": "h"    // 这里可配置任意的名称
    }]
  ]
}

接下来，我们只需要定义h函数，就能构造出VD

function flatten(arr) {
    return [].concat.apply([], arr);
}

function h(tag, props, ...children) {
    return {
        tag, 
        props: props || {}, 
        children: flatten(children) || []
    };
}


h函数会传入三个或以上的参数，前两个参数一个是标签名，一个是属性对象，从第三个参数开始的其它参数都是children。children元素有可能是数组的形式，需要将数组解构一层。比如：

function render() {
    return (
        <ul>
            <li>0</li>
            {
                [1, 2, 3].map( i => (
                    <li>{i}</li>
					                ))
            }
        </ul>
    );
}

// JSX编译后
function render() {
    return h(
        'ul',
        null,
        h(
            'li',
            null,
            '0'
        ),
        /*
         * 需要将下面这个数组解构出来再放到children数组中
         */
        [1, 2, 3].map(i => h(
            'li',
            null,
            i
        ))
    );
}
继续之前的例子。执行h函数后，最终会得到如下的VD对象：

{
    tag: "div",
    props: {},
    children: [
        "Hello World", 
        {
            tag: "ul",
            props: {},
            children: [{
                tag: "li",
                props: {
                    id: 1,
                    class: "li-1"
                },
                children: ["第", 1]
            }]
        }
    ]
}
下一步，通过遍历VD对象，生成真实的dom

// 创建dom元素
function createElement(vdom) {
    // 如果vdom是字符串或者数字类型，则创建文本节点，比如“Hello World”
    if (typeof vdom === 'string' || typeof vdom === 'number') {
        return doc.createTextNode(vdom);
    }

    const {tag, props, children} = vdom;

    // 1. 创建元素
    const element = doc.createElement(tag);

    // 2. 属性赋值
    setProps(element, props);

    // 3. 创建子元素
    // appendChild在执行的时候，会检查当前的this是不是dom对象，因此要bind一下
    children.map(createElement)
            .forEach(element.appendChild.bind(element));

    return element;
}

// 属性赋值
function setProps(element, props) {
    for (let key in props) {
        element.setAttribute(key, props[key]);
    }
}


createElement函数执行完后，dom元素就创建完并展示到页面上了（页面比较丑，不要介意...）。
					


总结

本文介绍了VD的基本概念，并讲解了如何利用JSX编译HTML标签，然后生成VD，进而创建真实dom的过程。下一篇文章将会实现一个简单的VD Diff算法，找出2个VD的差异并将更新的元素映射到dom中去：你不知道的Virtual DOM（二）：Virtual Dom的更新







ref:
https://segmentfault.com/a/1190000016129036




========================================
ES6 export和import模块：浏览器原生支持啦
----------------------------------------
1. 测试需要3个文件

(1)入口js文件 index.js 
export default function bar() {
  alert("I am bar from bar.js")
}


(2)几个提供函数的文件 bar.js 
import bar from './bar.js';
bar();


(3)首页 index.html，要注意引入js时刻要加上type="module" 属性，否则报错。

<meta http-equiv=Content-Type content="text/html;charset=utf-8">

learn webpack 4<br>
https://webpack.js.org/<br>
<h3>F12</h3>

<pre>
    在浏览器加载html文件时，需要在script 标签中加入type="module"属性。
</pre>

<script type="module" src="./index.js"></script>





========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------




========================================
----------------------------------------

