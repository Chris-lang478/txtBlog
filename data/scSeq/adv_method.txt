单细胞进阶分析主要是
	- 拟时序分析：
	- 细胞通讯分析：
	- SCENIC转录因子分析：
	- RNA Velocity 分析：

https://github.com/DawnEve/scRNAseqCode

视频讲解 单细胞RNA测序分析图解读： https://www.bilibili.com/video/BV1ev41177i4?




========================================
进阶分析方法概述
----------------------------------------

单细胞分析十八般武艺
https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIyMzMwNDQ2MA==&action=getalbum&album_id=1593332494622359552





========================================
双细胞检测 doublet detection: Scrublet
----------------------------------------
什么是doublets？简单的说就是两个细胞混在一起，可能发生在细胞捕获过程中，并且可能会误导认为是两种细胞类型的过渡态（transitory states），所以应该去除

Doublets检测的软件：
①DoubletFinder
(https://github.com/chris-mcginnis-ucsf/DoubletFinder)
②Scrublet
(https://github.com/AllonKleinLab/scrublet)
③DoubletDecon
(https://github.com/EDePasquale/DoubletDecon)
④DoubletCluster



1. 张泽民 Science paper方法学描述

看来是对读入Seurat对象的做初步质控的细胞做的 Scrublet 检测。

(1)For the newly generated scRNA-seq data, Cell Ranger (version 3.0, 10x Genomics Inc) was used for sequencing reads mapping against the GRCh38 human reference genome, UMI counting, and cell identification. 

(2)Then cells with fewer than 200 genes detected or >10% mitochondrial UMI counts were filtered out; 
- genes detected in > 3 cells were kept. 
- Scrublet (49) was applied to each sequencing library to remove potential doublets, setting the expected doublet rate to 0.05, and the cells with doubletScore larger than 0.3 were filtered out.

(3) We applied Seurat (version 3) with default parameters to identify T/NK clusters.





2. Scrublet 的安装
https://github.com/AllonKleinLab/scrublet

(1) 官方安装会报错
$ pip3 install --user scrublet -i https://pypi.douban.com/simple/
一直报错，有人说 I also experienced this and managed to solve this by downgrading annoy to 1.16.3.
https://github.com/swolock/scrublet/issues/28

# 再次尝试
$ pip3 install --user annoy==1.16.3 -i https://pypi.douban.com/simple/
$ pip3 install --user scrublet -i https://pypi.douban.com/simple/
Successfully installed scrublet-0.2.3

# 版本检测
$ pip3 freeze | grep scrublet
scrublet==0.2.3


(2) 开 jupyter notebook 
$ jupyter notebook --no-browser --port 8787 --ip=192.168.2.xx
## 可能需要开放端口 sudo iptables -I INPUT -p tcp --dport 8787 -j ACCEPT 


(3) numpy兼容性报错修复
ImportError: cannot import name '_validate_lengths' from 'numpy.lib.arraypad' (/home/wangjl/software/anaconda3/lib/python3.7/site-packages/numpy/lib/arraypad.py)

~/software/anaconda3/lib/python3.7/site-packages/skimage/util/arraycrop.py in <module>
import numpy as np
----> 8 from numpy.lib.arraypad import _validate_lengths


版本太高了，而本工具使用的是 1.15.2: https://github.com/swolock/scrublet/issues/4
$ pip3 freeze | grep numpy
numpy==1.18.3
numpydoc==0.8.0



1)要么降低 np 版本：有风险，用完再升级回1.18.3。
$ pip3 install numpy==1.16.2 -i https://pypi.douban.com/simple/ #还是报错
$ pip3 install numpy==1.15.2 -i https://pypi.douban.com/simple/ #需要重启 jupyter 才能生效！




2) 要么修改该包源码：尝试，没找到地方，放弃
> import sys
> print(sys.path)

['/data/jinwf/wangjl/neu/scRNA/202201filter/script', 
'/home/wangjl/software/anaconda3/lib/python37.zip', 
'/home/wangjl/software/anaconda3/lib/python3.7', 
'/home/wangjl/software/anaconda3/lib/python3.7/lib-dynload', 
'/home/wangjl/.local/lib/python3.7/site-packages', 
'/home/wangjl/software/anaconda3/lib/python3.7/site-packages', 
'/home/wangjl/software/anaconda3/lib/python3.7/site-packages/IPython/extensions', 
'/home/wangjl/.ipython']


一个一个找这些路径，肯定能找到:
$ find /home/wangjl/.local/lib/python3.7/site-packages/. | grep -v -P "(py|pyc)$" | xargs grep -i "scrublet" --color=auto

因为设定了 --user，装到这里了：
$ cd /home/wangjl/.local/lib/python3.7/site-packages/./scrublet
$ ls -lht
total 52K
drwxr-xr-x. 2 wangjl jinwf 123 Dec 28 09:17 __pycache__
-rw-r--r--. 1 wangjl jinwf 25K Dec 28 09:17 scrublet.py
-rw-r--r--. 1 wangjl jinwf 20K Dec 28 09:17 helper_functions.py
-rw-r--r--. 1 wangjl jinwf  63 Dec 28 09:17 __init__.py

查找这个函数的位置
$ find . | xargs grep "_validate_lengths" --color=auto 2>/dev/null

没找到位置，放弃。

解决方法: 
from distutils import LooseVersion as Version
old_numpy = Version(np.__version__) < Version('1.16')
if old_numpy:
    from numpy.lib.arraypad import _validate_lengths
else:
    from numpy.lib.arraypad import _as_pairs




(4) 基本使用
给定原始（非标准化）UMI计算矩阵counts_matrix，其中细胞为行，基因为列，计算每个cell的doublet分数：

import scrublet as scr
scrub = scr.Scrublet(counts_matrix)
doublet_scores, predicted_doublets = scrub.scrub_doublets()

scr.scrub_doublets（）模拟数据的doublets，并使用k-最近邻分类器是每个转录组计算连续的doublet_score（在0和1之间）。
分数是由自动设定的阈值生成 predict_doublets，一个布尔数组，预测是doublets时为True，否则为False。








3. 运行
(1) 我的版本
import pandas as pd
counts_matrix = pd.read_csv("../filterSample/data/_BL2Y.counts.df.txt", sep=" ") #, header = None, index_col=None, names=['barcode'])
counts_matrix.shape

# check
# print(counts_matrix.shape)
# counts_matrix.iloc[1:4, 1:4]

import numpy as np
import scrublet as scr

scrub = scr.Scrublet(counts_matrix)
doublet_scores, predicted_doublets = scrub.scrub_doublets()


最佳实践 Best practices:
- 处理来自多个样品的数据时，分别对每个样品运行Scrublet。Scrublet用于检测由两个细胞的随机共包封形成的doublets，所以它可能在合并数据集上表现不佳;
- 在2-D嵌入（例如，UMAP或t-SNE）中可视化doublets预测;




(2) 重要的参数
https://github.com/swolock/scrublet/blob/master/examples/scrublet_basics.ipynb

1)初始化Scrublet对象
相关参数为：
•expected_doublet_rate，doublets的预期占比，通常为0.05-0.1，结果对该参数不是特别敏感。对于此示例数据，预期的doublets占比来自Chromium用户指南[9]
•sim_doublet_ratio，要模拟的doublets数量相对于转录组的观测值的比例。此值应该足够高，以使所有的doublet状态都能很好地由模拟doublets表示。设置得太高会使计算量增大，默认值是2（尽管设置低至0.5的值也对测试的数据集产生非常相似的结果。
•n_neighbors，用于构造转录组观测值和模拟doublets的KNN分类器的邻居数。默认值为round（0.5 * sqrt（n_cells）），通常表现比较好。

scrub = scr.Scrublet(counts_matrix, expected_doublet_rate=0.06)



2) 计算doublet score
运行下面的代码计算doublet score，内部处理过程包括:
	1.Doublet simulation
	2.Normalization, gene filtering, rescaling, PCA
	3.Doublet score calculation
	4.Doublet score threshold detection and doublet calling

doublet_scores, predicted_doublets = scrub.scrub_doublets(n_prin_comps=30, mean_center=True, normalize_variance=True)

doublet_scores, predicted_doublets = scrub.scrub_doublets(min_counts=2, min_cells=3, min_gene_variability_pctl=85, n_prin_comps=30)










========================================
|-- DoubletDetection依赖scanpy，在安装DoubletDetection前务必安装scanpy //todo
----------------------------------------












========================================
细胞周期的区分方法？
----------------------------------------

1. 2015 cell, Drop-seq

> dput(cycle.list)
list(G1S = c("ACD", "ACYP1", "ADAMTS1", "ANKRD10", "APEX2", "ARGLU1", "ATAD2", "BARD1", "BRD7", "C1orf63", "C7orf41", "C14orf142", "CAPN7", "CASP2", "CASP8AP2", "CCNE1", "CCNE2", "CDC6", "CDC25A", "CDCA7", "CDCA7L", "CEP57", "CHAF1A", "CHAF1B", "CLSPN", "CREBZF", "CTSD", "DIS3", "DNAJC3", "DONSON", "DSCC1", "DTL", "E2F1", "EIF2A", "ESD", "FAM105B", "FAM122A", "FLAD1", "GINS2", "GINS3", "GMNN", "HELLS", "HOXB4", "HRAS", "HSF2", "INSR", "INTS8", "IVNS1ABP", "KIAA1147", "KIAA1586", "LNPEP", "LUC7L3", "MCM2", "MCM4", "MCM5", "MCM6", "MDM1", "MED31", "MRI1", "MSH2", "NASP", "NEAT1", "NKTR", "NPAT", "NUP43", "ORC1", "OSBPL6", "PANK2", "PCDH7", "PCNA", "PLCXD1", "PMS1", "PNN", "POLD3", "RAB23", "RECQL4", "RMI2", "RNF113A", "RNPC3", "SEC62", "SKP2", "SLBP", "SLC25A36", "SNHG10", "SRSF7", "SSR3", "TAF15", "TIPIN", "TOPBP1", "TRA2A", "TTC14", "UBR7", "UHRF1", "UNG", "USP53", "VPS72", "WDR76", "ZMYND19", "ZNF367", "ZRANB2"), 

S = c("ABCC5", "ABHD10", "ANKRD18A", "ASF1B", "ATAD2", "BBS2", "BIVM", "BLM", "BMI1", "BRCA1", "BRIP1", "C5orf42", "C11orf82", "CALD1", "CALM2", "CASP2", "CCDC14", "CCDC84", "CCDC150", "CDC7", "CDC45", "CDCA5", "CDKN2AIP", "CENPM", "CENPQ", "CERS6", "CHML", "COQ9", "CPNE8", "CREBZF", "CRLS1", "DCAF16", "DEPDC7", "DHFR", "DNA2", "DNAJB4", "DONSON", "DSCC1", "DYNC1LI2", "E2F8", "EIF4EBP2", "ENOSF1", "ESCO2", "EXO1", "EZH2", "FAM178A", "FANCA", "FANCI", "FEN1", "GCLM", "GOLGA8A", "GOLGA8B", "H1F0", "HELLS", "HIST1H2AC", "HIST1H4C", "INTS7", "KAT2A", "KAT2B", "KDELC1", "KIAA1598", "LMO4", "LYRM7", "MAN1A2", "MAP3K2", "MASTL", "MBD4", "MCM8", "MLF1IP", "MYCBP2", "NAB1", "NEAT1", "NFE2L2", "NRD1", "NSUN3", "NT5DC1", "NUP160", "OGT", "ORC3", "OSGIN2", "PHIP", "PHTF1", "PHTF2", "PKMYT1", "POLA1", "PRIM1", "PTAR1", "RAD18", "RAD51", "RAD51AP1", "RBBP8", "REEP1", "RFC2", "RHOBTB3", "RMI1", "RPA2", "RRM1", "RRM2", "RSRC2", "SAP30BP", "SLC38A2", "SP1", "SRSF5", "SVIP", "TOP2A", "TTC31", "TTLL7", "TYMS", "UBE2T", "UBL3", "USP1", "ZBED5", "ZWINT"), 

G2M = c("ANLN", "AP3D1", "ARHGAP19", "ARL4A", "ARMC1", "ASXL1", "ATL2", "AURKB", "BCLAF1", "BORA", "BRD8", "BUB3", "C2orf69", "C14orf80", "CASP3", "CBX5", "CCDC107", "CCNA2", "CCNF", "CDC16", "CDC25C", "CDCA2", "CDCA3", "CDCA8", "CDK1", "CDKN1B", "CDKN2C", "CDR2", "CENPL", "CEP350", "CFD", "CFLAR", "CHEK2", "CKAP2", "CKAP2L", "CYTH2", "DCAF7", "DHX8", "DNAJB1", "ENTPD5", "ESPL1", "FADD", "FAM83D", "FAN1", "FANCD2", "G2E3", "GABPB1", "GAS1", "GAS2L3", "H2AFX", "HAUS8", "HINT3", "HIPK2", "HJURP", "HMGB2", "HN1", "HP1BP3", "HRSP12", "IFNAR1", "IQGAP3", "KATNA1", "KCTD9", "KDM4A", "KIAA1524", "KIF5B", "KIF11", "KIF20B", "KIF22", "KIF23", "KIFC1", "KLF6", "KPNA2", "LBR", "LIX1L", "LMNB1", "MAD2L1", "MALAT1", "MELK", "MGAT2", "MID1", "MIS18BP1", "MND1", "NCAPD3", "NCAPH", "NCOA5", "NDC80", "NEIL3", "NFIC", "NIPBL", "NMB", "NR3C1", "NUCKS1", "NUMA1", "NUSAP1", "PIF1", "PKNOX1", "POLQ", "PPP1R2", "PSMD11", "PSRC1", "RANGAP1", "RCCD1", "RDH11", "RNF141", "SAP30", "SKA3", "SMC4", "STAT1", "STIL", "STK17B", "SUCLG2", "TFAP2A", "TIMP1", "TMEM99", "TMPO", "TNPO2", "TOP2A", "TRAIP", "TRIM59", "TRMT2A", "TTF2", "TUBA1A", "TUBB", "TUBB2A", "TUBB4B", "TUBD1", "UACA", "UBE2C", "VPS25", "VTA1", "WSB1", "ZNF587", "ZNHIT2"), 

M = c("AHI1", "AKIRIN2", "ANKRD40", "ANLN", "ANP32B", "ANP32E", "ARHGAP19", "ARL6IP1", "ASXL1", "ATF7IP", "AURKA", "BIRC2", "BIRC5", "BUB1", "CADM1", "CCDC88A", "CCDC90B", "CCNA2", "CCNB2", "CDC20", "CDC25B", "CDC27", "CDC42EP1", "CDCA3", "CENPA", "CENPE", "CENPF", "CEP55", "CFLAR", "CIT", "CKAP2", "CKAP5", "CKS1B", "CKS2", "CNOT10", "CNTROB", "CTCF", "CTNNA1", "CTNND1", "DEPDC1", "DEPDC1B", "DIAPH3", "DLGAP5", "DNAJA1", "DNAJB1", "DR1", "DZIP3", "E2F5", "ECT2", "FAM64A", "FOXM1", "FYN", "G2E3", "GADD45A", "GAS2L3", "GOT1", "GRK6", "GTSE1", "HCFC1", "HMG20B", "HMGB3", "HMMR", "HN1", "HP1BP3", "HPS4", "HS2ST1", "HSPA8", "HSPA13", "INADL", "KIF2C", "KIF5B", "KIF14", "KIF20B", "KLF9", "LBR", "LMNA", "MCM4", "MDC1", "MIS18BP1", "MKI67", "MLLT4", "MZT1", "NCAPD2", "NCOA5", "NEK2", "NUF2", "NUP35", "NUP98", "NUSAP1", "ODF2", "ORAOV1", "PBK", "PCF11", "PLK1", "POC1A", "POM121", "PPP1R10", "PRPSAP1", "PRR11", "PSMG3", "PTP4A1", "PTPN9", "PWP1", "QRICH1", "RAD51C", "RANGAP1", "RBM8A", "RCAN1", "RERE", "RNF126", "RNF141", "RNPS1", "RRP1", "SEPHS1", "SETD8", "SFPQ", "SGOL2", "SHCBP1", "SMARCB1", "SMARCD1", "SPAG5", "SPTBN1", "SRF", "SRSF3", "SS18", "SUV420H1", "TACC3", "THRAP3", "TLE3", "TMEM138", "TNPO1", "TOMM34", "TPX2", "TRIP13", "TSG101", "TSN", "TTK", "TUBB4B", "TXNDC9", "TXNRD1", "UBE2D3", "USP13", "USP16", "VANGL1", "WIBG", "WSB1", "YWHAH", "ZC3HC1", "ZFX", "ZMYM1", "ZNF207"), 

MG1 = c("AGFG1", "AGPAT3", "AKAP13", "AMD1", "ANP32E", "ANTXR1", "BAG3", "BTBD3", "CBX3", "CDC42", "CDK7", "CDKN3", "CEP70", "CNIH4", "CTR9", "CWC15", "DCP1A", "DCTN6", "DEXI", "DKC1", "DNAJB6", "DSP", "DYNLL1", "EIF4E", "ELP3", "FAM60A", "FAM189B", "FOPNL", "FOXK2", "FXR1", "G3BP1", "GATA2", "GNB1", "GRPEL1", "GSPT1", "GTF3C4", "HIF1A", "HMG20B", "HMGCR", "HSD17B11", "HSPA8", "ILF2", "JMJD1C", "KDM5B", "KIAA0586", "KIF5B", "KPNB1", "KRAS", "LARP1", "LARP7", "LRIF1", "LYAR", "MORF4L2", "MRPL19", "MRPS2", "MRPS18B", "MSL1", "MTPN", "NCOA3", "NFIA", "NFIC", "NUCKS1", "NUFIP2", "NUP37", "ODF2", "OPN3", "PAK1IP1", "PBK", "PCF11", "PLIN3", "PPP2CA", "PPP2R2A", "PPP6R3", "PRC1", "PSEN1", "PTMS", "PTTG1", "RAD21", "RAN", "RHEB", "RPL13A", "SLC39A10", "SNUPN", "SRSF3", "STAG1", "SYNCRIP", "TAF9", "TCERG1", "TLE3", "TMEM138", "TOB2", "TOP1", "TROAP", "TSC22D1", "TULP4", "UBE2D3", "VANGL1", "VCL", "WIPF2", "WWC1", "YY1", "ZBTB7A", "ZCCHC10", "ZNF24", "ZNF281", "ZNF593"))





2. 其他的文献线索

(1) 荧光法
Genome Res. 2020 Apr;30(4):611-621. doi: 10.1101/gr.247759.118. Epub 2020 Apr 20.
Characterizing and inferring quantitative cell cycle phase in single-cell RNA-seq data analysis

https://pubmed.ncbi.nlm.nih.gov/32312741/

Although standard methods assign cells to discrete cell cycle stages, our method goes beyond this and quantifies cell cycle progression on a continuum. We found that, on average, scRNA-seq data from only five genes predicted a cell's position on the cell cycle continuum to within 14% of the entire cycle and that using more genes did not improve this accuracy. 


(2)Applying Oscope to a number of data sets, we demonstrated its utility and also identified a potential artifact in the Fluidigm C1 platform.
https://pubmed.ncbi.nlm.nih.gov/26301841/

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE64016

Total 213 H1 single cells and 247 H1-Fucci single cells were sequenced. The 213 H1 cells were used to evaluate Oscope in identifying oscillatory genes. The H1-Fucci cells were used to confirm the cell cycle gene cluster identified by Oscope in the H1 hESCs.







========================================
RNA Velocity 分析
----------------------------------------


1.轨迹推断 (Trajectory Inference, TI):
	从成千上万的细胞组学数据中推断细胞发育轨迹的方法。

Monocle 基于降维的算法，把高维映射到低维。
不足: 
	不能提供方向;
	不能精确定量细胞的状态，根据转录组的相似性而非细胞的真实状态。

(1) 原始 paper: velocyto
Letter | Published: 08 August 2018: RNA velocity of single cells
https://www.nature.com/articles/s41586-018-0414-6
该文章使用的软件：http://velocyto.org/
目前有2个实现:
	velocyto.py
	velocyto.R
其中py提供了一个命令行工具：http://velocyto.org/velocyto.py/tutorial/index.html#running-the-cli



(2) 改进 scVelo
Article | Published: 03 August 2020 |(velocyto--> scVelo)
Generalizing RNA velocity to transient cell states through dynamical modeling
https://www.nature.com/articles/s41587-020-0591-3
该文章使用的软件：https://scvelo.readthedocs.io/


这个相较于之前18年的Nature文章提出的RNA速率的概念的基础上，并对之前的数学模型做了进一步优化，在这篇文章中提出了更全面更准确的模型和方法


该文献中文阅读笔记: 
	latent time: https://zhuanlan.zhihu.com/p/168735707
	翻译 https://zhuanlan.zhihu.com/p/440413581


作者 Fabian Theis: https://www.helmholtz-munich.de/icb/institute/staff/staff/ma/2494/index.html
	https://www.sanger.ac.uk/external_person/theis-fabian/
	https://www.professoren.tum.de/en/theis-fabian/


操作笔记: https://zhuanlan.zhihu.com/p/436419029
	https://www.jianshu.com/p/fb1cf5806912



(3) velocyto 和 Monocle 的区别
velocyto
	- 研究的维度: mRNA速度(基因表达状态的时间导数)
	- 展示: 细胞的真实状态
	- 输入文件: 10X 的bam 文件

Monocle 
	- 研究的维度: RNA 的表达量
	- 展示：转录组的相似性
	- 输入文件: 10X的表达矩阵



(4) 在RNA成熟的过程中会经历三个主要的阶段：转录---剪接---降解
当新生 mRNA 速度和 成熟mRNA的降解速度 相等时，达到稳态。
Reads based  / UMI based;


Spliced
	only to the exonic regions 
Unspliced 
	spanned exon-intron boundary
	mapped to intron 
Ambiguous:
	exonic-only and other intronic
delete:
	multiple mappings 
	mapped inside repeat masked


那在瞬时状态下：未剪切和剪切成熟的RNA可以表征为如下的两个式子：
同时The time derivative of mature spliced mRNA, termed RNA velocity, 就是下图中的第二个式子。
	du(t)/dt = alpha(k)(t) - Beta*u(t);
	ds(t)/dt = Beta*u(t) - gama*s(t);
其中 
	alpha 转录速率 Transcription
	beta 剪接速率 unsliced mRNA
	gamma 降解速率 Degradation
	s: spliced
	u: unspliced

	v = ds/dt = u - gamma*s
	constant: 细胞下一个状态
	correlation: 与每一个细胞的向量，有方向、有大小
	RNA velocity: velocity






==> 评估RNA速率有哪些方法？
目前有三种方法:
  稳态/确定性模型(在velocyto中使用)
  随机模型(使用二阶矩)，
  动态模型(使用基于概率的框架)。



(4) loom 中间文件使用 velocyto 生成
http://loompy.org/
http://velocyto.org/velocyto.py/tutorial/cli.html
https://scvelo.readthedocs.io/VelocityBasics/

https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI1Njk4ODE0MQ==&action=getalbum&album_id=1774746462153687043

https://zhuanlan.zhihu.com/p/142327236

https://zhuanlan.zhihu.com/p/180253811 评论区说作者有个视频 //todo
	可以看作者的视频，解释的很清楚，就像拍照拍一个背景快速流动，然后主角不动，是靠拍照人往反方向去甩相机镜头







2. 背景介绍

- 无需生物学背景的先验经验：研究者可以从向量结果中读出分化轨迹
- 数据兼容性强：RNA velocity的数据可以嵌入普通的PCA、tSNE、UMAP降维，也可以嵌入monocle、PAGA构建的细胞轨迹


(1)
这就像在所有运动时间凝固的照片，”教授解释斯登Linnarsson在医学生物化学与生物物理系，卡罗林斯卡医学院，谁领导这项研究的研究人员之一。“我们现在已经开发出一种新方法，不仅可以测量遗传活性，还可以测量单个细胞中这种活性的变化。您可以将其与长时间曝光拍摄的照片进行比较，这会导致运动模糊：静止的对象清晰而运动的对象模糊。快速移动的对象会变得模糊，而移动的方向会被模糊的方向所揭示。”
用于研究肿瘤形成，伤口愈合和免疫系统的方法

新方法利用了这样一个事实，即当基因被激活时，一系列RNA分子会以一定顺序形成。通过分离这些分子，研究人员可以确定一个基因是否刚刚被激活，或者例如它即将被关闭。

Linnarsson教授说：“这种新方法使我们能够详细观察胚胎中包括人类胚胎如何形成专门的细胞类型。” “它也可以用于研究动态的疾病过程，例如肿瘤形成，伤口愈合和免疫系统。”





(2)测量跨复杂组织的基因表达的动态变化

RNA剪切：成熟mRNA表达时，未成熟的一部分转录本会被剪切掉。当基因的表达增加时，在细胞中观察到未成熟、未剪接的转录本的比例与成熟的剪接的转录本的比例相比瞬时增加。相反，当基因表达降低时，在短时间内看到较高比例的剪接转录本（未显示）。La Manno等。

原理: 

通过测量单个细胞中每个基因的未剪接转录本与剪接转录本的比率，计算出一个称为RNA速度的量，揭示了基因表达的变化方式。b通过测量组织中成千上万个细胞（此处为发育中的小鼠大脑神经元）中的RNA速度，作者可以生成图，不仅显示相互关联的细胞之间的紧密程度（相似性用相似的颜色表示），而且还根据它们正在经历的基因表达变化，将来与哪些细胞相似（如箭头所示）。RNA速度成功地追踪了早期祖细胞（橙色和黄色），这些祖细胞最终引起了一系列分化的细胞类型（蓝色虚线圆圈）。





(3) velocity和scVelo哪家强？

scVelo开发团队认为现有的计算RNA velocity的稳态模型(steady-state model)存在一些不足，这种模型有个两个基本的假设前提：
①在基因水平上，所有具有转录诱导、抑制和稳态mRNA水平的完整剪接动力学被捕捉到；
②在细胞水平上，所有基因具有共同的剪接率。

但是，当一个种群包含多个具有不同动力学的异质亚种群时，这些假设就不合理。所以，他们开发了seVelo，一个基于似然的动力学模型(likelihood-based dynamical model)，它解决了以上提出的全基因转录动力学的问题，从而将RNA速度估计推广到瞬时状态系统和具有非均匀亚种群动力学的系统。
scVelo提供了两种扩展：一种是包含二阶矩的随机模型，另一种是捕获全剪接动力学的动力学模型。


en教程: https://scvelo.readthedocs.io/getting_started/
翻译:
https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI1Njk4ODE0MQ==&action=getalbum&album_id=1774746462153687043&subscene=159&subscene=&scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3Fsrc%3D11%26timestamp%3D1645359169%26ver%3D3632%26signature%3D6mvXUh0qENFPeP3tF3BNVGXRtBulXZTwo71Kop*VZVziXwOYluCjHkePH2vQFWY6e7I9zpEXLWee2qh93Cn1U-Ma0yrXpnu1h1DDQehcN39eYfoVEMffFnL*548RFt7c%26new%3D1&nolastread=1#wechat_redirect







(4) 原理与代码

velocyto 使用 mRNA 的可变剪切来估计 RNA 变化速率。可变剪切（differential splicing）也称选择性剪切（alternative splicing），是前体 RNA 转化为成熟 mRNA 的关键步骤。一般来说基因转录开始后，相关前体 RNA 最开始增加，随后 mRNA 才开始增加，天然具有时间属性。

测序数据比对结果中总存在一定比例无法定义为 counts 的 reads。在传统比对时，一般舍弃。


velocyto 通过重新注释比对结果来评估细胞中特定基因的剪接读长（spliced reads）和未剪接读长（unspliced）。根据这些信息对每个基因拟合一个数学模型，认为该模型代表基因表达平衡态。


该模型中，u 代表 unspliced reads ，s 代表 spliced reads，γ 代表 RNA 降解和剪接速率的估计，虚线是拟合出来的平衡态。一般认为当 u> γs 时基因处于转录激活态，反之为抑制。这样，对于每个基因，拟合出 γ 后，就可以根据平衡态预测速率；再通过基因预测结果综合判断细胞的速率；最后计算细胞间速率相关性，最终完成轨迹推断。

velocyto 软件有 python 和 R 两种版本，大家可按需取用。
http://velocyto.org/velocyto.py/tutorial/analysis.html


seuratwrapper 整合了 velocyto 软件并提供测试数据下载，大家可以根据示例代码，跑一跑测试数据，直观感受一下运行流程。
# https://mp.weixin.qq.com/s?__biz=MzU2Nzg3MzYyOA==&mid=2247485100&idx=1&sn=2b8d81881966797497412c508402e9b6

library(Seurat)
library(velocyto.R)
library(SeuratWrappers)

# If you don't have velocyto's example mouse bone marrow dataset, download with the CURL command
# curl::curl_download(url = 'http://pklab.med.harvard.edu/velocyto/mouseBM/SCG71.loom', destfile = '~/Downloads/SCG71.loom')

# 转换为seurat对象
ldat <- ReadVelocity(file = "~/Downloads/SCG71.loom")
bm <- as.Seurat(x = ldat)

# 整合降维聚类
bm <- SCTransform(object = bm, assay = "spliced")
bm <- RunPCA(object = bm, verbose = FALSE)
bm <- FindNeighbors(object = bm, dims = 1:20)
bm <- FindClusters(object = bm)
bm <- RunUMAP(object = bm, dims = 1:20)

# 速率分析及可视化
# 拟合平衡系数 γ
bm <- RunVelocity(object = bm, deltaT = 1, kCells = 25, fit.quantile = 0.02)
ident.colors <- (scales::hue_pal())(n = length(x = levels(x = bm)))
names(x = ident.colors) <- levels(x = bm)
cell.colors <- ident.colors[Idents(object = bm)]
names(x = cell.colors) <- colnames(x = bm)


# 将速率投射在降维空间上画图。使用全部100多个CPU核，跑了 15min 出图。
show.velocity.on.embedding.cor(emb = Embeddings(object = bm, reduction = "umap"), vel = Tool(object = bm,
    slot = "RunVelocity"), n = 200, scale = "sqrt", cell.colors = ac(x = cell.colors, alpha = 0.5),
    cex = 0.8, arrow.scale = 3, show.grid.flow = TRUE, min.grid.cell.mass = 0.5, grid.n = 40, arrow.lwd = 1,
    do.par = FALSE, cell.border.alpha = 0.1)


>> Debug:
# 最后一步的报错：BLAS : Program is Terminated. Because you tried to allocate too many memory regions.
This worked for me.
"BLAS stands for Basic Linear Algebra Subprograms. BLAS provides standard interfaces for linear algebra, including BLAS1 (vector-vector operations), BLAS2 (matrix-vector operations), and BLAS3 (matrix-matrix operations).
As per the documentation, if your application is already multi-threaded, it will conflict with OpenBLAS multi-threading. Therefore, you must set OpenBLAS to use a single thread.
So, it seems that your application is conflicting with OpenBLAS multi-threading. You need to run the followings on the command line and it should fix the error:"

$ vim ~/.bashrc # 新增行
export OPENBLAS_NUM_THREADS=1
export GOTO_NUM_THREADS=1
export OMP_NUM_THREADS=1
$ source ~/.bashrc

https://www.discoverbits.in/2509/program-terminated-because-tried-allocate-memory-regions






(5) 结果解读
velocyto 提供在总体细胞和单个基因两个层面上的结果。

1) 总体细胞轨迹推断在特定降维空间的投射结果

如上图，左图在单个细胞层面的投射结果，右图为根据周围细胞计算简化后的结果。

velocyto 会对每个细胞拟合一个速率推断结果，将之投射在降维空间中就能显示轨迹推断的方向。在细胞量较多时，左图轨迹可能会高度重叠看不清楚，常转化为右图简化的形式。

2) 单个基因的速率拟合结果

上图中，从左到右依次是选定基因的 splice reads(s)、unspliced reads(u) 统计、 速率拟合和拟合结果残差分布结果。

velocyto 也可以展示单个细胞的速率拟合结果，包含每个细胞该基因注释出剪切 reads 数和非剪切 reads 数、平衡态 γ 系数和单个细胞距离平衡态的残差。一般来说基因在特定细胞中 u 残差越大其转录越活跃。


(6) 文献解读

一项有关肌层浸润性膀胱癌（muscle-invasive bladder cancer ，MIBC）的研究中，发现一类高表达 Cadherin 12（CDH12）的上皮细胞亚型可以用于预测免疫治疗效果[2]。
[2]. Gouin, Kenneth H 3rd et al. “An N-Cadherin 2 expressing epithelial cell subpopulation predicts response to surgery, chemotherapy and immunotherapy in bladder cancer.” Nature communications vol. 12,1 4906. 12 Aug. 2021, doi:10.1038/s41467-021-25103-7


velocyto 预测速率（左图）和拟时变量（中图）在不同上皮细胞亚群聚类图上的投射结果。分化相关基因的unspliced reads 关于拟时变量的分布热图和亚群细胞密度统计（右图）。

为研究 MIBC 上皮细胞亚型间存在的发育演化路径，研究把 velocyto 轨迹推断结果投射在细胞亚型聚类结果中，发现基底层细胞（basal）可以通过是否包含 CDH12 高表达亚型的两条路径转化为伞状细胞（umbrella），该分支相关的 marker gene 可以揭示高表达 CDH12 上皮细胞亚型预测免疫治疗效果的机理。








3.学习文献 https://pubmed.ncbi.nlm.nih.gov/34914499/  Fig.2B

(1) Fig. 2. Heterogeneity and dynamics of CD8+ exhausted T cells. 
	(B) RNA velocities overlaid on UMAP showing two major state transition paths from naïve to exhaustion. 
	Arrows on a grid show the RNA velocity field, and dots are colored by metaclusters.

可能的代码:
	w.step1.Figure2.CD8_Tex_velo.ipynb

相关的代码:
	w.step2.FigureS20.CD8_ovTex_velo.ipynb

	w.step1.Figure3.CD4_global_velo.ipynb
	w.step2.FigureS26.CD4_Treg_velo.ipynb
	w.step2.FigureS13.CD8_global_velo.ipynb


(2) 复制到 jupyter 目录
$ cp w.step1.Figure2.CD8_Tex_velo.ipynb /data/wangjl/web/docs/jupyterlab/

jupyter notebook:
http://y.biomooc.com:9000/notebooks/w.step1.Figure2.CD8_Tex_velo.ipynb









========================================
|-- velocyto
----------------------------------------

http://pklab.med.harvard.edu/velocyto/notebooks/R/SCG71.nb.html


入门教程
http://velocyto.org/velocyto.py/install/index.html

1. 安装
# 依赖: numpy scipy cython numba matplotlib scikit-learn h5py click
$ pip3 install velocyto  #0.17.17


2. Tutorial
(1) 该工具包含2部分：
Velocyto consists of two main components:
1) 命令行工具
A command line interface (CLI), that is used to run the pipeline that generates spliced/unspliced expression matrices.
2) 一个函数库
A library including functions to estimate RNA velocity from the above mentioned data matrices.




(2) Running the CLI: 命令行从 bam/sam 文件到 loom 文件。
It starts from .bam/.sam files to yield a .loom file with counts divided in spliced/unspliced/ambiguous.

$ velocyto --help
Usage: velocyto [OPTIONS] COMMAND [ARGS]...

Options:
  --version  Show the version and exit.
  --help     Show this message and exit.

Commands:
  run            Runs the velocity analysis outputting a loom file
  run10x         Runs the velocity analysis for a Chromium Sample
  run_dropest    Runs the velocity analysis on DropEst preprocessed data
  run_smartseq2  Runs the velocity analysis on SmartSeq2 data (independent bam file per cell)
  tools          helper tools for velocyto


$ velocyto --version
velocyto, version 0.17.17

获取子命令的帮助
$ velocyto run --help

或者看 子命令的API文档: http://velocyto.org/velocyto.py/fullapi/cliapi.html#cliapi



(3) 准备文件
下载 GENCODE or Ensembl 的 gtf 文件。
如果是 10x 的数据，从这里下载: https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/advanced/references

命令格式: cellranger mkgtf input.gtf output.gtf --attribute=key:allowable_value

cellranger mkgtf Homo_sapiens.GRCh38.ensembl.gtf Homo_sapiens.GRCh38.ensembl.filtered.gtf \
                   --attribute=gene_biotype:protein_coding \
                   --attribute=gene_biotype:lincRNA \
                   --attribute=gene_biotype:antisense \
                   --attribute=gene_biotype:IG_LV_gene \
                   --attribute=gene_biotype:IG_V_gene \
                   --attribute=gene_biotype:IG_V_pseudogene \
                   --attribute=gene_biotype:IG_D_gene \
                   --attribute=gene_biotype:IG_J_gene \
                   --attribute=gene_biotype:IG_J_pseudogene \
                   --attribute=gene_biotype:IG_C_gene \
                   --attribute=gene_biotype:IG_C_pseudogene \
                   --attribute=gene_biotype:TR_V_gene \
                   --attribute=gene_biotype:TR_V_pseudogene \
                   --attribute=gene_biotype:TR_D_gene \
                   --attribute=gene_biotype:TR_J_gene \
                   --attribute=gene_biotype:TR_J_pseudogene \
                   --attribute=gene_biotype:TR_C_gene

多物种
cellranger mkref --genome=GRCh38 --fasta=GRCh38.fa --genes=GRCh38-filtered-ensembl.gtf \
                 --genome=mm10 --fasta=mm10.fa --genes=mm10-filtered-ensembl.gtf


# 对于新技术，支持写自己的逻辑，就是一个输入判断
http://velocyto.org/velocyto.py/fullapi/api_cli_logic.html#logicapi








(4) 运行 10x 数据，生成 loom 文件

第一个参数是包含子目录的 output 文件夹
(e.g. this is the folder containing the subfolder: outs, outs/analys and outs/filtered_gene_bc_matrices).

$ velocyto run10x --help
Usage: velocyto run10x [OPTIONS] SAMPLEFOLDER GTFFILE
  Runs the velocity analysis for a Chromium 10X Sample
  10XSAMPLEFOLDER specifies the cellranger sample folder
  GTFFILE genome annotation file
Options:
  -s, --metadatatable PATH        Table containing metadata of the various samples (csv fortmated rows are samples and cols are entries)
  -m, --mask PATH                 .gtf file containing intervals to mask
  -l, --logic TEXT                The logic to use for the filtering (default: Default)
  -M, --multimap                  Consider not unique mappings (not reccomended)
  -@, --samtools-threads INTEGER  The number of threads to use to sort the bam by cellID file using samtools
  --samtools-memory INTEGER       The number of MB used for every thread by samtools to sort the bam file
  -t, --dtype TEXT                The dtype of the loom file layers - if more than 6000 molecules/reads per gene per cell are expected set uint32 to avoid truncation (default run_10x: uint16)
  -d, --dump TEXT                 For debugging purposes only: it will dump a molecular mapping report to hdf5. --dump N, saves a cell every N cells. If p is prepended a more complete (but huge) pickle report is printed (default: 0)
  -v, --verbose                   Set the vebosity level: -v (only warinings) -vv (warinings and info) -vvv (warinings, info and debug)
  --help                          Show this message and exit.


$ velocyto run10x -m repeat_msk.gtf mypath/sample01 somepath/refdata-cellranger-mm10-1.2.0/genes/genes.gtf

参数说明:
Where genes.gtf is the genome annotation file provided with the cellranger pipeline.  
repeat_msk.gtf is the repeat masker file described in the Preparation section above. 可选。
# 下载 mm10 的 mask 的gtf文件，就是重复区域不要。
https://genome.ucsc.edu/cgi-bin/hgTables?hgsid=611454127_NtvlaW6xBSIRYJEBI0iRDEWisITa&clade=mammal&org=Mouse&db=mm10&hgta_group=allTracks&hgta_track=rmsk&hgta_table=0&hgta_regionType=genome&position=chr12%3A56694976-56714605&hgta_outputType=primaryTable&hgta_outputType=gff&hgta_outFileName=mm10_rmsk.gtf

通常一个样品运行3个小时。
Execution time is ~3h for a typical sample but might vary significantly by sequencing depth and cpu power.

输出:
$ ls *
outs/
	cellsorted_possorted_genome_bam.bam
velocyto/
	cellranger.loom #后续使用R包分析，就是基于该文件。




#
### 对于 SmartSeq2 样品。
velocyto includes a shortcut to perform the read counting for UMI-less, not stranded, full-length techniques such as SmartSeq2.
Typically SmartSeq2 bam files are generated and organized by well/cell in a folder structure similar to the following

plateX/A01/A01.bam
plateX/A02/A02.bam
plateX/A03/A03.bam

$ velocyto run_smartseq2 -o OUTPUT -m repeat_msk.gtf -e MyTissue plateX/*/*.bam mm10_annotation.gtf




#
如果使用规定的细胞呢？使用 velocyto run:
$ velocyto run [OPTIONS] BAMFILE... GTFFILE

$ velocyto run -b filtered_barcodes.tsv -o output_path -m repeat_msk_srt.gtf possorted_genome_bam.bam mm10_annotation.gtf
参数列表:
-b, --bcfile FILE               Valid barcodes file, to filter the bam. 
	如果不提供 -b 参数则使用全部细胞，会占用巨大的内存，花费很长时间，强烈建议提供 cell barcode!
-o, --outputfolder PATH         Output folder, if it does not exist it will be created.

-@, --samtools-threads INTEGER  The number of threads to use to sort the bam by cellID file using samtools
--samtools-memory INTEGER       The number of MB used for every thread by samtools to sort the bam file
	第一步在输入的bam文件夹创建按cellbarcode排序的bam文件特别耗时。建议使用多线程，还要控制每个线程使用的内存: --samtools-threads and --samtools-memory
	如果同名的 cellsorted_[ORIGINALBAMNAME] 存在，则会跳过第一步，直接使用这个文件。
	第一步也可以直接使用 samtools sort ，调用结束再运行 velocyto:
	$ samtools sort -t CB -O BAM -o cellsorted_possorted_genome_bam.bam possorted_genome_bam.bam


需要提前排序，cellranger做过了。
$ samtools sort mybam.bam -o sorted_bam.bam





对输入文件bam的要求:
- sorted by mapping position;
- 一个bam代表一个样品(10x)或者一个细胞(Smart-Seq2)
- 包含CB标签 (Contain an error corrected cell barcodes as a TAG named CB or XC.)
- 包含UB标签 (Contain an error corrected molecular barcodes as a TAG named UB or XM.)
对于SmartSeq2不需要(3-4)，因为它没有UMI.


GTF 文件的要求: http://velocyto.org/velocyto.py/tutorial/cli.html
	velocyto assumes that the gtf file follows the GENCODE gtf format description. 







(5) 输出的 loom 文件
About the output .loom file
The main result file is a 4-layered loom file : sample_id.loom.
	http://loompy.org/
	http://linnarssonlab.org/loompy/index.html

A valid .loom file is simply an HDF5 file that contains specific groups representing the main matrix as well as row and column attributes. Because of this, .loom files can be created and read by any language that supports HDF5.

.loom files can be easily handled using the loompy package: http://loompy.org/



2) Merging multiple samples/lanes in a single file
请问能够整合不同样本产生的Loom文件吗？还是只能单样本分析？

loompy.combine(files, output_filename, key="Accession")

或者:

files = ["file1.loom","file2.loom","file3.loom","file4.loom"]
# on the command line do: cp file1.loom merged.loom
ds = loompy.connect("merged.loom")
for fn in files[1:]:
    ds.add_loom(fn, batch_size=1000)


3) HDF5 的连接就像数据库一样，不是完全载入，只是在必须的时刻载入需要的数据，也可以修改、写入。
ds = loompy.connect("filename.loom")
# do something with the connection object ds
ds.close()


HDF5(https://en.wikipedia.org/wiki/Hierarchical_Data_Format) 文件不支持并发读写(They do not support writing and reading concurrently.)

也不支持日志。所以写入时发生意外，有可能造成整个文件丢失！
They also do not support journalling, so if something happens during a write, the entire file can be lost. 





2. 使用R分析 loom 文件
http://pklab.med.harvard.edu/velocyto/notebooks/R/SCG71.nb.html

(1) 读入数据
library(velocyto.R)
loom="/data/cellranger.loom"
Idat=read.loom.matrices(loom)
prefix="cellranger"
emat=Idat$spliced
hist( log(colSums(emat)), col="wheat", xlab="cell size")

说明:
emat 格式:
	cellranger.TTGGTTACAXx cellranger.TTAACCGGXx
A1CF                     0                     1
AACS                     3                     2

- 每个细胞表达基因的统计直方图
- 大部分基因表达处于中间位置，基因表达过低或者过高的细胞较少
- Cell size: 值的是每个细胞检测到的编导的基因数(log10)




(2) 数据过滤和标准化
# 对数据进行过滤：筛选出大于等于 200 个基因的细胞
emat=emat[, colSums(emat)>=200]
# 导入 pagoda2 包，生成细胞矩阵
library(pagoda2)
rownames(emat) = make.unique(rownames(emat))
#标准化数据
r=Pagoda2$new(emat, modelType="plain", trim=10, log.scale=T)
#作图，挑选变化较大的基因
r$adjustVariance(plot=T, do.par=T, gam.k=10)
# 一个点一个基因，x=在左右细胞中该基因的平均表达量，y=该基因的方差



(3) 细胞聚类与细胞嵌入分析
# 对细胞进行聚类和细胞嵌入分析
r$calculatePcaReduction(nPcs=100,n.odgenes=3e3,maxit=300)
r$makeKnnGraph(k=30,type='PCA',center=T,distance='cosine');

r$getKnnClusters(method=multilevel.community,type='PCA',name='multilevel')
r$getEmbedding(type='PCA',embeddingType='tSNE',perplexity=50,verbose=T)

# 聚类结果 可视化
par(mfrow=c(1,2))
r$plotEmbedding(type='PCA',embeddingType='tSNE',show.legend=F,mark.clusters=T,min.group.size=10,shuffle.colors=F,mark.cluster.cex=1,alpha=0.3,main='cell clusters')
r$plotEmbedding(type='PCA',embeddingType='tSNE',colors=r$depth,main='depth')  



(4) RNA 速度可视化
# 获取剪接、未剪接数据
# disregarding spanning reads, as there are too few of them
emat <- ldat$spliced; 
nmat <- ldat$unspliced; 


# 通过p2对细胞进行过滤
# restrict to cells that passed p2 filter
emat <- emat[,rownames(r$counts)]; 
nmat <- nmat[,rownames(r$counts)]; 


# 对分类数据进行标记
# take cluster labels
cluster.label <- r$clusters$PCA$multilevel # take the cluster factor that was calculated by p2
cell.colors <- pagoda2:::fac2col(cluster.label)
# take embedding form p2
emb <- r$embeddings$PCA$tSNE

# 计算细胞间的距离
cell.dist <- as.dist(1-armaCor(t(r$reductions$PCA)))

# 基于最小平均表达量筛选基因（至少在一个簇中），输出产生的有效基因数
emat <- filter.genes.by.cluster.expression(emat,cluster.label,min.max.cluster.average = 0.2)
nmat <- filter.genes.by.cluster.expression(nmat,cluster.label,min.max.cluster.average = 0.05)
length(intersect(rownames(emat),rownames(nmat)))

# 计算RNA速度
fit.quantile <- 0.02
rvel.cd <- gene.relative.velocity.estimates(emat,nmat,deltaT=1,kCells=25,cell.dist=cell.dist,fit.quantile=fit.quantile)


# 可视化RNA速度
show.velocity.on.embedding.cor(emb,rvel.cd,n=200,scale='sqrt',cell.colors=ac(cell.colors,alpha=0.5),cex=0.8,arrow.scale=3,show.grid.flow=TRUE,min.grid.cell.mass=0.5,grid.n=40,arrow.lwd=1,do.par=F,cell.border.alpha = 0.1)
# 箭头表示细胞发育方向



(5) 可视化特定的基因
# gene="IGHM"
gene <- "Camp"
gene.relative.velocity.estimates(
	emat,nmat,deltaT=1,kCells = 25,kGenes=1,
	fit.quantile=fit.quantile,	cell.emb=emb,	cell.colors=cell.colors,
	cell.dist=cell.dist,	show.gene=gene,	old.fit=rvel.cd,	do.par=T)




总结:
- 指向必须是已经测得的细胞，所以不能揭示潜在路径；
- 根据提供的坐标轴位置，揭示已知细胞群里最优2可能的发育方向
- 对数据进行回收利用，通过对 unsplied reads 获得细胞发育轨迹的潜在可能方向
- 做一些之前做不了的动力学研究，比如人前额大脑细胞













========================================
|-- scVelo 的使用
----------------------------------------

1. 原文推荐的
https://www.nature.com/articles/s41587-020-0591-3

Tenfold speedup for the steady-state model and large-scale applicability
The dynamical, the stochastic as well as the steady-state model are available within scVelo as a robust and scalable implementation (https://scvelo.org).

号称比原始实现 velocyto 要快10倍。
Illustratively, on pancreas development with 25,919 transcriptome profiles, scVelo runs the full pipeline for the steady-state as well as stochastic model from pre-processing the data to velocity estimation to projecting the data in any embedding in less than 1 min (Supplementary Fig. 13). That is obtained by memory-efficient, scalable and parallelized pipelines via integration with scanpy21, by leveraging efficient nearest-neighbor search39, analytical closed-form solutions, sparse implementation and vectorization. The scVelo pipeline thereby achieves more than a tenfold speedup over the original implementation (velocyto).


(1) 主要作用 scVelo’s key applications
https://scvelo.readthedocs.io/

estimate RNA velocity to study cellular dynamics.
identify putative driver genes and regimes of regulatory changes.
infer a latent time to reconstruct the temporal sequence of transcriptomic events.
estimate reaction rates of transcription, splicing and degradation.
use statistical tests, e.g., to detect different kinetics regimes.






2. 安装 py 包

(1) 尝试
$ pip3 install -U scvelo -i https://pypi.douban.com/simple/ --user

-U 是--upgrade 的缩写。如果出现Permission denied错误，请改用pip install -U scvelo --user
-i 是指定国内镜像。


2) 报错，可能是 numpy 版本太低：
$ pip3 list | grep numpy
numpy                              1.15.2
$ pip3 install -U numpy
$ pip3 list | grep numpy
numpy                              1.21.5     

3) 报错: AttributeError: module 'enum' has no attribute 'IntFlag'
reason
This is likely caused by the package enum34. Since python 3.4 there's a standard library enum module, so you should uninstall enum34, which is no longer compatible with the enum in the standard library since enum.IntFlag was added in python 3.6.

solution
uninstall enum34:
$ pip uninstall enum34  


升级 conda
$ conda update conda
# conda                              4.6.14     
# conda-build                        3.15.1 



4) 报错: 
ERROR: Failed building wheel for llvmlite

ERROR: statsmodels 0.13.2 has requirement pandas>=0.25, but you'll have pandas 0.23.4 which is incompatible.
ERROR: statsmodels 0.13.2 has requirement patsy>=0.5.2, but you'll have patsy 0.5.0 which is incompatible.
ERROR: multiqc 1.7 has requirement matplotlib<3.0.0,>=2.1.1, but you'll have matplotlib 3.5.1 which is incompatible.
ERROR: anndata 0.7.8 has requirement pandas>=1.1.1, but you'll have pandas 0.23.4 which is incompatible.

$ pip3 install -U pandas --user #pandas-1.3.5


ERROR: statsmodels 0.13.2 has requirement packaging>=21.3, but you'll have packaging 17.1 which is incompatible.
ERROR: statsmodels 0.13.2 has requirement patsy>=0.5.2, but you'll have patsy 0.5.0 which is incompatible.
ERROR: multiqc 1.7 has requirement matplotlib<3.0.0,>=2.1.1, but you'll have matplotlib 3.5.1 which is incompatible.
ERROR: matplotlib 3.5.1 has requirement packaging>=20.0, but you'll have packaging 17.1 which is incompatible.
ERROR: anndata 0.7.8 has requirement packaging>=20, but you'll have packaging 17.1 which is incompatible.

$ pip3 install -U patsy --user
$ pip3 install -U matplotlib --user
$ pip3 install -U packaging --user

Installing collected packages: llvmlite, numba, pynndescent, umap-learn, natsort, cached-property, h5py, zipp, importlib-metadata, anndata, fonttools, pyparsing, pillow, matplotlib, stdlib-list, sinfo, networkx, statsmodels, scanpy, numpy-groupies, loompy, scvelo

$ pip3 install -U llvmlite --user
# Error: RuntimeError: Could not find a `llvm-config` binary.



5) 升级pip版本

$ pip3 install --upgrade pip 
$ pip3 install -U llvmlite --user #升级 pip3 后就正常了！！


$ pip3 install -U scvelo --user

$ pip3 install -U numexpr --user # 测试加载时报warning
## Pandas requires version '2.7.0' or newer of 'numexpr' (version '2.6.8' currently installed).

$ pip3 install -U tqdm  --user # 测试代码报错：ModuleNotFoundError: No module named 'tqdm.auto' #4.62.3
$ pip3 install -U seaborn --user # 画图时警告 #0.11.2


检查版本：
$ pip3 list | grep scvelo
scvelo                             0.2.4

尝试加载：
$ python3
>>> import scvelo as scv
>>> 
>>> quit()
$ 


小结：
升级 pip 很关键！



依赖包
anndata - 带注释的数据对象。0.7.8
scanpy - 用于单细胞分析的工具包。1.8.2
numpy - 1.21.5
scipy - 1.4.1
pandas - 1.3.5
scikit-learn - 0.24.1
matplotlib - 3.5.1
notebook - 5.6.0

部分scVelo（定向 PAGA 和 Louvain 模块化）需要安装（可选）：
$ pip3 install python-igraph louvain  #0.9.9 / 0.7.1

通过hnswlib[7]使用快速邻近搜索进一步需要安装（可选）：
$ pip3 install pybind11 hnswlib  #2.9.1 / 0.6.2










3. 使用 Seurat 和 scVelo 估计 RNA 速率

(1) 在R中
library(Seurat)
library(SeuratDisk)

# BiocManager::install("SeuratWrappers") #failed

# https://github.com/satijalab/seurat-wrappers
# remotes::install_github('satijalab/seurat-wrappers') #ok
library(SeuratWrappers)


#https://github.com/velocyto-team/velocyto.R
library(devtools)
if(0){
  BiocManager::install("pcaMethods")
  install_github("velocyto-team/velocyto.R")
}
library(velocyto.R)

# 下载 loom 格式的数据
# $ wget http://pklab.med.harvard.edu/velocyto/mouseBM/SCG71.loom
ldat <- ReadVelocity(file = "tmp/SCG71.loom")
bm <- as.Seurat(x = ldat)
bm[["RNA"]] <- bm[["spliced"]]
bm <- SCTransform(bm)
bm <- RunPCA(bm)
bm <- RunUMAP(bm, dims = 1:20)
bm <- FindNeighbors(bm, dims = 1:20)
bm <- FindClusters(bm)
DefaultAssay(bm) <- "RNA"
DimPlot(bm, label = T)

SaveH5Seurat(bm, filename = "tmp/mouseBM.h5Seurat")
Convert("tmp/mouseBM.h5Seurat", dest = "h5ad")




(2) 在py中 jupyter notebook







步骤 -1：将数据从 Seurat 转换为 Python / anndata
在 R 中使用 Seurat 执行了主要数据处理（过滤、归一化、聚类、批量对齐、降维）。可以使用 SeuratDisk R 包在 Seurat 和 anndata 格式之间进行转换。

# assuming that you have some Seurat object called seurat_obj:
seurat_obj=subset(scObj_nue, subset=sample=="APC1") #取一个小子集，缩短测试时间
seurat_obj # 3265 samples
DimPlot(seurat_obj, label = T)
out_data_dir="202202newTag/scVelo/"


# save metadata table:
seurat_obj$barcode <- colnames(seurat_obj)
seurat_obj$UMAP_1 <- seurat_obj@reductions$umap@cell.embeddings[,1]
seurat_obj$UMAP_2 <- seurat_obj@reductions$umap@cell.embeddings[,2]
write.csv(seurat_obj@meta.data, file='metadata.csv', quote=F, row.names=F)

# write expression counts matrix
library(Matrix)
counts_matrix <- GetAssayData(seurat_obj, assay='RNA', slot='counts')
writeMM(counts_matrix, file=paste0(out_data_dir, 'counts.mtx'))

# write dimesnionality reduction matrix, in this example case pca matrix
write.csv(seurat_obj@reductions$pca@cell.embeddings, file='pca.csv', quote=F, row.names=F)

# write gene names
write.table(
  data.frame('gene'=rownames(counts_matrix)),file='gene_names.csv',
  quote=F,row.names=F,col.names=F
)




## 转到 jupyter notebook
import os
os.chdir("/home/wangjl/data/neu/scRNA/202202newTag/scVelo/")
os.getcwd()
#

import scanpy as sc
import anndata
from scipy import io
from scipy.sparse import coo_matrix, csr_matrix
import numpy as np
import os
import pandas as pd

# load sparse matrix:
X = io.mmread("counts.mtx")

# create anndata object
adata = anndata.AnnData(
    X=X.transpose().tocsr()
)

# load cell metadata:
cell_meta = pd.read_csv("metadata.csv")

# load gene names:
with open("gene_names.csv", 'r') as f:
    gene_names = f.read().splitlines()

# set anndata observations and index obs by barcodes, var by gene names
adata.obs = cell_meta
adata.obs.index = adata.obs['barcode']
adata.var.index = gene_names

# load dimensional reduction:
pca = pd.read_csv("pca.csv")
pca.index = adata.obs.index

# set pca and umap
adata.obsm['X_pca'] = pca.to_numpy()
adata.obsm['X_umap'] = np.vstack((adata.obs['UMAP_1'].to_numpy(), adata.obs['UMAP_2'].to_numpy())).T

# plot a UMAP colored by sampleID to test:
sc.pl.umap(adata, color=['SampleID'], frameon=False, save=True)

# save dataset as anndata format
adata.write('my_data.h5ad')

# reload dataset
# adata = sc.read_h5ad('my_data.h5ad') #报错
adata.write_loom('out/my_data.loom')






################
## 最后一步保存排错:
ValueError: Unable to create dataset (name already exists)
Above error raised while writing key 'barcode' of <class 'h5py._hl.group.Group'> from /.
Above error raised while writing key 'obs' of <class 'h5py._hl.files.File'> from /.


$ python3 -m pip install --upgrade pip

$ pip3 list | grep scipy
## scipy   1.7.3
## pandas  1.3.5
## anndata  0.7.8
## h5py     3.6.0
$ pip3 install scipy --force-reinstall
$ pip3 install pandas --force-reinstall
$ pip3 install anndata --force-reinstall



ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.
tensorflow 2.1.0 requires scipy==1.4.1; python_version >= "3", but you have scipy 1.7.3 which is incompatible.
multiqc 1.7 requires matplotlib<3.0.0,>=2.1.1, but you have matplotlib 3.5.1 which is incompatible.
jupyter-console 5.2.0 requires prompt-toolkit<2.0.0,>=1.0.0, but you have prompt-toolkit 2.0.9 which is incompatible.


# https://www.jianshu.com/p/fb1cf5806912
大佬，我希望scVelo做RNA速率分析时使用的降维和聚类结果使用先前Seurat分析得到的。于是我将先前的Seurat转为loom再读入scanpy，可惜只将meta.data转为了.obs，reductinons中的结果并没有转换成功，请问知道如何解决这个问题嘛？？？期待你的回复。
=> 把降维聚类的结果替换就可以了.








Step 0: Constructing spliced and unspliced counts matrices
与Seurat 中使用的相同的基于 UMI 的基因计数矩阵不同，We need to have a matrix for spliced and unspliced transcripts。 我们可以使用 velocyto 命令行工具或使用 Kallisto-Bustools 构建这个矩阵。 在这里我使用了 velocyto 命令行工具。

velocyto 命令行工具具有直接从 cellranger 输出目录运行的功能，只需要提供 .bam 文件，也可以在任何单细胞平台上使用。

用法：
$ repeats="/path/to/repeats/mm10_rmsk.gtf"
$ transcriptome="/path/to/annoation/file/gencode.vM25.annotation.gtf"
$ cellranger_output="/path/to/cellranger/output/"  #是 out/的上一层文件夹。

$ velocyto run10x -m $repeats \
	$cellranger_output \
    $transcriptome


实例:APC1
$ cd /home/wangjl/data/neu/scRNA/202202newTag/scVelo/velocyto_apc1/ #这个没用，在哪运行无所谓。
$ velocyto run10x \
	-@ 50 \
	/home/wangjl/data/neu/neutrophils_scRNA/APC_tumor/apc_tumor_1/Tumor-1/ \
    /home/wangjl/data/ref/GRCm39/gencode/gencode.vM28.annotation.gtf
# 16:11-->21:38, 耗时 5h30min, 35G bam;
难怪没有指定输出文件夹，直接在原始文件夹内输出的。
/home/wangjl/data/neu/neutrophils_scRNA/APC_tumor/apc_tumor_1/Tumor-1/
outs/
velocyto/

生成的文件:
-rw-r--r--. 1 wangjl jinwf 45M Mar  8 21:38 /home/wangjl/data/neu/neutrophils_scRNA/APC_tumor/apc_tumor_1/Tumor-1/velocyto/Tumor-1.loom
-rw-r--r--. 1 wangjl jinwf 87M Mar  9 03:39 /home/wangjl/data/neu/neutrophils_scRNA/APC_tumor/apc_tumor_2/T1/velocyto/T1.loom





# Step 1: Load data

Now that we have our input data properly formatted, we can load it into python. 
Velocyto created a separate spliced and unspliced matrix for each sample, so we first have to merge the different samples into one object. 
Additionally, I am reformatting the cell barcodes to match my anndata object with the full genes-by-cells data.


import scvelo as scv
import scanpy as sc
import cellrank as cr
import numpy as np
import pandas as pd
import anndata as ad

scv.settings.verbosity = 3
scv.settings.set_figure_params('scvelo', facecolor='white', dpi=100, frameon=False)

cr.settings.verbosity = 2
adata = sc.read_h5ad('my_data.h5ad')

# load loom files for spliced/unspliced matrices for each sample:
ldata1 = scv.read('Sample1.loom', cache=True)
ldata2 = scv.read('Sample2.loom', cache=True)
ldata3 = scv.read('Sample3.loom', cache=True)
#Variable names are not unique. To make them unique, call `.var_names_make_unique`.
#Variable names are not unique. To make them unique, call `.var_names_make_unique`.
#Variable names are not unique. To make them unique, call `.var_names_make_unique`.

# rename barcodes in order to merge:
barcodes = [bc.split(':')[1] for bc in ldata1.obs.index.tolist()]
barcodes = [bc[0:len(bc)-1] + '_10' for bc in barcodes]
ldata1.obs.index = barcodes

barcodes = [bc.split(':')[1] for bc in ldata2.obs.index.tolist()]
barcodes = [bc[0:len(bc)-1] + '_11' for bc in barcodes]
ldata2.obs.index = barcodes

barcodes = [bc.split(':')[1] for bc in ldata3.obs.index.tolist()]
barcodes = [bc[0:len(bc)-1] + '_9' for bc in barcodes]
ldata3.obs.index = barcodes


# make variable names unique
ldata1.var_names_make_unique()
ldata2.var_names_make_unique()
ldata3.var_names_make_unique()

# concatenate the three loom
ldata = ldata1.concatenate([ldata2, ldata3])

# merge matrices into the original adata object
adata = scv.utils.merge(adata, ldata)

# plot umap to check
sc.pl.umap(adata, color='celltype', frameon=False, legend_loc='on data', title='', save='_celltypes.pdf')








ref:
https://mp.weixin.qq.com/s?__biz=MzI1Njk4ODE0MQ==&mid=2247493623&idx=1&sn=539756a4c444665aa6ab2024b44cb64d














========================================
细胞通讯分析
----------------------------------------




========================================
|- 细胞间通讯教程： cellphonedb 及其可视化
----------------------------------------
https://www.jianshu.com/p/f196c98e0954

1.
但是解析细胞类型异质性不应止于这些，还可以看细胞群之间的通讯。当然，这方面我们介绍过CellChat：细胞间相互作用分析利器。CellChat是以信号通路为单位来计算细胞间交流状态的，很多同学用cellphonedb来做基于配受体对的细胞间交流。


文章用到的图实例： Single-cell transcriptomics reveals regulators underlying immune cell diversity and immune subtypes associated with prognosis in nasopharyngeal carcinoma




2. 实例: 用经典的pbmc3k数据跑一下cellphonedb，并尝试可视化。














========================================
|-- CellChat：细胞间相互作用分析利器
----------------------------------------
https://www.jianshu.com/p/da145cff3d41

1.
细胞间信息传递方式一个是细胞表面配受体的相互作用，另一个通过细胞产生的可溶性小分子，即细胞因子。在单细胞数据分析中下游，有时候我们想看某几种细胞类型之间的相互作用，就有人推荐我们做一个配受体分析。那什么是配受体？我们在文章Cell-Cell Interaction Database|| 单细胞配受体库你还在文章的附录里找吗？中提到配受体其实是细胞的特定蛋白，蛋白追溯到基因表达上就是基因对。

Inference and analysis of cell-cell communication using CellChat
Suoqin Jin, Christian F. Guerrero-Juarez, Lihua Zhang, Ivan Chang, Peggy Myung, Maksim V. Plikus, Qing Nie
bioRxiv 2020.07.21.214387; doi: https://doi.org/10.1101/2020.07.21.214387






2. 实例：用CellChat来分析一下我们的PBMC数据，看看配受体分析的一般流程。






========================================
SCENIC转录因子分析: 单细胞基因调控网络分析
----------------------------------------

py https://www.bilibili.com/video/BV1az4y1673b/?spm_id_from=autoNext

1. 主要是4步
- GENIE3: 共表达模块分析
- RcisTarget: 调控元件分析
- AUCell: 细胞网络活动度分析
- cluster: 鉴定稳定的细胞状态


2. SCENIC 和 pySCENIC 的异同点

相同点 
	- 功能基本相同，都可以进行基因调控子分析和细胞状态的鉴定
	- 研发团队相同，作者排序略有差异
不同点
	- 样本量不同：
		前者用 GENIE3 适合小样本量数据
		后者使用 GRNBoost，更适合处理大样本数据
	- 网址不同
		https://github.com/aertslab/SCENIC 
		https://github.com/aertslab/pySCENIC






========================================
|- 转录因子调控网络 SCENIC: single-cell regulatory network inference and clustering //todo
----------------------------------------
SCENIC | 从单细胞数据推断基因调控网络和细胞类型 

SCENIC是一种同时重建基因调控网络并从单细胞RNA-seq数据中鉴定stable cell states的工具。基于共表达和DNA模基序 （motif）分析推断基因调控网络 ，然后在每个细胞中分析网络活性以鉴定细胞状态。


1.
SCENIC发表于2017年的Nature method文章。具体见链接:
https://www.nature.com/articles/nmeth.4463

以t-SNE图呈现AUC评分和TF表达情况（即调控元件的活动度）




2. 文章中的实例
https://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&mid=2247497665&idx=1&sn=74ac0e87b9689d5df7c0208e1c1dc0ac

(1)2018年CELL文章的800多个单细胞
文章标题是《Toward Minimal Residual Disease-Directed Therapy in Melanoma》，链接：https://pubmed.ncbi.nlm.nih.gov/30017245/

使用了SCENIC转录因子分析的结果制作了如下所示的3张图：

(A) t-SNE shows cells colored by state identity(SCENIC approach). The identities are inferred by the binary activities of the TF regulons. Cell identitiesinferred by SCENIC are largely overlappingwith the SCDE approach
(B) SCENIC analysis predicts TFs such as SOX10,MEF2C, TFAP2B, and RXRG as central hubs governing the NCSC state. TF regulon activitieswere quantified using AUCell.
(D) Gene regulatory network analysis using SCENIC identifies critical nodes driving the NDTC state.
图A是为了突出一个细胞亚群是某些TF的调控活性区域，图B是分别显示具体的TF是如何在该细胞亚群被富集出来的，图C是看该调控活性区域的突出TF的基因网络情况。

每个亚群都有各自富集到的转录因子，包括：pigmentation, NCSC, “invasive,” “proliferative” and SMC states ，都可以根据SCENIC转录因子分析的结果来绘制经典三张图，数据集在GSE116237，总共也就是 865个细胞：


(2)
2020年10月NC的膀胱癌免疫微环境
文章标题是；《Single-cell RNA sequencing highlights the role of inflammatory cancer-associated fibroblasts in bladder urothelial carcinoma》，链接是：https://www.nature.com/articles/s41467-020-18916-5

首先是：图 a Heatmap of the area under the curve (AUC) scores of TF motifs estimated per cell by SCENIC. Shown are top five differentially activated motifs in iCAFs and mCAFs, respectively

也就是说，研究者定位到了两个细胞亚群 iCAFs and mCAFs，然后针对性的对这两个细胞亚群进行SCENIC分析，取那些在两个细胞亚群有统计学差异的TF的全部细胞的AUC值进行热图可视化，如下：


然后是对两个细胞亚群有统计学差异的TF各取2个进行tSNE的可视化，看看具体是如何的差异：

TF各取2个进行tSNE的可视化

哪怕是这篇文章的作者并没有直接在GEO里面提供表达矩阵，我们也可以很容易去借鉴这里面的可视化方法，来具体展现我们的SCENIC分析结果！


(3)2020年12月NC的食管鳞状细胞癌微环境
文章标题是；《Immune suppressive landscape in the human esophageal squamous cell carcinoma microenvironment》，链接是 https://www.nature.com/articles/s41467-020-20019-0

同样的，取细胞亚群有统计学差异的TF的全部细胞的AUC值进行热图可视化：

文中图例是：j Heat-map of the t values of AUC scores of expression regulation by transcription factors of the indicated clusters, as estimated using SCENIC

这个时候的细胞亚群比较多，所以并不需要展现具体的每个细胞里面的该TF的AUC值啦，直接以细胞亚群的混合方式进行展现即可。

同样的分析，完全不同的展现方式

主要是靠大家对这个细胞通讯分析流程的理解，以及对结果的解读，后续我们会针对此推文前面提到的5款做细胞通讯分析软件的用法解读，并且合理的使用它们的分析结果来支撑我们的数据成为一个合理的生物学故事！





ref:
实例：https://www.jianshu.com/p/0bf18fe92c7d
http://blog.sciencenet.cn/home.php?mod=space&uid=118204&do=blog&id=1208136
https://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&mid=2247497665&idx=1&sn=74ac0e87b9689d5df7c0208e1c1dc0ac




========================================
inferCNV
----------------------------------------
1. 安装
(1)安装inferCNV之前需要安装JAGS程序，下载地址：
https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/

$ wget https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/Source/JAGS-4.3.0.tar.gz
$ tar zxvf JAGS-4.3.0.tar.gz
$ cd JAGS-4.3.0/
$ ./configure --prefix="/home/wangjl/"
$ make && make install

$ jags
Welcome to JAGS 4.3.0 on Tue Feb 23 12:19:27 2021

$ which jags
/home/wangjl/bin/jags

此程序安装之后，inferCNV依赖的rjags包才能正常安装，否则报错：configuration failed for package ‘rjags’


2) 放到路径中
$ pkg-config --modversion jags
4.3.0

## 在R中
> install.packages("rjags", configure.args="--enable-rpath")





(2) 安装发行版，作者推荐
if (!requireNamespace("BiocManager", quietly = TRUE))
     install.packages("BiocManager")
BiocManager::install("infercnv")

library(infercnv) # v 1.0.4



# or 安装github上的最新版
library("devtools")
devtools::install_github("broadinstitute/infercnv")




2. 使用10x pbmc-10k 单数据集。










========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------

