单细胞进阶分析主要是
	- 拟时序分析：
	- 细胞通讯分析：
	- SCENIC转录因子分析：
	- RNA Velocity 分析：

https://github.com/DawnEve/scRNAseqCode



========================================
进阶分析方法概述
----------------------------------------

单细胞分析十八般武艺
https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIyMzMwNDQ2MA==&action=getalbum&album_id=1593332494622359552





========================================
双细胞检测 doublet detection: Scrublet
----------------------------------------
什么是doublets？简单的说就是两个细胞混在一起，可能发生在细胞捕获过程中，并且可能会误导认为是两种细胞类型的过渡态（transitory states），所以应该去除

Doublets检测的软件：
①DoubletFinder
(https://github.com/chris-mcginnis-ucsf/DoubletFinder)
②Scrublet
(https://github.com/AllonKleinLab/scrublet)
③DoubletDecon
(https://github.com/EDePasquale/DoubletDecon)
④DoubletCluster



1. 张泽民 Science paper方法学描述

看来是对读入Seurat对象的做初步质控的细胞做的 Scrublet 检测。

(1)For the newly generated scRNA-seq data, Cell Ranger (version 3.0, 10x Genomics Inc) was used for sequencing reads mapping against the GRCh38 human reference genome, UMI counting, and cell identification. 

(2)Then cells with fewer than 200 genes detected or >10% mitochondrial UMI counts were filtered out; 
- genes detected in > 3 cells were kept. 
- Scrublet (49) was applied to each sequencing library to remove potential doublets, setting the expected doublet rate to 0.05, and the cells with doubletScore larger than 0.3 were filtered out.

(3) We applied Seurat (version 3) with default parameters to identify T/NK clusters.





2. Scrublet 的安装
https://github.com/AllonKleinLab/scrublet

(1) 官方安装会报错
$ pip3 install --user scrublet -i https://pypi.douban.com/simple/
一直报错，有人说 I also experienced this and managed to solve this by downgrading annoy to 1.16.3.
https://github.com/swolock/scrublet/issues/28

# 再次尝试
$ pip3 install --user annoy==1.16.3 -i https://pypi.douban.com/simple/
$ pip3 install --user scrublet -i https://pypi.douban.com/simple/
Successfully installed scrublet-0.2.3

# 版本检测
$ pip3 freeze | grep scrublet
scrublet==0.2.3


(2) 开 jupyter notebook 
$ jupyter notebook --no-browser --port 8787 --ip=192.168.2.xx
## 可能需要开放端口 sudo iptables -I INPUT -p tcp --dport 8787 -j ACCEPT 


(3) numpy兼容性报错修复
ImportError: cannot import name '_validate_lengths' from 'numpy.lib.arraypad' (/home/wangjl/software/anaconda3/lib/python3.7/site-packages/numpy/lib/arraypad.py)

~/software/anaconda3/lib/python3.7/site-packages/skimage/util/arraycrop.py in <module>
import numpy as np
----> 8 from numpy.lib.arraypad import _validate_lengths


版本太高了，而本工具使用的是 1.15.2: https://github.com/swolock/scrublet/issues/4
$ pip3 freeze | grep numpy
numpy==1.18.3
numpydoc==0.8.0



1)要么降低 np 版本：有风险，用完再升级回1.18.3。
$ pip3 install numpy==1.16.2 -i https://pypi.douban.com/simple/ #还是报错
$ pip3 install numpy==1.15.2 -i https://pypi.douban.com/simple/ #需要重启 jupyter 才能生效！




2) 要么修改该包源码：尝试，没找到地方，放弃
> import sys
> print(sys.path)

['/data/jinwf/wangjl/neu/scRNA/202201filter/script', 
'/home/wangjl/software/anaconda3/lib/python37.zip', 
'/home/wangjl/software/anaconda3/lib/python3.7', 
'/home/wangjl/software/anaconda3/lib/python3.7/lib-dynload', 
'/home/wangjl/.local/lib/python3.7/site-packages', 
'/home/wangjl/software/anaconda3/lib/python3.7/site-packages', 
'/home/wangjl/software/anaconda3/lib/python3.7/site-packages/IPython/extensions', 
'/home/wangjl/.ipython']


一个一个找这些路径，肯定能找到:
$ find /home/wangjl/.local/lib/python3.7/site-packages/. | grep -v -P "(py|pyc)$" | xargs grep -i "scrublet" --color=auto

因为设定了 --user，装到这里了：
$ cd /home/wangjl/.local/lib/python3.7/site-packages/./scrublet
$ ls -lht
total 52K
drwxr-xr-x. 2 wangjl jinwf 123 Dec 28 09:17 __pycache__
-rw-r--r--. 1 wangjl jinwf 25K Dec 28 09:17 scrublet.py
-rw-r--r--. 1 wangjl jinwf 20K Dec 28 09:17 helper_functions.py
-rw-r--r--. 1 wangjl jinwf  63 Dec 28 09:17 __init__.py

查找这个函数的位置
$ find . | xargs grep "_validate_lengths" --color=auto 2>/dev/null

没找到位置，放弃。

解决方法: 
from distutils import LooseVersion as Version
old_numpy = Version(np.__version__) < Version('1.16')
if old_numpy:
    from numpy.lib.arraypad import _validate_lengths
else:
    from numpy.lib.arraypad import _as_pairs




(4) 基本使用
给定原始（非标准化）UMI计算矩阵counts_matrix，其中细胞为行，基因为列，计算每个cell的doublet分数：

import scrublet as scr
scrub = scr.Scrublet(counts_matrix)
doublet_scores, predicted_doublets = scrub.scrub_doublets()

scr.scrub_doublets（）模拟数据的doublets，并使用k-最近邻分类器是每个转录组计算连续的doublet_score（在0和1之间）。
分数是由自动设定的阈值生成 predict_doublets，一个布尔数组，预测是doublets时为True，否则为False。








3. 运行
(1) 我的版本
import pandas as pd
counts_matrix = pd.read_csv("../filterSample/data/_BL2Y.counts.df.txt", sep=" ") #, header = None, index_col=None, names=['barcode'])
counts_matrix.shape

# check
# print(counts_matrix.shape)
# counts_matrix.iloc[1:4, 1:4]

import numpy as np
import scrublet as scr

scrub = scr.Scrublet(counts_matrix)
doublet_scores, predicted_doublets = scrub.scrub_doublets()


最佳实践 Best practices:
- 处理来自多个样品的数据时，分别对每个样品运行Scrublet。Scrublet用于检测由两个细胞的随机共包封形成的doublets，所以它可能在合并数据集上表现不佳;
- 在2-D嵌入（例如，UMAP或t-SNE）中可视化doublets预测;




(2) 重要的参数
https://github.com/swolock/scrublet/blob/master/examples/scrublet_basics.ipynb

1)初始化Scrublet对象
相关参数为：
•expected_doublet_rate，doublets的预期占比，通常为0.05-0.1，结果对该参数不是特别敏感。对于此示例数据，预期的doublets占比来自Chromium用户指南[9]
•sim_doublet_ratio，要模拟的doublets数量相对于转录组的观测值的比例。此值应该足够高，以使所有的doublet状态都能很好地由模拟doublets表示。设置得太高会使计算量增大，默认值是2（尽管设置低至0.5的值也对测试的数据集产生非常相似的结果。
•n_neighbors，用于构造转录组观测值和模拟doublets的KNN分类器的邻居数。默认值为round（0.5 * sqrt（n_cells）），通常表现比较好。

scrub = scr.Scrublet(counts_matrix, expected_doublet_rate=0.06)



2) 计算doublet score
运行下面的代码计算doublet score，内部处理过程包括:
	1.Doublet simulation
	2.Normalization, gene filtering, rescaling, PCA
	3.Doublet score calculation
	4.Doublet score threshold detection and doublet calling

doublet_scores, predicted_doublets = scrub.scrub_doublets(n_prin_comps=30, mean_center=True, normalize_variance=True)

doublet_scores, predicted_doublets = scrub.scrub_doublets(min_counts=2, min_cells=3, min_gene_variability_pctl=85, n_prin_comps=30)










========================================
|-- DoubletDetection依赖scanpy，在安装DoubletDetection前务必安装scanpy //todo
----------------------------------------












========================================
细胞周期的区分方法？
----------------------------------------

1. 2015 cell, Drop-seq

> dput(cycle.list)
list(G1S = c("ACD", "ACYP1", "ADAMTS1", "ANKRD10", "APEX2", "ARGLU1", "ATAD2", "BARD1", "BRD7", "C1orf63", "C7orf41", "C14orf142", "CAPN7", "CASP2", "CASP8AP2", "CCNE1", "CCNE2", "CDC6", "CDC25A", "CDCA7", "CDCA7L", "CEP57", "CHAF1A", "CHAF1B", "CLSPN", "CREBZF", "CTSD", "DIS3", "DNAJC3", "DONSON", "DSCC1", "DTL", "E2F1", "EIF2A", "ESD", "FAM105B", "FAM122A", "FLAD1", "GINS2", "GINS3", "GMNN", "HELLS", "HOXB4", "HRAS", "HSF2", "INSR", "INTS8", "IVNS1ABP", "KIAA1147", "KIAA1586", "LNPEP", "LUC7L3", "MCM2", "MCM4", "MCM5", "MCM6", "MDM1", "MED31", "MRI1", "MSH2", "NASP", "NEAT1", "NKTR", "NPAT", "NUP43", "ORC1", "OSBPL6", "PANK2", "PCDH7", "PCNA", "PLCXD1", "PMS1", "PNN", "POLD3", "RAB23", "RECQL4", "RMI2", "RNF113A", "RNPC3", "SEC62", "SKP2", "SLBP", "SLC25A36", "SNHG10", "SRSF7", "SSR3", "TAF15", "TIPIN", "TOPBP1", "TRA2A", "TTC14", "UBR7", "UHRF1", "UNG", "USP53", "VPS72", "WDR76", "ZMYND19", "ZNF367", "ZRANB2"), 

S = c("ABCC5", "ABHD10", "ANKRD18A", "ASF1B", "ATAD2", "BBS2", "BIVM", "BLM", "BMI1", "BRCA1", "BRIP1", "C5orf42", "C11orf82", "CALD1", "CALM2", "CASP2", "CCDC14", "CCDC84", "CCDC150", "CDC7", "CDC45", "CDCA5", "CDKN2AIP", "CENPM", "CENPQ", "CERS6", "CHML", "COQ9", "CPNE8", "CREBZF", "CRLS1", "DCAF16", "DEPDC7", "DHFR", "DNA2", "DNAJB4", "DONSON", "DSCC1", "DYNC1LI2", "E2F8", "EIF4EBP2", "ENOSF1", "ESCO2", "EXO1", "EZH2", "FAM178A", "FANCA", "FANCI", "FEN1", "GCLM", "GOLGA8A", "GOLGA8B", "H1F0", "HELLS", "HIST1H2AC", "HIST1H4C", "INTS7", "KAT2A", "KAT2B", "KDELC1", "KIAA1598", "LMO4", "LYRM7", "MAN1A2", "MAP3K2", "MASTL", "MBD4", "MCM8", "MLF1IP", "MYCBP2", "NAB1", "NEAT1", "NFE2L2", "NRD1", "NSUN3", "NT5DC1", "NUP160", "OGT", "ORC3", "OSGIN2", "PHIP", "PHTF1", "PHTF2", "PKMYT1", "POLA1", "PRIM1", "PTAR1", "RAD18", "RAD51", "RAD51AP1", "RBBP8", "REEP1", "RFC2", "RHOBTB3", "RMI1", "RPA2", "RRM1", "RRM2", "RSRC2", "SAP30BP", "SLC38A2", "SP1", "SRSF5", "SVIP", "TOP2A", "TTC31", "TTLL7", "TYMS", "UBE2T", "UBL3", "USP1", "ZBED5", "ZWINT"), 

G2M = c("ANLN", "AP3D1", "ARHGAP19", "ARL4A", "ARMC1", "ASXL1", "ATL2", "AURKB", "BCLAF1", "BORA", "BRD8", "BUB3", "C2orf69", "C14orf80", "CASP3", "CBX5", "CCDC107", "CCNA2", "CCNF", "CDC16", "CDC25C", "CDCA2", "CDCA3", "CDCA8", "CDK1", "CDKN1B", "CDKN2C", "CDR2", "CENPL", "CEP350", "CFD", "CFLAR", "CHEK2", "CKAP2", "CKAP2L", "CYTH2", "DCAF7", "DHX8", "DNAJB1", "ENTPD5", "ESPL1", "FADD", "FAM83D", "FAN1", "FANCD2", "G2E3", "GABPB1", "GAS1", "GAS2L3", "H2AFX", "HAUS8", "HINT3", "HIPK2", "HJURP", "HMGB2", "HN1", "HP1BP3", "HRSP12", "IFNAR1", "IQGAP3", "KATNA1", "KCTD9", "KDM4A", "KIAA1524", "KIF5B", "KIF11", "KIF20B", "KIF22", "KIF23", "KIFC1", "KLF6", "KPNA2", "LBR", "LIX1L", "LMNB1", "MAD2L1", "MALAT1", "MELK", "MGAT2", "MID1", "MIS18BP1", "MND1", "NCAPD3", "NCAPH", "NCOA5", "NDC80", "NEIL3", "NFIC", "NIPBL", "NMB", "NR3C1", "NUCKS1", "NUMA1", "NUSAP1", "PIF1", "PKNOX1", "POLQ", "PPP1R2", "PSMD11", "PSRC1", "RANGAP1", "RCCD1", "RDH11", "RNF141", "SAP30", "SKA3", "SMC4", "STAT1", "STIL", "STK17B", "SUCLG2", "TFAP2A", "TIMP1", "TMEM99", "TMPO", "TNPO2", "TOP2A", "TRAIP", "TRIM59", "TRMT2A", "TTF2", "TUBA1A", "TUBB", "TUBB2A", "TUBB4B", "TUBD1", "UACA", "UBE2C", "VPS25", "VTA1", "WSB1", "ZNF587", "ZNHIT2"), 

M = c("AHI1", "AKIRIN2", "ANKRD40", "ANLN", "ANP32B", "ANP32E", "ARHGAP19", "ARL6IP1", "ASXL1", "ATF7IP", "AURKA", "BIRC2", "BIRC5", "BUB1", "CADM1", "CCDC88A", "CCDC90B", "CCNA2", "CCNB2", "CDC20", "CDC25B", "CDC27", "CDC42EP1", "CDCA3", "CENPA", "CENPE", "CENPF", "CEP55", "CFLAR", "CIT", "CKAP2", "CKAP5", "CKS1B", "CKS2", "CNOT10", "CNTROB", "CTCF", "CTNNA1", "CTNND1", "DEPDC1", "DEPDC1B", "DIAPH3", "DLGAP5", "DNAJA1", "DNAJB1", "DR1", "DZIP3", "E2F5", "ECT2", "FAM64A", "FOXM1", "FYN", "G2E3", "GADD45A", "GAS2L3", "GOT1", "GRK6", "GTSE1", "HCFC1", "HMG20B", "HMGB3", "HMMR", "HN1", "HP1BP3", "HPS4", "HS2ST1", "HSPA8", "HSPA13", "INADL", "KIF2C", "KIF5B", "KIF14", "KIF20B", "KLF9", "LBR", "LMNA", "MCM4", "MDC1", "MIS18BP1", "MKI67", "MLLT4", "MZT1", "NCAPD2", "NCOA5", "NEK2", "NUF2", "NUP35", "NUP98", "NUSAP1", "ODF2", "ORAOV1", "PBK", "PCF11", "PLK1", "POC1A", "POM121", "PPP1R10", "PRPSAP1", "PRR11", "PSMG3", "PTP4A1", "PTPN9", "PWP1", "QRICH1", "RAD51C", "RANGAP1", "RBM8A", "RCAN1", "RERE", "RNF126", "RNF141", "RNPS1", "RRP1", "SEPHS1", "SETD8", "SFPQ", "SGOL2", "SHCBP1", "SMARCB1", "SMARCD1", "SPAG5", "SPTBN1", "SRF", "SRSF3", "SS18", "SUV420H1", "TACC3", "THRAP3", "TLE3", "TMEM138", "TNPO1", "TOMM34", "TPX2", "TRIP13", "TSG101", "TSN", "TTK", "TUBB4B", "TXNDC9", "TXNRD1", "UBE2D3", "USP13", "USP16", "VANGL1", "WIBG", "WSB1", "YWHAH", "ZC3HC1", "ZFX", "ZMYM1", "ZNF207"), 

MG1 = c("AGFG1", "AGPAT3", "AKAP13", "AMD1", "ANP32E", "ANTXR1", "BAG3", "BTBD3", "CBX3", "CDC42", "CDK7", "CDKN3", "CEP70", "CNIH4", "CTR9", "CWC15", "DCP1A", "DCTN6", "DEXI", "DKC1", "DNAJB6", "DSP", "DYNLL1", "EIF4E", "ELP3", "FAM60A", "FAM189B", "FOPNL", "FOXK2", "FXR1", "G3BP1", "GATA2", "GNB1", "GRPEL1", "GSPT1", "GTF3C4", "HIF1A", "HMG20B", "HMGCR", "HSD17B11", "HSPA8", "ILF2", "JMJD1C", "KDM5B", "KIAA0586", "KIF5B", "KPNB1", "KRAS", "LARP1", "LARP7", "LRIF1", "LYAR", "MORF4L2", "MRPL19", "MRPS2", "MRPS18B", "MSL1", "MTPN", "NCOA3", "NFIA", "NFIC", "NUCKS1", "NUFIP2", "NUP37", "ODF2", "OPN3", "PAK1IP1", "PBK", "PCF11", "PLIN3", "PPP2CA", "PPP2R2A", "PPP6R3", "PRC1", "PSEN1", "PTMS", "PTTG1", "RAD21", "RAN", "RHEB", "RPL13A", "SLC39A10", "SNUPN", "SRSF3", "STAG1", "SYNCRIP", "TAF9", "TCERG1", "TLE3", "TMEM138", "TOB2", "TOP1", "TROAP", "TSC22D1", "TULP4", "UBE2D3", "VANGL1", "VCL", "WIPF2", "WWC1", "YY1", "ZBTB7A", "ZCCHC10", "ZNF24", "ZNF281", "ZNF593"))





2. 其他的文献线索

(1) 荧光法
Genome Res. 2020 Apr;30(4):611-621. doi: 10.1101/gr.247759.118. Epub 2020 Apr 20.
Characterizing and inferring quantitative cell cycle phase in single-cell RNA-seq data analysis

https://pubmed.ncbi.nlm.nih.gov/32312741/

Although standard methods assign cells to discrete cell cycle stages, our method goes beyond this and quantifies cell cycle progression on a continuum. We found that, on average, scRNA-seq data from only five genes predicted a cell's position on the cell cycle continuum to within 14% of the entire cycle and that using more genes did not improve this accuracy. 


(2)Applying Oscope to a number of data sets, we demonstrated its utility and also identified a potential artifact in the Fluidigm C1 platform.
https://pubmed.ncbi.nlm.nih.gov/26301841/

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE64016

Total 213 H1 single cells and 247 H1-Fucci single cells were sequenced. The 213 H1 cells were used to evaluate Oscope in identifying oscillatory genes. The H1-Fucci cells were used to confirm the cell cycle gene cluster identified by Oscope in the H1 hESCs.










========================================
轨迹推断（TI，trajectory inference）也常被称作 伪时间分析（ pseudotime analysis ）
----------------------------------------

总体而言，作者发现大多数TI方法在这四个评估标准之间存在很大差异，只有少数方法（例如PAGA，Slingshot和SCORPIUS）比较均衡。
http://www.seqyuan.com/A%20comparison%20of%20single-cell%20trajectory%20inference%20methods.html


目前常用的轨迹推断软件包括monocle，slingshot，velocyto等，各有优劣。


拟时分析的本质是包含一条具有起点和终点的时间轴的细胞轨迹。时间轴的构建是在细胞轨迹的基础上，依据生物学先验知识来确定起点和终点完成的。

细胞轨迹的构建则是通过细胞的表达量特征来完成的，主流方法有三种：

（1）基于基因表达量的树图方法，经典软件是monocle和PAGA，以基因表达量动态变化来构建细胞轨迹；
（2）无监督聚类，经典算法是UMAP，UMAP的聚类结果包含一条隐匿的时间轴，这也是今年文章中UMAP降维逐渐替代tSNE降维的一个原因；
（3）基因的降解趋势和合成趋势，也就是今天我们会重点讨论的RNA velocity。




1. 许多生物过程都伴随着细胞状态的连续性变化，比如研究发育就会经常使用到。我们可以利用单细胞数据在高维空间画一条线，贯穿于多种细胞状态。最简单是点到点的一条路径，更复杂的还有一个点出发再生成多个分支。



轨迹推断，英文名词是：Trajectory Analysis。和它相关的另一个名词是：拟时序分析（pseudotime），指的是细胞沿着这个轨迹，并且对潜在的生物活动进行量化。注意这里看字面意思就知道，并不是指真正的时间，而是指细胞与细胞之间的更替、转化的顺序或者是轨迹，可以理解为“一个连续过程的缩影”。

不同的生物过程对应的“拟时序”也是不同的：
- Receptor Signaling
- Cell activation
- Cell proliferation
- Marker expression 




2. 看一下现在做相关分析的工具：来自
https://broadinstitute.github.io/2019_scWorkshop/pseudotime-cell-trajectories.html

Comparison: Cell Trajectories
Diffusion maps for high-dimensional single-cellanalysis
Diffusion pseudotime
Slingshot Paper
Optimal Transport
RNA Velocity


有评测文章发现：Slingshot、TSCAN、Monocle DDRTree这几种方法都不错


(2)在数据集上尝试不同TI方法的意义
在推断感兴趣的数据集的轨迹时，必须考虑另外两点：

• 轨迹以及其下游结果/假设需要在多种TI方法上得到重现，这样做可以确保轨迹的预测不会是由于给定的参数设置或TI方法所基于的特定算法而产出的偏好性的结果。
• 即使我们知道了预期的轨迹拓扑，也可以尝试一些分支较少的轨迹拓扑假设。如果使用这种方法确认了预期的拓扑，那么它将为用户提供证据支持；当产生更复杂的拓扑时，这可能表明基础生物学比用户预期的要复杂得多。


2019年发表在Nature biotechnology的一篇文章A comparison of single-cell trajectory inference methods (Saelensetal., 2019[6]) 对45种TI方法在110个真实数据集和229个合成数据集中进行了全面比较，主要评估了TI方法的准确性、可扩展性、稳定性和可用性四个方面


## 以下是文章(Saelens et al., 2019)的主要可参考点：
• 文章的研究评估发现：发现当前TI方法之间存在很大的互补性，数据集的特性不同，执行效果最佳的TI方法也不同
• 作者基于评估的结果，制定了一套准则，以帮助用户为自己的数据集选择最佳方法http://guidelines.dynverse.org
• 开发了一个R包--dyno[7]，把文章中测试过的TI方法进行了封装，目前已封装了55种，允许用户根据guidelines.dynverse推荐的方法，自由选择进行TI分析，dyno采用统一的输入，同时也对不同TI方法的输出做了统一


https://zouter.shinyapps.io/server/

作者对几十种TI方法的输入输出接口进行了标准化，并提供的统一的工具包dyno.






(3)有人整理了一份轨迹推断工具的清单：https://github.com/agitter/single-cell-pseudotime

做这个分析之前，最好先问几个问题：
- 确定数据会体现发育轨迹吗？也就是研究的样本是不是和发育相关的？
- 数据中的细胞会体现出中间态吗？
- 是否认为轨迹会出现分支？

并且要注意：
- 任何数据都可以强行画出轨迹，但不一定都有生物学意义！
- 先要保证目前找到的HVGs和降维结果符合我们的预期，才能继续向下分析












========================================
|-- Diffusion pseudotime (DPT): 2016
----------------------------------------
1. papers

https://academic.oup.com/bioinformatics/article/31/18/2989/241305
# Bioinformatics, Volume 31, Issue 18, 15 September 2015
Diffusion maps for high-dimensional single-cell analysis of differentiation data 

https://www.nature.com/articles/nmeth.3971
# nm|Published: 29 August 2016 | 
Diffusion pseudotime robustly reconstructs lineage branching




2.







========================================
|-- slingshot: minimum spanning tree (MST)
----------------------------------------
1.官方文档：
https://bioconductor.org/packages/release/bioc/vignettes/slingshot/inst/doc/vignette.html

它需要两个必须的输入文件：降维结果与细胞分群结果

因为它分析的基础假设就是：在低维空间上，细胞的位置是连续的并且是一个接一个的






========================================
|-- Monocle3 拟时序分析/细胞轨迹分析
----------------------------------------

Monocle的官网在：
版本2：https://cole-trapnell-lab.github.io/monocle-release/docs/#installing-monocle
版本3：https://cole-trapnell-lab.github.io/monocle3/monocle3_docs/


1. 定义
本质就是根据每个细胞的基因表达情况找出关键的表达模式来对细胞进行排序，反推出细胞发育轨迹。
用于细胞分化的研究(胚胎发育，细胞重编程，癌细胞分化，...)

2. 原理 
一次取样中有不同发育状况的细胞。
如果根据转录组能推断出细胞的先后顺序，则可以反推出细胞发育轨迹。

达尔文物种进化分析类似，是根据形态学的相似性排序的。



3. 软件简介
(1)单细胞轨迹分析的软件: Monocle, SCUBA, STREAM, Wishbone, ...

(2)Monocle 的优势：主流期刊常用，接受度高；功能强大。
https://cole-trapnell-lab.github.io/monocle3/

功能: trajectories, clustering, Defferential expression.


实例: 细胞重编程成功与失败的分界点 Cell Stem Cell 2018 paper:
Single-Cell RNA-Seq Reveals Dynamic Early Embryonic-like Programs during Chemical Reprogramming
https://pubmed.ncbi.nlm.nih.gov/29937202/

Reconstruction of Chemical Reprogramming Trajectory in a Pseudotime Manner
The gene expression profiling data of all the single cells allowed us to deconstruct the population heterogeneity and reconstruct the reprogramming trajectory. We ordered cells in a pseudo-temporal manner using Monocle 2, an algorithm for the lineage reconstruction of biological processes based on transcriptional similarity (Qiu et al., 2017).


(3) 流程 workflow

scRNAseq -> Pre-process data(Normalize, Remove batch effect) ->Non_linear dimensionality reduction(UMAP) ->Cluster cells
-> Compare clusters(Identify top markers, Targeted contrasts) -> Trajectory analysis

导入数据 - 预处理 - 降维 -聚类 - 比较找marker - 拟时序分析 



(4) 数据导入 
library(monocle3) #v1.0.0

1)可以导入 cellrange结果(v2, v3)
gene_bc_matrix <- load_cellranger_data("/home/user/cellranger_output")

2) 否则就要准备三个文件
expression_matrix 就是表达矩阵，一行一个基因，一列一个cell，值是 raw counts，是一个稀疏矩阵
cell_metadata 一行一个细胞，一列代表一个细胞属性，比如样本编号、组织类型、分群编号
gene_metadata 一行一个基因，三列 id, gene_short_name(必须列), num_cell_expressed

new_cell_data_set(expression_data, cell_metadata = NULL, gene_metadata = NULL)

Arguments
expression_data: expression data matrix for an experiment, can be a sparseMatrix.

cell_metadata: data frame containing attributes of individual cells, where row.names(cell_metadata) = colnames(expression_data).

gene_metadata: data frame containing attributes of features (e.g. genes), where row.names(gene_metadata) = row.names(expression_data).



3) 比如，导入 Seurat 的结果
# load data from Seurat
pbmc

expression_data=as.matrix(pbmc@assays$RNA@counts)
cell_data=pbmc@meta.data
gene_data=data.frame(
  gene_short_name=row.names(pbmc), #must have this column
  row.names = row.names(pbmc)
)
head(gene_data)

cds=new_cell_data_set(expression_data, cell_data, gene_data)
cds






4. 分析流程示例

(1) 数据导入 
pbmc
DimPlot(pbmc, label = T)
pbmc$celltype=pbmc@active.ident

sce_T=subset(pbmc, celltype %in%  c("Naive CD4 T", "Memory CD4 T", "CD8 T", "NK"))
sce_T
DimPlot(sce_T, label = T)


library(monocle3)
# 1.load data from Seurat
load_from_Seurat=function(sce){
  expression_data=GetAssayData(sce, assay = 'RNA', slot = 'counts')
  cell_data=sce@meta.data
  gene_data=data.frame(
    gene_short_name=row.names(sce), #must have this column
    row.names = row.names(sce)
  )
  # head(gene_data)

  new_cell_data_set(expression_data, cell_data, gene_data)
}

cds=load_from_Seurat(sce_T)
cds




(2) 预处理 (log预处理)
#preprocess_cds函数相当于seurat中NormalizeData+ScaleData+RunPCA

# pre-processing(log)
cds=preprocess_cds(cds, norm_method = "log", method = "PCA",
                   num_dim=100)

# 标准化: log处理，减小数据的离散程度
# 线性降维: PCA, LSI。RNA-seq前者更好。ATAC使用后者
# 使用的PC数，默认为50.

# 判断使用多少个PC
plot_pc_variance_explained(cds) #从图中看，15个够用了


(3) 降维 
# UMAP
cds=reduce_dimension(cds, preprocess_method = "PCA", reduction_method = 'UMAP')
plot_cells(cds, reduction_method="UMAP", color_cells_by="celltype") + ggtitle('cds.umap')


# 查看基因表达情况
gene_list=c("CD3D", "CD4", "CD8A", "CD79A")
plot_cells(cds,
           genes=gene_list,
           label_cell_groups = F,
           show_trajectory_graph = F)

(4) 细胞聚类(比 Seurat 的粗，大概认为一个发育过程的几个细胞亚群都划分到一个 partition 了)
目的：找到那些细胞在一个发育轨迹上。
#cds = cluster_cells(cds)
#plot_cells(cds, color_cells_by = "partition")



##从seurat导入整合过的umap坐标(可选)
cds.embed <- cds@int_colData$reducedDims$UMAP

int.embed <- Embeddings(sce_T, reduction = "umap")
int.embed <- int.embed[rownames(cds.embed),]

cds@int_colData$reducedDims$UMAP <- int.embed
p2 <- plot_cells(cds, reduction_method="UMAP", color_cells_by="celltype") + ggtitle('int.umap')
p2

## Monocle3聚类分区
# cds <- cluster_cells(cds)
p1 <- plot_cells(cds, color_cells_by = "seurat_clusters", show_trajectory_graph = FALSE) + ggtitle("label by clusterID")
p2 <- plot_cells(cds, color_cells_by = "partition", show_trajectory_graph = FALSE) +
  ggtitle("label by partitionID")
p1 + p2





(5). 找出发育轨迹
目的：在上一步分群的基础上，找出每个群内的细胞的发育轨迹。
无监督，没有基于生物学背景知识。需要酌情取舍。

cds=learn_graph(cds)
plot_cells(cds, color_cells_by = "seurat_clusters",
           label_groups_by_cluster = F,
           label_leaves = F,
           label_branch_points = F)
#Error: color_cells_by must one of 'cluster', 'partition', 'pseudotime, 
# or a column in the colData table.


(6) 确定轨迹的先后顺序
对每条轨迹确定头和尾巴
- 基于算法
	根据细胞轨迹图中的节点把它们相聚较近的细胞进行分组
	计算每个节点来自最早时间的细胞(场外信息)所占的比例
	包含早期细胞最多的节点就是根节点。
- 手动(每个轨迹均需要指定一个根节点) 大多数情况是手动。


cds=order_cells(cds, reduction_method = "UMAP") #手动设定起点
plot_cells(cds, color_cells_by = "pseudotime")











5. monocle3差异分析

##寻找拟时轨迹差异基因 Finding genes that change as a function of pseudotime
#graph_test分析最重要的结果是莫兰指数（morans_I），其值在-1至1之间，0代表此基因没有
#空间共表达效应，1代表此基因在空间距离相近的细胞中表达值高度相似。
Track_genes <- graph_test(cds, neighbor_graph="principal_graph", cores=10)

#挑选top10画图展示
Track_genes_sig <- Track_genes %>% filter(q_value < 0.05) %>% top_n(n=10, morans_I) %>%
  pull(gene_short_name) %>% as.character()

plot_cells(cds, genes=Track_genes_sig,
           show_trajectory_graph=FALSE,
           label_cell_groups=FALSE,
           label_leaves=FALSE)


#(1)基因表达趋势图
plot_genes_in_pseudotime(cds[Track_genes_sig,], color_cells_by="seurat_clusters", #celltype
                         min_expr=0.5, ncol = 2)+
  guides( color = guide_legend( override.aes = list(size=5)))
# 可比较基因开始表达时间的早晚。


#(2)FeaturePlot图
plot_cells(cds, genes=Track_genes_sig, show_trajectory_graph=FALSE,
           label_cell_groups=FALSE,  label_leaves=FALSE)

##(3)寻找共表达模块
genelist <- pull(Track_genes, gene_short_name) %>% as.character()
gene_module <- find_gene_modules(cds[genelist,], resolution=1e-2, cores = 10)
cell_group <- tibble::tibble(cell=row.names(colData(cds)),
                             cell_group=colData(cds)$celltype)
agg_mat <- aggregate_gene_expression(cds, gene_module, cell_group)
row.names(agg_mat) <- stringr::str_c("Module ", row.names(agg_mat))
pheatmap::pheatmap(agg_mat, scale="column", border_color = NA,
                   clustering_method="ward.D2")

pheatmap::pheatmap( t(agg_mat), scale="row", border_color = NA,
                   clustering_method="ward.D2")

plot_cells(cds,
           genes=gene_module %>% filter(module %in% c(16, 27, 10, 7, 30,13)),
           label_cell_groups=FALSE,
           show_trajectory_graph=FALSE)







6. choose one branch

# 手动选择一个分支
cds_subset <- choose_cells(cds)
cds_subset

subset_pr_test_res <- graph_test(cds_subset, neighbor_graph="principal_graph", cores=4)
pr_deg_ids <- row.names(subset(subset_pr_test_res, q_value < 0.05))

gene_module_df <- find_gene_modules(cds_subset[pr_deg_ids,], resolution=0.001)

agg_mat <- aggregate_gene_expression(cds_subset, gene_module_df)
module_dendro <- hclust(dist(agg_mat))
gene_module_df$module <- factor(gene_module_df$module,
                                levels = row.names(agg_mat)[module_dendro$order])

plot_cells(cds_subset,
           genes= gene_module_df %>% group_by(module) %>% top_n(4) %>% pull(id),
           label_cell_groups=F,
           show_trajectory_graph=F)




refer:
https://mp.weixin.qq.com/s?__biz=MzIyMzMwNDQ2MA==&mid=2247484327&idx=1&sn=46c78c70cbe2b8c3fb5f282458bff0d6












========================================
|-- Monocle2 分析
----------------------------------------

1. Monocle2 拟时序轨迹分支的两种情况处理

区分的关键是要不要分支。要根据情况确定。

(1) 不考虑分支，只考虑随时间变化的基因变化趋势。
(2) 在变化过程中两个分支差异比较大可以考虑分支变化。

2. 三种图，分别表示不同的意义

- 拟时序基因表达量图: 一个基因在不同cluster中的表达情况

- 拟时序基因表达量图在 UMAP 上：看出在发育过程中的变化

- 基因 switch (开关): x是时间，y是一条线上面是表达to不表达，线下 不表达to表达。距离线越远，表示开关变化越明显。

- 基因密度图：对基因开关进行富集分析，然后把GO画到 拟时间 轴上。



例子: 对原发和复发HCC放到一起 拟时间分析，然后分析时间轴上哪边细胞多(细胞密度图)









========================================
|-- RNA Velocity 分析
----------------------------------------

paper:
Letter | Published: 08 August 2018: RNA velocity of single cells
https://www.nature.com/articles/s41586-018-0414-6



https://zhuanlan.zhihu.com/p/142327236

1. 背景介绍

- 无需生物学背景的先验经验：研究者可以从向量结果中读出分化轨迹
- 数据兼容性强：RNA velocity的数据可以嵌入普通的PCA、tSNE、UMAP降维，也可以嵌入monocle、PAGA构建的细胞轨迹


(1)
这就像在所有运动时间凝固的照片，”教授解释斯登Linnarsson在医学生物化学与生物物理系，卡罗林斯卡医学院，谁领导这项研究的研究人员之一。“我们现在已经开发出一种新方法，不仅可以测量遗传活性，还可以测量单个细胞中这种活性的变化。您可以将其与长时间曝光拍摄的照片进行比较，这会导致运动模糊：静止的对象清晰而运动的对象模糊。快速移动的对象会变得模糊，而移动的方向会被模糊的方向所揭示。”
用于研究肿瘤形成，伤口愈合和免疫系统的方法

新方法利用了这样一个事实，即当基因被激活时，一系列RNA分子会以一定顺序形成。通过分离这些分子，研究人员可以确定一个基因是否刚刚被激活，或者例如它即将被关闭。

Linnarsson教授说：“这种新方法使我们能够详细观察胚胎中包括人类胚胎如何形成专门的细胞类型。” “它也可以用于研究动态的疾病过程，例如肿瘤形成，伤口愈合和免疫系统。”



(2)测量跨复杂组织的基因表达的动态变化

RNA剪切：成熟mRNA表达时，未成熟的一部分转录本会被剪切掉。当基因的表达增加时，在细胞中观察到未成熟、未剪接的转录本的比例与成熟的剪接的转录本的比例相比瞬时增加。相反，当基因表达降低时，在短时间内看到较高比例的剪接转录本（未显示）。La Manno等。

原理: 

通过测量单个细胞中每个基因的未剪接转录本与剪接转录本的比率，计算出一个称为RNA速度的量，揭示了基因表达的变化方式。b通过测量组织中成千上万个细胞（此处为发育中的小鼠大脑神经元）中的RNA速度，作者可以生成图，不仅显示相互关联的细胞之间的紧密程度（相似性用相似的颜色表示），而且还根据它们正在经历的基因表达变化，将来与哪些细胞相似（如箭头所示）。RNA速度成功地追踪了早期祖细胞（橙色和黄色），这些祖细胞最终引起了一系列分化的细胞类型（蓝色虚线圆圈）。

(3) 论文 
https://www.biorxiv.org/content/10.1101/820936v1.full.pdf
https://www.nature.com/articles/s41587-020-0591-3


(4) 原理与代码

velocyto 使用 mRNA 的可变剪切来估计 RNA 变化速率。可变剪切（differential splicing）也称选择性剪切（alternative splicing），是前体 RNA 转化为成熟 mRNA 的关键步骤。一般来说基因转录开始后，相关前体 RNA 最开始增加，随后 mRNA 才开始增加，天然具有时间属性。

测序数据比对结果中总存在一定比例无法定义为 counts 的 reads。在传统比对时，一般舍弃。


velocyto 通过重新注释比对结果来评估细胞中特定基因的剪接读长（spliced reads）和未剪接读长（unspliced）。根据这些信息对每个基因拟合一个数学模型，认为该模型代表基因表达平衡态。


该模型中，u 代表 unspliced reads ，s 代表 spliced reads，γ 代表 RNA 降解和剪接速率的估计，虚线是拟合出来的平衡态。一般认为当 u> γs 时基因处于转录激活态，反之为抑制。这样，对于每个基因，拟合出 γ 后，就可以根据平衡态预测速率；再通过基因预测结果综合判断细胞的速率；最后计算细胞间速率相关性，最终完成轨迹推断。

velocyto 软件有 python 和 R 两种版本，大家可按需取用。
http://velocyto.org/velocyto.py/tutorial/analysis.html


seuratwrapper 整合了 velocyto 软件并提供测试数据下载，大家可以根据示例代码，跑一跑测试数据，直观感受一下运行流程。
# https://mp.weixin.qq.com/s?__biz=MzU2Nzg3MzYyOA==&mid=2247485100&idx=1&sn=2b8d81881966797497412c508402e9b6

library(Seurat)
library(velocyto.R)
library(SeuratWrappers)

# If you don't have velocyto's example mouse bone marrow dataset, download with the CURL command
# curl::curl_download(url = 'http://pklab.med.harvard.edu/velocyto/mouseBM/SCG71.loom', destfile = '~/Downloads/SCG71.loom')

ldat <- ReadVelocity(file = "~/Downloads/SCG71.loom")
bm <- as.Seurat(x = ldat)
bm <- SCTransform(object = bm, assay = "spliced")
bm <- RunPCA(object = bm, verbose = FALSE)
bm <- FindNeighbors(object = bm, dims = 1:20)
bm <- FindClusters(object = bm)
bm <- RunUMAP(object = bm, dims = 1:20)

# 拟合平衡系数 γ
bm <- RunVelocity(object = bm, deltaT = 1, kCells = 25, fit.quantile = 0.02)
ident.colors <- (scales::hue_pal())(n = length(x = levels(x = bm)))
names(x = ident.colors) <- levels(x = bm)
cell.colors <- ident.colors[Idents(object = bm)]
names(x = cell.colors) <- colnames(x = bm)

# 将速率投射在降维空间上画图
show.velocity.on.embedding.cor(emb = Embeddings(object = bm, reduction = "umap"), vel = Tool(object = bm,
    slot = "RunVelocity"), n = 200, scale = "sqrt", cell.colors = ac(x = cell.colors, alpha = 0.5),
    cex = 0.8, arrow.scale = 3, show.grid.flow = TRUE, min.grid.cell.mass = 0.5, grid.n = 40, arrow.lwd = 1,
    do.par = FALSE, cell.border.alpha = 0.1)




(5) 结果解读
velocyto 提供在总体细胞和单个基因两个层面上的结果。

1) 总体细胞轨迹推断在特定降维空间的投射结果

如上图，左图在单个细胞层面的投射结果，右图为根据周围细胞计算简化后的结果。

velocyto 会对每个细胞拟合一个速率推断结果，将之投射在降维空间中就能显示轨迹推断的方向。在细胞量较多时，左图轨迹可能会高度重叠看不清楚，常转化为右图简化的形式。

2) 单个基因的速率拟合结果

上图中，从左到右依次是选定基因的 splice reads(s)、unspliced reads(u) 统计、 速率拟合和拟合结果残差分布结果。

velocyto 也可以展示单个细胞的速率拟合结果，包含每个细胞该基因注释出剪切 reads 数和非剪切 reads 数、平衡态 γ 系数和单个细胞距离平衡态的残差。一般来说基因在特定细胞中 u 残差越大其转录越活跃。


(6) 文献解读

一项有关肌层浸润性膀胱癌（muscle-invasive bladder cancer ，MIBC）的研究中，发现一类高表达 Cadherin 12（CDH12）的上皮细胞亚型可以用于预测免疫治疗效果[2]。
[2]. Gouin, Kenneth H 3rd et al. “An N-Cadherin 2 expressing epithelial cell subpopulation predicts response to surgery, chemotherapy and immunotherapy in bladder cancer.” Nature communications vol. 12,1 4906. 12 Aug. 2021, doi:10.1038/s41467-021-25103-7


velocyto 预测速率（左图）和拟时变量（中图）在不同上皮细胞亚群聚类图上的投射结果。分化相关基因的unspliced reads 关于拟时变量的分布热图和亚群细胞密度统计（右图）。

为研究 MIBC 上皮细胞亚型间存在的发育演化路径，研究把 velocyto 轨迹推断结果投射在细胞亚型聚类结果中，发现基底层细胞（basal）可以通过是否包含 CDH12 高表达亚型的两条路径转化为伞状细胞（umbrella），该分支相关的 marker gene 可以揭示高表达 CDH12 上皮细胞亚型预测免疫治疗效果的机理。








2.学习文献 https://pubmed.ncbi.nlm.nih.gov/34914499/  Fig.2B

(1) Fig. 2. Heterogeneity and dynamics of CD8+ exhausted T cells. 
	(B) RNA velocities overlaid on UMAP showing two major state transition paths from naïve to exhaustion. 
	Arrows on a grid show the RNA velocity field, and dots are colored by metaclusters.

可能的代码:
	w.step1.Figure2.CD8_Tex_velo.ipynb

相关的代码:
	w.step2.FigureS20.CD8_ovTex_velo.ipynb

	w.step1.Figure3.CD4_global_velo.ipynb
	w.step2.FigureS26.CD4_Treg_velo.ipynb
	w.step2.FigureS13.CD8_global_velo.ipynb


(2) 复制到 jupyter 目录
$ cp w.step1.Figure2.CD8_Tex_velo.ipynb /data/wangjl/web/docs/jupyterlab/

jupyter notebook:
http://y.biomooc.com:9000/notebooks/w.step1.Figure2.CD8_Tex_velo.ipynb















========================================
细胞通讯分析
----------------------------------------




========================================
|- 细胞间通讯教程： cellphonedb 及其可视化
----------------------------------------
https://www.jianshu.com/p/f196c98e0954

1.
但是解析细胞类型异质性不应止于这些，还可以看细胞群之间的通讯。当然，这方面我们介绍过CellChat：细胞间相互作用分析利器。CellChat是以信号通路为单位来计算细胞间交流状态的，很多同学用cellphonedb来做基于配受体对的细胞间交流。


文章用到的图实例： Single-cell transcriptomics reveals regulators underlying immune cell diversity and immune subtypes associated with prognosis in nasopharyngeal carcinoma




2. 实例: 用经典的pbmc3k数据跑一下cellphonedb，并尝试可视化。














========================================
|-- CellChat：细胞间相互作用分析利器
----------------------------------------
https://www.jianshu.com/p/da145cff3d41

1.
细胞间信息传递方式一个是细胞表面配受体的相互作用，另一个通过细胞产生的可溶性小分子，即细胞因子。在单细胞数据分析中下游，有时候我们想看某几种细胞类型之间的相互作用，就有人推荐我们做一个配受体分析。那什么是配受体？我们在文章Cell-Cell Interaction Database|| 单细胞配受体库你还在文章的附录里找吗？中提到配受体其实是细胞的特定蛋白，蛋白追溯到基因表达上就是基因对。

Inference and analysis of cell-cell communication using CellChat
Suoqin Jin, Christian F. Guerrero-Juarez, Lihua Zhang, Ivan Chang, Peggy Myung, Maksim V. Plikus, Qing Nie
bioRxiv 2020.07.21.214387; doi: https://doi.org/10.1101/2020.07.21.214387






2. 实例：用CellChat来分析一下我们的PBMC数据，看看配受体分析的一般流程。






========================================
SCENIC转录因子分析
----------------------------------------



========================================
|- 转录因子调控网络 SCENIC: single-cell regulatory network inference and clustering //todo
----------------------------------------
SCENIC | 从单细胞数据推断基因调控网络和细胞类型 

SCENIC是一种同时重建基因调控网络并从单细胞RNA-seq数据中鉴定stable cell states的工具。基于共表达和DNA模基序 （motif）分析推断基因调控网络 ，然后在每个细胞中分析网络活性以鉴定细胞状态。


1.
SCENIC发表于2017年的Nature method文章。具体见链接:
https://www.nature.com/articles/nmeth.4463

以t-SNE图呈现AUC评分和TF表达情况（即调控元件的活动度）




2. 文章中的实例
https://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&mid=2247497665&idx=1&sn=74ac0e87b9689d5df7c0208e1c1dc0ac

(1)2018年CELL文章的800多个单细胞
文章标题是《Toward Minimal Residual Disease-Directed Therapy in Melanoma》，链接：https://pubmed.ncbi.nlm.nih.gov/30017245/

使用了SCENIC转录因子分析的结果制作了如下所示的3张图：

(A) t-SNE shows cells colored by state identity(SCENIC approach). The identities are inferred by the binary activities of the TF regulons. Cell identitiesinferred by SCENIC are largely overlappingwith the SCDE approach
(B) SCENIC analysis predicts TFs such as SOX10,MEF2C, TFAP2B, and RXRG as central hubs governing the NCSC state. TF regulon activitieswere quantified using AUCell.
(D) Gene regulatory network analysis using SCENIC identifies critical nodes driving the NDTC state.
图A是为了突出一个细胞亚群是某些TF的调控活性区域，图B是分别显示具体的TF是如何在该细胞亚群被富集出来的，图C是看该调控活性区域的突出TF的基因网络情况。

每个亚群都有各自富集到的转录因子，包括：pigmentation, NCSC, “invasive,” “proliferative” and SMC states ，都可以根据SCENIC转录因子分析的结果来绘制经典三张图，数据集在GSE116237，总共也就是 865个细胞：


(2)
2020年10月NC的膀胱癌免疫微环境
文章标题是；《Single-cell RNA sequencing highlights the role of inflammatory cancer-associated fibroblasts in bladder urothelial carcinoma》，链接是：https://www.nature.com/articles/s41467-020-18916-5

首先是：图 a Heatmap of the area under the curve (AUC) scores of TF motifs estimated per cell by SCENIC. Shown are top five differentially activated motifs in iCAFs and mCAFs, respectively

也就是说，研究者定位到了两个细胞亚群 iCAFs and mCAFs，然后针对性的对这两个细胞亚群进行SCENIC分析，取那些在两个细胞亚群有统计学差异的TF的全部细胞的AUC值进行热图可视化，如下：


然后是对两个细胞亚群有统计学差异的TF各取2个进行tSNE的可视化，看看具体是如何的差异：

TF各取2个进行tSNE的可视化

哪怕是这篇文章的作者并没有直接在GEO里面提供表达矩阵，我们也可以很容易去借鉴这里面的可视化方法，来具体展现我们的SCENIC分析结果！


(3)2020年12月NC的食管鳞状细胞癌微环境
文章标题是；《Immune suppressive landscape in the human esophageal squamous cell carcinoma microenvironment》，链接是 https://www.nature.com/articles/s41467-020-20019-0

同样的，取细胞亚群有统计学差异的TF的全部细胞的AUC值进行热图可视化：

文中图例是：j Heat-map of the t values of AUC scores of expression regulation by transcription factors of the indicated clusters, as estimated using SCENIC

这个时候的细胞亚群比较多，所以并不需要展现具体的每个细胞里面的该TF的AUC值啦，直接以细胞亚群的混合方式进行展现即可。

同样的分析，完全不同的展现方式

主要是靠大家对这个细胞通讯分析流程的理解，以及对结果的解读，后续我们会针对此推文前面提到的5款做细胞通讯分析软件的用法解读，并且合理的使用它们的分析结果来支撑我们的数据成为一个合理的生物学故事！





ref:
实例：https://www.jianshu.com/p/0bf18fe92c7d
http://blog.sciencenet.cn/home.php?mod=space&uid=118204&do=blog&id=1208136
https://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&mid=2247497665&idx=1&sn=74ac0e87b9689d5df7c0208e1c1dc0ac




========================================
inferCNV
----------------------------------------
1. 安装
(1)安装inferCNV之前需要安装JAGS程序，下载地址：
https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/

$ wget https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/Source/JAGS-4.3.0.tar.gz
$ tar zxvf JAGS-4.3.0.tar.gz
$ cd JAGS-4.3.0/
$ ./configure --prefix="/home/wangjl/"
$ make && make install

$ jags
Welcome to JAGS 4.3.0 on Tue Feb 23 12:19:27 2021

$ which jags
/home/wangjl/bin/jags

此程序安装之后，inferCNV依赖的rjags包才能正常安装，否则报错：configuration failed for package ‘rjags’


2) 放到路径中
$ pkg-config --modversion jags
4.3.0

## 在R中
> install.packages("rjags", configure.args="--enable-rpath")





(2) 安装发行版，作者推荐
if (!requireNamespace("BiocManager", quietly = TRUE))
     install.packages("BiocManager")
BiocManager::install("infercnv")

library(infercnv) # v 1.0.4



# or 安装github上的最新版
library("devtools")
devtools::install_github("broadinstitute/infercnv")




2. 使用10x pbmc-10k 单数据集。










========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------

