Servlet使用

http://www.runoob.com/servlet/servlet-tutorial.html


========================================
Servlet大纲
----------------------------------------
1.
Servlet 包
Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。
Servlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。

2.
Servlet 生命周期
Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：
Servlet 通过调用 init () 方法进行初始化。
Servlet 调用 service() 方法来处理客户端的请求。
Servlet 通过调用 destroy() 方法终止（结束）。
最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。






Tomcat 简介
http://tomcat.apache.org/
Apache Tomcat version 7.0 implements the Servlet 3.0 and JavaServer Pages 2.2 specifications from the Java Community Process.

>2016-11-08 Tomcat 8.5.8 Released


========================================
xampp中的tomcat怎么激活
----------------------------------------
环境变量：https://zhidao.baidu.com/question/256492455.html
添加注册表项：http://www.ithao123.cn/content-3176358.html


环境变量：
JAVA_HOME=jdk主目录 
TOMCAT_HOME=tomcat的主目录 

--
catalina_start.bat
[XAMPP]: Searching JDK HOME with reg query ...
错误: 系统找不到指定的注册表项或值。
. [XAMPP]: Cannot find current JDK installation!
. [XAMPP]: Cannot set JAVA_HOME. Aborting ...
done.
请按任意键继续. . .
说找不到键值，我们打开这个bat看看！！！

解决方法：
我们regedit打开注册表：HKEY_LOCAL_MACHINE—>SOFTWARE—>Wow6432Node
新建项JavaSoft
在JavaSoft下新建项Java Development Kit和Java Runtime Environment

Java Development Kit默认值指定为你jdk的路径
我的jdk路径为：
D:\Program Files\Java\jdk1.8.0_66

Java Runtime Environment指定你jre路径
比如我的jre路径为：
D:\Program Files\Java\jdk1.8.0_66\jre

自己安装版的java应该是不会出现这样的现象的，只有当你免安装的时候才会出现这样的现象
我们再来运行一下xmapp的tomcat看完美解决了问题没有！！！

访问：http://localhost:8080/
登录密码：
（1）打开文件conf/tomcat-users.xml
（2）增加2条
<role rolename="admin-gui"/>
<user username="tomcat" password="tomcat" roles="admin-gui"/>
（3）重启tomcat。



被拒绝后提示详细的用户设置
You are not authorized to view this page. If you have not changed any configuration files, please examine the file conf/tomcat-users.xml in your installation. That file must contain the credentials to let you use this webapp.

For example, to add the admin-gui role to a user named tomcat with a password of s3cret, add the following to the config file listed above.

<role rolename="admin-gui"/>
<user username="tomcat" password="s3cret" roles="admin-gui"/>
Note that for Tomcat 7 onwards, the roles required to use the host manager application were changed from the single admin role to the following two roles. You will need to assign the role(s) required for the functionality you wish to access.

admin-gui - allows access to the HTML GUI
admin-script - allows access to the text interface
The HTML interface is protected against CSRF but the text interface is not. To maintain the CSRF protection:

Users with the admin-gui role should not be granted the admin-script role.
If the text interface is accessed through a browser (e.g. for testing since this interface is intended for tools not humans) then the browser must be closed afterwards to terminate the session.



========================================
Servlet版HelloServlet，和eclipse中配置servlet
----------------------------------------

Servlet的四步开发流程。
1.首先在Tomcat的主目录下的webapp文件夹内新建mywebsite文件夹，里面新建WEB-INF文件夹;
在WEB-INF文件夹下建立classes子文件夹 存放你的servlet
然后在WEB-INF文件夹下建立一个web.xml文件,记录网站的配置信息

当然这个操作你可以自己完成 也可以在root目录下拷贝一份
大家可以看到 这个地方传递过来了一个信息，什么信息呢？
文件夹结构：

F:\xampp\tomcat\webapps\mywebsite\WEB-INF\web.xml 

webapps/WEB-INF/web.xml 
webapps/WEB-INF/classes/HelloServletDemo.class 


2.开发Servlet（引入Servlet-api.jar）

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class HelloServletDemo implements Servlet{
	// 用于得到servlet配置文件 与生命周期无关
	@Override
	public ServletConfig getServletConfig() {
		return null;
	}

	@Override
	public String getServletInfo() {
		// TODO Auto-generated method stub
		return "Servlet info here...";
	}

	// 该函数用于初始化该servlet， 类似于我们的类的构造函数
	// 该函数只是会被调用一次， 当用户第一次访问该servlet的时候被调用
	@Override
	public void init(ServletConfig arg0) throws ServletException {
		System.out.println("init it !");
	}


	// service 函数用于处理业务逻辑
	// 程序员应当把业务逻辑代码写在这里
	// 该函数在用户每次访问servlet的时候都会被调用
	// ServletRequest 对象用于获得客户端信息，
	//ServletResponse 对象用于向客户端返回信息	（客户端可以理解为浏览器）
	// servelt jsp b/s
	@Override
	public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
		System.out.println("Service start");
		PrintWriter pw=res.getWriter();
		pw.println("Hello world, Servlet");
	}
	
	
	// 销毁servlet实例（释放内存）
	// 1 reload 该servlet(webApp)
	// 2 关闭Tomcat 或者说 关机之后 都会调用这个函数
	@Override
	public void destroy() {
		System.out.println("destory it");
	}

}



3.部署Servlet。在web.xml中加入如下内容：
<servlet>
	<!--给你的servlet起名字，任意的-->
	<servlet-name>hello_servlet</servlet-name>
	<!--指明servlet的路径，包名+类名 注意类名后不能加上java-->
	<servlet-class>com.tsinghua.Hello</servlet-class>
</servlet>
 
<servlet-mapping>
	<!--mapping  自然就是映射了  于是乎 这个同上,一致-->
	<servlet-name>hello_servlet</servlet-name>
	<!--这是浏览器中输入的访问该servlet的url 任意的-->
	<url-pattern>/sp</url-pattern>
</servlet-mapping>



web.xml的最终内容如下：
<?xml version="1.0" encoding="ISO-8859-1"?>

<web-app xmlns="http://java.sun.com/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
  version="3.0"
  metadata-complete="true">

  <display-name>Welcome to Tomcat</display-name>
  <description>
     Welcome to Tomcat
  </description>
 	  
  	<servlet>
		<!--给servlet取个名字，任意的-->
		<servlet-name>hello</servlet-name>
		<!--指定servlet的路径，就是（包名字+类名）-->
		<servlet-class>HelloServletDemo</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>hello</servlet-name>
		<url-pattern>/hello</url-pattern>
	</servlet-mapping>
	
</web-app>

这里面，servlet标签标注着我们的servlet名字和class名，而mapping标签则是代表着servlet的访问地址。


4.启动tomcat，访问你的Servlet
http://localhost:8080/mywebsite/hello

显示：Hello world, Servlet


注意：WEB-INF不要写错！不是WEB_INF，也不是WEB-INFO。
https://www.zhihu.com/question/21416727



我的实践：
1.在Eclipse中提示 找不到类 javax.servlet.http.HttpServletResponse
http://bbs.csdn.net/topics/370187655?page=1

在tomcat的lib目录下可以找到的。如果你把J2EE的相关包加到buildPath里面去，那应该不会出错的。

到tomcat的安装路径下\lib\servlet-api.jar 复制到WEB-INF/lib下，然后点项目名按F5，应该就OK了。


2.如果您有一个完全合格的类名称 com.myorg.MyServlet，那么这个 Servlet 类必须位于 WEB-INF/classes/com/myorg/MyServlet.class 中。
web.xml中也必须是包的全称 com.myorg.MyServlet。





========================================
Eclipse+Tomcat环境下部署Servlet步骤如下：
----------------------------------------
一、建立项目：建立一个动态的web项目（Dynamic Web Project），起名为BlogWeb，并在Target runtime下配置tomcat 
二、在WebContent下WEB-INF的lib里放入mysql-connector-java.5.0.5-bin.jar 
三、编写数据库操作和servlet页面信息的代码：在src里编写pojo类，数据库连接类，数据库操作类dao以及servlet中用于显示页面信息的类 
四、编写html页面，并放在WEB-INF下 
五、配置web.xml中的信息，即servlet中的页面信息 
六、创建Server并启动 
七、打开IE，输入地址进行测试 
八、发布WEB项目：将项目以WAR file形式导出，并将导出的文件置于tomcat目录下的webapps里。
这样不用启动server，也能直接用IE看见我们编写的html了




========================================
Servlet get参数
----------------------------------------
1.输出到网页，获取get方式传递过来的变量
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello3 extends HttpServlet {

	private static final long serialVersionUID = 1L;
	private String message="";
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
		message = "Hello World, today";
	}
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		// 设置响应内容类型
		res.setContentType("text/html");//设置编码格式
		
		//接收get过来的变量
		String usr=req.getParameter("username");
		String pass=req.getParameter("password");
		
		// 实际的逻辑是在这里
		PrintWriter out = res.getWriter();//输出内容到网页
		out.println("<h1>" + message + "</h1>" + usr+":"+pass);
	}

}


========================================
Servlet Session
----------------------------------------
1.ReadSession.java 遍历session
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class ReadSession extends HttpServlet {
	private static final long serialVersionUID = 1L;

	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		//关于session部分
		HttpSession hs=req.getSession(true);
		
		//设置session时间.默认是30min。
		//hs.setMaxInactiveInterval(10);//10s 
		//输出到控制台
		System.out.println(hs.getAttribute("pass"));
		System.out.println(hs.getAttribute("usr"));
		System.out.println(hs.getAttribute("usr_id"));
		System.out.println();
		
		
		//获取输出流,输出到网页
		PrintWriter out = res.getWriter();
		java.util.Enumeration   e   =   req.getSession().getAttributeNames(); 
		//遍历输出session内容
		//http://ssh-2009-126-com.iteye.com/blog/1111994
		while( e.hasMoreElements()){   
		    String sessionName=(String)e.nextElement();   
		    out.println("\nsession item name="+sessionName);  
		    out.println("\nsession item value="+req.getSession().getAttribute(sessionName)); 
		    out.println("<br>");
		}
	}
}



2.session操作 Hello4.java 
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello4 extends HttpServlet {

	/** 
	 * session操作
	 */
	private static final long serialVersionUID = 1L;
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
	}
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		//关于session部分
		HttpSession hs=req.getSession(true);
		
		//设置session时间.默认是30min。
		hs.setMaxInactiveInterval(10);//10s 
		
		//设置session内容
		hs.setAttribute("pass","ok");
		hs.setAttribute("name","天天");
		
		//读取session内容
		String str=(String)hs.getAttribute("name");
		System.out.println(str);
		
		//获取sessionid
		String id=hs.getId();
		System.out.println(id);//A10F4CC8AD14A3BB7D09B0143E10FAA7
		
		
		// 设置响应内容类型
		//res.setContentType("text/html");
		
		// 实际的逻辑是在这里
		PrintWriter out = res.getWriter();
		out.println("<h1>" + str + "</h1> sessionid="+id);
	}

}

3.判断是否有session值
Hello5.java 
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello5 extends HttpServlet {

	/** 
	 * session操作 判断与跳转
	 */
	private static final long serialVersionUID = 1L;
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		//关于session部分
		HttpSession hs=req.getSession(true);
		
		//判断是否合格
		String val=(String) hs.getAttribute("pass");
		if(val==null){
			//非法登录
			res.sendRedirect("hello4?info=error");//重定向到某个url
			return;
		}

		// 实际的逻辑是在这里
		PrintWriter out = res.getWriter();
		out.println("<h1>" + "保密内容" + "</h1>");
	}
}





========================================
Servlet Cookie
----------------------------------------
问题：
Cookie1 cookie的读写: cookie时间总是不准确，超前24小时左右。但是时间5和10s还是有区别的。
	ame	tomcat	localhost	/mywebsite	2017-01-01T17:03:09.672Z	10				
	pass	123	localhost	/	2017-01-01T17:03:14.672Z	7	
	
	
Cookie1.java 

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Date;
import java.util.TimeZone;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Cookie1 extends HttpServlet{

	/**
	 * cookie封装： http://www.cnblogs.com/muzongyan/archive/2010/08/30/1812552.html
	 * 
	 * http://localhost:8080/mywebsite/cookie1?option=get 获取cookie
	 * http://localhost:8080/mywebsite/cookie1 删除cookie name
	 * http://localhost:8080/mywebsite/cookie1?option=set 设置cookie name pass
	 */
	private static final long serialVersionUID = 1L;
	static{
		TimeZone.getTimeZone("Asia/Shanghai");//
	}
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		String option=req.getParameter("option");
		if(option==null){
			System.out.println("没有参数");
			
			//清空cookie name
			Cookie cookie = new Cookie("name", null);
			cookie.setMaxAge(0);
			//删除指定路径上的Cookie，不设置该路径，默认为删除当前路径Cookie；
			//cookie.setPath("/");
			res.addCookie(cookie);
			
			return;
		}
		if(option.equals("set")){
			mySet(req,res);
		}
		if(option.equals("get")){
			myGet(req,res);
		}
		
	}
	
	//设置cookie
	static void mySet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		//分别设定cookie，和生命周期
		Cookie cookie=new Cookie("name","tomcat");
		//如果设置为负值的话，则为浏览器进程Cookie(内存中保存)，关闭浏览器就失效
		cookie.setMaxAge(5);//5s
		res.addCookie(cookie);

		Cookie cookie2=new Cookie("pass","123");
		cookie2.setMaxAge(10);//10s
		//设置路径，这个路径即该工程下都可以访问该cookie 
		//如果不设置路径，那么只有设置该cookie路径及其子路径可以访问
		cookie2.setPath("/");
		res.addCookie(cookie2);
		
//		Cookie c = new Cookie("lastAccessTime",System.currentTimeMillis()+"");
		Cookie c = new Cookie("lastAccessTime", new Date().toString());
		//c.setMaxAge(0);//0s不保存
		c.setMaxAge(-1);//浏览器关闭前有效
		res.addCookie(c);
		
		System.out.println("cookie设定完成！");
	}
	
	//读取cookie
	static void myGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		Cookie[] cookies = req.getCookies();//这样便可以获取一个cookie数组
		if (null==cookies) {
            System.out.println("没有cookie=========");
        } else {
        	PrintWriter out=res.getWriter();
			for(Cookie cookie : cookies){
			    String str=cookie.getName()+"="+cookie.getValue();
			    System.out.println(str);
			    out.println(str);
			}
        }
		
		System.out.println("cookie读取完成");
	}

	
}



========================================
Servlet, JDBC, 分页
----------------------------------------
1.文件 
Hello7.java 
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello7 extends HttpServlet {

	/** 
	 * session操作 db分页
	 * http://localhost:8080/mywebsite/hello7?page=3
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
		System.out.println("Hello World, init hello7~");
	}
	
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		
		Connection conn=null;
		Statement stmt=null;
		ResultSet rs=null;
		try {
			//1.连接数据库
			Class.forName("com.mysql.jdbc.Driver");
			//2.获得连接
			conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/test","root","");
		
			//3.获取statement
			stmt=conn.createStatement();
			stmt.executeQuery("use think;");
			
			//分页设置
			int pageSize=5;//一页多少条-设置
			int totalRow=0;//一共多少行？查表
			int totalPage=0;//一共多少页-计算
			int currentPage=1;//get传过来
			
			//获取总页码
			rs=stmt.executeQuery("select count(*) from think_user;");
			if(rs.next()){
				totalRow=rs.getInt(1);
			}
			if(rs!=null){
				rs.close();
			}

			//计算总页码
			if(totalRow%pageSize==0){
				totalPage=totalRow/pageSize;
			}else{
				totalPage=totalRow/pageSize+1;
			}
			
			//获得当前页码
			String gcurrentPage=req.getParameter("page");
			if(gcurrentPage != null){
				currentPage=Integer.parseInt(gcurrentPage);
				if(currentPage<1)currentPage=1;
				if(currentPage>totalPage)currentPage=totalPage;
			}
			
			int start=(currentPage-1)*pageSize;
			rs = stmt.executeQuery("select * from think_user limit "+start+","+pageSize);//结果集
			
			//4.输出结果
			//获取输出流
			PrintWriter out = res.getWriter();
			out.println("<table border='1'>");
			out.println("<tr><td>id</td><td>name</td><td>pass</td></tr>");
			while(rs.next()){
				out.println("<tr><td>"+rs.getString(1)+"</td><td>"+rs.getString(2)+
						"</td><td>"+rs.getString(3)+"</td></tr>");
			}
			out.println("</table>");
			
			//输出分页代码
			if(currentPage>1){
				out.print(" <a href='?page="+(currentPage-1)+"'>上一页</a> ");
			}
			for(int i=1;i<=totalPage;i++){
				if(i!=currentPage){
					out.print(" <a href='?page="+i+"'>"+i+"</a> ");
				}else{
					out.print(i);
				}
					
			}
			if(currentPage<totalPage){
				out.print(" <a href='?page="+(currentPage+1)+"'>下一页</a> ");
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				if(rs!=null) rs.close();
				if(stmt!=null) stmt.close();
				if(conn!=null) conn.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
			
		}
	}
}

2.配置文件：
F:\xampp\tomcat\webapps\mywebsite\WEB-INF\web.xml
	  	<servlet>
		<!--给servlet取个名字，任意的-->
		<servlet-name>hello7</servlet-name>
		<!--指定servlet的路径，就是（包名字+类名）-->
		<servlet-class>Hello7</servlet-class>
	</servlet>
	<servlet-mapping>
		<servlet-name>hello7</servlet-name>
		<url-pattern>/hello7</url-pattern>
	</servlet-mapping>

3.url 
http://localhost:8080/mywebsite/hello7?page=3

id	name	pass
6	Smith	e10adc3949ba59abbe56e057f20f883e
7	timoc	e10adc3949ba59abbe56e057f20f883e
11	石劲	e10adc3949ba59abbe56e057f20f883e
25	Tomcat	e10adc3949ba59abbe56e057f20f883e
27	Tomcat@qq.com	e10adc3949ba59abbe56e057f20f883e
上一页 1 2 3 下一页





========================================
servlet设置-列举文件、改端口、设置虚拟目录、添加用户
----------------------------------------
http://www.cnblogs.com/webqiand/p/4315618.html

1.控制列举文件夹
打开Tomcat目录下的/conf/web.xml，将下面listings的属性设置为True。
    <servlet>
        <servlet-name>default</servlet-name>
        <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
        <init-param>
            <param-name>debug</param-name>
            <param-value>0</param-value>
        </init-param>
        <init-param>
            <param-name>listings</param-name>
            <param-value>true</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
如果把false设成true，那么将允许在网页中列出目录，让Tomcat 支持文件列表显示
因此注意，这里为了安全，应该设置成false

2.改端口
在conf目录下的server.xml文件里面，修改
<Connector port="8080" protocol="HTTP/1.1"
connectionTimeout="20000"
redirectPort="8443" />
8080是默认的端口！可以改成80，这样在地址栏就不需要写端口号了。

3.设置tomcat虚拟目录
tomcat7的安装路径下，D:\Program Files\java\Tomcat 7.0\conf，修改server.xml文件
在</Host>标签前，添加上图选中部分即可，
  path ： 地址栏访问路径。
  docBase : 文件的真实路径。注意这里如果有文件上传，则将上传的文件路径设置为docBase，而不是path。  
例如： 
<Context path="/carapp" docBase="D:\nginx-1.8.1\html\carapp" debug="0" reloadable="true" />

可添加多个 目录
修改好之后，重启tomcat7

通过路径http://localhost:8080  即可访问了
本人在测试时，把上面选中部分删掉后，访问路径http://localhost:8080,还是访问的演示工程，而不是tomcat7欢迎页面，
这是tomcat缓存目录在作怪，删除路径Tomcat 7.0\work\Catalina\localhost下的文件夹名是 -  (横杠)的文件夹即可。


以上虚拟目录一直无效，因为eclipse默认的build路径和tomcat不一致。
eclipse的java EE配置一直无效。//todo 


/////////////////////////////////////////
起作用的设置如下，我新建了个ServletDemo项目：
（1）修改Eclipse的build路径：
右击项目，选择 properties，右侧选择Java Build Path，Source选项卡， 
底部默认输出文件夹：ServletDemo/build/classes，改为 ServletDemo/WEB-INF/classes

(2)查看文件夹结构
Servlet/ 这个文件夹的绝度路径放到comcat\conf\server.xml的Context标签的docBase中。
 |-放图片、文本等资源文件。
 |-WEB-INF
    |-web.xml 部署class文件
    |-classes 其中就是eclipse生成的class文件。
看时间戳，确保eclipse修改后classes文件也会重新生成。

（3）配置tomcat虚拟目录，
F:\xampp\tomcat\conf\server.xml文件，在底部</Host>标签前增加一行
<Context path="/mywebsite" reloadable="true" docBase="F:\gitHub\learngit\Java\Servlet"></Context>
  path ： 地址栏url访问路径。
  docBase : 文件的真实路径。注意其中的文件结构符合（2）；
（4）重启tomcat，输入路径 http://localhost:8080/mywebsite/readnum
即可访问其中的Servlet文件了。


备注：
F:\xampp\tomcat\conf\context.xml中设置web.xml文件的位置：
    <WatchedResource>WEB-INF/web.xml</WatchedResource>
	
	
4.tomcat添加用户
空密码是不安全的。
设置方式：F:\xampp\tomcat\conf\tomcat-users.xml中添加：

<tomcat-users>
	<role rolename="admin-gui"/>
	<user username="tomcat" password="tomcat" roles="admin-gui"/>

	<role rolename="manager-gui"/>
	<user username="tomcat" password="tomcat" roles="manager-gui"/>
</tomcat-users>

重启tomcat即可。



========================================
tomcat如何设置数据源和连接池（公司常用）？
----------------------------------------
什么是数据库连接池
数据库连接池技术的思想非常简单，将数据库连接作为对象存储在一个Vector对象中，一旦数据库连接建立后，不同的数据库访问请求就可以共享这些连接，这样，通过复用这些已经建立的数据库连接，可以克服上述缺点，极大地节省系统资源和时间。

在实际应用开发中，特别是在WEB应用系统中，如果JSP、Servlet或EJB使用JDBC直接访问数据库中的数据，每一次数据访问请求都必须经历建立数据库连接、打开数据库、存取数据和关闭数据库连接等步骤，而连接并打开数据库是一件既消耗资源又费时的工作，如果频繁发生这种数据库操作，系统的性能必然会急剧下降，甚至会导致系统崩溃。数据库连接池技术是解决这个问题最常用的方法，在许多应用程序服务器（例如：Weblogic,WebSphere,JBoss）中，基本都提供了这项技术，无需自己编程，但是，深入了解这项技术是非常必要的。


数据库连接池的主要操作如下：
（1）建立数据库连接池对象（服务器启动）。
（2）按照事先指定的参数创建初始数量的数据库连接（即：空闲连接数）。
（3）对于一个数据库访问请求，直接从连接池中得到一个连接。如果数据库连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的数据库连接。
（4）存取数据库。
（5）关闭数据库，释放所有数据库连接（此时的关闭数据库连接，并非真正关闭，而是将其放入空闲队列中。如实际空闲连接数大于初始空闲连接数则释放连接）。
（6）释放数据库连接池对象（服务器停止、维护期间，释放数据库连接池对象，并释放所有连接）。

配置步骤：
1.在Tomcat/conf/content.xml中<Context>节点内添加如下内容
<Resource name="jdbc/user" auth="Container" type="javax.sql.DataSource" maxActive="100" maxIdle="30" maxWait="10000" username="sa" password="120010" driverClassName="com.microsoft.sqlserver.jdbc.SQLServerDriver" url="jdbc:sqlserver://localhost:1433;DatabaseName=user"/>

	name:之后我们要调用resource时候用到 
	type:是链接数据库时候用到的java扩展包下的类 
	maxActive:最大连接数 
	maxIdle:是空闲时候最大连接数 
	maxwait:空闲判断标准 

注意： 
1.该配置文件里不允许有中文；各个属性间的用一个空格隔开 
2.要将对应链接数据库的jar包放到tomcat/lib文件夹中工程中就不需要存放了 
下面还中是链接oracle的
<Resource type="javax.sql.DataSource" name="jdbc/user" url="jdbc:oracle:thin:@192.168.2.102:1521:orcl" driverClassName="oracle.jdbc.driver.OracleDriver" password="bg" username="test" maxWait="10000" maxIdle="30" maxActive="100" auth="Container"/>
2.在工程的web.xml中添加如下代码
<resource-ref>
      <res-ref-name>jdbc/user</res-ref-name>
      <res-type>javax.sql.DataSource</res-type>
      <res-auth>Container</res-auth>
</resource-ref>
这里<res-ref-name>标签里面的名字就是在content.xml文件中的name的名字

3.得到数据库连接池中的Connection对象

Context context=new InitialContext();
DataSourceds=(DataSource)context.lookup("java:comp/env/jdbc/user");
Connectionconn = ds.getConnection();

context是javax.namingx下的类 
dataSource是javax.sql下的类 
"java:comp/env/jdbc/user"中：java:comp/env是固定写法 jdbc/user是jndi名称（Tomcat中配置的那个name）




如果我们不是在web.xml中配置数据源，我们用spring来控制数据库链接方法步骤：
1.在配置文件中添加如下节点
<bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
    <property name="jndiName" value="java:comp/env/jdbc/user"/> 
</bean>
配置好了获取sql语句查询数据有多少条：

    调用的时候直接Dao类继承JdbcDaoSupport类（spring.jar中的类） 
    int count = this.getJdbcTemplate().queryForInt("select * from users");

http://www.jb51.net/article/36705.htm






/////////////////////////////////////////
我的配置：
参考：【推荐】http://kingxss.iteye.com/blog/1479451
1.
修改tomcat/conf/server.xml 
<Context path="/mywebsite" reloadable="true" docBase="F:\gitHub\learngit\Java\Servlet">
	<Resource name="jdbc/user" auth="Container"   
    type="javax.sql.DataSource"  
    driverClassName="com.mysql.jdbc.Driver"  
    url="jdbc:mysql://localhost:3306/think"  
    username="root"  
    password=""  
    maxActive="50"  
    maxIdle="10"  
    maxWait="10000" />
</Context>

使用的是think数据库。


2.
在项目文件件下web.xml的根节点配置：
  <resource-ref>
      <description>mysqlDB Connection</description>  
      <res-ref-name>jdbc/user</res-ref-name>
      <res-type>javax.sql.DataSource</res-type>
      <res-auth>Container</res-auth>
 </resource-ref>

完成上述步骤数据源的连接池配置已经完成，但是为了提高项目的可移植性，
最好将上述第一步的内容放入到工程的META-INF目录的context.xml中（这个文件需要自行建立）：
<?xml version="1.0" encoding="UTF-8"?>  
<Context>  
      <Resource name="jdbc/demoDB" auth="Container"   
      type="javax.sql.DataSource"  
      driverClassName="com.mysql.jdbc.Driver"  
      url="jdbc:mysql://localhost:3306/demo"  
      username="root"  
      password="123"  
      maxActive="50"  
      maxIdle="30"  
      maxWait="10000" />  
</Context>  


3.使用配置数据源的数据库连接池时的数据库操作工具类
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

import javax.sql.DataSource;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.servlet.ServletException;
import javax.servlet.http.*;

public class Hello8 extends HttpServlet {

	/** 
	 * session操作 db分页
	 * http://localhost:8080/mywebsite/hello7?page=3
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	public void init() throws ServletException
	{
		// 执行必需的初始化
		System.out.println("Hello World, init hello8~");
	}
	
	
	public void doGet(HttpServletRequest req,HttpServletResponse res)
			throws ServletException, IOException
	{
		res.setContentType("text/html;charSet=utf8");
		System.out.println("use 连接池");
		
		Connection conn=null;
		Statement stmt=null;
		ResultSet rs=null;
		try {
			
			//1.2.使用数据库连接池获得连接
			Context context=new InitialContext();
			DataSource ds=(DataSource)context.lookup("java:comp/env/jdbc/user");
			if( ds == null ){  
		           throw new Exception("Data source not found!");  
		    }
			conn = ds.getConnection();
			
			//1.连接数据库
			//Class.forName("com.mysql.jdbc.Driver");
			//2.获得连接
			//conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/test","root","");
		
			//3.获取statement
			stmt=conn.createStatement();
			stmt.executeQuery("use think;");
			
			//分页设置
			int pageSize=5;//一页多少条-设置
			int totalRow=0;//一共多少行？查表
			int totalPage=0;//一共多少页-计算
			int currentPage=1;//get传过来
			
			//获取总页码
			rs=stmt.executeQuery("select count(*) from think_weibo;");
			if(rs.next()){
				totalRow=rs.getInt(1);
			}
			if(rs!=null){
				rs.close();
			}

			//计算总页码
			if(totalRow%pageSize==0){
				totalPage=totalRow/pageSize;
			}else{
				totalPage=totalRow/pageSize+1;
			}
			
			//获得当前页码
			String gcurrentPage=req.getParameter("page");
			if(gcurrentPage != null){
				currentPage=Integer.parseInt(gcurrentPage);
				if(currentPage<1)currentPage=1;
				if(currentPage>totalPage)currentPage=totalPage;
			}
			
			int start=(currentPage-1)*pageSize;
			rs = stmt.executeQuery("select * from think_weibo limit "+start+","+pageSize);//结果集
			
			//4.输出结果
			//获取输出流
			PrintWriter out = res.getWriter();
			out.println("<table border='1'>");
			out.println("<tr><td>id</td><td>uid</td><td>content</td></tr>");
			while(rs.next()){
				out.println("<tr><td>"+rs.getString(1)+"</td><td>"+rs.getString(2)+
						"</td><td>"+rs.getString(3)+"</td></tr>");
			}
			out.println("</table>");
			
			//输出分页按钮
			if(currentPage>1){
				out.print(" <a href='?page="+(currentPage-1)+"'>上一页</a> ");
			}
			//如果太多，怎么显示分页按钮呢？模仿网易博客
			for(int i=1;i<=totalPage;i++){
				if(i!=currentPage){
					out.print(" <a href='?page="+i+"'>"+i+"</a> ");
				}else{
					out.print(i);
				}

			}
			if(currentPage<totalPage){
				out.print(" <a href='?page="+(currentPage+1)+"'>下一页</a> ");
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			try {
				if(rs!=null) rs.close();
				if(stmt!=null) stmt.close();
				if(conn!=null) conn.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
			
		}
	}
}
数据库连接写到init方法中。
数据库销毁放到destroy方法中。




========================================
----------------------------------------


========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------
