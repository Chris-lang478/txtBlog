php基础知识 


========================================
php 运行方式、注释
----------------------------------------
1.
<?php 
echo "hello, PHP"; //这是行注释

/*这是块注释
line2*/
?php>


2. 代码书写：
- 每行必须要用;结束。 
- 可以连写很多行到一行，但是每一句结束都必须有分号。
- 变量名必须$开头。




========================================
php调试函数
----------------------------------------
1.//调试函数:打印
function debug($s,$isDetail=false,$isDie=false){
	echo "<pre>";
	$isDetail?var_dump($s):print_r($s);
	echo "</pre>";
	if($isDie) die();
}

2.//调试函数:写入文件
//file_put_contents() 函数把一个字符串写入文件中。
//与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。
function mylog($s){
	file_put_contents("test.txt",$s,FILE_APPEND );
}




========================================
php与字符串
----------------------------------------

1.php大小写转换函数（包括首字母大小写）
$str = "This is 7woshi.com";  
echo "全部变小写 strtolower: ".strtolower($str);  
echo "第一个字母大写 ucfirst: ".ucfirst($str);  
echo "单词首字母大写 ucwords: ".ucwords($str);  
echo "全部变大写 strtoupper: ".strtoupper($str);  
// 5.3 以后, 支持lcfirst($str); //第一个字母小写

http://blog.sina.com.cn/s/blog_61e65d1701017mcu.html



========================================
php函数
----------------------------------------




2.递归
//例子来源 http://tieba.baidu.com/p/4262397578
1). 递归是很强大的，但是一定要避免无限递归！要留有出口。
2). 在PHP中，必须要在递归调用函数时加上return(这也算PHP递归函数的Bug，时间太长就变成特性了。)

function reverse_r($str){
	if (strlen($str)>0){
		reverse_r(substr($str,1));
	}
	echo substr($str,0,1);
	return;
}
reverse_r('hello');

这个递归实现了字符串的首尾翻转，那么他是如何工作的呢、每一步返回什么呢？

1.搞清楚函数作用
echo substr('abc',1);//'bc' 去掉首字母后的字符串
echo substr('abc',0,1);//'a' 相当于输出首字母

2.递归调用先入后出：
以次调用如下：
f1('hello')
-f2('ello')
--f3('llo')
---f4('lo')
----f5('o')
-----f6('') //这里可以省略一步，就是改为 if (strlen($str)>1)
倒着弹出首字母：
olleh

思考题1：分析如下阶乘函数的每一步堆栈细节：
//阶乘的递归
function fn($i){ 
	if($i==1){
		return 1; 
	}
	return $i*fn($i-1);
} 

echo fn(5);

思考题2：试用return改造字符串颠倒函数，最后返回完整的颠倒后的字符串。
参考答案：
function reverse_r2($str){
	if (strlen($str)>0){
		return  reverse_r2(substr($str,1)) . substr($str,0,1);
	}
	return;
}
echo reverse_r2('hello');



========================================
php的类与OOP
----------------------------------------

10.反射
<?php
//利用反射调用对象的方法

//定义类
class Person{
	private $name;
	function __construct($name=''){
	   $this->name=$name;
	}
    function say(){
        return 'I am ' . $this->name;
    }
    
    function run($addr, $speed = 0){
        return $this->name . " is runing at ".$addr." now, and the speed is ".$speed;
    }
}

function br(){echo '<br>';}

/*
//常规调用
$p=new Person('Jim');
echo $p->say(); br();
echo $p->run(100);
*/

//使用反射实现对象调用方法
$tom=new Person('Tom');
//没有参数时
$method=new ReflectionMethod($tom, 'say');
echo $method->invoke($tom);br();

//有参数时
$method2=new ReflectionMethod($tom, 'run');
echo $method2->invoke($tom, '河源西路',255); br();
echo $method2->invokeArgs($tom, array('河源东路',133));

更多的，可以根据一个实例，反射得到其所属类的方法信息，是否公开，是否有该方法等。


========================================
php的魔术方法
----------------------------------------

1.__get和__set
/*
在PHP5中，预定义了两个函数“__get()”和“__set()”来获取和赋值其属性，对每个字段进行set和get的操作。只需要加上两个魔术方法即可
*/
class Person{
	private $name;
	private $age;
	private $sex;
	private $height;
	
	public $info='this is a msg';
	
	//__set()方法用来设置私有属性 
	public function __set($property_name,$value){ 
		$this->$property_name = $value; 
	}
	//__get()方法用来获取私有属性 
	public function __get($property_name){ 
		if(isset($this->$property_name)){
			return($this->$property_name); 
		}else{ 
			return(NULL); 
		}
	}
}

//echo Person::class;die();

$p=new Person();
echo $p->info;
//$p->getRequest();

//直接设置属性
$p->name='Dawn';
$p->height=200;

//获取属性
echo $p->name;
echo $p->height;
echo $p->sex;
//以上代码如果不加上__get()和__set()方法，程序就会出错，因为不能在类的外部操作私有成员，而上面的代码是通过自动调用__get()和__set()方法来帮助我们直接存取封装的私有成员的。





2.__call(//$a->getB();//获取 A::$b 属性)
/*
public mixed __call ( string $name , array $arguments )
public static mixed __callStatic ( string $name , array $arguments )
在对象中调用一个不可访问方法时，__call() 会被调用。 

用静态方式中调用一个不可访问方法时，__callStatic() 会被调用。 

$name 参数是要调用的方法名称。$arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。 
*/

class A{
	public $name='dawn';
	public $age=100;
	
	public function __call($name,$para=''){
		$keyword=explode('get',$name)[1];
		return $this->get( strtolower($keyword) );	
		//return self::get( strtolower($keyword) );	
	}
	
	//使用魔术方法
	public function get($para){
		return $this->$para;
	}	
}


$a=new A();
//echo $a->get('name');
echo $a->getName(); //$a->getB();//获取 A::$b 属性
echo $a->getAge();

//http://tieba.baidu.com/p/4316562130?pid=82821666717&cid=0#82821666717





========================================
php文件操作
----------------------------------------
1.php获取获取当前文件夹
//获取当前绝对路径
define('ROOT_PATH',dirname( __FILE__ ));
echo ROOT_PATH;
//或者：
echo getcwd(); //F:\xampp\htdocs\smartyLearn\demo1\dustbin

比如在库的入口文件定义该库的根目录：
defined('DAWN_PATH') or define('DAWN_PATH', dirname(__file__) .'/' );





2.php获取文件创建时间、修改时间
filemtime ( string filename )
返回文件上次被修改的时间，出错时返回 FALSE。时间以 Unix 时间戳的方式返回，可用于 date()。
例如：$a=filemtime("log.txt");
           echo "修改时间：".date("Y-m-d H:i:s",$a)."

filectime ( string filename )
返回文件上次 inode 被修改的时间，如果出错则返回 FALSE。时间以 Unix 时间戳的方式返回。

例如：$a=filectime("log.txt");
           echo "创建时间：".date("Y-m-d H:i:s",$a)."

fileatime ( string filename )
返回文件上次被访问的时间，如果出错则返回 FALSE。时间以 Unix 时间戳的方式返回。
例如：$a=fileatime("log.txt");
          echo "修改时间：".date("Y-m-d H:i:s",$a)."
		  
from: http://www.cnblogs.com/JemBai/archive/2009/04/21/1440249.html





3.php文件缓存
要点：ob_start();开启缓存；文件部分暂时输出到缓存； $content = ob_get_clean(); 清除缓存并保存到变量$content中。

基于这两个函数可以实现基于文件的缓存。可以实现带“继承”的模板系统。

主要是基于php的ob函数。

layout.php 
<!-- templates/layout.php -->
<!DOCTYPE html>
<html>
    <head>
        <title><?php echo $title ?></title>
    </head>
    <body>
        <?php echo $content ?>
    </body>
</html>


The template (templates/list.php) can now be simplified to "extend" the layout:

<?php $title = 'List of Posts' ?>

<?php ob_start() ?>
    <h1>List of Posts</h1>
    <ul>
        <?php foreach ($posts as $post): ?>
        <li>
            <a href="/read?id=<?php echo $post['id'] ?>">
                <?php echo $post['title'] ?>
            </a>
        </li>
        <?php endforeach ?>
    </ul>
<?php $content = ob_get_clean() ?>

<?php include 'layout.php' ?>






========================================
php数组
----------------------------------------

10.检测数组中键是否存在？
php中有两个函数用来判断数组中是否包含指定的键，分别是array_key_exists和isset
array_key_exists语法如下
	array_key_exists($key, $array)
如果键存在返回true isset函数语法如下
	isset($array[$key])
	
	

========================================
php与html
----------------------------------------
1.html实体
htmlentities() 函数把字符转换为 HTML 实体。 
提示:要把HTML 实体转换回字符,请使用 html_entity_decode() 函数。


========================================
php中heredoc与nowdoc的使用方法
----------------------------------------
一、heredoc结构及用法
Heredoc 结构就象是没有使用双引号的双引号字符串，这就是说在 heredoc 结构中单引号不用被转义。其结构中的变量将被替换，但在 heredoc 结构中含有复杂的变量时要格外小心。其对格式化输出内容时，比较有用 。具体其有以下特点：

1、开始标记和结束标记使用相同的字符串，通常以大写字母来写。
2、开始标记后不能出现空格或多余的字符。
3、结束标记必须顶头写，不能有缩进和空格，且在结束标记末尾要有分号 。
4、位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。在heredoc中，变量不需要用连接符.或,来拼接 。

function outputhtml()
{
 //自 PHP 5.3.0 起还可以在 Heredoc 结构中用双引号来声明标识符，所以开头这句也可以写为echo <<<"EOT"
echo <<<EOT
   <html>
   <head><title>主页</title></head>
   <body>主页内容</body>
   </html>
EOT;
}
outputhtml();


这里，就不用像普通的php写法那样，echo "<html>"  echo "<head>……" ，这样不但看上去舒服易读，而且也省去了每行双引号的引用。

再给出一个变量引用的例子：

<?php
$name = '361way运维之路';
print <<<EOT
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<title>Untitled Document</title>
</head>
<body>
<!--12321-->
Hello,$name!
</body>
</html>
EOT;
?>




二、nowdoc结构及用法


在 PHP 5.3.0 及其以后的版本中增加了nowdoc结构，其用法和heredoc相同，不同的是Nowdoc 结构是类似于单引号字符串的。nowdoc 中不进行解析操作。这种结构很适合用于嵌入 PHP 代码或其它大段文本而无需对其中的特殊字符进行转义。与 SGML 的 结构是用来声明大段的不用解析的文本类似，nowdoc 结构也有相同的特征。

一个 nowdoc 结构也用和 heredocs 结构一样的标记 <<<， 但是跟在后面的标识符要用单引号括起来，即 <<<'EOT'。

例如：now结构中复杂变理的示例

<?php
$str = <<<'EOD'
Example of string
spanning multiple lines
using nowdoc syntax.
EOD;
/* 含有变量的更复杂的示例 */
class foo
{
    public $foo;
    public $bar;
    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}
$foo = new foo();
$name = 'MyName';
echo <<<'EOT'
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should not print a capital 'A': x41
EOT;
?>
其输出为：

My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should not print a capital 'A': x41
具体可以和heredoc中的作下比较，在heredoc中，变量会被正常解析。x41也会被解析也A 。



三、其他

在使用heredoc和nowdoc时，经常会遇到如下报错：

Parse error: syntax error, unexpected T_SL in php
一段遇到该问题的原因是定界符之后空格的问题引起的。如上例中的EOT后面有空格就会报这个错。处理是否有空格还有一个小技巧。以vim为例，语法正确时，开始和结尾处的EOF会高亮显示。不高亮时，则证明语法有问题。






========================================
php传递数据的格式
----------------------------------------
使用json_encode、serialize 或者var_export来产生被传递的内容，这几个方法都有现成的反解函数，而print_r没有。




========================================
PHP 中的 serialize() 函数可以实现 数组的序列化
----------------------------------------

serialize() 
	产生一个可存储的值的表示，也就是把数组转化为一个可以保存的字符串
unserialize()
	从已存储的表示中创建 PHP 的值，也就是把serialize()转化的字符串再还原为数组

例如：
<?php
	$array = array('a','b');
	$str = serialize($array);
	echo $str;
	$array_temp = unserialize($str);
	print_r($array_temp);
?>
https://zhidao.baidu.com/question/982045874307716779.html




========================================
用户访问统计 目录
----------------------------------------
用户来源
//用户来源URL记录
$Referer='';
if(isset($_SERVER['HTTP_REFERER'])){
	$Referer=$_SERVER['HTTP_REFERER'];
}
echo $Referer;




========================================
PHP上传文件
----------------------------------------
http://www.w3school.com.cn/php/php_file_upload.asp


1.index.html
<html>
<body>

<form action="upload_file.php" method="post"
enctype="multipart/form-data">
<label for="file">Filename:</label>
<input type="file" name="file" id="file" /> 
<br />
<input type="submit" name="submit" value="Submit" />
</form>

</body>
</html>



2.upload_file.php
<?php
if (1 || (($_FILES["file"]["type"] == "image/gif")
|| ($_FILES["file"]["type"] == "image/jpeg")
|| ($_FILES["file"]["type"] == "image/pjpeg"))
&& ($_FILES["file"]["size"] < 2000000))
  {
  if ($_FILES["file"]["error"] > 0)
    {
    echo "Return Code: " . $_FILES["file"]["error"] . "<br /><hr>";
	var_dump($_FILES["file"]);
    }
  else
    {
    echo "Upload: " . $_FILES["file"]["name"] . "<br />";
    echo "Type: " . $_FILES["file"]["type"] . "<br />";
    echo "Size: " . ($_FILES["file"]["size"] / 1024) . " Kb<br />";
    echo "Temp file: " . $_FILES["file"]["tmp_name"] . "<br />";

    if (file_exists("upload/" . $_FILES["file"]["name"]))
      {
      echo $_FILES["file"]["name"] . " already exists. ";
      }
    else
      {
      move_uploaded_file($_FILES["file"]["tmp_name"],
      "upload/" . $_FILES["file"]["name"]);
      echo "Stored in: " . "upload/" . $_FILES["file"]["name"];
      }
    }
  }
else
  {
  echo "Invalid file";
  }
?>


3.新建/upload文件夹


4. 修改PHP上传文件大小限制的方法
//https://www.cnblogs.com/nofacemale/p/5228278.html
1). 一般的文件上传,除非文件很小.就像一个5M的文件,很可能要超过一分钟才能上传完.
但在php中,默认的该页最久执行时间为 30 秒.就是说超过30秒,该脚本就停止执行.
这就导致出现 无法打开网页的情况.这时我们可以修改 max_execution_time
在php.ini里查找
max_execution_time
默认是30秒.改为
max_execution_time = 0
0表示没有限制
2). 修改 post_max_size 设定 POST 数据所允许的最大大小。此设定也影响到文件上传。
php默认的post_max_size 为2M.如果 POST 数据尺寸大于 post_max_size $_POST 和 $_FILES superglobals 便会为空.
查找 post_max_size .改为
post_max_size = 150M
3). 很多人都会改了第二步.但上传文件时最大仍然为 8M.
为什么呢.我们还要改一个参数upload_max_filesize 表示所上传的文件的最大大小。
查找upload_max_filesize,默认为8M改为
upload_max_filesize = 100M
另外要说明的是,post_max_size 大于 upload_max_filesize 为佳.

修改php.ini需要重启php，配置才能生效。


5.ipconfig查服务器ip，可以上传文件了。


========================================
使用curl请求url数据
----------------------------------------
get和post?
怎么传数据?
怎么模拟header和cookie?


1.实例1：简单get请求
<?php
//初始化curl：
$url="https://www.baidu.com/";
$ch=curl_init();

//发送请求：
curl_setopt($ch,CURLOPT_URL,$url);
#怎么添加header头

$data=curl_exec($ch);
curl_close($ch);

//打印结果
#print("Print<pre>");
print($data);





2. 写成get函数
<?php
function curl_get_contents($url = '', $ispost = 0, $post_data = array())
{
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);


    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); // 对认证证书来源的检查
    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0); // 从证书中检查SSL加密算法是否存在
    curl_setopt($ch, CURLOPT_USERAGENT, $_SERVER['HTTP_USER_AGENT']); // 模拟用户使用的浏览器
    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); // 使用自动跳转
    curl_setopt($ch, CURLOPT_AUTOREFERER, 1); // 自动设置Referer
    curl_setopt($ch, CURLOPT_TIMEOUT, 10); // 设置超时限制防止死循环
    curl_setopt($ch, CURLOPT_HEADER, 0); // 查询显示返回的Header区域内容
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // 获取的信息以文件流的形式返回
    if ($ispost)
    {        
        curl_setopt($ch, CURLOPT_POST, $ispost);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
    }
    $output = curl_exec($ch);
    curl_close($ch);
    return $output;
}

$data=curl_get_contents("https://www.sina.com.cn");
print($data);



3. 写成类
<?php  
  
/**
 * Date: 2015/7/17 0017  
 * Time: 13:24  
 */  
class Action  {  
    public static function curl_get($url){
           $testurl = $url;
           $ch = curl_init();  
           curl_setopt($ch, CURLOPT_URL, $testurl);  
            //参数为1表示传输数据，为0表示直接输出显示。  
           curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
            //参数为0表示不带头文件，为1表示带头文件  
           curl_setopt($ch, CURLOPT_HEADER,0);
           $output = curl_exec($ch); 
           curl_close($ch); 
           return $output;
     }  
    /*  
     * url:访问路径  
     * array:要传递的数组  
     * */  
    public static function curl_post($url,$array=array()){
        $curl = curl_init();
        //设置提交的url  
        curl_setopt($curl, CURLOPT_URL, $url);
        //设置头文件的信息作为数据流输出  
        curl_setopt($curl, CURLOPT_HEADER, 0);
        //设置获取的信息以文件流的形式返回，而不是直接输出。  
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
        //设置post方式提交  
        curl_setopt($curl, CURLOPT_POST, 1);
        //设置post数据  
        $post_data = $array;
        curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data);
        //执行命令  
        $data = curl_exec($curl);
        //关闭URL请求  
        curl_close($curl);
      //获得数据并返回  
        return $data;
    }
}


# 之后就可以通过Action::curl_post($url,$array)或者Action::curl_get($url);的方式调用接口并得到数据了。
print( Action::curl_get("https://www.baidu.com") );







refer:
https://www.cnblogs.com/yixiao21/p/8507473.html
https://www.jb51.net/article/41831.htm



========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------



