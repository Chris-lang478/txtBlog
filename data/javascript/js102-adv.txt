JavaScript教程 函数


js从入门到精通： 案例+面试题驱动。
JavaScript原生对象及扩展: http://www.xinbujing.com/art/20150331/17658.html


========================================
函数定义和调用
----------------------------------------
1.定义
function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}

各个部分作用：
	- function指出这是一个函数定义；
	- abs是函数的名称；
	- (x)括号内列出函数的参数，多个参数以,分隔；
	- { ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。

请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。

如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。

第二种定义函数的方式如下：

	var abs = function (x) {
		if (x >= 0) {
			return x;
		} else {
			return -x;
		}
	};

在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。

上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。

2. 调用函数

abs(10); // 返回10
abs(-9); // 返回9

3. arguments
JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：

function foo(x) {
    alert(x); // 10
    for (var i=0; i<arguments.length; i++) {
        alert(arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);

利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：


实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法：
	// foo(a[, b], c)
	// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
	function foo(a, b, c) {
		if (arguments.length === 2) {
			// 实际拿到的参数是a和b，c为undefined
			c = b; // 把b赋给c
			b = null; // b变为默认值
		}
		// ...
	}
要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。



4. rest参数(ES6)
由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数：
	function foo(a, b) {
		var i, rest = [];
		if (arguments.length > 2) {
			for (i = 2; i<arguments.length; i++) {
				rest.push(arguments[i]);
			}
		}
		console.log('a = ' + a);
		console.log('b = ' + b);
		console.log(rest);
	}
为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？

ES6标准引入了rest参数，上面的函数可以改写为：

	function foo(a, b, ...rest) {
		console.log('a = ' + a);
		console.log('b = ' + b);
		console.log(rest);
	}

	foo(1, 2, 3, 4, 5);
	// 结果:
	// a = 1
	// b = 2
	// Array [ 3, 4, 5 ]

	foo(1);
	// 结果:
	// a = 1
	// b = undefined
	// Array []

  rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。
  如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。
  因为rest参数是ES6新标准，所以你需要测试一下浏览器是否支持。

5. 小心你的return语句
这样写是正常的：
	function foo() {
		return { name: 'foo' };
	}

	foo(); // { name: 'foo' }
这样写呢？
	function foo() {
		return 
			{ name: 'foo' };
	}
	返回
	foo(); // undefined


原因：	
由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了：
	function foo() {
		return; // 自动添加了分号，相当于return undefined; 
			{ name: 'foo' };
	}
	
所以正确的多行写法是：

	function foo() {
		return { // 这里不会自动加分号，因为{表示语句尚未结束
			name: 'foo'
		};
	}

========================================
|-- 变量作用域
----------------------------------------
js词法作用域：http://www.veryhuo.com/a/view/37894.html


1. js的变量作用域只有全局和函数内两种。
不加var声明的变量都是认为是全局变量！
例如：
	function foo(){
		var a=12;
	}
	foo();
	alert(a);
不出所料，警告：a is not defined


那么去掉var呢？
	function foo(){
		 a=12;
	}
	foo();
	alert(a);//弹出了12

结论：所有变量的声明都要加var！


2. 严格模式下不用var声明变量会报错。
	'use strict';
	function foo() {
		var x = 'Hello, ' + y;
		alert(x);
	}
	
	foo();//VM139:4 Uncaught ReferenceError: y is not defined

但是，尝试这个函数，会报错y未定义吗？
	'use strict';
	function foo() {
		var x = 'Hello, ' + y;
		alert(x);
		var y = 'Bob';
	}

	foo();
结果：没有报错，但是弹出的是 Hello, undefined

结论：
	- js会把函数内定义的变量提前到最初。但是赋值并没有提前。
由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：

	function foo() {
		var
			x = 1, // x初始化为1
			y = x + 1, // y初始化为2
			z, i; // z和i为undefined
		// 其他语句:
		for (i=0; i<100; i++) {
			//...
		}
	}

3. 全局作用域
不在任何函数内部声明的变量就具有全局作用域。
具有全局作用域的变量都是window的属性。
	var a=12;
	alert(a);//12
	alert( window.a);//12

顶层函数的定义也被视为一个全局变量，并绑定到window对象：
	window.alert( '12' );//和alert('12');等效
	
	function foo() {
		alert('foo');
	}

	foo(); // 直接调用foo()
	window.foo(); // 通过window.foo()调用

4. 命名空间(有人翻译为：名字空间)
所有变量和函数都绑定到window上，不同的js脚本可能发生命名冲突。例如
	//先定义bar函数
	function bar(){
		alert('hello');
	}

	var bar='good';//不小心在另一个地方定义了bar变量

	bar();//后来调用的时候出错
	Uncaught TypeError: bar is not a function(…)

减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：

	// 唯一的全局变量MYAPP:
	var MYAPP = {};

	// 其他变量:
	MYAPP.name = 'myapp';
	MYAPP.version = 1.0;

	// 其他函数:
	MYAPP.foo = function () {
		return 'foo';
	};

把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。

许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。
	
命名空间的定义：



	
5. 局部作用域
由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：
	'use strict';

	function foo() {
		for (var i=0; i<100; i++) {
			//
		}
		i += 100; // 仍然可以引用变量i
	}

为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：
	'use strict';

	function foo() {
		var sum = 0;
		for (let i=0; i<100; i++) {
			sum += i;
		}
		i += 1; // SyntaxError
	}

Uncaught SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode(…)
看来F12控制台模式不能这样执行let语句，写到html文件的script标签中执行：
	"use strict";
	function foo() {
		for (let i=0; i<100; i++) {
			//
		}
		i += 100; // Uncaught ReferenceError: i is not defined
	}

	foo();

其实，在console中不支持全局严格模式，但是在函数内，let之前用'use strict'; 	
	function foo() {
		"use strict";
		for (let i=0; i<100; i++) {
			//
		}
		i += 100; // Uncaught ReferenceError: i is not defined
	}
	foo();//报错i is not defined

6. 常量
由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：
	var PI = 3.14;

ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域：
	'use strict';

	const PI = 3.14;
	PI = 3; // 某些浏览器不报错，但是无效果！
	PI; // 3.14



========================================
|-- arguments对象
----------------------------------------
类数组，有length属性，可以使用下标取值，但是没有数组方法。
可以转化为数组：	var arr=Array.prototype.slice.call(arguments);

function test(){
	console.log(arguments);
	//arguments.push(12);//arguments.push is not a function(…)
	var arr=Array.prototype.slice.call(arguments);
	arr.push(14);
	return arr;
}
test(1,2,3);





========================================
闭包
----------------------------------------
js的闭包很典型，也很容易犯错。

简单说，就是内函数能访问外函数的上下文变量，当内函数被外函数返回时，外函数消失了，但是外函数的局部变量缺和内函数一样保留下来，可以被内函数调用，这就是闭包。

function outer(){
	var i=100;
	function inner(num=1){
		i+=num
		return(i)
	}
	
	return inner;
}

f1=outer() //外函数调用结束，由于返回值是其内函数，则其内变量i也保留下来，并可供内函数调用。
f1() //101
f1(20) //121




========================================
|-- js的定时器与闭包
----------------------------------------

任务： 编写一个计数器，每1秒小时一个数字，该数字逐步递增；
代码1: 简单的循环并不能达到期望的效果
for(var i = 0; i < 5; i++) {
	setTimeout(function () {
		console.log(i);
	}, 1000*i);
}
console.log('a');
//先输出a，再输出5个1
//看来有定时器也没用，先执行同步的(输出a)，然后才处理异步的，而这时候i的值是5(跳出循环时是5)，所以每秒输出一个5，连续5个5；





代码2: 使用闭包，当内函数执行的时候，是按照外函数传入时的值执行的
for(var i = 0; i < 5; i++) {
	(function(a){
		console.log("i=",i);
		setTimeout(function () {
			console.log(a);
		}, 1000*a);
	})(i)
}
console.log('a');




========================================
|-- js的定时器setInterval与for循环写轮播图 //todo
----------------------------------------
https://blog.csdn.net/XinYe666666/article/details/80634374
效果： 鼠标移开时，图片自动切换，移入时，停止切换；
鼠标放入左右箭头那，背景变白，箭头变红变为鼠标手且内角从120度变为90度，点击可以切换图片右下一张左上一张；
鼠标移入下面相应的数字变换为相应的图片且背景变蓝变为鼠标手。






========================================
Map和Set
----------------------------------------
1. Map
JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。
但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。
为了解决这个问题，最新的ES6规范引入了新的数据类型Map。

Map是一组键值对的结构，具有极快的查找速度。
初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：

	var m = new Map(); // 空Map
	m.set('Adam', 67); // 添加新的key-value
	m.set('Bob', 59);
	m.has('Adam'); // 是否存在key 'Adam': true
	m.get('Adam'); // 67
	m.delete('Adam'); // 删除key 'Adam'
	m.get('Adam'); // undefined
由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉.

2. Set
和数学中的集合概念类似，只保存key，不保存value。
	var s = new Set([1, 2, 3, 3, '3']);
	s; // Set {1, 2, 3, "3"}
通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：

	>>> s.add(4)
	>>> s
	{1, 2, 3, 4}
	>>> s.add(4)
	>>> s
	{1, 2, 3, 4}

通过delete(key)方法可以删除元素：

	var s = new Set([1, 2, 3]);
	s; // Set {1, 2, 3}
	s.delete(3);
	s; // Set {1, 2}

	
小结
Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。

========================================
iterable
----------------------------------------
遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。

具有iterable类型的集合可以通过新的for ... of循环来遍历。

for ... of循环是ES6引入的新的语法。

用for ... of循环遍历集合，用法如下：

	var a = ['A', 'B', 'C'];
	var s = new Set(['A', 'B', 'C']);
	var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
	for (var x of a) { // 遍历Array
		alert(x);
	}
	for (var x of s) { // 遍历Set
		alert(x);
	}
	for (var x of m) { // 遍历Map
		alert(x[0] + '=' + x[1]);
	}
你可能会有疑问，for ... of循环和for ... in循环有何区别？

for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。

当我们手动给Array对象添加了额外的属性后，for ... in循环将带来意想不到的意外效果：

	var a = ['A', 'B', 'C'];
	a.name = 'Hello';
	for (var x in a) {
		alert(x); // '0', '1', '2', 'name'
	}
for ... in循环将把name包括在内，但Array的length属性却不包括在内。

for ... of循环则完全修复了这些问题，它只循环集合本身的元素：

	var a = ['A', 'B', 'C'];
	a.name = 'Hello';
	for (var x of a) {
		alert(x); 'A', 'B', 'C'
	}
	
这就是为什么要引入新的for ... of循环。

然而，更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：

	var a = ['A', 'B', 'C'];
	a.forEach(function (element, index, array) {
		// element: 指向当前元素的值
		// index: 指向当前索引
		// array: 指向Array对象本身
		alert(element);
	});



暂时先漏过，需要再看：
http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143450082788640f82a480be8481a8ce8272951a40970000

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach



========================================
prototype 原型与原型链
----------------------------------------

========================================
|-- js的浅复制、深度复制
----------------------------------------
js中实现深度复制
https://blog.csdn.net/HUOJUNHUAN/article/details/79826429

深度复制：将一个对象复制给另一个对象，不是引用的复制而是值的复制，复制后的对象的改变不会影响原来对象的值。
浅复制：将一个对象复制给另一个对象，只是简单的引用复制，复制后的对象的改变会引起原来对象的值的改变。


实现深度复制的代码：
function deepClone(a,b){
	b=b||{};
	for(var i in a){
		if(a.hasOwnProperty(i)){
			if(typeof a[i]==="object"){
				b[i]=(Object.prototype.toString.call(a[i])==="[object Array]")?[]:{};
				deepClone(a[i],b[i]);
			}
			else{
				b[i]=a[i];
			}
		}
	}
	return b;
}


第二种实现深度复制的方法是使用es5中处理JSON对象的处理方法，JSON.stringify();将对象转换为字符串，JSON.parse()将字符串转换为对象。
var b=JSON.parse(JSON.stringify(a));
当改变b的值时，a的值是不会改变的，从而实现a的深度复制。

目前正在看使用JSON实现深度复制的原理，希望有兴趣可以来互相学习。我也是边学习边总结，希望自己慢慢进步。



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------



========================================
总结
----------------------------------------
1. 严格遵守“在函数内部首先申明所有变量”这一规则。


########################################
first added: 2016-1-5
modify at: 2016-1-x
########################################
