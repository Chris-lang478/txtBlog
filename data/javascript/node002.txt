
node.JS学习 入门篇（主要是基础知识）

当前node版本：v4.2.4 LTS(npm 3.5.3)
	2015年，npm超过cpan，成为这个星球上最大的包管理分发平台。

视频：http://www.imooc.com/learn/348

基础要求：学习nodeJS要有一定的js基础，最好有一点后端语言（java、php、python等）基础。
文本编辑器：vim、sublime text 2
浏览器：chrome

	本文使用ubuntu1404系统。也可以使用win7、Mac等系统。

课程须知
我们的课程面向的同学是：有 JavaScript 基础的同学，如果有过任何后台语言开发的经验更适合，对于有基础的同学，可以快进跳着看课程，不必拘束于每一分钟都听，很多时候其实是思路，思路打通了，很多技术细节也就不用纠结了。
 
老师告诉你能学到什么？
从 Node.js 基础知识入手，比如安装，环境配置、开发环境等，
进一步熟悉 Node.js API ，一些 HTTP 知识，
并且对模块的概念和使用更加熟悉，从而进阶到模块或者插件的开发，最终能够借助 Node.js 快速实现特定的需求。
最终能够借助 Node.js 快速实现特定的需求或功能。




========================================
nodeJS简介
----------------------------------------
什么是nodeJS?
nodeJS是一个c++编写的javascript运行环境。
可以解析js代码，没有浏览器安全级别限制。
提供系统级别的API:
	1.文件的读写；
	2.进程的管理；
	3.网络通信；
	
为什么学习nodeJS?
首先TA很火。
	npmjs.com有很多包。这里是伸手党的天堂。228,032 total packages
	打开github，搜索nodejs关键字，We’ve found 43,569 repository results
TA很强大：
	appjs做移动应用、jade做模板引擎、Ghost是博客、grunt/gulp是构建、log.io实时监控日志、
	PDFKit制作pdf、Haroopad是linux的markdown编辑器、NodeOS是系统。
	其他语言能做的，nodeJS也可以做。
	
对初学者推荐如下网站：
	官网nodejs.org 最新的更新、新的api、未来的发展趋势；
	npmjs.org 搜索是否有现有模块，省时省力
	github.com 代码托管平台，可以看到很多优秀的带按摩
	stackoverflow.com	一个很赞的程序问答系统
	
========================================
安装node.js
----------------------------------------
1.版本规则：
	偶数为是稳定版本 0.6.x ：推荐使用。
	奇数为非稳定版本 0.7.x ：可能有bug、可能移除API等。

2.apt-get install node提供的版本太老了，只好到官网下载最新版。
先安装vim，以后有用。
$ sudo apt-get install vim
	
3.在Ubuntu1404，使用火狐登陆https://nodejs.org/en/或者wget命令下载安装包：node-v4.2.4-linux-x64.tar.gz
$ wget https://nodejs.org/dist/v4.2.4/node-v4.2.4-linux-x64.tar.gz


>tips(2016-1-22)
几天不见有更新了，最新版4.2.6已经采用.xz压缩了
创建tar.xz文件：只要先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件先，然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz
解压tar.xz文件：先 xz -d xxx.tar.xz 将 xxx.tar.xz解压成 xxx.tar 然后，再用 tar xvf xxx.tar来解包。
(http://blog.csdn.net/rheostat/article/details/7614451)


解压：
$cd Downloads/
$tar -xvzf node-v4.2.4-linux-x64.tar.gz

然后将安装包移动到自己喜欢的地方(具体地址您随意):
$sudo mv node-v4.2.4-linux-x64 /usr/local/node/
进入文件夹，查看版本号
$./bin/node -v
v4.2.4
出现正确版本号，说明安装成功。

这就妥妥的了，node文件夹具体放在哪，叫什么名字随你怎么定。然后设置全局：
当然我们肯定是不满足只能在当前目录下运行的,所以我们还需要配置环境变量。
（修改软链接或者设置全局变量。此时设置软链接）
$sudo ln -s /usr/local/node/node-v4.2.4-linux-x64/bin/node /usr/local/bin/node
$sudo ln -s /usr/local/node/node-v4.2.4-linux-x64/bin/npm /usr/local/bin/npm


查看版本号
wjl@ubuntu:~$ npm -v
2.14.12
wjl@ubuntu:~$ node -v
v4.2.4

4.使用最新版本安装包，则node是附带npm的。
在npm查到npm最新版：3.5.3 is the latest of 187 releases

升级npm
$ npm update -g npm
/usr/local/node/node-v4.2.4-linux-x64/bin/npm -> /usr/local/node/node-v4.2.4-linux-x64/lib/node_modules/npm/bin/npm-cli.js
npm@3.5.3 /usr/local/node/node-v4.2.4-linux-x64/lib/node_modules/npm

再查看，发现已经是最新版本了：
wjl@ubuntu:~$ npm -v
3.5.3

到此，安装完毕。
node -v //v4.2.4
npm -v //3.5.3

refer: http://www.xitongzhijia.net/xtjc/20150202/36680.html


5.node有两种运行方式：
脚本运行环境，如使用如下脚本获取文件名：
dirname.js
	console.log(__dirname)
	console.log(__filename)

$ node dirname.js
/home/wjl/Public
/home/wjl/Public/dirname.js

交互式运行环境：
$ node
> 1+100
101


6.退出node交互式环境：[ctrl+c]两次

7.编辑器：WebStorm 可以配置，达到追踪和查看nodejs的源代码。
	Source Code Pre字体，是Adobe公司为程序员专门开发的一款等宽字体。
	

#











========================================
|-- 使用 ubuntu复习一下node[2021.4.23]
----------------------------------------
官网都打不开，尝试失败。


1. 系统自带的
$ node --version
v10.13.0
 
$ npm --version
6.4.1


2. 升级 
$ npm update -g npm


ref:
https://www.liaoxuefeng.com/wiki/1022910821149312/1099503821472096




========================================
nodeJS版本管理模块n
----------------------------------------

貌似可以在一台机器上安装好几个版本的node。


node有一个模块叫n（这名字可够短的。。。），是专门用来管理node.js的版本的。
首先安装n模块：
npm install -g n 

第二步：
升级node.js到最新稳定版
n stable

是不是很简单？
n后面也可以跟随版本号比如： 
n v0.10.26 

或 
n 0.10.26

分享几个npm的常用命令
npm -v #显示版本，检查npm 是否正确安装。 
npm install express #安装express模块 
npm install -g express #全局安装express模块 
npm list #列出已安装模块 
npm show express #显示模块详情 
npm update #升级当前目录下的项目的所有模块 
npm update express #升级当前目录下的项目的指定模块 
npm update -g express #升级全局安装的express模块 
npm uninstall express #删除指定的模块


========================================
第一个小程序：启动一个服务器
----------------------------------------
每次修改都要重启服务器！否则看不到效果。


1. 新建文本文件 
$vim server1.js

var http = require('http'); //http模块创建web服务器

http.createServer(function (request, response) { //匿名回调函数，参数是请求，响应
  response.writeHead(200, {'Content-Type': 'text/plain'});//响应的状态码
  response.end('Hello World\n'); //返回的内容
}).listen(8124);//监听8124端口

console.log('Server running at http://127.0.0.1:8124/');

运行
$node server1.js
Server running at http://127.0.0.1:8124/

访问：http://192.168.1.180:8124/
发现显示：Hello World

2.略作调整，修改链式调用为普通调用，修改plain文本为html，输出代码中加入<hr />标签。

server1.js
var http=require('http');

var server=http.createServer(function (request, response) {
  response.writeHead(200, {'Content-Type': 'text/html'});
  response.end("Hello Node.js <hr />\n");
})

server.listen(8124);

console.log('Server running at http://127.0.0.1:8124/');

ctrl + C暂停服务器后，重启：
wjl@ubuntu:~/Public$ node server1.js
Server running at http://127.0.0.1:8124/

访问：http://192.168.1.180:8124/
输出：Hello Node.js <hr />


========================================
js运行时环境：浏览器运行时和node运行时
----------------------------------------
1.浏览器中的js运行环境：打开浏览器，快捷键F12，点击控制台。

2.命令行的js运行环境，输入$node

3.全局对象

在两个环境执行普通js方法没有区别。
但是顶层对象（也叫全局对象）不同。
比如浏览器中：
>window
Window {external: Object, chrome: Object, document: document, speechSynthesis: SpeechSynthesis, caches: CacheStorage…}

node中没有window概念：
> window
ReferenceError: window is not defined

浏览器中的顶层对象是window
for(var key in window){console.log(key)};
VM91:2 external
VM91:2 chrome
VM91:2 document
VM91:2 define
VM91:2 global
VM91:2 cr
VM91:2 ntp
VM91:2 loadTimeData


无意试了一下，浏览器也有顶层对象global：
for(var key in global){console.log(key)};
VM67:2 external
VM67:2 chrome
VM67:2 document
VM67:2 define
VM67:2 global
VM67:2 cr
VM67:2 ntp
VM67:2 loadTimeData

再试一次：
global==window //true


node中的顶层对象是global。
>  for(var key in global){console.log(key)};
global
process
GLOBAL
root
Buffer
clearImmediate
clearInterval
clearTimeout
setImmediate
setInterval
setTimeout
console
module
require
key
undefined

貌似目前只有这15个对象。




4.但是node中也有独有的对象：
> process
process {
  title: 'node',
  version: 'v4.2.4',
  moduleLoadList: 
   [ 'Binding contextify',
     'Binding natives',
     'NativeModule events',
     'NativeModule buffer',
     'Binding buffer',
     'NativeModule internal/util',
...



5.console对象
共有四个方法log/info/error/warn
console.js
	console.log('log text')
	console.info('info text')
	console.error('error text')
	console.warn('warn text')

$ node console.js 
log text
info text
error text
warn text
wjl@ubuntu:~/Public$ node console.js ->test.txt
error text
warn text

在test.txt中：
log text
info text



========================================
Node.js中的三个核心知识
----------------------------------------
Node.js中的三个核心知识：模块和包，文件读取，异步（非阻塞式）。这一讲都是非常重要的知识点


http://study.163.com/course/courseLearn.htm?courseId=601001#/learn/video?lessonId=752002&courseId=601001



========================================
模块与包管理工具
----------------------------------------
怎么解决方法被覆盖、变量被重写的问题？
特别是怎么处理依赖关系？

由于js天生没有模块概念，只能人肉一套规范，就是Commonjs规范。
它包含了modules/binary/packages/system/filesystems/console/encodings/sockets/unit test...
不同于jQuery，Comonjs是一套规范。
来约定js怎么编写。

Node.js/Couchdb都是Commonjs的实现。规范与实现相互促进。

一个模块包括三个部分：定义、标识、引用。
npm install 需要的模块名。
每个模块都是独立的，完整的。
node中模块和文件是一一对应的。

模块的分类：
核心模块	http fs path...
文件模块	var uti=require('./util.js');
第三方模块	var promise=require('myJS');


简单的模块
创建模块	test2.js
导出模块	exports.add=function(){}
	exports.add=fn
	module.exports=fn 
	以上两种的区别是什么？

加载模块	var test3=require('./test2.js');
使用模块	test3.doSth('somePara');

nodejs没有全局命名空间一说。



演示js文件之间引用的小例子：共4个文件
学生、老师被班级引用，班级被index引用，启动index。
$cat student.js
function add (sname){
    console.log('student:'+sname);
}

exports.add=add

$cat teacher.js
function add (tname){
    console.log('teacher:'+tname);
}

exports.add=add

$ cat klass.js
var student=require('./student');
var teacher=require('./teacher');

function add (teacherName,students){
    teacher.add(teacherName);

    students.forEach(function(item,index){
        student.add(item)
    })
}

exports.add=add
//module.exports=add

$ cat index.js
var klass =require('./klass')

klass.add('Scott',['bfm','gfs'])

启动：
$ node index
teacher:Scott
student:bfm
student:gfs

再抽象，修改index.js文件，可以传入很多班级，并暴露出班级。
index.js
var klass =require('./klass')

exports.add = function(klasses){
    klasses.forEach(function(item,index){
        var _klass=item;
        var teacherName=item.teacherName;
        var students=item.students;

        klass.add(teacherName,students);
    })
}

都移动到school文件夹中，然后怎么用呢？

todo 留待下文分解。



========================================
nodeJS API讲解：url模块(url网址解析的好帮手。)
----------------------------------------
不要陷入版本争端中。还好，io.js和node.js已经合并了。
nodejs能满足高并发、大规模的场景。

url是uri的一个子集。

文档：http://nodejs.cn/doc/node_4/url.html

也输入命令查看方法：
$ node
> url
{ parse: [Function: urlParse],
  resolve: [Function: urlResolve],
  resolveObject: [Function: urlResolveObject],
  format: [Function: urlFormat],
  Url: [Function: Url] }
已经列出了可用的几个方法。我们尝试其中一个方法：

> url.parse('http://www.imooc.com/video/6710')
Url {
  protocol: 'http:',
  slashes: true,
  auth: null,
  host: 'www.imooc.com',
  port: null,
  hostname: 'www.imooc.com',
  hash: null,
  search: null,
  query: null,
  pathname: '/video/6710',
  path: '/video/6710',
  href: 'http://www.imooc.com/video/6710' }
 
> url.parse('http://www.imooc.com:8081/video/6710?name=dawn&year=2015&topic=node#urlTopic')
Url {
  protocol: 'http:',
  slashes: true,
  auth: null,
  host: 'www.imooc.com:8081',
  port: '8081',
  hostname: 'www.imooc.com',
  hash: '#urlTopic',
  search: '?name=dawn&year=2015&topic=node',
  query: 'name=dawn&year=2015&topic=node',
  pathname: '/video/6710',
  path: '/video/6710?name=dawn&year=2015&topic=node',
  href: 'http://www.imooc.com:8081/video/6710?name=dawn&year=2015&topic=node#urlTopic' }
> 
这几个协议一定要记住！分别在什么位置。

>url.format({
  protocol: 'http:',
  slashes: true,
  auth: null,
  host: 'www.imooc.com:8081',
  port: '8081',
  hostname: 'www.imooc.com',
  hash: '#urlTopic',
  search: '?name=dawn&year=2015&topic=node',
  query: 'name=dawn&year=2015&topic=node',
  pathname: '/video/6710',
  path: '/video/6710?name=dawn&year=2015&topic=node'})
输出一个完整且合法的url：'http://www.imooc.com:8081/video/6710?name=dawn&year=2015&topic=node#urlTopic'


可以把url解析成完整的url。
>url.resolve('http://www.imooc.com/','/course/list/1234.html')
'http://www.imooc.com/course/list/1234.html'

parse方法可以加第2个参数true(默认是false)，则query的值是一个json对象：
> url.parse('http://www.imooc.com:8081/video/6710?name=dawn&year=2015&topic=node#urlTopic',true)
Url {
  protocol: 'http:',
  slashes: true,
  auth: null,
  host: 'www.imooc.com:8081',
  port: '8081',
  hostname: 'www.imooc.com',
  hash: '#urlTopic',
  search: '?name=dawn&year=2015&topic=node',
  query: { name: 'dawn', year: '2015', topic: 'node' },
  pathname: '/video/6710',
  path: '/video/6710?name=dawn&year=2015&topic=node',
  href: 'http://www.imooc.com:8081/video/6710?name=dawn&year=2015&topic=node#urlTopic' }

parse方法可以加第3个参数true(默认是false)，则没有协议时host也能解析，对比如下：
> url.parse('//www.imooc.com:8081/video/6710?name=dawn&year=2015&topic=node#urlTopic',true)
Url {
  protocol: null,
  slashes: null,
  auth: null,
  host: null,
  port: null,
  hostname: null,
  hash: '#urlTopic',
  search: '?name=dawn&year=2015&topic=node',
  query: { name: 'dawn', year: '2015', topic: 'node' },
  pathname: '//www.imooc.com:8081/video/6710',
  path: '//www.imooc.com:8081/video/6710?name=dawn&year=2015&topic=node',
  href: '//www.imooc.com:8081/video/6710?name=dawn&year=2015&topic=node#urlTopic' }
> url.parse('//www.imooc.com:8081/video/6710?name=dawn&year=2015&topic=node#urlTopic',true,true)
Url {
  protocol: null,
  slashes: true,
  auth: null,
  host: 'www.imooc.com:8081',
  port: '8081',
  hostname: 'www.imooc.com',
  hash: '#urlTopic',
  search: '?name=dawn&year=2015&topic=node',
  query: { name: 'dawn', year: '2015', topic: 'node' },
  pathname: '/video/6710',
  path: '/video/6710?name=dawn&year=2015&topic=node',
  href: '//www.imooc.com:8081/video/6710?name=dawn&year=2015&topic=node#urlTopic' }
同时path参数也正常了。

	
========================================
querystring模块：处理参数的利器
----------------------------------------
文档地址：http://nodejs.cn/doc/node_4/querystring.html

命令行下查看方法数：
> querystring
{ unescapeBuffer: [Function],
  unescape: [Function],
  escape: [Function],
  encode: [Function],
  stringify: [Function],
  decode: [Function],
  parse: [Function] }

querystring.stringify序列化（json到string）
> querystring.stringify({ name: 'dawn', year: '2015', topic: 'node' })
输出：'name=dawn&year=2015&topic=node'

querystring.stringify第二个参数 是连接字符串：
> querystring.stringify({ name: 'dawn', year: '2015', topic: 'node' },'%')
'name=dawn%year=2015%topic=node'

> querystring.stringify({ name: 'dawn', year: '2015', topic: 'node' },',')
'name=dawn,year=2015,topic=node'

querystring.stringify第三个参数是key和value之间的符号
> querystring.stringify({ name: 'dawn', year: '2015', topic: 'node' },',',':')
'name:dawn,year:2015,topic:node'

querystring.parse反序列化
> querystring.parse('name=dawn&year=2015&topic=node')
{ name: 'dawn', year: '2015', topic: 'node' }

querystring.parse第二个参数、第三个参数分别是连接字符串和k-v分隔符
> querystring.parse('name::dawn,year::2015,topic::node',',','::')
{ name: 'dawn', year: '2015', topic: 'node' }

> querystring.parse('name::dawn,year::2015,topic::node,topic::js,topic::php',',','::')
{ name: 'dawn', year: '2015', topic: [ 'node', 'js', 'php' ] }
还是成功解析成了数组。

转义：
> querystring.escape('<a>视频</a>');
'%3Ca%3E%E8%A7%86%E9%A2%91%3C%2Fa%3E'

反转义：
> querystring.unescape('%3Ca%3E%E8%A7%86%E9%A2%91%3C%2Fa%3E');
'<a>视频</a>'

> querystring.escape(' ');
'%20'


========================================
一次http的过程（理论篇）
----------------------------------------
什么是http？
	超文本传输协议。

http与https的区别？	//todo

http的流程？
	http客户端发起请求，创建端口。
	http服务器在端口监听客户端请求。
	http服务器向客户端返回状态和内容。比如200，错误404等。

	是一个请求-响应的被动过程。

http 一次请求都做了什么（在chrome中输入一个网址，从回车到看到网页中间发生了什么）？
1.chrome搜索自身的DNS缓存，默认1min过期。
	查看方式：chrome://net-internals/#dns
2.如果没有找到浏览器缓存或缓存已经失效，搜索操作系统自身的DNS缓存，
3.读取本地的host文件：C:/WINDOWS/system32/drivers/etc/hosts(这是只读的，先取消只读再修改)
4.浏览器发起一个DNS的一个系统调用
	1).宽带运营商服务器查找本身缓存。
	2).运营商服务器发起一个迭代的DNS解析的请求。
		运营商服务器把结果返回给操作系统内核，同时把结果缓存起来。
		操作系统内核把结果返回给服务器。
		终于，浏览器拿到了www.xxx.com的IP地址。
5.浏览器获得域名对应的IP地址后，发起http“三次握手”。
	浏览器向服务器发送TCP连接，经过层层路由，到达网卡，到达TCP/IP协议栈，还有可能要经过防火墙的过滤。
	最终到达服务器端。

	"三次握手"都干了啥呢？//todo
		客户端说：能听到吗？
		服务器说：能听到。
		客户端说：那好，我们开始聊吧。
		更深层次的请搜索。。。

6.TCP/IP连接建立起来后，浏览器就可以向服务器发送http请求了。
	比如使用get方法向根域请求一个域名，协议可以采用http 1.0的协议。
	
7.服务器端接收到这个请求，
	根据路径参数，经过后端的一些处理之后，把处理过后的结果返回给浏览器，可以是html、json等。
	
8.浏览器拿到了网页的完整的html页面代码，在解析和渲染这个页面的时候，里面的css/js/图片等静态资源，同样也是一个个http请求。都需要经过以上7个步骤。

9浏览器根据拿到的资源，渲染页面，呈现给用户。



http包括请求和响应。
都会发送http头和正文信息。
http头：发送的是一些附加的信息：内容类型，http状态码，服务器发送响应的日期。
正文：提交的表达数据，或返回的数据。



========================================
一次http的过程（操作篇）
----------------------------------------
打开chrome，按F12打开开发者工具，点击network，选中all，在地址栏输入一个网址，回车。
观察开发者工具，每一条就是一个http请求。
随便点击一个，在右侧可以看到headers/preview/Response/Cookies/Timing.

点击Timing可以看到：
	stalled ??
	DNS Lookup	DNS解析时间。
	Proxy negotiation 代理协商的时间
	Request/Response
		Request sent 请求时间（上传时间）
		Waiting(TTFB)	请求结束到响应开始之前的时间。路由时间、后台处理时间
		Content Download	响应的花费时间(下载时间)
	
	通过分析Timing参数，可以看到网页慢的瓶颈所在。
	

点击header，可以看到如下内容：
[General]
Remote Address:116.213.120.41:80
Request URL:http://www.imooc.com/
Request Method:GET
Status Code:200 OK

[Response Headers]
view source
Connection:keep-alive
Content-Encoding:gzip
Content-Type:text/html; charset=utf-8
Date:Tue, 19 Jan 2016 09:32:54 GMT
Server:nginx
Set-Cookie:imooc_isnew=2; expires=Wed, 18-Jan-2017 09:32:51 GMT; path=/; domain=.imooc.com
Set-Cookie:cvde=567ff3c8258b4-153; path=/; domain=.imooc.com
Transfer-Encoding:chunked
Vary:Accept-Encoding
Vary:Accept-Encoding

[Request Headers]
view source
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding:gzip, deflate, sdch
Accept-Language:zh-CN,zh;q=0.8,en;q=0.6
Connection:keep-alive
Cookie:imooc_uuid=3d3b98b0-1f58-4cc9-9736-6080b454b383; imooc_isnew_ct=1451226056; IMCDNS=0; PHPSESSID=vdd7865vkj2uoe4c0tmdf3n8e4; loginstate=1; apsid=hhZTBlNjI3Mzg4ZmQ0ZGFiY2MwNWI4Nzc0NTg1ZDMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMTE2MTkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwb3N0ZXI0NjlAMTYzLmNvbQAAAAAAAAAAAAAAAAAAAGNkYTdlNmU2YjM0MTU3MTYyZmFjZGE2MjUxMjU5MTJjlLeLVpS3i1Y%3DNT; last_login_username=poster469%40163.com; channel=491b6f5ab9637e8f6dffbbdd8806db9b_phpkecheng; jwplayer.qualityLabel=æ®æ¸; Hm_lvt_f0cfcccd7b1393990c78efdeebff3968=1451226425,1453110324; Hm_lpvt_f0cfcccd7b1393990c78efdeebff3968=1453195940; cvde=567ff3c8258b4-152; imooc_isnew=2
Host:www.imooc.com
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36

请求方法
http 1.1协议共定义了8种方法，或方式。包括：
	get	取得数据
	post	提交数据
	put	更新头像等
	delete	删除
	head	想服务器发送请求
	trace	
	options
	...


状态码
1xx 请求已经接收，正在处理
2xx	请求已经接收，已经接收
3xx	请求重定向
4xx 客户端错误
5xx	服务器端错误

比较常见的
200 ok
304 资源没变化(Not Modified)
400 客户端请求有语法错误
401 请求没有授权
403 没有权限，拒绝服务
404 不存在该资源
500 服务器端发生不可预期错误
503	当前不可请求该请求，稍后重试。




	
========================================
http事件回调进阶：http模块（非阻塞、单线程、事件驱动。）
----------------------------------------

支持更多特性
不缓冲请求和响应
处理流相关

http都很底层，并不解析请求头和请求尾。

什么是回调？
什么是同步/异步？
什么是I/O?
什么是单线程/多线程？
什么是阻塞/非阻塞？
什么是事件？
什么是事件驱动？
什么是基于事件驱动的回调？
什么是事件循环？


1.回调：异步编程的方式，后续步骤了作为前一步的参数。
$ cat callback.js 
function learn(something){
	console.log(something)
}

function we(callback,something){
	something += ' is cool'
	callback(something);
}

we(learn,'Nodejs')

运行后：
$ node callback.js 
Nodejs is cool

以上是一个具名函数的例子，下面增加一个匿名函数的例子。
we(function(something){
	console.log(something)
},'Jade')

运行后：
$ node callback.js 
Nodejs is cool
Jade is cool


2.异步：
对应的是同步：打电话，问消息，得到回复，挂电话。
	就是顺序执行顺序。
	
异步：打电话，问消息，挂电话。有消息了打电话回来。
	一旦有返回，就立刻触发回调函数。
	程序的执行顺序与事件的执行顺序是不一致的。
	js中最经典的异步就是setTimeout和setInterval。

同步的例子：
var c=0;
function printIt(){
        console.log(c)
}

function add(){
        c += 1;
}

add()
printIt()
	
$ node cb.js
1


异步的例子：
var c=0;
function printIt(){
        console.log(c)
}

function add(){
        setTimeout(function(){
                c +=1 ;
        },1000);
}
add()
printIt()

$ node cb.js
0

可以使其保持异步，同时还实现加1，修改后：
var c=0;
function printIt(){
        console.log(c)
}

function add(callback){
        setTimeout(function(){
                c +=1 ;
                callback();
        },1000);
}
add(printIt)

$ node cb.js
1

3.单线程。一次只能进行一个。
	同时运行多个，就叫多线程。
	
	单线程和多线程都有对应的场景，都有优缺点。

4.IO就是读写。

5.什么是阻塞？打电话的时候，不能离开，你就被阻塞了。
但是打电话问一下，挂电话，等回话，这时你可以随便活动，你就没有被阻塞。

6.什么是事件，事件驱动？
一个事件就是一个定义好的行为：单击、双击等就是事件。

node中server被连接时会触发事件。

EventEmitter的对象。

事件发生才会促发代码执行，就叫做事件驱动。

>基于回调的异步IO。

Event loop，事件循环。很多异步，需要回调函数队列查询。

这时，我们就理解力三个概念：非阻塞、单线程、事件驱动。


	
========================================
http源码解读-基础篇：作用域、上下文
----------------------------------------
nodeJS适合高并发、IO密集操作等场景。

作用域：调用函数，使用变量的能力。
上下文：与this关键字有关。是调用当前执行文件的引用。谁调用this指向谁。

作用域：全局作用域、局部作用域。

this指向函数的拥有者，this只能在函数内部使用。
定义时的上下文，运行时的上下文，还可以改变上下文。

1.
call和apply方法改变this的上下文，后者传入参数必须为数组形式。

var pet={
	words:'...',
	speak:function(who){
		console.log(who + ' '+ this.words);
	}
}

var dog={
	words:'Wang'
}

pet.speak.call(dog, 'dog say:');//执行者变成了dog，它获得了pet对象的speak方法。

//dog say: Wang

pet.speak.apply({words:'hehe'}, ['haha']);




2.使用call实现继承：
function Pet(words){
	this.words=words;
	this.speak=function(){
		console.log(this.words)
	}
}

function Dog(words){
	//继承Pet
	Pet.call(this, words);
	//或 Pet.apply(this,arguments);
}

var dog=new Dog('Wang');
dog.speak(); //Wang



========================================
http源码解读
----------------------------------------

跳跃式看代码，先形成脉络。
现有问题，带着问题看代码。
没有问题怎么办？

看最早的一段代码，怎么理解全过程？

1.看文档：doc: http://nodejs.cn/doc/node_4/http.html
首先http模块除了createServer还有很多方法，如get：
	http.createServer([requestListener])
	http.get(options[, callback])
	http.globalAgent
	http.request(options[, callback])

2.看http源码：
到github查看源码， https://github.com/nodejs/node
选择最新版0.12版本，按下键盘上的t健，即可呼出搜索页面。
输入http.js，找到该文件，并单击打开node/lib/http.js。
该文件行数121 lines (97 sloc)  3.63 KB
(https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/http.js)

	下划线的_是私有模块，通过exports就可以暴露出去。

这是两个输入输出，输入输出流对象是重点，后续会讲。	
exports.IncomingMessage = require('_http_incoming').IncomingMessage;
exports.OutgoingMessage = require('_http_outgoing').OutgoingMessage;


找到了request和get，他们就是文档接口中所描述的源代码。
exports.request = function(options, cb) {
  return new ClientRequest(options, cb);
};

exports.get = function(options, cb) {
  var req = exports.request(options, cb);
  req.end();
  return req;
};
发现get是request的一个封装，返回了一个request的实例。


这里看到了createServer方法，他返回了一个Server实例，同时把回调函数作为参数传入。
exports.createServer = function(requestListener) {
  return new Server(requestListener);
};
搜索Server，
var server = require('_http_server');
exports.ServerResponse = server.ServerResponse;
exports.STATUS_CODES = server.STATUS_CODES;

发现Server是require进来的一个_http_server模块。



3.看_http_server源码：
我们按下t键，输入_http_server.js，点击打开node/lib/_http_server.js：
https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/_http_server.js
499 lines (423 sloc)  15.4 KB


搜索function server，找到如下函数：
function Server(requestListener) {
  if (!(this instanceof Server)) return new Server(requestListener);
  net.Server.call(this, { allowHalfOpen: true });

  if (requestListener) {
    this.addListener('request', requestListener);
  }

  // Similar option to this. Too lazy to write my own docs.
  // http://www.squid-cache.org/Doc/config/half_closed_clients/
  // http://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F
  this.httpAllowHalfOpen = false;

  this.addListener('connection', connectionListener);

  this.addListener('clientError', function(err, conn) {
    conn.destroy(err);
  });

  this.timeout = 2 * 60 * 1000;
}
util.inherits(Server, net.Server);

里面有一句：
  if (requestListener) {
    this.addListener('request', requestListener);
  }
是说'request'事件触发的时候，就执行requestListener回调函数。
'request'事件在哪里呢？


怎么找呢？
第一：当前文件搜索'request'这个关键词；
第二：如果不在当前文件，怎么找？貌似只好通读代码了。

当前页底部找到了一行：
	self.emit('request', req, res);
就是触发'request'事件的地方。
	如果我们看到过文档介绍，或者了解nodejs的事件机制的话，可以直接用emit单词搜索会更快。
	这个emit还有两个参数，分别是req和res，就是我们定义的回调函数的两个参数。还有疑问，请继续看。。。
	
向上，找到方法名parserOnIncoming，
function parserOnIncoming(req, shouldKeepAlive) {
    incoming.push(req);
	//...
}

req和res是怎么生成的呢？
发现parserOnIncoming方法本身就被传入一个req参数，也就是req这个参数不是该方法本身构建的。
搜索res，在该方法体中找到了res的声明，是ServerResponse的实例，传入了req参数：
	var res = new ServerResponse(req);


ServerResponse是什么？本页内搜索，发现ServerResponse是一个构造函数：
function ServerResponse(req) {
  OutgoingMessage.call(this);//ServerResponse是OutgoingMessage的一个子类。继承参数

  if (req.method === 'HEAD') this._hasBody = false;

  this.sendDate = true;

  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {
    this.useChunkedEncodingByDefault = chunkExpression.test(req.headers.te);
    this.shouldKeepAlive = false;
  }
}
util.inherits(ServerResponse, OutgoingMessage);//ServerResponse继承自OutgoingMessage。继承方法

ServerResponse.prototype._finish = function() {
  DTRACE_HTTP_SERVER_RESPONSE(this.connection);
  COUNTER_HTTP_SERVER_RESPONSE();
  OutgoingMessage.prototype._finish.call(this);
};

exports.ServerResponse = ServerResponse;//ServerResponse作为一个接口，暴露出去。



搜索OutgoingMessage，发现一行：
	var OutgoingMessage = require('_http_outgoing').OutgoingMessage;
它是_http_outgoing模块的方法。



按键盘上的t健，输入_http_outgoing，点击打开node/lib/_http_outgoing.js：
625 lines (513 sloc)  16.7 KB

util.inherits(OutgoingMessage, Stream);//OutgoingMessage继承自Stream
exports.OutgoingMessage = OutgoingMessage;//暴露出去OutgoingMessage方法。

function OutgoingMessage() {
  Stream.call(this);
  //...
}
OutgoingMessage中初始化了很多变量，都是和服务器返回的内容有关的。



按键盘上的t健，输入stream，点击打开node/lib/stream.js
'use strict';
module.exports = Stream;
这里把exports暴露给了module？？？//todo


>>>>结论：res是 Stream->OutgoingMessage->ServerResponse的一个实例。

4.
req呢？
回到node/lib/_http_server.js
function parserOnIncoming(req, shouldKeepAlive) 的参数是req，它来自于
	parser.onIncoming = parserOnIncoming;
当前页面没有更多信息了，怎么办？
向上找。找parser的来源，发现
	 var parser = parsers.alloc();
继续找parsers的来源，
	var common = require('_http_common');
	var parsers = common.parsers;

5.按t键，输入_http_common，点击打开私有模块node/lib/_http_common.js
https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/_http_common.js
229 lines (189 sloc)  6.71 KB

搜索onIncoming，
	 skipBody = parser.onIncoming(parser.incoming, info.shouldKeepAlive);
	 第一个参数推测及时req，第二个参数就是keepAlive。
向上找incoming，
	 parser.incoming = new IncomingMessage(parser.socket);
	 发现parser的套接字给了构造函数IncomingMessage。
找IncomingMessage，
	var incoming = require('_http_incoming');
	var IncomingMessage = incoming.IncomingMessage;
	

6....
经过类次上推，发现
	req是 _http_incoming->IncomingMessage->parser的实例。

7.如果使用过Express框架，Express对req和res进行了扩展。
在github中搜索express，
	https://github.com/strongloop/express
	Fast, unopinionated, minimalist web framework for node. http://expressjs.com

	
	
按t键，搜索request.js，点击打开express/lib/request.js
https://github.com/strongloop/express/blob/master/lib/request.js
490 lines (424 sloc)  11.1 KB

var req = exports = module.exports = {
  __proto__: http.IncomingMessage.prototype
};
说明req的原型指向http.IncomingMessage的原型。


按t键，搜索response.js，点击打开express/lib/response.js
https://github.com/strongloop/express/blob/master/lib/response.js
1054 lines (909 sloc)  24.2 KB

var res = module.exports = {
  __proto__: http.ServerResponse.prototype
};
说明res的原型指向http.ServerResponse的原型。



8.返回node的node/lib/_http_server.js模块：
	function parserOnIncoming(req, shouldKeepAlive)方法在 function connectionListener(socket)中
本页搜索connectionListener：	
  this.addListener('connection', connectionListener);
  在'connection'事件触发的时候执行回调函数connectionListener。

而connection事件什么时候触发呢？搜connection和emit都没有相关的结果。
	本页只有一条：net.Server.call(this, { allowHalfOpen: true });//表示net.Server的触发对象已经指向当前函数。
	没有更多线索，找net.js吧。

9.按t键，搜索net.js，点击打开node/lib/net.js
https://github.com/nodejs/node/blob/master/lib/net.js
1592 lines (1269 sloc)  39.7 KB
搜emit，找到：
	self.emit('connection', socket);
在方法function onconnection(err, clientHandle)中。


搜索onconnection：
	self._handle.onconnection = onconnection;
该语句在函数Server.prototype._listen2 = function(address, port, addressType, backlog, fd)中。

继续找_listen2：
	self._listen2(address, port, addressType, backlog, fd);
在方法function listen(self, address, port, addressType, backlog, fd, exclusive)中。


这个listen方法是在Socket的原型上定义的。
Socket.prototype.listen = function() {
  debug('socket.listen');
  var self = this;
  self.on('connection', arguments[0]);
  listen(self, null, null, null);
};


所以：net->_http_server->实例会有listen方法。
Net中的listen - _listen2 - 内部把onconnection方法赋值给self._handle.onconnection
在onconnection中，会触发一个'connection'事件，
_http_server.js中的connectionListener被调用，其内部会构建req和res。
以及触发self.emit('request', req, res);
'request'事件再触发this.addListener('request', requestListener);中定义的requestListener回调函数。
也即是我们定义的回调函数。


好晕乎。。。

=======
未知概念：
1.流、事件监听、调用、几个模块的嵌套关系。
2.emit函数如何实现事件触发的？

如果多看几遍，还是可以看到源代码的。

真正难的是配套的知识结构，和实际场景中解决问题的思路。
这个需要时间积累。
	
========================================
http性能小测试：ab是apachebench命令的缩写
----------------------------------------
nodejs空框架用apache ab测试性能。
ab可以模拟任何场景下的网络请求。


ab简介：http://www.111cn.net/phper/apache/74246.htm


1.安装ab。
$ ab
The program 'ab' is currently not installed. You can install it by typing:
sudo apt-get install apache2-utils

$ sudo apt-get install apache2-utils

2.查看网址:
	inet addr:192.168.1.180 

3.启动nodejs的服务器：
$ cat server1.js 
var http=require('http');

var server=http.createServer(function (request, response) {
  response.writeHead(200, {'Content-Type': 'text/html'});
  response.end("Hello Node.js, I am back.<hr />\n");
})
server.listen(8124);
console.log('Server running at http://127.0.0.1:8124/');

$ node server1.js 
Server running at http://127.0.0.1:8124/

4.开始压力测试：
	-n requests     Number of requests to perform 请求次数
    -c concurrency  Number of multiple requests to make at a time 单个时间请求个数，并发数。
	-t timelimit    Seconds to max. to spend on benchmarking 请求的最多时间。
                    This implies -n 50000 默认50000 //todo 单位是什么？
	-p postfile     File containing data to POST. Remember also to set -T 想要post过去的文件
	-T content-type Content-type header to use for POST/PUT data, eg. 设置post过去的数据的格式，
                    'application/x-www-form-urlencoded'	比如：'application/x-www-form-urlencoded'
                    Default is 'text/plain'	默认是文本。
	-w              Print out results in HTML tables 使用html表格输出结果。



	地址后面要加斜杠/；
$ab -n1000 -c10 http://127.0.0.1:8124/
回车即可看到测试结果：
This is ApacheBench, Version 2.3 <$Revision: 1528965 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking 127.0.0.1 (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Completed 400 requests
Completed 500 requests
Completed 600 requests
Completed 700 requests
Completed 800 requests
Completed 900 requests
Completed 1000 requests
Finished 1000 requests


Server Software:        
Server Hostname:        127.0.0.1
Server Port:            8124

Document Path:          /
Document Length:        32 bytes

Concurrency Level:      10	并发数，命令中设置过
Time taken for tests:   0.352 seconds  花费的总时间
Complete requests:      1000	总的请求数
Failed requests:        0	请求失败个数
Total transferred:      132000 bytes	整个过程中网络传输数据量
HTML transferred:       32000 bytes	传输的http字节数
Requests per second:    2843.44 [#/sec] (mean)	【重点】服务器的吞吐率
Time per request:       3.517 [ms] (mean) 【重要】请求的平均等待时间
Time per request:       0.352 [ms] (mean, across all concurrent requests) 每个连接请求实际运行时间。
Transfer rate:          366.54 [Kbytes/sec] received	单位时间内在网络中的流量。排除单位时间内传输过大导致的延时。

Connection Times (ms) 网络消耗时间的分解
              min  mean[+/-sd] median   max
Connect:        0    0   2.2      0      30	连接
Processing:     1    3   3.1      2      29	处理
Waiting:        1    3   3.0      2      29	等待
Total:          1    3   4.1      2      41	总时间

Percentage of the requests served within a certain time (ms) 在一定时间内请求完成百分比
  50%      2
  66%      3
  75%      4
  80%      4
  90%      6
  95%      8
  98%     15
  99%     29
 100%     41 (longest request)

因为是本地测试，少了很多网络传输时间，所以很快。 





5.测试一下慕课网的首页：
$ab -n1000 -c10 http://www.imooc.com/

远程测试确实慢很多，所以花费在网络传输上的时间很大！
压力测试的时候，最好在本地局域网内的另一台电脑上测试，得到的结果更准确、可信。

This is ApacheBench, Version 2.3 <$Revision: 1528965 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking www.imooc.com (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Completed 400 requests
Completed 500 requests
Completed 600 requests
Completed 700 requests
Completed 800 requests
Completed 900 requests
Completed 1000 requests
Finished 1000 requests


Server Software:        nginx 服务器软件名称是nginx
Server Hostname:        www.imooc.com
Server Port:            80

Document Path:          /
Document Length:        49676 bytes 正文长度

Concurrency Level:      10
Time taken for tests:   161.986 seconds
Complete requests:      1000
Failed requests:        0
Total transferred:      50322435 bytes
HTML transferred:       49676000 bytes
Requests per second:    6.17 [#/sec] (mean)
Time per request:       1619.863 [ms] (mean)
Time per request:       161.986 [ms] (mean, across all concurrent requests)
Transfer rate:          303.38 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:       12   13   2.3     13      52
Processing:   617 1599 515.6   1529    5261
Waiting:      567 1543 515.8   1472    5232
Total:        630 1612 515.7   1543    5273

Percentage of the requests served within a certain time (ms)
  50%   1543
  66%   1706
  75%   1820
  80%   1894
  90%   2130
  95%   2469
  98%   3082
  99%   3905
 100%   5273 (longest request)

有99%的用户访问时间是小于4905ms的。


压力测试与机器配置、硬件老化程度、网络条件等因素有关。
经过对比，总是可以构建一套标准，评估代码运行速度，做进一步优化。


========================================
使用nodeJS做http小爬虫：借助http API
----------------------------------------
网络中每时每刻都有很多请求，客户端到服务端的，服务端到服务端的。

1.获取imooc某页面所有结果
$spider.js
var http= require('http')
var url='http://www.imooc.com/learn/348'

http.get(url,function(res){
	var html=''
	res.on('data',function(data){
		html += data;
	})

	res.on('end', function(){
		console.log(html)
	})

}).on('error', function(){
	console.log('some thing wrong ...')
})
这个结果是html格式的，不适合直接阅读。



2.获取imooc某页面所有结果，从html中提取并显示章节信息。
$spider2.js 使用了cheerio模块，就是node端的jQuery。
npm install cheerio

var http= require('http')
var url='http://www.imooc.com/learn/348'
var cheerio=require('cheerio')

function filterChapters(html){
	//npm install cheerio
	//like jQuery in dom
	var $=cheerio.load(html)

	var chapters=$('.chapter')

	var courseData=[];
	chapters.each(function(item){
		var chapter=$(this)
		var chapterTitle=chapter.find('strong').text();
		var videos=chapter.find('.video').children('li');
		var chapterData={
			'chapterTitle':chapterTitle,
			'videos':[]
		}

		videos.each(function(item){
			var video=$(this).find('.studyvideo');
			var videoTitle=video.text();
			var id=video.attr('href').split('video/')[1];
			chapterData.videos.push({
				title:videoTitle,
				id:id
			})
		})

		courseData.push(chapterData)
	})

	return courseData;
/*	data format:
	[{
		chapterTitle:'',
		videos:[
			title:'',
			id:''
		]
	}]*/
}

function printCourseData(courseData){
	courseData.forEach(function(item){
		var chapterTitle=item.chapterTitle;
		console.log(item['chapterTitle'])

		item.videos.forEach(function(video){
			console.log('	['+video.id + '] '+video.title)
		})
	})
}

http.get(url,function(res){
	var html=''
	res.on('data',function(data){
		html += data;
	})

	res.on('end', function(){
		//console.log(html)
		var courseData = filterChapters(html);
		printCourseData(courseData);
	})
}).on('error', function(){
	console.log('some thing wrong ...')
})


运行后的结果：
$ node spider2.js 
第1章 前言
	[6687] 1-1 前言 (01:20)                                              
	[6688] 1-2 为什么学习Nodejs (05:43)                                                   
第2章 安装 Nodejs
	[6689] 2-1 课程简介 (01:19)                                                  
	[6690] 2-2 Nodejs版本常识 (01:02)                                                
	[6691] 2-3 Windows下安装Nodejs (04:43)                                               
	[6692] 2-4 Linux下安装Nodejs (06:24)                                              
	[6693] 2-5 Mac下安装Nodejs (03:55)                                                
第3章 等不及了来尝鲜
	[6694] 3-1 起一个web服务器 (05:14)                                             
	[6695] 3-2 命令行中体验 (02:47)                                                   
第4章 模块与包管理工具
	[6697] 4-1 Node.js 的模块 与 Commonjs 规范 (03:44)                                             
	[6700] 4-2 模块的分类 (00:45)                                            
	[6701] 4-3 简单的Nodejs模块 (09:23)                                           
第5章 横扫 Nodejs API
	[6705] 5-1 不要陷入版本选择的深渊 (02:32)                                          
	[6710] 5-2 URL网址解析的好帮手 (10:30)                                              
	[6711] 5-3 QueryString参数处理小利器 (06:40)                                         
	[6712] 5-4 HTTP知识先填坑 (09:43)                                          
	[6713] 5-5 HTTP知识填坑之“以慕课网为例分析” (10:13)                                        
	[7557] 5-6 HTTP 事件回调进阶 (17:51)                                       
	[7558] 5-7 HTTP 源码解读之先了解作用域、上下文 (20:50)                                          
	[7963] 5-8 HTTP 源码解读 (22:08)                                         
	[7964] 5-9 HTTP 性能测试 (09:15)                                      
	[7965] 5-10 HTTP 小爬虫 (17:33)                                     
	[8525] 5-11 事件模块小插曲 (15:15)                                        
	[8837] 5-12 request方法 (17:56)

	
========================================
事件模块小插曲：回调
----------------------------------------
response为什么有一个on方法？
response为什么有一个end方法？

1.
nodeJs里面最重要的模块：events模块
对外只暴露一个对象，EventEmit，events中emit的两个作用：事件的发射和事件的监听。。。

life.setMaxListeners(11) ; // 设置事件最大监听（针对每种事件） 默认为10个
设置监听器数量，这样超过10个监听器，可以不报警告。
官方说明超过十个会造成内存泄露，最好不要超过十个


on和addEventListener的区别？？todo
addNodeEventListener用于注册系统事件的监听，如触摸事件、帧事件、按键事件等。
addEventListener用于注册自定义事件的监听，节点必须经过组件扩展后才能使用。 

EventEmit 类下生成事件对象， life = new EventEmit();
on 方法 监听事件 ，emit方法触发（发射）事件；

life.on( 'eventname', function(arg){} ); // 监听的时间和事件触发后执行的函数
life.emit( 'eventname', arg)； // 触发的事件和需要传递的形参 
emit 方法的返回值为true 或 false, 如果事件监听过为true,没监听过为false



event.js
var EventEmitter = require('events').EventEmitter
var life=new EventEmitter();

//on == addEventListener at server side
life.on('myEvent', function(who){
	console.log('give ' + who + ' some water.')
})

life.on('myEvent', function(who){
	console.log('give ' + who + ' some money.')
})

life.on('myEvent', function(who){
	console.log('give ' + who + ' some books.')
})

life.on('myEvent2', function(who){
	console.log('give ' + who + ' from event3.')
})

var a=life.emit('myEvent','me')
var a2=life.emit('myEvent2','me')
var a3=life.emit('myEvent3','me')

console.log(a)
console.log(a2)
console.log(a3)


执行之后：
$ node event.js
give me some water.
give me some money.
give me some books.
give me from event3.
true
true
false//这个没有自定义事件，所以返回false。




2.
removeListener删除监听要用非匿名函数!

event2.js
var EventEmitter = require('events').EventEmitter
var life=new EventEmitter();

//on == addEventListener at server side
function fn(who){
	console.log('give ' + who + ' some water.')
}

life.on('myEvent', fn);
life.on('myEvent', function(who){
	console.log('give ' + who + ' some money.')
})

life.emit('myEvent','me')
life.removeListener('myEvent',fn);//去除监听函数

console.log('\n')
life.emit('myEvent','me')

3.
查询某个事件下的监听函数个数。

console.log(life.listeners('myEvent').length) //1
console.log(life.listeners('myEvent2').length) //0

或者：
console.log(EventEmitter.listenerCount(life,'myEvent')) //1

4.移除所有事件后的所有监听函数
//removeAll
life.removeAllListeners();

console.log(EventEmitter.listenerCount(life,'myEvent')) //0

不过，缺点是移除了所有事件背后的监听函数，有点过了。

5.移除某一个事件后的监听函数：life.removeAllListeners('myEvent');

event3.js
var EventEmitter = require('events').EventEmitter
var life=new EventEmitter();

//on == addEventListener at server side
function fn(who){
	console.log('give ' + who + ' some water.')
}

life.on('myEvent', fn);
life.on('myEvent', function(who){
	console.log('give ' + who + ' some money.')
})
life.emit('myEvent','me')

life.on('myEvent2',fn)
//life.removeListener('myEvent',fn);

//console.log(life.listeners('myEvent').length)

//removeAll
life.removeAllListeners('myEvent');

console.log(EventEmitter.listenerCount(life,'myEvent')) //0
console.log(EventEmitter.listenerCount(life,'myEvent2')) //1


========================================
request方法
----------------------------------------
get方法是request方法的封装，会request方法，get也就很容易了。

1.
http.request(options[, callback])
常用的参数
	host path
	hostname headers
	port auth
	localAddress agent
	socketPath keepAlive
	method keepAliveMsecs

2.
用node自动化加入评论的功能。
comment.js的内容（header是从评论区复制过来的：先打开chrome控制台network，评论后点击ajax连接，复制request的header部分）

var http=require('http')
var querystring=require('querystring')

var postData=querystring.stringify({	//从
	'content':'I am here again. from nodeJS@ubuntu1404 ',
	'mid':8837	//评论的视频的id，可以从url地址中获取http://www.imooc.com/video/8837
})

var options={
	hostname: 'www.imooc.com',
	port:80,
	path:'/course/docomment',
	method:'post',
	headers:{
		'Accept':'application/json, text/javascript, */*; q=0.01',
		'Accept-Encoding':'gzip, deflate',
		'Accept-Language':'zh-CN,zh;q=0.8,en;q=0.6',
		'Connection':'keep-alive',
		'Content-Length': postData.length,//'27',  //这个字符长度imooc在服务器端做验证的，要保证正确
		'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
		'Cookie':'imooc_uuid=3d3b98b0-1f58-4cc9-9736-6080b454b383; imooc_isnew_ct=1451226056; IMCDNS=0; PHPSESSID=vdd7865vkj2uoe4c0tmdf3n8e4; loginstate=1; apsid=hhZTBlNjI3Mzg4ZmQ0ZGFiY2MwNWI4Nzc0NTg1ZDMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMTE2MTkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwb3N0ZXI0NjlAMTYzLmNvbQAAAAAAAAAAAAAAAAAAAGNkYTdlNmU2YjM0MTU3MTYyZmFjZGE2MjUxMjU5MTJjlLeLVpS3i1Y%3DNT; last_login_username=poster469%40163.com; jwplayer.qualityLabel=æ®æ¸; Hm_lvt_f0cfcccd7b1393990c78efdeebff3968=1451226425,1453110324; Hm_lpvt_f0cfcccd7b1393990c78efdeebff3968=1453286213; cvde=567ff3c8258b4-203; imooc_isnew=2',
		'Host':'www.imooc.com',
		'Origin':'http://www.imooc.com',
		'Referer':'http://www.imooc.com/video/8837',
		'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36',
		'X-Requested-With':'XMLHttpRequest'
	}
}

//这是request的用法，第一个参数是header部分，第二个参数是回调函数，回调函数的参数是返回值对象
var req=http.request(options,function(res){
	console.log('Status:'+res.statusCode)	//状态码
	console.log('headers: ' + JSON.stringify(res.headers))	//返回的头文件

	//如果有数据返回，则触发'data'事件
	res.on('data',function(chunk){
		console.log(Buffer.isBuffer(chunk)) //数据类型是不是buffer类型？
		console.log(typeof chunk)
	})
	//如果响应结束，则触发'end'事件
	res.on('end',function(){
		console.log('comment is over')
	})
})

//如果请求失败，则打印错误信息
req.on('error',function(e){
	console.log('Error:' + e.message)
})

req.write(postData);//写入post数据
req.end();//写入结束


运行脚本：
$ node comment.js 
Status:200
headers: {"server":"nginx","date":"Wed, 20 Jan 2016 13:05:49 GMT","content-type":"text/html; charset=utf-8","transfer-encoding":"chunked","connection":"keep-alive","vary":"Accept-Encoding, Accept-Encoding","set-cookie":["imooc_isnew=2; expires=Thu, 19-Jan-2017 13:05:49 GMT; path=/; domain=.imooc.com"],"content-encoding":"gzip"}
true
object
comment is over


3.
get是封装的request方法，做了如下修改：
	设置方法为get，
	自动执行req.end();

慕课网建议每一期4个小时，第一期结束。



========================================
有待验证：
----------------------------------------

nodejs模块前后端都能用，react+flux架构的store有用得上。



单词与短语
>synopsis 英[sɪˈnɒpsɪs] 美[sɪˈnɑ:psɪs]
n.	大纲; 摘要，梗概;
http://nodejs.cn/doc/node_4/synopsis.html
