DOM 操作




========================================
js dom 插入
----------------------------------------
existingItem.appendChild(newItem);//在existingItem内部的最后添加元素newItem
document.getElementById("myList").insertBefore(newItem,existingItem);//在myList内部的existingItem前面添加newItem



1.使用数组信息，向文档中插入dom元素

<!--start 积累句型 小目录-->	
<div class=item id=juxing>
	<h2  class="title">20190608 <a>如何通过英语读报积累写作句型？</a></h2>
</div>
<!--end-->	

<script>
//只需要补充url和text，即可自动更新链接
var url_list1=[
	["https://mp.weixin.qq.com/s?__biz=MzI0NDcxNzc5Mg==&mid=2247486402&idx=2&sn=79b61e7be76fbf4d7e9541ab47c8d670","(1)经济学人：老年盗窃团伙"],
	["https://mp.weixin.qq.com/s?__biz=MzI0NDcxNzc5Mg==&mid=2247486404&idx=2&sn=100aae2456dce4b45fe807da65d419eb","(2)Atlantic: 权游配乐"],
	["https://mp.weixin.qq.com/s?__biz=MzI0NDcxNzc5Mg==&mid=2247486411&idx=2&sn=a6e4cb50296856aac414bb4fccfae418","(3)NPR: 放大的疼痛"],
]

// 自动更新dom
for(var i in url_list1){
	var oDiv=document.getElementById("juxing") //找到父元素
	url_info=url_list1[i] //获取url信息
	
	//创建链接元素
	oA=document.createElement("A");
	oA.setAttribute("target","_blank");
	oA.setAttribute("href",url_info[0]);
	//向链接元素中添加文本
	oText=document.createTextNode(url_info[1]); //创建文本节点
	oA.appendChild(oText)
	//向父元素插入链接元素
	oDiv.appendChild(oA)
	oDiv.appendChild( document.createTextNode(" | ") )
	//console.log(oA) //test
}
</script>





2.innerHTML在body标签中插入隐藏html内容
//定义广告
function sapp(){
	window.onload = function () {
		var body = document.body;
		var div = document.createElement("div");
		div.id = "downdiv";
		div.innerHTML = '<div class="downcode" style="position:fixed;z-index:1000;top:200px;right:10px;overflow:hidden;background: #fff;"><p style="text-align:right;color:#b50723;margin: 3px;cursor: pointer;"><span onclick="hidedown();">关闭</span></p><img alt= "下载" src= "http://www.yueshuapp.com/app/2wm.png" style= "width:200px;height:200px;" /><p style="text-align:center;line-height:24px;">下载看书APP 告别广告,超快更新</p></div >';
		body.appendChild(div);
	}
}

//隐藏按钮
function hidedown() {
	document.getElementById("downdiv").style.display = "none";
}

//启动
sapp();

refer: https://m.mxguan.com/xxgg/apppc.js



========================================
|-- 删除dom节点
----------------------------------------
//保证传入的是node
function deleteNode(node){
	if(node.parentNode){
		console.log(i);
		node.parentNode.removeChild(node); 
	}
}
// 删除一个网页中的css表，因为aLink是动态数组，删除一个元素之后数组更新，最大角标对应的元素已经不存在，删除过程会报错。
// 倒序删除则没问题！
var aLink=document.getElementsByTagName('link');
for(var i=aLink.length-1; i>=0; i--){
		deleteNode(aLink[i]);
}
//测试站点：https://segmentfault.com/q/1010000002955089


========================================
|-- 动态加载js文件：创建dom并加载js、document.writeln
----------------------------------------
1.
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>





2.向现有文件中添加js脚本: document.writeln
使用 document.writeln()
document.writeln("<script src=\'https://m.mxguan.com/xxgg/apppc.js\'></script>");

refer: 
document.write() 和 document.writeln() 区别 https://www.cnblogs.com/colmeluna/p/3862642.html


========================================
|-- 原生js删除节点、替换节点、复制节点node.cloneNode(true)
----------------------------------------
1、removeChild() 用来删除父节点的一个子节点。 
parent.removeChild(childNode); 
如下：

<div id="box">
    <p id="p1">这是一个段落</p>
    <p id="p2">第二个段落</p>
</div>
<script>
    var box=document.getElementById("box");  //找到父元素
    var p1=document.getElementById("p1");    //找到子元素    
    box.removeChild(p1);  
    //也可以通过要删除的子节点的父节点删除子节点
    p1.parentNode.removeChild(p1);                  
</script>





2、replaceChild() 用新节点替换某个子节点。 
parent.replaceChild (newnode,oldnode ) ； 
如下：

<div id="box">
    <p id="p1">这是一个段落</p>
    <p id="p2">第二个段落</p>
    <div id="div1">这是div</div>
</div>
<script>
    var box=document.getElementById("box");  //找到父元素
    var p1=document.getElementById("p1");    //找到要替换的元素

    var p3=document.createElement('p');//创建要替换的元素
    p3.innerHTML="这是第三个段落";  //为创建的元素赋值
    box.replaceChild(p3,p1);  //替换节点
    p1.parentNode.replaceChild(p3,p1); //通过parentNode节点替换
</script>
注意：新节点可以是文档中某个已存在的节点，也可以创建新的节点。






3、cloneNode() 复制节点并返回复制的节点 
node.cloneNode(true|false) ; //默认是 false。 
参数设置为 true，克隆节点及其属性，以及后代；设置为 false，克隆节点本身 
如下：
<div id="main">
    <div id="box">
        <p id="p1">这是一个段落</p>
        <p id="p2">第二个段落</p>
    </div>
</div>
<script>
    var main=document.getElementById("main"); 
    var box=document.getElementById("box"); 

    var newNode=box.cloneNode(true);
    main.appendChild(newNode);
    console.log(main);
</script>



https://blog.csdn.net/LLL_liuhui/article/details/79978487


========================================
|-- js运动 - 完美运动框架 startMove.js(支持缓冲运动、链式运动、同时运动)
----------------------------------------
支持多物体运动，定时器和obj绑定；
支持链式运动，只需要传入匿名运动函数；
支持同时运动，只需要传入json运动目标；
支持像素变化和不透明度的变化，不支持颜色的变化。


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<title>完美运动框架</title>
<style>
*{
	padding: 0;
	margin: 0;
}
div{
	color: #fff;
	width: 200px;
	height: 100px;
	background-color: yellow;
	border: 4px solid #000;
	filter: alpha(opacity:30);
	opacity: 0.3;
}
</style>
</head>
<body>
	
	<div id="div1"></li>
</body>
<script>
window.onload = function(){
	var oDiv = document.getElementById('div1');
	oDiv.onmouseover = function(){
		
		startMove(oDiv,{width:400,height:125,opacity:100});
	}
	oDiv.onmouseout = function(){
		startMove(oDiv,{height:100,width:200,opacity:30});
	}
	
}
function getStyle(obj,attr){
	if (obj.currentStyle) {
		return obj.currentStyle[attr];
	}
	else{
		return getComputedStyle(obj,false)[attr];
	}
}

function startMove(obj,json,fn){
	var flag = true;
	clearInterval(obj.timer);
	obj.timer = setInterval(function(){
		for(var attr in json){
			// 1.取当前的值
			var iCur = 0;
			if(attr == 'opacity'){
				iCur = Math.round(parseFloat(getStyle(obj,attr))*100);
			}
			else{
				iCur = parseInt(getStyle(obj,attr));
			}
			// 2.算速度
			var iSpeed = (json[attr]-iCur)/8;
			iSpeed = iSpeed>0?Math.ceil(iSpeed):Math.floor(iSpeed);

			// 3.检测停止
			if(iCur != json[attr])
			{
				flag = false;
			}

			if (attr == 'opacity') {
				obj.style.filter = 'alpha(opacity:'+(iCur + iSpeed)+')';
				obj.style.opacity = (iCur+iSpeed)/100;
			}
			else
			{
				obj.style[attr] = iCur + iSpeed + 'px';
			}
			
		}

		if (flag) {
			clearInterval(obj.timer);
			if (fn) {
				fn();
			}
		}

	},30)
}
</script>
</html>


========================================
js点击按钮显示再点击空白地方隐藏
----------------------------------------

http://zhidao.baidu.com/link?url=mLGTly6mxZyvbUl_vcmiBuhsVqVezpcBRGLJOi2n4Bvielzz7CutoTssV97UYTw8ChZGi4pMATX4_zKIX2W30wlix2DyIo8QIwCRDolEDHS

可以参考这个！

document.onclick = function(){
    //隐藏层代码
};
 
div.onclick = function(oEvent){
    //取消冒泡
    oEvent = oEvent || window.event;
    if(document.all){
        oEvent.cancelBubble = true;
    }else{
        oEvent.stopPropagation();
    }
};




========================================
使用||设置默认值
----------------------------------------
//例1. 这一段是设置属性的，用||设置了一个{}默认值
(google_async_config = window.google_async_config || {})['ca-pub-1307862221338762'] = {"sra_enabled":false};



//例2. 先使用CDN的jQ，如果加载失败，使用本地jQ文件
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>
	window.jQuery||document.write('<script src="../assets/js/vendor/jquery-1.11.3.min.js"><\/script>');
</script>




========================================
css类名添加和删除
----------------------------------------
可以参考一下classList，提供了add、remove、toggle以及contains等方法方便操作className
https://segmentfault.com/q/1010000002955089


var classVal = document.getElementById("id").getAttribute("class");

//删除的话
classVal = classVal.replace("someClassName","");
document.getElementById("id").setAttribute("class",classVal );

//添加的话
classVal = classVal.concat(" someClassName");
document.getElementById("id").setAttribute("class",classVal );

//替换的话
classVal = classVal.replace("someClassName","otherClassName");
document.getElementById("id").setAttribute("class",classVal );
只是匹配个class名字，用不着正则应该。



========================================
AJAX
----------------------------------------



========================================
Promise对象
----------------------------------------
https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544
http://es6.ruanyifeng.com/#docs/promise





========================================
Canvas 标签
----------------------------------------
有了canvas，flash就没啥用了。
鼠标粒子吸附效果： https://www.sojson.com/hexadecimal.html



1. 创建dom 
<canvas id="test-canvas" width="300" height="200"></canvas>
或
<canvas id="test-stock" width="300" height="200">
    <p>当前浏览器不支持Canvas，请使用chrome访问</p>
</canvas>



2. 检测是否支持： 在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas
var canvas = document.getElementById('test-canvas');
if (canvas.getContext) {
    console.log('你的浏览器支持Canvas!');
} else {
    console.log('你的浏览器不支持Canvas!');
}



3. 画图
(1) 熟悉坐标
getContext('2d')方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。
var ctx = canvas.getContext('2d');

如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形：
gl = canvas.getContext("webgl");

本节我们只专注于绘制2D图形。

Canvas的坐标系统：坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。



(2) 画一个笑脸
var canvas = document.getElementById('test-shape-canvas');
var ctx = canvas.getContext('2d');

ctx.clearRect(0, 0, 200, 200); // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
ctx.fillStyle = '#dddddd'; // 设置颜色
ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色

// 利用Path绘制复杂路径:
var path=new Path2D();
path.arc(75, 75, 50, 0, Math.PI*2, true);
path.moveTo(110,75);
path.arc(75, 75, 35, 0, Math.PI, false);
path.moveTo(65, 65);
path.arc(60, 65, 5, 0, Math.PI*2, true);
path.moveTo(95, 65);
path.arc(90, 65, 5, 0, Math.PI*2, true);
ctx.strokeStyle = '#0000ff';
ctx.stroke(path);


(3) 绘制文本: 带阴影的文字
绘制文本就是在指定的位置输出文本，可以设置文本的字体、样式、阴影等，与CSS完全一致：
'use strict';
var
    canvas = document.getElementById('test-text-canvas'),
    ctx = canvas.getContext('2d');

ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.shadowOffsetX = 2;
ctx.shadowOffsetY = 2;
ctx.shadowBlur = 2;
ctx.shadowColor = '#666666';
ctx.font = '24px Arial';
ctx.fillStyle = '#333333';
ctx.fillText('带阴影的文字', 20, 40);







4. Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：

- 通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；
- 尽量使用整数坐标而不是浮点数；
- 可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；
- 背景图片如果不变可以直接用<img>标签并放到最底层。


例: 画股票交易k线图 https://www.liaoxuefeng.com/wiki/1022910821149312/1023022423592576






========================================
Bom操作
----------------------------------------
浏览器相关操作：浏览器大小、尺寸、新建窗口、历史记录等。


========================================
|-- js获取屏幕、浏览器的宽高：
----------------------------------------

当前浏览器的高度，该值会随着拖动浏览器而改变，document.documentElement.clientHeight //734




<html>
<script>
function a(){
document.write(
"屏幕分辨率为："+screen.width+"*"+screen.height
+"<br />"+
"屏幕可用大小："+screen.availWidth+"*"+screen.availHeight
+"<br />"+
"网页可见区域宽："+document.body.clientWidth
+"<br />"+
"网页可见区域高："+document.body.clientHeight
+"<br />"+
"网页可见区域宽(包括边线的宽)："+document.body.offsetWidth 
+"<br />"+
"网页可见区域高(包括边线的宽)："+document.body.offsetHeight 
+"<br />"+
"网页正文全文宽："+document.body.scrollWidth
+"<br />"+
"网页正文全文高："+document.body.scrollHeight
+"<br />"+
"网页被卷去的高："+document.body.scrollTop
+"<br />"+
"网页被卷去的左："+document.body.scrollLeft
+"<br />"+
"网页正文部分上："+window.screenTop
+"<br />"+
"网页正文部分左："+window.screenLeft
+"<br />"+
"屏幕分辨率的高："+window.screen.height
+"<br />"+
"屏幕分辨率的宽："+window.screen.width
+"<br />"+
"屏幕可用工作区高度："+window.screen.availHeight
+"<br />"+
"屏幕可用工作区宽度："+window.screen.availWidth
);
}
</script>
<body onload="a()" >
</body>
</html>
//from http://www.cnblogs.com/lf6112/archive/2011/07/26/2117348.html

========================================
|-- JS操作cookies方法!
----------------------------------------
//写cookies
function setCookie(name,value,days){
	var Days = days||30;
	var exp = new Date();
	exp.setTime(exp.getTime() + Days*24*60*60*1000);
	document.cookie = name + "="+ escape (value) + ";expires=" + exp.toGMTString();
}
//读cookies
function getCookie(name){
	var arr,reg=new RegExp("(^| )"+name+"=([^;]*)(;|$)");
	if(arr=document.cookie.match(reg))
		return unescape(arr[2]);
	else
		return null;
}
//删除cookies
function delCookie(name){
	var exp = new Date();
	exp.setTime(exp.getTime() - 1);
	var cval=getCookie(name);
	if(cval!=null)
		document.cookie= name + "="+cval+";expires="+exp.toGMTString();
}



========================================
监控鼠标滚轮的滚动，监控到哪个锚点了？
----------------------------------------
1.两种监听页面滚动的方法
(1).原生js通过window.onscroll监听
window.onscroll = function() {
  //为了保证兼容性，这里取两个值，哪个有值取哪一个
  //scrollTop就是触发滚轮事件时滚轮的高度
  var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
  console.log("滚动距离" + scrollTop);
}

(2).Jquery通过$(window).scroll()监听
$(window).scroll(function() {
  //为了保证兼容性，这里取两个值，哪个有值取哪一个
  //scrollTop就是触发滚轮事件时滚轮的高度
  var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
  console.log("滚动距离" + scrollTop);
})




2.每次滚轮事件，都做一次循环判断
jQ版
$(window).scroll(function(){
	//为页面添加页面滚动监听事件
	var wst =  $(window).scrollTop() //滚动条距离顶端值
	for (i=1; i<6; i++){             //加循环
		if($("#a"+i).offset().top<=wst){ //判断滚动条位置
			$('#nav a').removeClass("c"); //清除c类
			$("#a"+i+i).addClass("c");	//给当前导航加c类
		}
	}
})
$('#nav a').click(function(){
	$('#nav a').removeClass("c");
	$(this).addClass("c");
});



js版：
window.onscroll = function() {
	//为了保证兼容性，这里取两个值，哪个有值取哪一个
	//scrollTop就是触发滚轮事件时滚轮的高度
	var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
	//console.log("滚动距离" + scrollTop);
	//开始循环干活了
	//目录内容
	var oMenu=$('f_content');
	var aSpan=oMenu.getElementsByTagName("span");
	
	//正文内容
	var aA= document.querySelectorAll("a[name]");
	//对正文的锚点进行遍历
	for(var i=0;i<aA.length;i++){
		if(aA[i].offsetTop<scrollTop){
			//remove class cur, for 导航
			for(var j=0;j<aSpan.length;j++){
				aSpan[j].parentElement.parentElement.setAttribute("class","");
			}
			
			//add class cur, for 导航
			var oA=aSpan[i].parentElement.parentElement
			oA.setAttribute("class","cur")
		}
	}
}





refer:
鼠标滚动监听并且给锚点加class类 https://blog.csdn.net/sloafer/article/details/79446861
监听页面滚动及滚动到指定位置 https://www.jianshu.com/p/4bf613d8c927
原生JS实现随着鼠标滚动到元素位置触发对应css3动画，简单易用 https://blog.csdn.net/likeyou1207/article/details/80782935



========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------

