SVG(Scalable Vector Graphics){竞争对手: flash;}


SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 https://www.w3.org/TR/SVG11/

svg作品欣赏: https://www.html5tricks.com/tag/svg/


https://www.softwhy.com/article-9914-1.html
https://www.runoob.com/svg/svg-reference.html

my demo: http://jslecture.biomooc.com/canvas_SVG/indexSVG.html

========================================
**** SVG(Scalable Vector Graphics) 简介/使用方法 ****
----------------------------------------
SVG可以算是目前最最火热的图像文件格式了，它的英文全称为Scalable Vector Graphics，意思为可缩放的矢量图形。它是基于XML（Extensible Markup Language），由World Wide Web Consortium（W3C）联盟进行开发的。严格来说应该是一种开放标准的矢量图形语言，可让你设计激动人心的、高分辨率的Web图形页面。用户可以直接用代码来描绘图像，可以用任何文字处理工具打开SVG图像，通过改变部分代码来使图像具有交互功能，并可以随时插入到HTML中通过浏览器来观看。


SVG是一种用XML定义的语言，用来描述二维矢量及矢量/栅格图形。SVG提供了3种类型的图形对象：矢量图形（vectorgraphicshape例如：由直线和曲线组成的路径）、图象(image)、文本(text)。图形对象还可进行分组、添加样式、变换、组合等操作，特征集包括嵌套变换（nested transformations）、剪切路径（clipping paths）、alpha蒙板（alpha masks）、滤镜效果（filter effects）、模板对象（template objects）和其它扩展（extensibility）。

SVG图形是可交互的和动态的，可以在SVG文件中嵌入动画元素或通过脚本来定义动画。



1. svg是纯文本xml控制的画图体系，是矢量图；

SVG 图像可在任何的分辨率下被高质量地打印
SVG 可在图像质量不下降的情况下被放大

SVG 可以与 JavaScript 技术一起运行


如下是一个黑边红色填充的圆。
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="200" height="200">
  <circle cx="100" cy="50" r="40" stroke="black"
  stroke-width="2" fill="red" />
</svg>
注意: 所有的开启标签必须有关闭标签！





2. SVG 的四种引用方式
(1) 保存为 circle1.svg文件，浏览器直接打开; 或用到a链接的href属性中;
(2) 作为img标签的src属性值: <img src="01.svg">; 可以直接显示到浏览器中;
(3) 代码直接嵌入html中;(后文多使用这种方式)
(4) 作为css背景
<div id=bg></div>
<style>
#bg{background:black url(00_1.svg) repeat;
	width:400px;
	height:400px;
}
</style>

(5) [不推荐] 使用 embed/object/iframe 标签
<embed src="circle1.svg" type="image/svg+xml" />
<object data="circle1.svg" type="image/svg+xml"></object>
<iframe src="circle1.svg"></iframe>
其中 object标签不允许使用脚本。





========================================
|-- js基本操作API
----------------------------------------
(1)创建图形
document.createElementNS(namespace, tagName);
(2)添加图形
element.appendChild(childElement);
(3)设置/获取属性
element.setAttribute(name, value);
element.getAttribute(name);


实例:
<script>
var ns="http://www.w3.org/2000/svg";//命名空间
//创建svg标签
var svg=document.createElementNS(ns, 'svg');
//设置属性
svg.setAttribute('xmlns',ns);
svg.setAttribute('version',"1.1");
svg.setAttribute('fill',"black");  //不起作用
svg.setAttribute('width',"400");
svg.setAttribute('height',"400");
//添加到body末尾
document.body.append(svg);

//创建圆形circle
var c1=document.createElementNS(ns, 'circle');
c1.setAttribute('cx',"200");
c1.setAttribute('cy',"200");
c1.setAttribute('r',"200");
c1.setAttribute('fill',"yellow");
//添加到svg标签中
svg.appendChild(c1);
</script>






========================================
SVG 6个形状(rect /circle /ellipse /line /polyline /polygon)
----------------------------------------
矩形 rect: 左上角坐标(x,y), width,height, 可选圆角(rx,ry); 如果rx和ry只给一个，则默认为两个相等；
圆形 circle:圆心(cx,cy), 半径r;
椭圆 elipse:cx,cy, rx,ry;
线段 line: x1,y1, x2,y2;
折线 polyline: poiints x1,y1 x2,y2, ...;
多边形 polygon: points x1,y1 x2,y2, ...;和折线一样，只是最后是封闭图形；



1. 填充原则 fill-rule: nonzero | evenodd | inherit
非零环绕原则，奇偶原则
https://www.jianshu.com/p/d4b8b5d931df
https://www.runoob.com/svg/svg-polygon.html

(1)非零环绕原则 
是用来判断哪些区域属于路径内( 计算结果非0，即为路径内 )。
* 在路径包围的区域中，随便找一点，向外发射一条射线，和所有围绕它的边相交，
* 然后开启一个计数器，从0计数，
* 如果这个射线遇到顺时针围绕，那么+1，
* 如果遇到逆时针围绕，那么-1，
* 如果最终值非0，则这块区域在路径内。

(2)奇偶原则 
在路径包围的区域中，随便找一点，向外发射一条射线，和所有围绕它的边相交，查看相交线的个数，如果为奇数，就填充，如果是偶数，就不填充。








2. 基本形状实例
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
SVG形状元素: 矩形 <rect> / 圆形 <circle> / 椭圆 <ellipse> / 线 <line> / 折线 <polyline> /多边形 <polygon> /路径 <path><br>

<h3>矩形 rect width height</h3>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <rect width="300" height="100"
  style="fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)"/>
</svg>
<hr>

<h3>矩形: 定义左上角位置(x,y), 填充不透明度和描边不透明度</h3>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <rect x="50" y="20" width="150" height="150"
  style="fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;
  stroke-opacity:0.9"/>
</svg>
<p>也可以定义整个元素的的不透明度: opacity:0.5;</p>
<hr>


<h3>圆角矩形 rect rx ry width height</h3>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <rect x="50" y="20" rx="20" ry="20" width="150" height="150"
  style="fill:red;stroke:black;stroke-width:5;opacity:0.5"/>
</svg>
<p>rx 和 ry 属性可使矩形产生圆角。</p>
<hr>




<h3>圆 circle cx cy r</h3>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="100" cy="50" r="40" stroke="black"
  stroke-width="2" fill="red"/>
</svg>
<p>cx和cy属性定义圆点的x和y坐标。如果省略cx和cy，圆的中心会被设置为(0, 0)</p>
<p>r属性定义圆的半径</p>
<hr>



<h3>椭圆 ellipse cx cy rx ry</h3>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <ellipse cx="150" cy="80" rx="100" ry="50"
  style="fill:yellow;stroke:purple;stroke-width:2"/>
</svg>

<h4>三个重叠的椭圆</h4>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <ellipse cx="140" cy="100" rx="120" ry="30" style="fill:purple"/>
  <ellipse cx="120" cy="70" rx="90" ry="20" style="fill:lime"/>
  <ellipse cx="110" cy="45" rx="70" ry="15" style="fill:yellow"/>
</svg>


<h4>组合2个椭圆</h4>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <ellipse cx="140" cy="50" rx="120" ry="30" style="fill:yellow"/>
  <ellipse cx="140" cy="50" rx="100" ry="20" style="fill:white"/>
</svg>
<hr>


<h3>直线 line x1 y1 x2 y2</h3>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <line x1="0" y1="0" x2="200" y2="200"
  style="stroke:rgb(255,0,0);stroke-width:5"/>
</svg>
<hr>


<h3>多边形 polygon points</h3>
<svg  height="210" width="500">
  <polygon points="200,10 250,190 160,210 10,100"
  style="fill:lime;stroke:purple;stroke-width:1"/>
</svg>

<h4>五角星 填充方式: 非零环绕原则 fill-rule:nonzero;</h4>
<svg height="210" width="500">
  <polygon points="100,10 40,198 190,78 10,78 160,198"
  style="fill:yellow;stroke:red;stroke-width:5;fill-rule:nonzero;" />
</svg>

<h4>五角星 填充方式: 奇偶原则 fill-rule:evenodd</h4>
<svg height="210" width="500">
  <polygon points="100,10 40,198 190,78 10,78 160,198"
  style="fill:yellow;stroke:red;stroke-width:5;fill-rule:evenodd;" />
</svg>
<hr>




<h3>曲线 polyline points</h3>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <polyline points="20,20 40,25 60,40 80,120 120,140 140,80 120,100"
  style="fill:none;stroke:black;stroke-width:3" />
</svg>

<h4>台阶</h4>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <polyline points="0,40 40,40 40,80 80,80 80,120 120,120 120,160" style="fill:white;stroke:red;stroke-width:4" />
</svg>
<hr>







========================================
路径 path: 最灵活的绘图命令
----------------------------------------
强大的绘图工具，使用path可以绘制任何图形。
规范: http://www.w3.org/TR/SVG11/paths.html
由命令及其参数组成的字符串，
<path d="M0,0L10,20C30-10,40,20,100,100" stroke="red" />


1. SVG 路径 - <path>
<path> 元素用于定义一个路径。

下面的命令可用于路径数据：
M = moveto: M(x,y) 移动到当前位置
L = lineto: L(x,y) 从当前位置绘制线段到指定位置;
H = horizontal lineto: H(x) 从当前位置绘制水平线到x位置;
V = vertical lineto: V(x) 从当前位置绘制垂直线段到指定位置;
C = curveto 三次贝塞尔曲线: C(x1,y1, x2,y2, x,y)从当前位置绘制三次贝塞尔曲线到(x,y)，其中2个控制点为(x1,y1)(x2,y2);
S = smooth curveto: S(x2,y2, x,y) 光滑三次内塞尔曲线，就是2个控制点对称；
Q = quadratic Bézier curve 从当前位置绘制二次方贝塞尔曲线到指定位置: Q(x1,y1, x,y) 1个控制点为(x1,y1)
T = smooth quadratic Bézier curveto:T(x,y) 光滑二次贝塞尔曲线;
A = elliptical Arc: A(rx,ry, laf, sf, x,y) 从当前位置绘制弧线到指定位置;
Z = closepath 闭合路径;

注意：
- 以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。
- 最后的参数表示最终要到达的位置; 上一个命令结束的位置，就是下一个命令开始的位置;
- 命令可以重复参数表示重复执行同一个命令;??

- 移动命令M指定初始位置；
- 直线命令 L,H,V，相应的小写表示用相对位置绘制；




2. Path命令绘图练习demo: 
- 使用js控制台的set()自定义函数连续绘制;
- 刷新页面则重新初始化;
- 使用页面的编辑区，则替换原绘图命令;

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
path 详解 _2<br>
<style>
svg{border:1px dashed #eee;}
#cmdBox{width:100%; height:50px;}
.hint{color:#d00; margin-top:-2px;}
</style>
<svg id="svg1" width="100%" height="450" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<path d="M100 100" style="fill:none;stroke:red;stroke-width:2"/>
</svg>

<textarea id="cmdBox">M200 200 h100 l-100 100 v-100 M300 200 A 100 100 0 0 1 200 300</textarea>
<p class=hint>ctrl+enter提交</p>

<script>
function $(s){return document.getElementById(s);}
var svg=document.getElementById('svg1')
var path=svg.getElementsByTagName('path')[0];
function set(text){
	var dText=path.getAttribute('d');
	var text=text||"M 0 0 c 12 13  100 120 160 107";
	path.setAttribute('d', dText+text)
}
//set('l 100,20 h100 v100 h-100 c 0,250 200,-250 200,0')

$('cmdBox').onkeydown=function(e){
	wjl=e;
	if(e.code=="Enter" && e.ctrlKey==true){
		e.preventDefault();//不会换行
		console.log('text: ',cmdBox.value)
		//set(cmdBox.value);
		path.setAttribute('d', cmdBox.value)
	}
}
</script>









========================================
|-- 圆弧(弧线)命令 - 最复杂的命令，有7个参数 A(rx,ry, xr,laf,sf, x,y)
----------------------------------------
1. A(rx,ry, xr,laf,sf, x,y) 取自于椭圆的一部分，允许旋转;
- rx,ry 椭圆的半轴长度 radius-x,radius-y;
- xr(xAxis-rotation)弧线所在椭圆的长轴角度;
- laf(large-arc-flag) 是否选择弧长较长的那一段弧?
- sf(sweep-flag) 是否选择顺时针方向的的那一段弧?
- x,y 弧线的终点位置;



2. 难点
对任意2点，经过2点的椭圆可以有2个，那么连接起始点的弧线就有4个，取哪一个呢?
这就需要 laf(大弧优先吗?)和sf(逆时针吗?)参数了。

使用2中的demo进行测试: 

起点(M或者上一个命令的结束位置)在左，终点(A命令最后2个参数)在右时:
laf=0,sf=1 取小弧，取顺时针那段;(内 上)
laf=0,sf=0 取小弧，取拟时针那段;(内 下)

laf=1,sf=1 取大弧，取顺时针那段;(外 上)
laf=1,sf=0 取大弧，取顺时针那段;(外 下)

1)M 100 100 A 100 50 0 0 1 200 100
2)M 100 100 A 100 50 0 0 0 200 100
3)M 100 100 A 100 50 0 1 1 200 100
4)M 100 100 A 100 50 0 1 0 200 100


3. 实例 
<style>
svg{border:1px dashed #eee;}
#cmdBox{width:100%; height:50px;}
.hint{color:#d00; margin-top:-2px;}
</style>
<svg id="svg1" width="100%" height="450" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<circle cx="100" cy="100" r="3" />
	<circle cx="200" cy="100" r="3" />
	<path d="M100 100" style="fill:none;stroke:red;stroke-width:2"/>
	
	<path d="M 100 100 A 100 50 0 0 1 200 100" style="fill:none;stroke:#eeeeee;stroke-width:1"/>
	<path d="M 100 100 A 100 50 0 0 0 200 100" style="fill:none;stroke:#eeeeee;stroke-width:1"/>
	<path d="M 100 100 A 100 50 0 1 1 200 100" style="fill:none;stroke:#eeeeee;stroke-width:1"/>
	<path d="M 100 100 A 100 50 0 1 0 200 100" style="fill:none;stroke:#eeeeee;stroke-width:1"/>
</svg>

<textarea id="cmdBox">M 100 100 A 100 50 0 0 1 200 100</textarea>
<p class=hint>ctrl+enter提交</p>

<script>
function $(s){return document.getElementById(s);}
var svg=document.getElementById('svg1')
var path=svg.getElementsByTagName('path')[0];
function set(text){
	var dText=path.getAttribute('d');
	var text=text||"M 0 0 c 12 13  100 120 160 107";
	path.setAttribute('d', dText+text)
}
//set('l 100,20 h100 v100 h-100 c 0,250 200,-250 200,0')

$('cmdBox').onkeydown=function(e){
	wjl=e;
	if(e.code=="Enter" && e.ctrlKey==true){
		e.preventDefault();//不会换行
		console.log('text: ',cmdBox.value)
		//set(cmdBox.value);
		path.setAttribute('d', cmdBox.value)
	}
}
</script>









========================================
|-- 贝塞尔曲线原理和画法: 两次Q/ T(光滑) ["切图组合"]，三次 C/ S(光滑) ["厕所组合"]
----------------------------------------
贝塞尔简介 参考: https://www.zhangxinxu.com/wordpress/2014/06/deep-understand-svg-path-bezier-curves-command/


1. SVG的4个贝塞尔曲线命令:
两次 Q, T(平滑化)
三次 C, S(平滑化)

graphic.duapp.com/path-editor.html 

(1) Q二次贝塞尔曲线: M x0 y0 Q x1 y1 x y, 其中x1 y1为控制点
M300 200 l-100 100 M300 200 Q 500 300 200 300

(2) C三次贝塞尔曲线: M x0,y0 C x1,y1 x2,y2, x,y,其中 x1,y1和 x2,y2 是控制点;
M300 200 l-100 100 M300 200 C 500,300 400,400 200 300
M300 200 l-100 100 M300 200 C 500,200 400,500 200 300 #控制点更分散，则曲线更分撒


如果使用相坐标置则是（后面不展示）：
c dx1 dy1, dx2 dy2, dx dy
例子:#使用相对坐标(相对作图起始点，就是上一个命令的结束点)
M300 200 l-100 100 M300 200 c 200,0 100,300 -100 100 



(3)T: Q的光滑版本 T x,y
C1是上一段曲线的控制点1关于当前曲线起始点的镜像位置;

例子:(使用时去掉注释)
M 100,200 Q100,100 250,200 #第一段2次贝塞尔曲线
T 400,200 #第二段2次贝塞尔曲线，控制点关于起点对称



(4)S: C的光滑版本 S x2,y2, x,y 一般要和S配合使用！
C1是上一段曲线的控制点2关于当前曲线起始点的镜像位置;

例子:(使用时去掉注释)
M 100,200 C100,100 250,100 250,200 #第一段曲线
S 400,300 400,200 #第二段曲线
#相当于指定控制点2，控制点1则为上一个曲线的控制点2关于当前曲线起始点的镜像点;

例子2: 如果前面没有三次贝塞尔曲线(也就是没有C或S)，则S退化为2次贝塞尔曲线
M300 200  Q 500 300 200 300 S 500 500 500 300
M200 300 S 500 500 500 300







############
2. 贝塞尔曲线

<h3>path 命令</h3>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
    <path d="M150 0 L75 200 L225 200 Z" />
</svg>

<h4>二次方贝塞尔曲线，A 和 C 分别是起点和终点，B 是控制点：</h4>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="500" height="400">
  <path id="lineAB" d="M 100 350 l 150 -300" stroke="red" stroke-width="3" fill="none" />
  <path id="lineBC" d="M 250 50 l 150 300" stroke="red" stroke-width="3" fill="none" />
  <path d="M 175 200 l 150 0" stroke="green" stroke-width="3" fill="none" />
  <path d="M 100 350 q 150 -300 300 0" stroke="blue" stroke-width="5" fill="none" />
  <!-- Mark relevant points -->
  <g stroke="black" stroke-width="3" fill="black">
    <circle id="pointA" cx="100" cy="350" r="3" />
    <circle id="pointB" cx="250" cy="50" r="3" />
    <circle id="pointC" cx="400" cy="350" r="3" />
  </g>
  <!-- Label the points -->
  <g font-size="30" font="sans-serif" fill="black" stroke="none" text-anchor="middle">
    <text x="100" y="350" dx="-30">A</text>
    <text x="250" y="50" dy="-10">B</text>
    <text x="400" y="350" dx="30">C</text>
  </g>
</svg>






========================================
SVG 基本属性(fill, stroke, stroke-width)
----------------------------------------
4. SVG基本属性(fill, stroke, stroke-width, transform[在坐标中详解])
(1)fill是填充

(2)stroke属性
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
stroke 描边属性<br>

<pre>
SVG提供了一个范围广泛stroke 属性。在本章中，我们将看看下面：

stroke
stroke-width
stroke-linecap
stroke-dasharray
所有stroke属性，可应用于任何种类的线条，文字和元素就像一个圆的轮廓。
</pre>


<h3>stroke控制颜色，stroke-width线宽度</h3>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <g fill="none" stroke-width="10">
    <path stroke="red" d="M5 20 l215 0" stroke-width="5" />
    <path stroke="blue" d="M5 40 l215 0"/>
    <path stroke="black" d="M5 60 l215 0" />
  </g>
</svg>



<h3>stroke-linecap</h3>
<svg xmlns="http://www.w3.org/">
	<g fill="none" stroke="black" stroke-width="10">
		<path d="M5 2 l215 0" stroke="grey" />
		<path stroke-linecap="butt" d="M5 20 l215 0" />
		<path stroke-linecap="round" d="M5 40 l215 0" />
		<path stroke-linecap="square" d="M5 60 l215 0" />
	</g>
</svg>



<h3>stroke-dasharray</h3>
<svg xmlns="http://www.w3.org/">
	<g fill="none" stroke="black" stroke-width="5">
		<path stroke-dasharray="5,5" d="M5 20 l215 0" />
		<path stroke-dasharray="10,10" d="M5 40 l215 0" />
		<path stroke-dasharray="20,10,5,5,5,10" d="M5 60 l215 0" />
	</g>
</svg>





========================================
svg 坐标系统 ——1. 世界、视野、视窗
----------------------------------------
(1)世界: 无穷大; svg代码定义;
(2)视窗: svg的width-height属性; 也可以使用css定义;
(3)视野 viewBox, preserveAspectRatio: 观察世界的矩形区域;
视野和视窗默认是一致的，如果设置的大小不一致，则使用preserveAspectRatio指定的策略可视化;

<svg xmlns="" 
	width="800" height="600" 
	viewBox="0 0 400 300" 
	preserveAspectRatio="xMidYMid meet">
</svg>
preserveAspectRatio属性 有2个值组合而成，
第一个是 xMaxYMid,xMidYMin类似的x[]Y[]，[]中可以是max、mid、min;
第二个是 meet, slace;




实例:
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
viewBox 世界、视野、视窗<br>

<style>
svg{border:1px dashed blue;}
p{border:1px solid #ddd; padding:10px;}
#ctrl1 input{width:70px;}
</style>

<pre> svg: width 400, height 300; </pre>
<p id=ctrl1> 视野viewBox: 
	x<input type="number" name=x value="0">, 
	y<input type="number" name=y value="0">, 
	width<input type="number" name=width value="400">, 
	height<input type="number" name=height value="300">, 
</p>
<p id=ctrl2>
	比例preserveAspectRatio:
	align: <select name="align">
		<option value="none">none</option>
		<option value="xMidYMid" selected>xMidYMid</option>
		<option value="xMaxYMid">xMaxYMid</option>
		<option value="xMinYMid">xMinYMid</option>
		
		<option value="xMidYMin">xMidYMin</option>
		<option value="xMaxYMin">xMaxYMin</option>
		<option value="xMinYMin">xMinYMin</option>
		
		<option value="xMidYMax">xMidYMax</option>
		<option value="xMaxYMax">xMaxYMax</option>
		<option value="xMinYMax">xMinYMax</option>
	</select>, 
	meetOrSlice: <select name="meetOrSlice">
		<option value="meet">meet</option>
		<option value="slice">slice</option>
	</select>, 
</p>


<svg id=svg1 xmlns="" version="1.1" 
	viewBox="0 0 400 300" 
	width="400" height="300">
	<rect x="0" y="0" width="400" height="300" stroke="red" stroke-width="5" fill="#dddddd" />
	<circle cx="30" cy="100" r="30" fill="red"/>
	<circle cx="100" cy="100" r="40" fill="yellow"/>
	<circle cx="200" cy="100" r="50" fill="blue"/>
	<circle cx="300" cy="100" r="60" fill="orange"/>
</svg>

<pre>
结论:
1. viewBox视野，x增大则镜头右移动(世界物体左移)，y增大则镜头向下移动(世界物体上移)；

2. 宽高就相当于摄像头，小于svg的宽高，则放大显示；大于svg的宽高，则缩小显示；
3. 长宽比不一致的时候，
1) align=none时，按照视野显示，不顾长宽比;
2) align=xMinYMin时，(视野和视窗的)x的最小值对齐，y的最小值对齐，
但是x还是y对齐生效呢？取决于(视野和视窗的)长宽比。
3) 放大时(就是视野小于视窗)，meet或slice没区别;
缩小时(视野小于视窗)，有区别;

</pre>


<script>
//tools
function $(s){return document.getElementById(s);}

//添加事件
var aInput=document.getElementsByTagName('input');
for(var i=0;i<aInput.length;i++){
	var oInput=aInput[i];
	oInput.onchange=update;
}
var aSelect=document.getElementsByTagName('select');
aSelect[0].onchange=update;
aSelect[1].onchange=update;
//更新
function update(){
	//console.log('update now;');
	//input
	var aCtrl1=$('ctrl1').getElementsByTagName('input');
	var x=aCtrl1[0].value, y=aCtrl1[1].value, width=aCtrl1[2].value, height=aCtrl1[3].value;
	var svg=$('svg1');
	svg.setAttribute('viewBox', [x,y,width,height].join(' '));
	//select 
	var oCtrl2=$('ctrl2'), aCtrl2=oCtrl2.getElementsByTagName('select');
	svg.setAttribute("preserveAspectRatio", aCtrl2[0].value+' '+aCtrl2[1].value);
}
update();
</script>






========================================
|-- 坐标变换transform: g标签(逻辑分组、设置公共属性)和坐标系统(4个坐标系)
----------------------------------------
1. transform属性描述了坐标变换
transform="rotate(30)"; 旋转，是角度制，不是弧度制;
transform="translate(50, 100)"; 移动 原点到(50,100)
transform="scale(2,2)"; 放大 为原来的2倍(可以对x和y分别设置放大倍数);

变换矩阵 matrix(a,b,c,d,e,f)


(1)可以多次变换，用逗号隔开: transform="translate(100,100),rotate(-30)"
<rect x="0" y="0" width="20" height="120"  transform="scale(2)" fill="rgba(255,0,0,0.2)" />


(2)rotate用来使目标对象绕一点旋转一定的角度。
rotate的格式：rotate([angle] [px,py])
参数介绍：
	[angle] : 旋转角度。 由于屏幕坐标和数学坐标的Y轴相反，所以向左旋转为正角度值。
	[px,py] : 旋转的中心点。参数缺省默认为圆点（0,0）。
#





2.分组示例，可以在分组g标签内设置公共属性，
如果想整体移动，则需要设置 transform属性，该属性牵涉到坐标系概念。
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
group 分组<br>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width=400 height=400>
	<g fill="red" transform="translate(0,10)">
	  <rect x="100" y="50" width="100" height="50" />
	  <rect x="140" y="100" width="20" height="120" />
	</g>
</svg>




3. 坐标系概述
(1)笛卡尔直角坐标系;原点;互相垂直的数轴;y轴向下;角度是从x正方向到y正方向的方向为正角度；

(2)四个坐标系
1) 用户坐标系(user coordinate)
	世界的坐标系
- 比如svg属性 视窗viewBox="0 0 200 150"指的就是用户坐标系，是最原始的，也叫原始坐标系；

2) 自身坐标系(current coordinate)
	每个图形元素或分组独立与生俱来; 比如 rect自身的width和height就是相对于自身的坐标给出的长度值;
3) 前驱坐标系(previous coordinate)
	父容器的坐标系;
# 自身坐标系和前驱坐标系要对照着理解，
# 如果对子元素做坐标变换，则自身坐标系是相对于前驱坐标系做变换后得到的坐标系。

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
transform 坐标变换<br>
<style>
svg{padding:0; margin:0; border:1px dashed #f00;}
</style>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width=400 height=400>
	<rect x="100" y="100" width="300" height="300" fill="#eeeeee" stroke="grey"/>
	<rect x="0" y="0" width="20" height="120" fill="none" stroke="black"/>
	
	<rect x="0" y="0" width="20" height="120"  transform="translate(100,100),rotate(-30)" fill="black" />
	<rect x="0" y="0" width="20" height="120"  transform="rotate(-30),translate(100,100)" fill="red" />
</svg>

<pre>
1.左上角黑框为原始矩形;
2.中间灰色方框为移动后的坐标系;
3. 黑矩形为先移动原点，再旋转-30度;
4. 红矩形为先旋转-30度，再移动原点到100,,100;
每次坐标变换是以前一次为基准的;
</pre>



4) 参考坐标系(reference coordinate)
	使用其他坐标系来考究自身的情况时使用;
# 只是为了观察，逻辑上存在，用于推导，但是不用于设置.




4. 坐标变换 
(1)定义: 数学定义
线性变换方程 
X'=aX+cY+e;
Y'=bX+dY+f;
则变换矩阵，记为M
[a c e,
b d f,
0 0 1]

(2)平移示例
M=
1 0 10
0 1 10
0 0 1
则新坐标
X'=1*X+0*Y+10=X+10;
Y'=0*X+1*Y+10=Y+10;
表示坐标原点移动到(-10,-10)

(3)旋转示例
使用极坐标求变换矩阵
X=r*cos(a);
Y=r*sin(a);

旋转theta角度:
X'=r*cos(a+t);
Y'=r*sin(a+t);


展开后得到:
X'=r*cos(a)*cos(t)-r*sin(a)*sin(t)=cos(t)*X-sin(t)*Y+0;
Y'=r*cos(a)*sin(t)+r*sin(t)*cos(t)=sin(t)*X+cos(t)*Y+0;
矩阵为
[cos(t) -sin(t) 0
sin(t) cos(t) 0
0 0 1]

比如旋转30度的变换矩阵为
[cos(30) -sin(30) 0
sin(30) cos(30) 0
0 0 1]


(4) 缩放a和c参数
比如M=
[2 0 0
0 2 0
0 0 1]
X'=2*X
Y'=2*Y


(5) 线性变换列表
表示一系列的变换，结果为变换的矩阵的乘积
M=Mn*M(n-1)*...*M2*M1*M0;
后面的变换乘在前面(这是线性代数的一个结论)

先渲染，再平移: 
M(translate)*M(rotate)=
[1 0 10
0 1 10
0 0 1]
点乘
[cos(30) -sin(30) 0
sin(30) cos(30) 0
0 0 1]

(6) 实例
前驱坐标系：父容器的坐标系;
transform属性: 定义前驱坐标系到自身坐标系的线性变换;


前面三个最开始已经讲过，这里只说 matrix();
<rect x="0" y="0" width="20" height="120" fill="none" stroke="black"/>
<rect x="0" y="0" width="20" height="120"  transform="matrix(0.5,0,0,0.5,100,100)" fill="rgba(255,255,0,0.4)" />
# 淡黄色的矩形为缩小为原来的1/2，同时移动(100,100)后;


(7) 实例2
viewBox="-200.5 -100.5 1000 600" #tips: 定位加上0.5则对齐到整数的1px线条会比较锐利，这是浏览器渲染1px的小技巧;




========================================
|-- 分组元素: <g>、<defs>、<symbol>和<use>
----------------------------------------
1.g是group（分组）的缩写。
<g>元素通常用来对相关图形元素进行分组，以便统一操作，比如旋转，缩放或者添加相关样式等。


2. <use>实现SVG现有图形的重用，可以重用单个SVG图形元素，也可以重用<g>定义的组元素。

分析:
（1）<g>元素可以直接显示。
（2）<use>元素可以使用xlink:href属性（属性值是#+g元素id）多次引用<g>元素。
（3）被引用后创建的新元素是最初元素的一个副本；新元素会继承最初元素的样式、旋转、缩放等特性。
（4）不能在新元素中覆盖初始元素的样式（例如描边和填充）。
（5）x和y属性规定新元素的坐标原点。

最后一点:
<use id="one" x="0" y="110" xlink:href="#group" />
等同于:
<use id="one" transform="translate(0, 110)" xlink:href="#group" />




3.<defs>重用已存储元素:
<defs>可以定义我们不想直接显示的内容。
<g>分组定义的内容直接会显示，所以<defs>在使用的时候会有更大的灵活性。

<g>和<defs>定义的图形元素的样式在被重用的新元素中都是无法被改变的；由于<g>中的内容会直接显示，通常需要给元素一些样式，所以会对应用带来一些障碍；<defs>内部定义的元素不会直接显示，可以不用事先定义样式，而是在使用<use>实例化的时候再定义。

与<g>一个明显的区别是，<use>引用的是内部元素的id。
可以认为<defs>是为了定义初始不可见且可重用的元件，而<g>是一个初始可见且本身就是一个元件（当然具有分组功能）。



4.<symbol>元素的使用:
<symbol>兼具<g>的分组功能和<defs>初始不可见的特性。
<symbol>能够创建自己的视窗，所以能够应用viewBox和preserveAspectRatio属性。//todo

实例 
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600">
	<symbol id="symbol" viewBox="-10 -10 200 200">
		<rect x="0" y="0" width="250" height="250" fill="rgba(255,0,0,0.1)"/>
		<circle cx="0" cy="0" r="5" fill="black" opacity="0.3" />
		<rect x="45" y="55" width="100" height="100" fill-opacity="0.8" />
	</symbol>
	
	<line x1="0" y1="110" x2="900" y2="110" stroke="#eee" />
	<line x1="90" y1="0" x2="90" y2="900" stroke="#eee" />
	
	<!--边长为100的长方形，因为symbol定义了viewBox，所以缩放了-->
	<use fill="red" transform="translate(0 50) rotate(15)" xlink:href="#symbol" />
	<use fill="orange" transform="translate(250 50) rotate(15)" xlink:href="#symbol" />
	
	<!--定义边长为100的正方形-->
	<rect fill="blue" x="90" y="110" width="100" height="100"
		  transform="rotate(10 0 110)"
		  fill-opacity="0.5" />
</svg>






========================================
颜色(HSL颜色、透明度)、渐变(线性渐变、径向渐变)
----------------------------------------
1.RGB和HSL色彩
(1)RGB(255,255,255) 显示硬件就是使用该设置显示的，但是不适合人类直观修改;

(2)HSL(h, s%, L%) 符合人类对颜色的表述;
取值范围:
hue:[0-359] 色环柱的一周,0红色,120绿色,240是蓝色;
saturation:饱和度 [0,100] 色环柱从内到外,中心0退化为灰度，最外侧100%最饱和，最鲜艳;
lightness:亮度 [0,100] 色环柱从下到上，最底部0是黑色，100%是白色，如果是0或100，则无论h和s取什么值都是黑色或者白色;
常规颜色取50%亮度。

比如颜色 
hsl(9,100%,42%) 原始;
hsl(9,100%,65%) 亮一点;
hsl(9,77%,65%) 淡一点;
hsl(26,77%,65%) 偏黄一点;

配色应用示例: http://paletton.com/
基于HSL的配色方案，一般是比较和谐的。



2. 透明度
直接使用rgba(r,g,b,a)或者hsla(h,s%,l%,a)表示带透明度的颜色, 
或者使用opacity属性表示元素的透明度;

a和opacity取值范围[0,1]

示例
<rect x="160" y="0" width="50" height="100" fill="rgb(255,0,0)" opacity="0.5" />
<rect x="180" y="20" width="150" height="50" fill="rgba(0,255,0,0.5)" />



3.渐变
(1)线性渐变 <linearGradient> <stop>
定义方向:
关键点位置和颜色:
gradientUnits:

比如矩形从左上角到右下角的线性渐变:
左上角0%位置 蓝色, 右下角100%位置红色;

默认单位 gradientUnits="objectBoundingBox"是按照图形的百分比来定义的，起始位置是0，终止位置是100%；
单位另一个取值是 userSpaceOnUse，则使用世界坐标系。

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
linearGradient 线性渐变<br>
<style>svg{border:1px dashed #aaa;}</style>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="200" width="800">
	<defs>
		<!--默认单位：整个图形作为100%-->
		<linearGradient id="grd1" x1="0" y1="0" x2="1" y2="1"  gradientUnits="objectBoundingBox">
			<stop offset="0" stop-color="#1497fc" />
			<stop offset="0.5" stop-color="#a469be" />
			<stop offset="1" stop-color="#ff8c00" />
		</linearGradient>
		<linearGradient id="grd2" x1="200" y1="50" x2="500" y2="200"  gradientUnits="userSpaceOnUse">
			<stop offset="0" stop-color="#1497fc" />
			<stop offset="0.5" stop-color="#a469be" />
			<stop offset="1" stop-color="#ff8c00" />
		</linearGradient>
	</defs>
	<rect x="10" y="50" width="200" height="100" fill="url(#grd1)" />
	
	<rect x="300" y="50" width="200" height="100" fill="url(#grd2)"  opacity="0.8"/>
	<rect x="400" y="70" width="200" height="100" fill="url(#grd2)"  opacity="0.8"/>
</svg>



(2)径向渐变
<radialGradient>和<stop>
定义方向
关键点位置和颜色
gradientUnits
焦点位置

和线性渐变不同的2点:
 - 需要定义r，表示渐变走向终点的距离;
 - 焦点位置fx,fy，该位置有一个聚光灯效果;

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
radialGradient 径向渐变<br>
<style>svg{border:1px dashed #aaa;}</style>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="400" width="800">
	<defs>
		<!--默认单位：整个图形作为100%; fx,fy是焦点位置-->
		<radialGradient id="grd1" cx="0.5" cy="0.5" r="0.6" fx="0.9" fy="0.3"  gradientUnits="objectBoundingBox">
			<stop offset="0" stop-color="#1497fc" />
			<stop offset="0.5" stop-color="#a469be" />
			<stop offset="1" stop-color="#ff8c00" />
		</radialGradient>
		<!-- 世界坐标为单位 -->
		<radialGradient id="grd2" cx="500" cy="150" r="150" fx="400" fy="200"  gradientUnits="userSpaceOnUse">
			<stop offset="0" stop-color="#1497fc" />
			<stop offset="0.5" stop-color="#a469be" />
			<stop offset="1" stop-color="#ff8c00" />
		</radialGradient>
	</defs>
	<rect x="10" y="50" width="200" height="200" fill="url(#grd1)" />
	
	<rect x="300" y="50" width="200" height="200" fill="url(#grd2)"  opacity="0.8"/>
	<rect x="400" y="70" width="200" height="200" fill="url(#grd2)"  opacity="0.8"/>
</svg>






========================================
|-- pattern标签: 笔刷(使用预定义图形填充，比如方格背景)
----------------------------------------
1.笔刷: 绘制纹理(来填充), <pattern>标签
难点是2单位的设置:
(1)patternUnits属性: 指定图形本身宽高的意义;
objectBoundingBox(默认):为容器的百分比; 宽为一行填充几个，高为一列填充几个; 挤压时会有部分不显示，拉伸时会有空白。

userSpaceOnUse: 宽高为世界坐标系为准；一个挨着一个，没有缩放;

(2)patternCotentUnits: 指定pattern宽高的意义。
userSpaceOnUse(默认):按世界坐标系;
objectBoundingBox: 按照容器百分比绘制子元素;

一般 patternCotentUnits="objectBoundingBox" 时，patternUnits也设置为"objectBoundingBox"比较好处理.



目前没有测试出这两个属性的组合具体差异？ //todo


<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="1000" width="800">
	<defs>
		<!-- 笔刷内部可以是任意图形；-->
		<!--默认单位 是比例，表示横着填充5个，竖着填充4个 -->
		<pattern id="p1" x="0" y="0" width="0.2" height="0.25">
			<circle cx="10" cy="10" r="5" fill="red" />
			<polygon points="30,10 60,50 0,50" fill="green" />
		</pattern>
		
		<!--修改单位2: patternUnits="userSpaceOnUse" 变成世界坐标系，图形填充不会缩放了-->
		<pattern id="p2" x="0" y="0" width="60" height="50" patternUnits="userSpaceOnUse">
			<circle cx="10" cy="10" r="5" fill="red" />
			<polygon points="30,10 60,50 0,50" fill="green" />
		</pattern>
	</defs>
	
	<rect x="10" y="10" width="200" height="150" fill="url(#p1)" stroke="red"/>
	<rect x="300" y="10" width="400" height="200" fill="url(#p1)"  opacity="0.8"/>
	
	<rect x="10" y="250" width="200" height="150" fill="url(#p2)" stroke="orange"/>
	<rect x="300" y="250" width="400" height="200" fill="url(#p2)"  opacity="0.8"/>
</svg>






2. 方格子背景效果
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
brush 笔刷-绘制纹理: 格子背景<br>
<style>svg{border:1px dashed #aaa;}</style>

<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="800" width="800">
	<defs>
		<!-- 格子背景笔刷 -->
		<!-- 方格1 普通版 20px一个格子 -->
		<pattern id="p1" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
			<path d="M0,0 V20H20" stroke="lightgreen" fill="none" />
		</pattern>
		
		<!-- 方格2 加强版 20px一个小格子，100px一个大格子 -->
		<pattern id="p2" x="0" y="0" width="100" height="100" patternUnits="userSpaceOnUse">
			<path d="M0,20h100 M0,40h100 M0,60h100 M0,80h100" stroke="#ddd" fill="none" />
			<path d="M20,0v100 M40,0v100 M60,0v100 M80,0v100" stroke="#ddd" fill="none" />
			<path d="M0,0 V100H100" stroke="#ddd" fill="none" stroke-width="5" />
		</pattern>
	</defs>
	
	<rect x="0" y="0" width="700" height="200" fill="url(#p1)" stroke="none"/>
	<rect x="0.5" y="299.5" width="700" height="400" fill="url(#p2)" stroke="none"/>
</svg>




========================================
|-- filter 标签: 滤镜(高斯模糊等)
----------------------------------------
https://www.softwhy.com/article-10173-1.html
https://www.w3school.com.cn/svg/svg_filters_gaussian.asp

1.滤镜是SVG中最强大的功能之一，css3中也是如此，不借助专业的图形软件就可以绘制出强大的效果。

<filter>元素包含很多滤镜基元操作，每个基元操作在传入的对象上执行一个基本的图形操作，并产生图形输出。

大多数的基元操作生成的结果基本都是RGBA图片，总体来讲，<filter>作用就是对引用它的图形元素或者容器元素进行一系列的操作，产生一个新的图形来替代原来的图形。


在 SVG 中，可用的滤镜有：

feBlend - 与图像相结合的滤镜
feColorMatrix - 用于彩色滤光片转换
feComponentTransfer
feComposite
feConvolveMatrix
feDiffuseLighting
feDisplacementMap
feFlood
feGaussianBlur
feImage
feMerge
feMorphology
feOffset - 过滤阴影
feSpecularLighting
feTile
feTurbulence
feDistantLight - 用于照明过滤
fePointLight - 用于照明过滤
feSpotLight - 用于照明过滤
注释：您可以在每个 SVG 元素上使用多个滤镜！


2. 滤镜的使用

仅有<filter>元素是无法实现滤镜效果的，具体的滤镜效果是由它内部的滤镜基元来定义。

对<rect>应用滤镜效果，<feGaussianBlur>滤镜基元是具体滤镜效果生成的实际操作者，滤镜基元需要一个输入源，这个输入是由in属性规定，当然滤镜基元也可以有一个输出，由result属性来规定。

一个滤镜基元的输出可以作为另一个滤镜基元的输入。

(1)简单滤镜
<svg >
	<defs>
		<filter id="filter1">
			<feGaussianBlur in="SourceGraphic" stdDeviation="2" />
		</filter>
		
		<filter id="filter2">
			<feGaussianBlur in="SourceGraphic" stdDeviation="4" />
		</filter>
	</defs>
	
	<rect x="20" y="20" width="90" height="90" fill="blue" filter="url(#filter1)" />
	<rect x="150" y="20" width="90" height="90" fill="blue" filter="url(#filter2)" />	
</svg>



(2) 滤镜的组合: result属性规定一个滤镜的输出，可以用于下一个滤镜的输入in参数；
<svg>
	<defs>
		<filter id="filter2" y="0" x="0" width="3" height="2">
			<feOffset in="SourceGraphic" dx="10" dy="10" result="offset" />
			<feGaussianBlur in="offset" stdDeviation="3" result="blur" />
		</filter>
	</defs>

	<ellipse cx="80" cy="60" rx="50" ry="30" fill="none" stroke="red" />
	<ellipse cx="80" cy="60" rx="50" ry="30" fill="blue" filter="url(#filter2)"/>
</svg>




========================================
|-- feColorMatrix 滤镜 处理图像(png): 颜色的处理
----------------------------------------
使用矩阵来影响颜色的每个通道(基于RGBA): https://www.w3cplus.com/svg/finessing-fecolormatrix.html


1.输出图像:
<image x="0" y="0" width="400" height="400" xlink:href="../images/win7_H.png" filter="url(#green)" />
x,y定义左上角的位置；
宽高, 省略width和height属性，引入的图片将原图显示
xlink:href 图像路径
filter，可选，滤镜;


2.
(1) 滤镜的定义
<filter id="linear">
	<feColorMatrix type="matrix" 
		values="R 0 0 0 0 
				0 G 0 0 0 
				0 0 B 0 0 
				0 0 0 A 0 ">
	</feColorMatrix>
</filter>

(2)计算过程
矩阵计算RGBA自已每行的最终值，每个RGBA通道有自身的RGBA通道。最后一个值是一个乘数。最后RGBA的值从上向下读，像下面这个列表：

默认值:
/* R G B A 1 */
1 0 0 0 0 // R = 1*R + 0*G + 0*B + 0*A + 0
0 1 0 0 0 // G = 0*R + 1*G + 0*B + 0*A + 0
0 0 1 0 0 // B = 0*R + 0*G + 1*B + 0*A + 0
0 0 0 1 0 // A = 0*R + 0*G + 0*B + 1*A + 0

如果想得到一个 green colorized image:
0 0 0 0 0 // R = 0*R + 0*G + 0*B + 0*A + 0=0
0 1 0 0 0 // G = 0*R + 1*G + 0*B + 0*A + 0=G
0 0 0 0 0 // B = 0*R + 0*G + 0*B + 0*A + 0=0
0 0 0 1 0 // A = 0*R + 0*G + 0*B + 1*A + 0=A


3. 实例 
<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400">
	<filter id="green">
		<feColorMatrix type="matrix" 
			values="0 0 0 0 0 
					0 1 0 0 0 
					0 0 0 0 0 
					0 0 0 1 0 ">
		</feColorMatrix>
	</filter>
	
	<image x="0" y="0" width="100" xlink:href="../images/win7_H.png" filter="url(#green)" />
</svg>

按照定义，如下滤镜和上述效果一样
	<filter id="green_again">
		<feColorMatrix type="matrix" 
			values="0 0 0 0 0 
					0 1 0 0 0 
					0 0 1 -1 0 
					0 0 0 1 0 ">
		</feColorMatrix>
	</filter>
#



4. 更多颜色滤镜效果

(1)变深
	<!--深浅-->
	<filter id="darken">
		<feColorMatrix type="matrix" 
			values="0.5 0 0 0 0 
					0 0.5 0 0 0 
					0 0 0.5 0 0 
					0 0 0 1 0 ">
		</feColorMatrix>
	</filter>
	
	<filter id="lighter">
		<feColorMatrix type="matrix" 
			values="1.5 0 0 0 0 
					0 1.5 0 0 0 
					0 0 1.5 0 0 
					0 0 0 1 0 ">
		</feColorMatrix>
	</filter>
	
	<image x="200" y="0" width="90" xlink:href="../images/win7_H.png" filter="url(#darken)" />
	<image x="300" y="0" width="90" xlink:href="../images/win7_H.png" filter="url(#lighter)" />
#


(2)Blowing out channels
通过第四行的个人通道影响整个alpha通道，把绿色变成白色。
	<filter id="emit_green">
		<feColorMatrix type="matrix" 
			values="1 0 0 0 0 
					0 1 0 0 0 
					0 0 1 0 0 
					0 -2 0 1 0 ">
		</feColorMatrix>
	</filter>

(3)灰度图，想办法把rgb通道变得相等即可。
	<filter id="grey">
		<feColorMatrix type="matrix" 
			values="1 0 0 0 0 
					1 0 0 0 0 
					1 0 0 0 0 
					0 0 0 1 0 ">
		</feColorMatrix>
	</filter>

(4)组合色彩
	<filter id="lime">
		<feColorMatrix type="matrix" 
			values="1 0 0 0 0 
					0 2 0 0 0 
					1 0 0 0.5 0 
					0 0 0 1 0 ">
		</feColorMatrix>
	</filter>
	
	

========================================
文字: text和 tspan标签
----------------------------------------
1. 文字基础

(1)text 文本标签，属性 x,y表示位置,fill表示颜色
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="20">
	<text x="0" y="15" fill="red">I love SVG</text>
</svg>
<hr>


(2)旋转的文字，text标签的transform属性
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="80">
  <text x="0" y="15" fill="blue" transform="rotate(30 -30,40)">I love SVG</text>
</svg>


(3)沿着路径的文字, text子标签 textPath(属性xlink:href)
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink">
   <defs>
    <path id="path1" d="M25,10 a1,2 0 0,0 100,0" />
  </defs>
  <text x="10" y="100" style="fill:red;">
    <textPath xlink:href="#path1">I love SVG I love SVG</textPath>
  </text>
</svg>
<hr>

后文有标题详解。


(4) 分段的文字: text子标签 tspan
元素可以安排任何分小组与 tspan 元素的数量。每个 tspan 元素可以包含不同的格式和位置。几行文本(与 tspan元素):
<br>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <text x="10" y="20" style="fill:red;">Several lines:
    <tspan x="30" y="45" style="fill:lime">First line</tspan>
    <tspan x="50" y="90">Second line</tspan>
  </text>
</svg>
</hr>



(5)作为链接文字: text标签包在a标签内
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink">
  <a xlink:href="http://www.w3schools.com/svg/" target="_blank">
    <text x="0" y="15" fill="red">this is a link to w3c</text>
  </a>
</svg>







2. text的dx,dy属性，控制着文字的间距，如果tspan设置了该属性，则会被tspan的dx,dy属性覆盖
实例: 在正弦曲线舞动的彩色英文字母 https://www.cnblogs.com/fzz9/p/9256265.html

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
text tspan _ 舞动的多色字体<br>
<style>
#svg{border:1px dashed #eee;}
</style>
<svg id="svg" xmlns="http://www.w3.org/2000/svg" version="1.1" height="500" width="900">
	<!-- 网格背景-->
	<defs>
		<pattern id="grid" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
			<path d="M0,0H20V20" stroke="#eee"  fill="none" />
		</pattern>
	</defs>
	<rect fill="url(#grid)" height="500" width="900" />
	
	<!--文字-->
	<text x="100" y="200" fill="blue" style="font-size:20px; font-family:'Arial'"> <tspan fill="hsl(100, 100%, 50%)">xx</tspan> </text>
	<!--坐标-->
	<path d="M100,100v200M0,200h700" transform="translate(10,0)" stroke="red" />
</svg>


<script>
function $(s){return document.getElementById(s);}

var ns="http://www.w3.org/2000/svg";
var content="ABCDEFGHIJKLMNOKQRSTUVWXYZ", 
	n=content.length,
	span=10,
	dx=[], dy=[];

var svg=$('svg'), text=svg.getElementsByTagName('text')[0];
//text.innerHTML=content;
text.innerHTML='';
for(var i=0;i<n;i++){
	var tspan=document.createElementNS(ns, 'tspan');
	tspan.innerHTML=content[i];
	//set color for each letter
	var h=Math.round(360/n*i); //将颜色均分显示
	tspan.setAttribute('fill', "hsl("+h+", 100%,50%)");
	text.append(tspan);
	
	//dx
	dx.push(span);
	text.setAttribute('dx', dx.join(' '));
}

//dy 
//y=A*sin(w*x + t)
var cycle=Math.round(svg.width.animVal.value*0.15), 
	w=2*Math.PI/cycle, 
	A=100,
	t=0

function arrange(t){
	dy=[];
	var ly=0, cy; //last, current y;
	x=-span;
	for(var i in dx){
		//console.log(i, dx[i]);
		x+=dx[i];
		cy=-A*Math.sin(w*x + t); //svg.height.animVal.value/2;
		dy.push(cy-ly);
		ly=cy;
	}
}

//begin animation
function frame(){
	t+=0.02
	if(t==cycle)t=0;
	arrange(t)
	//
	text.setAttribute('dy', dy.join(' '));
	window.requestAnimationFrame(frame);
}
frame()
</script>






========================================
|-- 文字的水平/垂直居中
----------------------------------------
1. 水平居中，很简单
text-anchor 文字水平居中，使用text-anchor属性，值包括：start、middle、end，分别表示左对齐、居中对齐、右对齐.

<text x="100" y="100" fill="blue" text-anchor="start" style="font-size:20px; font-family:'Arial'">x=100, start(默认)</text>




2. 垂直居中

## 重要: rect.getBBox()方法获取图形边界x,y,width,height。


(1) dominant-baseline属性，值有很多:
var values = "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge | text-top | text-bottom".split(' | ');

默认是英文字体，对齐时小写x正好左下角对齐;
中文使用 ideographic，则汉字最低下对齐;
印度字体(?)使用hanging，中上部对齐;


(2)自己模拟
y轴方向上，文字最左上角为b.y，则底部为b.y+b.height, 中线为b.y+b.height/2;
而我们要设置的基线y=text.getAttribute('y');

则控制text的dy值，即可控制文字的位置。

则顶对齐、中线对齐、底部对齐时，text元素的dy的值分别为:
case 'top': return y-box.y;
case 'middle':return y-(box.y+box.height/2);
case 'bottom':return y-(box.y+box.height);



(2) 完整实例:
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
文字垂直居中 自己模拟<br>
rect.getBBox()方法获取图形边界x,y,width,height。<hr>

<style>
#svg{border:1px dashed #eee;}
</style>

<label>垂直居中属性：baseline=</label>
<select id="select"></select>

<svg id="svg" xmlns="http://www.w3.org/2000/svg" version="1.1" height="250" width="900">
	<path d="M100,0v300 M0,100h500" stroke="#ccc" fill="none" />
	<!--文字-->
	<text x="100" y="100" fill="blue" text-anchor="start" style="font-size:50px; font-family:'Arial'">x=100, middle (point)汉字</text>
	<rect x="100" y="100" width="100" height="100" fill="none" stroke="red" stroke-width="1" />
</svg>


<script>
//触发一个事件 https://blog.csdn.net/liuxiao723846/article/details/80822052
function trigger(element,eventName="change"){
	if( document.createEvent ){
		var evObj = document.createEvent('HTMLEvents');
		evObj.initEvent( eventName, false, true);
		element.dispatchEvent(evObj);//chrome
	}else if( document.createEventObject ){
		element.fireEvent('on'+eventName);//IE
	}
}


var svg=document.getElementById('svg'),
	text=svg.getElementsByTagName('text')[0],
	rect=svg.getElementsByTagName('rect')[0];
//自定义三种对齐方式
var values = "top | middle | bottom".split(' | ');
values.forEach(function(value) {
	//console.log(value);
	var option=document.createElement('option');
	option.value=value;
	option.innerHTML=value;
	select.append(option);
});

// 更新外边框
function updateRect(){
	//显示外边框
	var box=text.getBBox();
	wjl=box
	rect.setAttribute('x',box.x);
	rect.setAttribute('y',box.y);
	rect.setAttribute('width',box.width);
	rect.setAttribute('height',box.height);
}
updateRect();

// 下拉框值改变
select.onchange=function(){
	text.setAttribute('dy', 0 );//要先把dy归零，清除对box定位的影响
	text.setAttribute('dy', getDy(this.value) );
	console.log(this.value);
	
	updateRect();//外边框
}
//select.onchange(); //触发事件 方法1
trigger(select, 'change'); //触发事件 方法2


//计算3种对齐方式时，dy的取值
function getDy(align){
	var box=text.getBBox(), y=text.getAttribute('y');
	switch(align){
		case 'top': return y-box.y;
		case 'middle':return y-(box.y+box.height/2);
		case 'bottom':return y-(box.y+box.height);
	}
}
</script>

<pre>
模拟的垂直对齐: top, middle, bottom;







========================================
|-- SVG 路径文本: 子标签textPath，及其js动态控制
----------------------------------------
概要: 使用方法、布局原理、定位属性x,y,dx,dy的作用、脚本控制;

1. textPath 路径文本 渲染原理
浏览器查到文字的第一个字符的charWidth，
在路径上找到起始点放该字符，
找到起始点中间位置，做切线和法线，然后把文字底部和切线对齐，把文字竖中线对齐到法线；

然后下一个字符，上一个字符结束的位置作为下一个字符开始的位置.

注意: 文字太多时，排列起来长度超过路径长度的文本不显示;



<svg id='svg' xmlns="http://www.x.com" height="300" width="1000">
	<path id="path1" d="M100,200 Q200,100 300,200 T500,200" stroke="green" fill="none" />
	<circle cx="100" cy="200" r="2" fill="red" />
	<circle cx="300" cy="200" r="2" fill="red" />
	<circle cx="500" cy="200" r="2" fill="red" />
	
	<text style="font-size:24px;">
		<textPath xlink:href="#path1">
			12文字先上去，又下来了。Upside down in english!
		</textPath>
	</text>
</svg>

注意: textPath的属性xlink:href值前面必须有#！！！




2. 常用属性
(1) x, text-anchor和startOffset属性： 确定排列起始位置;
(2) dx,dy属性: 切线和法线方向的偏移;

Tips:
1).超出曲线长度的文字，浏览器不显示;
2).x, text-anchor和startOffset属性： 确定排列起始位置;
- x 文字起始位置，y不起作用;
- 想在法线方向移动，需要使用dy，也可以在tspan标签内使用dy属性，dy属性对该元素及之后的文字元素都生效;
- text-anchor="middle" 时，字符串中间和路径起始位置重合

- textPath的属性startOffset: 改变路径的起始位置，值可以是像素"100"，也可以是百分比"50%";





3. 脚本控制 
(1)setAttributeNS()方法设置xlink:href属性
(2)把文本节点替换为textPath节点;


源码:
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
textPath 路径文本 的脚本控制<br>

改变文字路径
<select id="select">
	<option value="none">none</option>
	<option value="path1">path1</option>
	<option value="path2">path2</option>
	<option value="path3">path3</option>
</select>

<svg id='svg' xmlns="http://www.w3.org/2000/svg" height="500" width="1000">
	<!-- 准备三条路径 -->
	<path id="path1" d="M100,200 Q200,100 300,200 T500,200" stroke="red" fill="none" />
	<path id="path2" d="M100,300 l100-50,200,100, 100,-50" stroke="green" fill="none" />
	<path id="path3" d="M100,400 A400,300, 0,0, 0,500,400" stroke="blue" fill="none" />

	<text id="text" x="20" y="100" style="font-size:24px;">
			Text path scripting <tspan>动态使用路径文本</tspan>
	</text>
</svg>

<script>
var SVG_NS="http://www.w3.org/2000/svg";
var XLINK_NS="http://www.w3.org/1999/xlink";
//
var select=document.getElementById('select');

var svg=document.getElementById('svg');
var text=svg.getElementsByTagName('text')[0];
var tspan=svg.getElementsByTagName('tspan')[0];

//添加textPath标签
function addTextPath(){
	var textPath=document.createElementNS(SVG_NS, 'textPath');
	while(text.firstChild){
		textPath.appendChild(text.firstChild);
	}
	text.appendChild(textPath);
}
//修改textPath标签路径值
function setTextPath(path){
	var textPath=text.firstChild;
	textPath.setAttributeNS(XLINK_NS, "xlink:href", path);
	
	//让文字和路径同样颜色
	var pathElement=document.querySelector(path);
	tspan.setAttribute('fill', pathElement.getAttribute('stroke') );
}
//删除textPath标签
function removeTextPath(){
	var textPath=text.firstChild;
	while(textPath.firstChild){
		text.appendChild(textPath.firstChild);
	}
	text.removeChild(textPath);
	//
	tspan.removeAttribute('fill');
}

// 下拉框选择路径时
select.oninput=function(){
	var value=select.value;
	if(text.firstChild.tagName && text.firstChild.tagName.toLowerCase()=="textpath"){
		if (value=="none") removeTextPath();
		else setTextPath("#"+value);
	}else{
		if (value!="none") {
			addTextPath();
			setTextPath("#"+value);
		}
	}
}
</script>



========================================
|-- 超链接 a标签: 可以添加到文字、图形上
----------------------------------------
1. 概述
- 可以添加到任意的图形上
- xlink:href 指定链接地址
- xlink:title 指定链接提示
- target 指定打开目标

2. 实例 
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
link A 超链接 <br>


<svg id='svg' xmlns="http://www.w3.org/2000/svg">
	<a 
		xlink:href="https://baidu.com/" 
		xlink:title="百度" 
		target="_blank"
	>
		<circle cx="200" cy="100" r="50" fill="blue" />
	</a>
</svg>





========================================
图形的引用use、裁切clipPath和蒙版mask
----------------------------------------
- 因为svg是个内联元素，当设置高宽是100%时，如果line-height和font-size不是0，则会有滚动条

实例概述:
- 画一个星星，然后使用use标签批量生成星星，给不同的大小、旋转、不透明度;
- 绘制灯塔灯光时，使用clipPath标签，用三角形给大椭圆做裁切，只有裁切区域可显示; 加入动画标签，让光锥可旋转;
- 月牙使用蒙版(白可见，黑不可见)，一个黑大圆遮住另一个白大圆，没遮住的白色可以透出来下一层;

<use xlink:href="#id" />
<clipPath> clip-path="url(#clip-id)"
<mask> mask="url(#mask-id)"


========================================
|-- use 标签创建图形引用 (实例:满天星星): 复用形状
----------------------------------------
- 使用use时，原有属性不能被use标签的属性覆盖！


1. 
定义
<polygon id="star" points="0 -10, 2 -2, 10 0, 2 2, 0 10, -2 2, -10 0, -2 -2" fill="#ffffff" />

使用
<use xlink:href="#star" />
<use xlink:href="#star" x="100" fill="yellow" />

- 定义被修改，则所有引用它的效果都会被修改;


2.实例: 画星空
<meta http-equiv=Content-Type content="text/html;charset=utf-8">
图形引用use<br>
<style>
html,body{background:black; line-height:0; font-size:0;}
</style>

<svg id='svg' xmlns="http://www.w3.org/2000/svg" 
	viewBox="-400 -300 800 600" preserveAspectRatio="xMidYMid slice">
	<defs>
		<!--星星图形-->
		<polygon id="star" points="0 -10, 2 -2, 10 0, 2 2, 0 10, -2 2, -10 0, -2 -2" fill="#ffffff" />
	</defs>
	
	<g id="star-group">
	<!--
		<use xlink:href="#star" />
		<use xlink:href="#star" x="100" fill="yellow" />
	-->
	</g>
</svg>

<script>
var SVG_NS="http://www.w3.org/2000/svg", XLINK_NS="http://www.w3.org/1999/xlink";
function $(s){return document.getElementById(s);}
function random(min,max){return min+(max-min)*Math.random(); }

var starRef=$('star'), starGroup=$('star-group');

//新建use标签，重用defs中定义的图形
function use(origin){
	var _use=document.createElementNS(SVG_NS, 'use');
	_use.setAttributeNS(XLINK_NS,'xlink:href','#'+origin.id);
	return _use;
}

//渲染星星
function renderStar(){
	var count=400;
	var star;
	while(count--){
		star=use(starRef);
		//设置
		star.setAttribute('transform',
			"translate("+random(-400,400)+","+random(-300,50)+"), "+ //位移
			"rotate("+random(0,360)+")"+ //旋转
			"scale("+random(0.1,0.6)+")" //大小
		);
		star.setAttribute('opacity', random(0.1,0.5) );//不透明度
		star.setAttribute('fill', "hsl("+Math.round(Math.random()*360)+",100%,50%)"  );//已有属性不能被覆盖！
		
		//加入dom
		starGroup.appendChild(star);
	}
}
renderStar()
</script>




========================================
|-- clipPath 标签裁切图形 (实例:绘制灯塔的光线): 只有在clip路径内的图形才可见
----------------------------------------
1. 使用方法 
(1)定义clipPath，其实就是一个形状

<!--灯塔发光的剪辑区域, 使用: 在形状上添加clip-path属性 -->
<clipPath id="light-clip">
	<polygon points="0 0, -400 -15, -400 15" fill="rgba(255,0,0,0.3)"></polygon>
	<circle cx="0" cy="0" r="2" fill="yellow"/>
</clipPath>


<!--灯塔发光区域的渐变-->
<radialGradient id="grd-light" cx="0.5" cy="0.5" r="0.5">
	<stop offset="0" stop-color="rgba(255,255,255,0.8)" />
	<stop offset="1" stop-color="rgba(255,255,255,0)" />
</radialGradient>

(2) 在形状上添加 clip-path 属性: 
<ellipse cx="0" cy="0" rx="300" ry="100" fill="url(#grd-light)" clip-path="url(#light-clip)" />

则椭圆ellipse只有在clip-path定义的区域才可见，其他区域被隐藏



2. 完整实例: 灯塔发出光线，光柱不停的旋转

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
裁切clip：绘制灯塔<br>
<style>
html,body{background:black; line-height:0; font-size:0;}
</style>

<svg id='svg' xmlns="http://www.w3.org/2000/svg" 
	viewBox="-400 -300 800 600" preserveAspectRatio="xMidYMid slice">
	
	<g id="light-tower" transform="translate(250,0)">
		<defs>
			<!--灯塔三角底座的渐变-->
			<linearGradient id="grd-tower" x1="0" y1="0" x2="1" y2="0">
				<stop offset="0" stop-color="#999" />
				<stop offset="1" stop-color="#333" />
			</linearGradient>
			
			<!--灯塔发光区域的渐变-->
			<radialGradient id="grd-light" cx="0.5" cy="0.5" r="0.5">
				<stop offset="0" stop-color="rgba(255,255,255,0.8)" />
				<stop offset="1" stop-color="rgba(255,255,255,0)" />
			</radialGradient>
			
			<!--灯塔发光的剪辑区域, 使用: 在形状上添加clip-path属性 -->
			<clipPath id="light-clip">
				<polygon points="0 0, -400 -15, -400 15" fill="rgba(255,0,0,0.3)">
					<!--添加动画效果: 光线剪影旋转效果-->
					<animateTransform
						attributeName="transform" 
						attributeType="XML" 
						type="rotate" 
						from="0" 
						to="360"
						dur="10s"
						repeatCount="indefinite">
					</animateTransform>
				</polygon>
				<circle cx="0" cy="0" r="2" fill="yellow"/>
			</clipPath>
		</defs>
		<polygon points="0 0, 5 50, -5 50" fill="url(#grd-tower)" />
		<ellipse cx="0" cy="0" rx="300" ry="100" fill="url(#grd-light)" clip-path="url(#light-clip)" />
	</g>
</svg>







========================================
|-- mask 标签创建蒙版 (实例:绘制月牙及湖面倒影)
----------------------------------------
<clipPath>裁切路径和<mask>蒙版非常类似，甚至可以说实现同一类型的效果。
它们之间的主要不同点是:
1) 裁切路径是可见与不可见的突变，要么可见要么不可见。
2) 蒙版则是可见与不可见的渐变，期间可以有过渡效果。


1. mask的使用 
蒙版中黑色代表不可见（opacity: 0），白色代表可见（opacity: 100%）

mask属性不能加到use标签上!

(1)定义mask
<defs>
	<!-- 蒙版的定义: 必须同时指定黑白元素，否则没效果 -->
	<mask id="moon-mask">
		<circle cx="-250" cy="-150" r="100" fill="white" />
		<circle cx="-200" cy="-200" r="100" fill="black" />
	</mask>
</defs>

(2)使用mask
<circle cx="-250" cy="-150" r="100" fill="yellow" mask="url(#moon-mask)" />





2. 完整实例
包含对一个图形的简单蒙版，和对一组图形的渐变蒙版

<meta http-equiv=Content-Type content="text/html;charset=utf-8">
蒙版mask：绘制月亮<br>
<style>
html,body{background:darkblue; line-height:0; font-size:0;}
</style>

<svg id='svg' xmlns="http://www.w3.org/2000/svg" 
	viewBox="-400 -300 800 600" preserveAspectRatio="xMidYMid slice">
	<g id="moon">
		<defs>
			<!-- 蒙版的定义: 必须同时指定黑白元素，否则没效果 -->
			<mask id="moon-mask">
				<circle cx="-250" cy="-150" r="100" fill="white" />
				<circle cx="-200" cy="-200" r="100" fill="black" />
			</mask>
		</defs>
		<circle cx="-250" cy="-150" r="100" fill="yellow" mask="url(#moon-mask)" />
	</g>
	
	<!-- 以下为倒影 -->
	<g id="reflect" transform="translate(0,50)" mask="url(#reflect-mask)">
		<defs>
			<linearGradient id="grd1" x1="0" y1="0" x2="0" y2="1">
				<stop offset="0" stop-color="rgba(255,255,255,0.7)" />
				<stop offset="0.8" stop-color="rgba(255,255,255,0)" />
			</linearGradient>
			<mask id="reflect-mask">
				<rect x="-400" y="0" width="800" height="300" fill="url(#grd1)" />
			</mask>
		</defs>
		<use xlink:href="#moon" transform="scale(1,-1) translate(0 -50)" />
	</g>
	<line x1="-400" y1="50" x2="400" y2="50" stroke="white" />
</svg>




========================================
SVG 动画
----------------------------------------
要点:
	动画原理
	SMIL for SVG
	动画脚本

#

1. 动画原理
动画就是一个value-time方程: 某一个值value 从 from 变动到 to，历经time为 duration;
每一个静止的画面，就是一帧;
24帧/秒 就差不多可以看了，为了流畅，要达到60帧/s;
帧与帧之间，通过插值实现;



========================================
|-- SVG 动画: SMIL for SVG (以标签的形式实现动画效果)
----------------------------------------
1. 参考资料
Synchronized Multimedia Integration Language（同步多媒体集成语言）

https://www.w3.org/TR/SVG/animate.html
https://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/

https://www.cnblogs.com/lovesong/p/6011328.html


SMIL允许你做下面这些事情：
	动画元素的数值属性（X, Y, …）
	动画属性变换（平移或旋转）
	动画颜色属性
	沿着运动路径运动
#前面三个css3也可以做，但是最后一个“沿着运动路径运动”css3无能为力。


(2) 5大动画标签
	<set>
	<animate>
	<animateColor> 已废弃
	<animateTransform>
	<animateMotion>
#


(3) 相同的策略: 动画元素、属性定位、动画参数

1)
attributeType="auto | CSS | XML" 变量类型，如果不指定就是auto(现在样式表找，没找到再在xml中找，不指定过于耗费性能)
attributeName: 具体变量名，比如"x","fill"

2)
from, to, 
	来回动画from to; 
	也可以用value()来代替form to; 
	from 不是必须设置的;
	除了to 还有 by ,to设置的是绝对路径，by设置的相对的

dur="10s" #变化持续时间
repeatCount="1(默认) | indefinite(无限循环)" 
fill="remove(默认) | freeze": remove就是动画结束去掉当前值，恢复原值; freeze则动画结束保持当前值;



3)calcMode,




(4). SMIL for SVG 定位动画目标
1)internal resource identifier 定位:
	<animate xlink:href="url(#rect1)"></animate>

2)被包含到目标元素中
<rect x="0" ...>
	<animate></animate>
</rect>







2. SMIL for SVG 基本动画

(1) 设置要进行动画的属性以及变化范围、时间长度
(2) 动画可以叠加的，也就是放置两个animate标签
	<rect id="rect1" x="10" y="10" width="20" height="40" fill="red">
		<animate
			attributeType="XML"
			attributeName="x"
			from="10"
			to="200"
			dur="3s" 
			fill="freeze">
		</animate>
		
		<!--动画可以叠加, 这些动画同时进行-->
		<animate
			attributeType="XML"
			attributeName="fill"
			from="red"
			to="yellow"
			dur="6s" 
			fill="freeze">
		</animate>
	</rect>

(3) begin属性: 动画的衔接(如果两个动画不想同时进行，一个结束，另一个再开始)
动画触发条件可以是: 一段时间、某个动画结束、鼠标单击等;

begin="0; goLeft.end" #动画开始时间，0表示载入就开始，分号表示并列，后面是id=goLeft这个动画end时开始.(id中不能有-符号)
begin="goLeft.end + 1s" #goLeft.end结束后，再等1s开始本动画

注意: begin的id是animate的id，不是元素的id;


实例 
<svg id='svg' xmlns="http://www.w3.org/2000/svg">
	<rect id="rect1" x="10" y="10" width="20" height="40" fill="red">
		<animate id="goRight"
			attributeType="XML"
			attributeName="x"
			begin="0; goLeft.end"
			from="10"
			to="200"
			dur="1s" 
			fill="freeze">
		</animate>
		
		<!--动画 顺序播放: begin 参数-->
		<animate id="goLeft"
			attributeType="XML"
			attributeName="x"
			begin="goRight.end+1s" 
			from="200"
			to="10"
			dur="1s" 
			fill="freeze">
		</animate>
	</rect>
</svg>







3. SMIL for SVG 变换动画
animateTransform标签有一个额外的参数type(变换的类型)，取值：translate、scale、rotate、skewX、skewY;

使用多个transform属性动画时，给后面的属性加上additive="sum"，否则只会显示最后定义的那个效果。

<svg id='svg' xmlns="http://www.w3.org/2000/svg" viewBox="-50 -50 200 200" height="400" width="400">
	<line x1="-100" y1="0" x2="200" y2="0" stroke="#eee" />
	<line x1="0" y1="-100" x2="0" y2="200" stroke="#eee" />
	<rect id="rect1" x="0" y="0" width="20" height="40" fill="red">
		
		<animateTransform id="rotate"
			attributeType="XML"
			attributeName="transform"
			
			type="rotate"
			from="0"
			to="360"
			dur="3s" 
			fill="remove"
			repeatCount="indefinite">
		</animateTransform>
		
		<!--animateTransform会覆盖掉上一个同名标签，除非后一个标签添加属性additive="sum" -->
		<!-- 并行 放大-->
		<animateTransform id="scale"
			attributeType="XML"
			attributeName="transform"
			
			type="scale" 
			from="1"
			to="2"
			
			dur="3s" 
			fill="freeze" 
			repeatCount="indefinite" additive="sum">
		</animateTransform>

	</rect>
</svg>



4. SMIL for SVG 轨迹移动
animateMotion 标签


实例:
<svg width="500" height="350" viewBox="-50 -50 500 450">
	<!--(1) path属性 定义路径 -->
	<path id="motionPath1" d="M0,0A200 50 0 0 1 0 100" stroke="blue" fill="none" />
	<rect x="0" y="0" width="20" height="40" fill="blue">
		<animateMotion
			path="M0,0A200 50 0 0 1 0 100"
			rotate="auto"
			dur="3s"
			repeatCount="indefinite">
		</animateMotion>
	</rect>

	<!--(2) mpath标签指定路径 -->
	<path id="motionPath2" d="M0,0A200 50 0 0 1 0 200Z" stroke="#eee" fill="none" transform="translate(0,150)" />
	<circle id="circle" r="20" cx="0" cy="150" fill="tomato"></circle>

	<!--运动的相关参数  1、href链接到图片   mpath链接到路径-->
	<animateMotion xlink:href="#circle" dur="2s" begin="click" fill="freeze" repeatCount="indefinite">
		<mpath xlink:href="#motionPath2" />
	</animateMotion>
</svg>




5. 渐变动画: 效果很神奇，但是原理是一样的。
https://www.softwhy.com/article-9147-1.html

<svg width="400" height="400" >
	<radialGradient id="gr-radial" cx="50%" cy="50%" r="70%">
		<animate attributeName="r" values="0%;150%;100%;0%" dur="5s" repeatCount="indefinite" />
		<stop stop-color="#FFF" offset="0">
			<animate attributeName="stop-color" values="#333;#FFF;#FFF;#333" dur="5s" repeatCount="indefinite" />
		</stop>

		<stop stop-color="rgba(55,55,55,0)" offset="100%" />
	</radialGradient>
	
  <circle cx="50%" cy="50%" r="30%" fill="url(#gr-radial)"/>
</svg>

<pre>
1). 对镜像渐变的半径r进行渐变，因为渐变收缩，会产生波纹效果;
2). 对stop的0%位置的stop-color渐变，中心颜色会有深浅变化




========================================
|-- SVG 动画: js 脚本动画
----------------------------------------
- 在自绘这块儿，好看好玩儿的效果，都离不开数学和物理原理做支撑，三角函数、加速度定律、定积分。
- 终于明白为什么说数学厉害的人物理厉害，数学厉害的人编程业厉害

1.js 动画的核心框架

function update(){
	updateTree()
	updateMan()
	
	//
	renderTree()
	renderMan();
	//
	requestAnimationFrame(update)
}

requestAnimationFrame(update)

简单的只需要一个update函数即可；
复杂点的，可以进一步抽象成计算参数的，和绘图更新的；
更复杂的，可以进一步抽象每一个动画元素的计算和绘制;




2. 实例：自由落体并弹起的小球

<svg xmlns="http://www.w3.org/2000/svg" width="800" height="600">
	<rect x="0" y="50" width="800" height="50" fill="#eee" />
	<circle id="circle1" fill="red" cx="400" cy="50" r="20"/>
	
	<line id="line1" x1="400" y1="70" x2="400" y2="600" stroke="#eee" stroke-width="0.5" />
	
	<path id="stone" d="M250,600 l50 -50 h200 l50 50Z" fill="#999" stroke="black" />
</svg>


<script>
var  circle=document.getElementById('circle1');
var  line=document.getElementById('line1');

//初始化条件
var ball={
	r:15, //球的半径
	a:9.8, //重力加速度
	v:0, //初速度
	s:0, //位置
	mu:0.9, //碰撞时的速度保留系数
};
circle.setAttribute('r', ball.r);

//更新每一帧
//var lastFrameTime=+new Date();
function update(){
	var oldY=ball.s;
	
	//1. 计算时间
	//var frameTime=+new Date();
	//var t=frameTime-lastFrameTime;
	//t/=80; //这个时间切换需要尝试，原来单位是毫秒(ms)，70比较理想
	var t=0.25;
	
	//计算速度 vt=v0+a*t;
	ball.v+=ball.a*t;
	//计算位移 st=s0+v*t;
	ball.s=+circle.getAttribute('cy');
	ball.s+=ball.v*t;
	//该次时间成为历史
	//lastFrameTime=frameTime
	
	//碰撞检测
	if( ball.s+ball.r >550 ){
		ball.s=oldY;//取消当前帧的更新
		ball.v=-ball.v * ball.mu; //每次碰撞，速度方向，损失速度
		
		//停止条件
		if(Math.abs(ball.v)<0.7 ){
			console.log('The ball stopped;');
			return;
		}
	}
	
	//重绘
	render();
	//下一帧
	window.requestAnimationFrame(update);
}
// 改变可视区
function render(){
	//更新小球位置
	circle.setAttribute('cy', ball.s);
	//更新线条起点
	line.setAttribute('y1', ball.s+ball.r);
}

window.requestAnimationFrame(update);
</script>





========================================
|-- 响应鼠标事件
----------------------------------------

1. 响应单击事件 Mouse Events - SMIL: 

单击后，颜色和位置会变化
<svg xmlns="http://www.w3.org/2000/svg"  xmlns:xlink="http://www.w3.org/1999/xlink">  
	<rect x="5" y="5" width="40" height="40" fill="red">  
		<set attributeName="fill" to="blue" begin="click" />  
		<set attributeName="x" to="100" begin="click" />  
	</rect>  
</svg>

或者在js中设置begin属性为鼠标事件:
set.setAttributeNS(null, "begin", "mousedown"); //mouseup/mouseover/mouseout/mousemove



2.Mouse Events - js: 直接绑定到标签上，或者使用dom.addEventListener方法

<svg xmlns="http://www.w3.org/2000/svg">
	<rect id="rect1" x="5" y="5" width="40" height="40" fill="red"  onclick="changeColor(evt)"/>  
</svg>

<script>
//method1
function changeColor(evt) { 
	var rect = evt.target;
	rect.setAttributeNS(null, "fill", "purple");
}

//method2
function changeColor2(evt) { 
	var rect = evt.target;
	rect.setAttributeNS(null, "x", "100");
}
rect1.addEventListener("click", changeColor2, false);
</script>





========================================
|-- 获取鼠标位置
----------------------------------------
http://www.kevlindev.com/tutorials/basics/transformations/tracker/index.htm
http://www.kevlindev.com/tutorials/basics/transformations/toUserSpace/index.htm



========================================
D3.js 也可以使用 SVG 绘图
----------------------------------------
https://www.it1352.com/OnLineTutorial/d3js/d3js_axis_api.html

https://d3js.org/

D3.js is a JavaScript library for manipulating documents based on data. D3 helps you bring data to life using HTML, SVG, and CSS. D3’s emphasis on web standards gives you the full capabilities of modern browsers without tying yourself to a proprietary framework, combining powerful visualization components and a data-driven approach to DOM manipulation.







========================================
Rough.js: 创建手绘风格的小图片 (支持 Canvas and SVG)
----------------------------------------
1. Create graphics with a hand-drawn, sketchy, appearance
https://roughjs.com/

Rough.js is a small (<9kB gzipped) graphics library that lets you draw in a sketchy, hand-drawn-like, style. The library defines primitives to draw lines, curves, arcs, polygons, circles, and ellipses. It also supports drawing SVG paths.

Rough.js works with both Canvas and SVG.



2. 案例: 置换检验图形示例
https://www.jwilber.me/permutationtest/








========================================
响应鼠标滚动事件的js包 scrollama
----------------------------------------

https://github.com/russellgoldenberg/scrollama


========================================
----------------------------------------



========================================
----------------------------------------

