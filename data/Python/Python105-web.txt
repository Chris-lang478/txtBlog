Python105-web

(2019.3.4)目前主要是flask 1.0.2和jinja2。
Django 框架



========================================
web based tutorials
----------------------------------------
python3的Django 写的博客系统：
https://tendcode.com/article/python-shell/ 


flask写用户登录功能 https://qinqianshan.com/web/flask/


========================================
|-- python web编程：使用socket包
----------------------------------------
建议直接用命令行窗口运行py的server脚本，不要用jupyter，否则端口无法释放。

1.error:[Errno 98] Address already in use的解决
当你该端口被其他进程占用时，那就需要你修改为一个未使用的端口号重新运行。

如果是运行程序没有通过<Ctrl> C正常结束， 而是直接关闭Terminal或者其他非正常途径退出的时候： 
通过lsof -i:(port)，查看占用该端口号的进程，一般就是刚未正常退出的进程。例如
$ lsof -i :8000 # 这个命令针对我用的port 8000
##COMMAND   PID   USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
##python3 16633 wangjl   56u  IPv4 38335892      0t0  TCP *:8000 (LISTEN)

然后kill掉该PID的进程，重新运行。
$ sudo kill -9 16633


如果是查看本机所有的进行的进程： 
ps aux　 #　用ps -A查看所有进程



2.



========================================
flask简介
----------------------------------------
flask: https://palletsprojects.com/p/flask/
文档： https://flask.palletsprojects.com/en/1.1.x/



《Flask Web开发：基于Python的Web应用开发实战》
http://blog.sina.com.cn/s/blog_c3b6050b0102x0l0.html

第一部分 Flask简介 
第1章 安装  
第2章 程序的基本结构 
第3章 模板  
第4章 web表单  
第5章 数据库 
第6章 电子邮件 
第7章 大型程序的结构 

第二部分 实例：社会化博客程序 
第8章 用户认证 
第9章 用户角色 
第10章 用户资料 
第11章 博客文章 
第12章 关注者 
第13章 用户评论 
第14章 程序编程接口 

第三部分 成功在望 
第15章 测试 
第16章 性能 
第17章 部署 
第18章 其他资源



Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions. And before you ask: It's BSD licensed!


1.安装
pip install flask

2. 老版1.0例子
文件hello.py
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"

if __name__ == '__main__':
    app.run()

运行
>python hello.py

然后浏览器输入 http://127.0.0.1:5000/




###
3. 新版1.1例子
文件a2.py 
from flask import Flask, escape, request

app = Flask(__name__)

@app.route('/')
def hello():
    name = request.args.get("name", "World")
    return f'Hello, {escape(name)}!'
#
运行：
env FLASK_APP=hello.py flask run

访问浏览器 http://127.0.0.1:5000/?name=Flask~~
Hello, Flask~~!









========================================
|-- flask URL生成: url_for()函数
----------------------------------------

1.url_for() 函数。按照函数名，生成其对应的报时器中的url。

本质是根据函数名反向生成url，使用函数 url_for() 来针对一个特定的函数构建一个 URL。它能够接受函数名作为第一参数，以及一些关键字参数， 每一个关键字参数对应于 URL 规则的变量部分。

未知变量部分被插入到 URL 中作为查询参数。

url_for(方法的名) =app.route参数名
而url_for() 本身和app.route的参数是没关系的，只和方法的参数名相关。


@app.route('/')
def index():
	url=url_for('hello') #第一个参数是函数名，不是路由
	return '<meta http-equiv="refresh" content="0;url='+url+'">'
#

@app.route('/index.py')
def hello():
	pass();
#



2.例2

from flask import Flask,url_for
app = Flask(__name__)


@app.route('/')       #定义一个路由
def hello_world():    #定义一个视图函数
    return "<a href="+url_for('index',keyword="Main", id="1_2" ) +">goto</a>"
#<a href=/html/Main/1_2>goto</a>


@app.route('/html/<keyword>/<id>')
def index(keyword,id):
    return 'Hello kw=%s, id=%s!\n'%(keyword, id);

if __name__ == '__main__':
    app.run()



========================================
|-- flask 的调试，输出到控制台
----------------------------------------
1. 输出到网页
@app.route('/wjl')
def ixx():
	a=getConf("style",'txt');

	#txtStyle = cf.get(section, item)
	return a;
#


2. 输出到控制台 
with app.test_request_context():
	a=getConf("style",'txt');
	print(a) 


========================================
|-- python web编程：使用flask包写接口(路由、参数传递)
----------------------------------------
WARNING: Do not use the development server in a production environment.
Use a production WSGI server instead.

Python实现简单的API接口
https://blog.csdn.net/u013040887/article/details/78895323/

教程：http://docs.jinkan.org/docs/flask/quickstart.html#static-files



1.基本例子
$ cat dFlask.py 
from flask import Flask
app = Flask(__name__)
@app.route('/')  
def hello_world():
    return "hello world"
if __name__=='__main__':
    app.run(host="192.168.2.120",port=8000)

运行该脚本后，就可以用浏览器访问了 192.168.2.120:8000





2.简单的get和post
$ cat dFlask2.py 
# -*- coding: utf-8 -*-
# Flask hello world
from flask import Flask, redirect, request
from flask import render_template
app = Flask(__name__)

@app.route('/send_msg', methods=['GET','POST']) #默认只接受get参数
def Messaging():
    if request.method =='POST':
        return('post1')
    elif request.method =='GET':
        return('get1')
    else:
        pass

@app.route('/send_msg2', methods=['POST'])
def do_send():
    return('post2')

@app.route('/send_msg2', methods=['GET'])
def show_form():
    return('get2')


@app.route('/')
def hello():
    return render_template('forms.html')


if __name__ == '__main__':
    ####默认监听127.0.0.1:5000   关闭调试模式
    app.run(host='192.168.2.120',port=8000,debug=True)
-
访问 
http://y.biomooc.com:8000/send_msg
http://y.biomooc.com:8000/send_msg2








3.路由解析：通过url动态传递参数
(1)#加不加最后的斜杠不一样
@app.route('/projects/')
def projects():
    return 'The project page' #访问时不带最后斜杠，会自动补齐斜杠

@app.route('/about')
def about():
    return 'The about page' #访问的时候加了斜杠，就会报错404
#



(2)从url传入的5类参数
#传入参数
@app.route('/user/<username>')
def show_user_profile(username):
    # show the user profile for that user
    return 'User %s' % escape(username)
#http://blog2.163.com:8000/user/wjl
#User wjl


@app.route('/post/<int:post_id>')
def show_post(post_id):
    # show the post with the given id, the id is an integer
    return 'Post %d' % post_id
# http://blog2.163.com:8000/post/123456
# Post 123456


@app.route('/path/<path:subpath>')
def show_subpath(subpath):
    # show the subpath after /path/
    return 'Subpath %s' % escape(subpath)
# http://blog2.163.com:8000/path/c/usr/bin/python3
# Subpath c/usr/bin/python3


Converter types:
	string:(default) accepts any text without a slash
	int:accepts positive integers
	float:accepts positive floating point values
	path:like string but also accepts slashes
	uuid:accepts UUID strings
#


(3) 从url获取get参数
@app.route('/hello2')
def hello2():
    name = request.args.get("name", "World2")
    return f'Hello, {escape(name)}!'
# http://blog2.163.com:8000/hello2?name=python3
# Hello, python3!

#






4.使用url_for函数构建URL
from flask import Flask, escape, url_for
app = Flask(__name__)

@app.route('/')
def index():
    return 'index'

@app.route('/login')
def login():
    return 'login'

@app.route('/user/<username>')
def profile(username):
    return '{}\'s profile'.format(escape(username))
# http://blog2.163.com:8000/user/百度
# 百度's profile

with app.test_request_context():
    print(url_for('index')) #第一个参数是函数名，不是路由。必须定义过，否则报错。
    print(url_for('login'))
    print(url_for('login', next='/'))
    print(url_for('profile', username='John Doe'))
#/
#/login
#/login?next=%2F
#/user/John%20Doe #输出的路径是按照路由构建的，与函数名无关。

if __name__ == '__main__':
    app.run(host="blog2.163.com",port=8000)
#







3.怎么接收js的参数，处理后的数据再以json传递给js？





========================================
|-- flask中的g、add_url_rule、send_from_directory、static_url_path、static_folder的用法
----------------------------------------
https://www.cnblogs.com/shengulong/p/7106166.html








========================================
|-- 加载非static/下的图片
----------------------------------------
# 添加新静态文件的路径，这样就允许data/下的图片加载了
@app.route("/data/<path:filename>")
def downloader(filename):
    return send_from_directory("data",filename,as_attachment=False)
#



========================================
|-- flask配合表达实现文件上传，下载(todo)
----------------------------------------
#version1: 基本功能
#
import flask, os,sys,time
from flask import request, send_from_directory

interface_path = os.path.dirname(__file__)
sys.path.insert(0, interface_path)  #将当前文件的父目录加入临时系统变量

server = flask.Flask(__name__)

htmlForm="""
<meta http-equiv="content-type" content="text/html;charset=utf-8">
upload a file<br>
<form action="/upload" method="post" enctype="multipart/form-data">
	<input type="file" name="file" />
	<input type="submit" value="上传文件" />
</form>
"""

htmlBtn="""
<style>
a.btn{
    border: 1px solid red;
    padding: 2px 5px;
    text-decoration: none;
	margin:5px;
	
	background:white;
	color:red;
}
a.btn:hover{
    color: white;
	background: red;
}
</style>
<a class=btn target="_blank" href='/upload'>Upload File</a> 
<a class=btn target="_blank" href='http://y.biomooc.com/wangjl/docs/'>File List(Download File)</a> 
<br>
1. Files stay more than 2 days may be deleted! Please backup in time;<br>
2. Now you cannot delete the file yourself; If you want to delete a file, please ask the administrator for help.<br>
3. 
"""

@server.route('/')
def index():
    return htmlBtn;

# post方法：上传文件的
@server.route('/upload', methods=['POST','GET'])
def upload():
    if request.method=='GET':
        return(htmlForm);

    fname = request.files.get('file')  #获取上传的文件
    if fname:
        t = time.strftime('%Y%m%d%H%M%S')
        new_fname = r'./' +t+"_" + fname.filename #文件名加时间前缀，防止覆盖同名文件
        fname.save(new_fname)  #保存文件到指定路径
        #status= '{"code": "ok"}'
        return '<meta http-equiv="refresh" content="2;url=/">Upload success!';
    else:
        return '{"msg": "no file"}';

server.run(host="192.168.2.120",port=8000, debug=True)

使用方法：
$ python upload.py
访问浏览器 http://192.168.2.120:8000
即可看到2个按钮，点上传到/upload页面，选择文件，点上传即可完成上传。



refer:
https://www.cnblogs.com/jessicaxu/p/7891372.html





========================================
|-- 404页面
----------------------------------------

@app.errorhandler(404)
def page_not_found(error):
    return render_template('page_not_found.html')
#

需要在 templates 下新建page_not_found.html。内容自定义。




========================================
|-- 使用flask的jsonify返回json数据
----------------------------------------
1.py文件

from flask import Flask
from flask import jsonify 

app = Flask(__name__)

#json Controler
@app.route('/api/content/<date>')
def content(date):
    status=True
    
    #从Mysql获取当天数据
    content="some content from Mysql-"+date
    
    if content=="":
        status=False;
    #返回json
    return jsonify({'status':status,'date':date, 'content':content})

#启动程序
if __name__ == '__main__':
    print("==> pls browse http://127.0.0.1:5000/api/content/2019")
    app.run()

2.运行
python hello2.py 

在浏览器输入 http://127.0.0.1:5000/api/content/2019
即可看到json个数的数据：
{"content":"some content from Mysql-2019","date":"2019","status":true}




3.用jQuery获取json数据
(1)py文件
from flask import Flask,request
from flask import jsonify
from flask.templating import render_template

app = Flask(__name__)

#首页Controler
@app.route('/', methods=['GET'])
def home():
    return render_template("jQ_index.html");


#计算并返回
@app.route('/add', methods=['GET'])
def add_numbers():
    a=request.args.get('a',0,type=int) #获取表单参数
    b=request.args.get('b',0,type=int)
    return jsonify({'result': a+b});


#run app
if __name__ == '__main__':
    print("==> pls browse http://10.21.127.192:5000/")
    app.run(host="0.0.0.0", debug=True)


(2)jQ_index.html文件放在py同级的templates文件夹下
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Flask JQuery</title>

<!-- 插入jquery -->
<script src="{{url_for('static', filename='jquery-1.8.0.js')}}"></script>

<script type=text/javascript>
var $SCRIPT_ROOT = {{request.script_root|tojson|safe}};//这是？
</script>

<script type=text/javascript>
$(function() {
    function submit_form(e) {
        $.getJSON($SCRIPT_ROOT + '/add', 
		{
            a: $('input[name="a"]').val(),
            b: $('input[name="b"]').val(),
            now: new Date().getTime()
        },
        function(data,status) { /*status 参数可以省略*/
			console.log("status =",status)
            $('#result').text(data.result);
        });
    };
    // 绑定click事件
    $('#calculate').bind('click', submit_form);
});
</script>
</head>
<body>
<p>
    <input type=text size=5 name=a> +
    <input type=text size=5 name=b> =
    <span id=result>?</span>
</p>
<p><input type="button" id="calculate" value="计算"></p>
</body>
</html>

(3)jquery-1.8.0.js文件放到py同级的static文件夹下
(4)访问 http://10.21.127.192:5000/ 即可。



========================================
|-- 从url获取参数，从mysql获取数据，以json格式返回
----------------------------------------
1.hello3.py 
from flask import Flask
from flask import jsonify
import pymysql

app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World! PLS browse: http://127.0.0.1:5000/about/32"

def getItem(id):
	#mysql 获取数据
	# 打开数据库连接
	#db = pymysql.connect(host='y.biomooc.com',port=7070,user='yanpd', password='789789', database='english')
	db = pymysql.connect(host='localhost',port=3306,user='root', password='', database='think')
	# 使用cursor()方法获取操作游标 
	cursor = db.cursor()
	# 执行sql语句
	sql = "select * from think_weibo where id="+id
	cursor.execute(sql)
	values = cursor.fetchall()
	# 关闭数据库连接
	db.close()
	#返回结果
	return values

#从url获取参数 http://127.0.0.1:5000/about/30
@app.route("/about/<id>")
def about(id):
	return jsonify(getItem(id));

if __name__ == '__main__':
    app.run()



2.运行该应用:
python hello3.py 

在浏览器输入 http://127.0.0.1:5000/about/30
即可看到json格式的、从mysql返回的数据。




========================================
jinja2 模板技术简介
----------------------------------------
jinja2: http://jinja.pocoo.org/
jinja2: https://palletsprojects.com/p/jinja/ 






========================================
Django框架 课程概述
----------------------------------------
入门课程: 
三小时带你入门Django框架 https://www.imooc.com/learn/1110
django入门与实践: https://www.imooc.com/learn/790


专题课程:
全面掌握Django ORM: https://www.imooc.com/learn/1087
Django的一个强大的功能是它的对象关系映射Object-Relational Mapping（ORM），它允许你就像使用 SQL一样去和你的数据库交互，本课程将以Django官方文档为依据，通过开发讲师、课程、学生、助教四个模型类，给大家完整透彻的讲解Django ORM知识体系，为更高级的开发打下坚实基础。

课程源码：https://github.com/liaogx/imooc




## 用户评价：
1.Tornado使用高并发。Django中异步需要使用Celery。
2.零零散散花了7小时42分，学习完了，感觉非常不错，特别是对 Models API的系统讲解。




========================================
Tornado 非阻塞式服务器
----------------------------------------
1. 简介
http://www.tornadoweb.org/en/stable/

Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed. By using non-blocking network I/O, Tornado can scale to tens of thousands of open connections, making it ideal for long polling, WebSockets, and other applications that require a long-lived connection to each user.

python写的异步web框架，起源于FriendFeed公司。使用非阻塞的网络IO， Tornado可以扩展到数以万计的开放连接，特别适用于long polling, WebSockets 等需要长时间和每个用户连接的情况。




2. Here is a simple “Hello, world” example web app for Tornado:
手动pip安装包: $ pip install tornado

$ vim tornado_demo.py
import tornado.ioloop
import tornado.web

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello, world")

def make_app():
    return tornado.web.Application([
        (r"/", MainHandler),
    ])

if __name__ == "__main__":
    app = make_app()
    app.listen(8000)
    tornado.ioloop.IOLoop.current().start()

$ python tornado_demo.py

什么也没显示，不过用浏览器访问该端口 http://y.biomooc.com:8000/，能看到 Hello, world，在F12能看到响应的服务器名字 Server: TornadoServer/5.1





========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------





========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------





