Python104-packages(under jupyter notebook and python shell)
提示: 本文数据都是随手编造的，仅用于演示相应Python包的使用。








========================================
Python数据分析: 教程与资料
----------------------------------------
1.官方及英文资料
https://www.data.gov/
教程: https://github.com/jrjohansson/scientific-python-lectures


https://github.com/DawnEve/pydata-book
Python 数据分析的底层基石 Numpy； Python 数据清洗大杀器 Pandas。




2. 视频资源
(1)Python数据预处理（一）一抽取多源数据文本信息
https://www.imooc.com/learn/1105

本课程由数据预处理整个流程到综合实战。包括：Anaconda、Sublime、Pywin32、数据采集、数据集成、缺失值处理、正则、jieba分词、NLTK、词袋模型、数据抽样、特征词抽取、文本向量化、gensim、数据降维、numpy、scipy、pandas、matplotlib、seaborn、Xgboost等核心技术。

(2)Python数据预处理（二）- 清洗文本数据
https://www.imooc.com/learn/1122

本课介绍数据预处理过程体系，包括数据类型与采集、文本转化与抽取、数据集成与规约、中文分词、数据清洗、特征提取与变换、特征向量化、特征降维、特征选择、可视化、词典模型、TF-IDF向量模型、主题模型等。









========================================
Numpy + Pandas 是python进行数据分析的基石
----------------------------------------
https://www.youtube.com/watch?v=To3YL92HZyc&list=PLXO45tsB95cKKyC45gatc8wEc3Ue7BlI4


Google在线深度学习神器Colab: https://www.jianshu.com/p/81eae79ee78b




1.因为基于C写的Numpy，所以速度快，比Python自身运算要快很多。
而且矩阵的计算也做了优化，比原生Python快十倍。


NumPy 官网 http://www.numpy.org/
教程 https://numpy.org/doc/stable/
源代码：https://github.com/numpy/numpy
NumPy is the fundamental package for scientific computing with Python. It contains among other things:

a powerful N-dimensional array object
sophisticated (broadcasting) functions
tools for integrating C/C++ and Fortran code
useful linear algebra, Fourier transform, and random number capabilities

除了科学计算，还可以任意定义数据，方便和数据库整合。Besides its obvious scientific uses, NumPy can also be used as an efficient multi-dimensional container of generic data. Arbitrary data-types can be defined. This allows NumPy to seamlessly and speedily integrate with a wide variety of databases.




2. 安装
pip install Numpy
pip install Pandas 




3.测试
import numpy as np
import pandas as pd

pd.test()
#报错 ImportError: Need pytest>=3.0 to run tests

安装 
$ pip install --user pytest

再测试，又报错：
$ pip install -U --user setuptools

不管了，先用吧。




========================================
|-- numpy基本功能、矩阵操作
----------------------------------------
官方教程： https://numpy.org/devdocs/user/quickstart.html
中文版：https://www.jianshu.com/p/a260a8c43e44


1. 入门
import numpy as np

#pd.test()
array=np.array([
    [1,2,3],
    [4,5,6]])
print(array)
#[[1 2 3]
#[4 5 6]]

array.size #6
array.shape  #(2, 3)
array.ndim #2


2.用np创建array
NumPy中创建数组的方式有若干种。最简单的，可以直接利用Python中常规的list和tuple进行创建。

a=np.array([1,23,4])
a # array([ 1, 23,  4])

b=np.array((1,23,4)) #但是 b=np.array(1,23,4) 是错的，会报错 


#dtype 定义数据的位数，越高占的空间也越多
a=np.array([1,23,4],dtype=np.int)
print(a.dtype) #np.array([1,23,4])

a=np.array([1,23,4],dtype=np.float)
print(a.dtype) #float64

a=np.zeros((3,4));a #3行4列的0矩阵。
np.ones((2,4)) #2行4列的1矩阵


创建等差数列
np.arange(10,20) #array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
np.arange(10,20,2) #等差是2 array([10, 12, 14, 16, 18])


#np.arange返回的不是list，而是array
np.arange( 10, 30, 5 ) #从10到29，以5为间隔
#array([10, 15, 20, 25])

np.arange(12).reshape(3,4) #3行4列
#array([[ 0,  1,  2,  3],
#       [ 4,  5,  6,  7],
#       [ 8,  9, 10, 11]])

np.linspace(1,10,5) #把1-10之间给出5个数字，平均间隔相同 
#array([ 1.  ,  3.25,  5.5 ,  7.75, 10.  ])
#该函数常用于为函数画点图
x = np.linspace( 0, 2*np.pi, 100 )
# useful to evaluate function at lots of points
f = np.sin(x)





(2)numpy的IO
读取csv文件
$ cat score.csv 
1,2,3,4,5
10,20,30,40,50

score=np.genfromtxt("/home/wangjl/score.csv",delimiter=",")
score
# array([[ 1.,  2.,  3.,  4.,  5.],
#        [10., 20., 30., 40., 50.]])


保存结果， todo?

还是用pandas读写文件比较方便。










3.矩阵运算

(1)加减乘除
a=np.array([10,20,40,30])
b=np.arange(4)
print(a,b) #[10 20 40 30] [0 1 2 3]

#减法
c=a-b
print(c) #[10 19 38 27]

b**2 #array([0, 1, 4, 9]) #乘方

10*np.sin(a) #三角函数 
#array([-5.44021111,  9.12945251,  7.4511316 , -9.88031624])

a<35 #布尔运算 array([ True,  True, False,  True])


(2)矩阵乘法
* 表示按照元素相乘。
a*b #array([ 0, 20, 80, 90])

使用@(python>=3.5)或者dot函数表示矩阵乘积
A = np.array( [[1,1],
             [0,1]] )
B = np.array( [[2,0],
             [3,4]] )
A@B #或者 A.dot(B)
#array([[5, 4],
#       [3, 4]])


(3)+= and *=直接修改已有矩阵，而不是创建一个新的
a = np.ones((2,3), dtype=int)
b = np.random.random((2,3))
a *= 3
a
#array([[3, 3, 3],
#       [3, 3, 3]])
b += a
b
#array([[3.57371054, 3.01654088, 3.23986455],
#      [3.4613754 , 3.11336145, 3.40659914]])
a +=b #报错，b不会自动转为整数，因为会丢失精度【upcasting向上转型问题】
a+b #这样不会报错
b +=a #int->float向下转型无所谓，因为不丢失任何精度。


向下转型没问题，越来越细，占用越来越多空间
a=np.ones(3,dtype=np.int32);print(a)
b=np.linspace(0,np.pi, 3); print(b)
#[1 1 1]
#[0.         1.57079633 3.14159265]
b.dtype #dtype('float64')
c=a+b;print(c); #[1.         2.57079633 4.14159265]
c.dtype #dtype('float64')
d=np.exp(c*1j);print(d)
d.dtype #dtype('complex128')


(4)很多像sum等计算一元类的是以ndarray类的方法提供的
a = np.random.random((2,3))
a.sum()
a.min()
a.max()
a.mean()

还可以指定轴参数axis：
b = np.arange(12).reshape(3,4)
b
# array([[ 0,  1,  2,  3],
#        [ 4,  5,  6,  7],
#        [ 8,  9, 10, 11]])
print( b.sum() ) #总和 66
print( b.sum(axis=0) ) #列求和 array([12, 15, 18, 21])
b.sum(axis=1) #行求和 array([ 6, 22, 38])
b.cumsum(axis=1) #每一行的累加
# array([[ 0,  1,  3,  6],
#        [ 4,  9, 15, 22],
#        [ 8, 17, 27, 38]])




(5)通用函数
NumPy提供很多数学函数，如sin, cos, and exp，统称通用函数“universal functions”(ufunc)。作用于每个元素，输出为array。
>>> B = np.arange(3)
>>> B
array([0, 1, 2])
>>> np.exp(B)
array([ 1.        ,  2.71828183,  7.3890561 ])
>>> np.sqrt(B)
array([ 0.        ,  1.        ,  1.41421356])
>>> C = np.array([2., -1., 4.])
>>> np.add(B, C)
array([ 2.,  0.,  6.])






========================================
|-- numpy 索引、切片、迭代(Indexing, Slicing and Iterating)
----------------------------------------
1. 一维数组可以像list和其他python序列一样索引、切片、迭代。

a=np.arange(10)**3;a
# array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])

a[2] #8 第一个下标是0
a[2:5] # 有头2无尾5 array([ 8, 27, 64])

a[:6:2] = -1000 # equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000
a
# array([-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,
         729])
a[ : :-1]  # reversed a		 
# array([  729,   512,   343,   216,   125, -1000,    27, -1000,     1,
       -1000])
for i in a:
     print(i**(1/3.))




2. 多维数组，则每个轴可以有一个index。
>>> def f(x,y):
...     return 10*x+y
...
>>> b = np.fromfunction(f,(5,4),dtype=int)
>>> b
array([[ 0,  1,  2,  3],
       [10, 11, 12, 13],
       [20, 21, 22, 23],
       [30, 31, 32, 33],
       [40, 41, 42, 43]])
>>> b[2,3]
23
>>> b[0:5, 1]            # each row in the second column of b
array([ 1, 11, 21, 31, 41])
>>> b[ : ,1]             # equivalent to the previous example
array([ 1, 11, 21, 31, 41])
>>> b[1:3, : ]            # each column in the second and third row of b
array([[10, 11, 12, 13],
       [20, 21, 22, 23]])

#当维度少于实际维度时，则认为剩余维度为全部。
b[-1]     # the last row. Equivalent to b[-1,:]，或者用三个点 b[-1,...]
# array([40, 41, 42, 43])

三个点可以表达任意维度的全部：
 x[1,2,...] is equivalent to x[1,2,:,:,:],
 x[...,3] to x[:,:,:,:,3] and
 x[4,...,5,:] to x[4,:,:,5,:].





3. 迭代
对多维数组的迭代是相对于第一维度的。
for row in b:
     print(row)
# [0 1 2 3]
# [10 11 12 13]
# [20 21 22 23]
# [30 31 32 33]
# [40 41 42 43]

如果相对每一个元素做运算，则可以使用flat属性展开一个array
for element in b.flat:
     print(element)
# 0
# 1
# 2
# 3
# 10
# 11








========================================
Scipy: high-level scientific computing(教程)
----------------------------------------
https://docs.scipy.org/doc/numpy/user/quickstart.html

SciPy 官网：https://www.scipy.org/
SciPy 源代码：https://github.com/scipy/scipy


1.描述
SciPy (pronounced “Sigh Pie”) 是一个开源软件，用于数学、科研、工程计算。
依赖NumPy提供的方便快速的N维数组操作。
SciPy库建立在NumPy数组上，提供用户友好的、高效的数值路径：数据整合和优化。
它们在主流系统上都能跑，好安装，免费。
NumPy and SciPy使用方便，收到世界顶级科学家和工程师的信赖。
If you need to manipulate numbers on a computer and display or publish the results, give SciPy a try!

scipy包含致力于科学计算中常见问题的各个工具箱。它的不同子模块相应于不同的应用。像插值，积分，优化，图像处理，统计，特殊函数等等。



2. Scipy简介
文件输入和输出scipy.io
线性代数操作scipy.linalg
快速傅里叶变换scipy.fftpack
优化器scipy.optimize
统计工具scipy.stats

因为兼容等历史原因，scipy命名空间本身有很多numpy导入的函数(尝试 scipy.cos 就是 np.cos)。
建议任何时候都不要使用 import scipy，而要使用：
from scipy import stats
或
import scipy.io as spio



3. Scipy课程
http://www.scipy-lectures.org/
每个课程1-2h，由浅入深。

SciPy Tutorial
https://docs.scipy.org/doc/scipy/reference/tutorial/index.html
https://docs.scipy.org/doc/scipy/reference/tutorial/
https://docs.scipy.org/doc/scipy/reference/

中文：
https://www.jianshu.com/p/1a3db06e786d

Scipy有很多子模块可以应对不同的应用，例如插值运算，优化算法、图像处理、数学统计等。
https://blog.csdn.net/q583501947/article/details/76735870







========================================
pandas: 数据清洗 powerful Python data analysis toolkit (df可保存到excel文件中)
----------------------------------------
1.简介
官网： http://pandas.pydata.org/
文档：http://pandas.pydata.org/pandas-docs/stable/
Cookbook: http://pandas.pydata.org/pandas-docs/stable/cookbook.html#cookbook

10min入门 https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html
中文：https://www.yiibai.com/pandas/python_pandas_series.html


安装
$ conda install pandas
或
$ pip install pandas
$ pip install --upgrade pandas


pandas 解决什么问题？
python善于数据整理和预处理，不太擅长数据分析和建模，pandas弥补了这一点。
对于线性拟合和panel回归之外的建模，请使用statsmodels and scikit-learn包。
距离Python成为统计建模环境的一类公民还很远，我们正在努力。


pandas包含的数据类型：Series和DataFrame。
 - Series：一维数组，与Numpy中的一维array类似。二者与Python基本的数据结构List也很相近。Series如今能保存不同种数据类型，字符串、boolean值、数字等都能保存在Series中。
 - Time- Series：以时间为索引的Series。
 - DataFrame：二维的表格型数据结构。很多功能与R中的data.frame类似。可以将DataFrame理解为Series的容器。
 - Panel ：三维的数组，可以理解为DataFrame的容器。

我们重点学习DataFrame






2. 10分钟入门
http://pandas.pydata.org/pandas-docs/stable/10min.html
首先导入pandas库，一般都会用到numpy库，所以我们先导入备用：

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt #可能画图

(1)创建对象
https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html

nlist=['artical 1','a20','a30','a40','a50']
plist=[10,20,30,40,50]
clist=['评论1','评论2','评论3','评论4','评论5']

df=pd.DataFrame( data={'name':nlist, 'price':plist, 'comment':clist} )
#print(df.dtypes)
df
## 结果
# 	name	price	comment
# 0	artical 1	10	评论1
# 1	a20	20	评论2
# 2	a30	30	评论3
# 3	a40	40	评论4
# 4	a50	50	评论5

#转置行和列 https://blog.csdn.net/u013817676/article/details/94861359
df2=df.stack();
#print(df2) #将df格式从表格形式转化成了花括号结构
df3=df2.unstack(0) #行列转置，将第二行的列索引转化成行索引
df3
# 	   0	1	2	3	4
# name	artical 1	a20	a30	a40	a50
# price	10	20	30	40	50
# comment	评论1	评论2	评论3	评论4	评论5

### 最简单的转置
df.T





(2)用pandas筛选annovar结果文件
ex=pd.read_csv("EX23_.hg19_multianno.csv", na_values=["."]) #读取csv文件，并填充空值
ex

ex.shape #(628993, 88)

ex.dtypes

ex=ex.fillna(0) #用0填充na值

#测试语句
tmp=ex["1000g2015aug_all"].iloc[50:60]
print(tmp)
tmp<0.01

#filter1:
print( ex["Func.refGene"].value_counts() ) #对某一列进行计数
ex2=ex[ex["Func.refGene"].isin(['exonic',"exonic;splicing","splicing"])] #对一列进行筛选
ex2.shape #(25347, 88)

#filter2:
ex3=ex2[ (ex2["1000g2015aug_all"]<0.01) & (ex2['1000g2015aug_eas']<0.01) & (ex2['esp6500siv2_all']<0.01) \
        & (ex2['ExAC_ALL']<0.01)& (ex2['ExAC_EAS']<0.01)] #对一列进行筛选
ex3.shape #(1484, 88)

#filter?:是不是要挑出来 非同意突变
ex3["ExonicFunc.refGene"].value_counts()

#过滤后的结果，保存到csv中
ex3.to_csv("EX23_.hg19_multianno.filter1_2.csv")





(3) 保存到excel的sheet中
1)
writer=pd.ExcelWriter('titanic.xlsx')
#
df.to_excel(writer, sheet_name="titanic")
#
df2=df.loc[0:100,]
df2.to_excel(writer, sheet_name="titanic2")
#
writer.save()




2)
# 保存到excel中 pip install openpyxl
with pd.ExcelWriter('aaa.xlsx') as writer:
    df.to_excel(writer, sheet_name="aaa")

# 简洁形式
df=pd.DataFrame(data={'name':nlist, 'price':plist})
df.to_excel(xlsName, sheet_name=sheet_name)

#更复杂的形式：合并2个数据框
#df1 = pd.DataFrame(nlist,columns=['product'])
#df2 = pd.DataFrame(plist,columns=['price'])
#df3 = pd.concat([df1,df2],axis=1,ignore_index=False)
#df3.to_excel('aaa.xlsx',sheet_name='aaa')









3.python:pandas 合并多个DataFrame
https://www.jianshu.com/p/5ecea164cec6

http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.merge.html
 - merge 左右合并
 - join
 

 - append 上下合并
 - concat





========================================
|-- pandas 读取文件(文本/excel/mysql)、数据结构(Series/DataFrame)
----------------------------------------
视频:
https://www.bilibili.com/video/BV1UJ411A7Fs?p=1 从入门到实践(todo:3,)
https://www.bilibili.com/video/BV16E411G7sd?p=1 简介快速入门(done)

英文视频:
https://www.bilibili.com/video/BV1zA411b7Ly?from=search&seid=7102611799471868216




使用jupyter演示。
首先引入库
import pandas as pd;



1. 读取数据
数据类型	说明	pandas读取方法
csv/tsv/txt 逗号、tab分割的纯文本文件 pd.read_csv()
excel	微软xls/xlsx文件 pd.read_excel()
mysql 关系型数据库 	pd.read_sql()


例1: 读存文本文件
fpath="xx.csv"
ratings=pd.read_csv(fpath); #读取csv文件 help(pd.read_csv)查看更多参数
	# sep="\t" 指定分隔符为tab，默认为逗号;
	# header=None, 没有标题行
	
	# index_col=0, # 将第一列作为行名字
	
	# names=['pdate', 'pv', 'uv'] 给出列名
ratings.head();#查看前几行

ratings.shape #查看行列数
ratings.columns #查看列名

ratings.index #查看索引列

ratings.dtypes #查看每一列数据类型


例2: 读取excel
#excel文件和pandas的交互读写，主要使用到pandas中的两个函数,一个是pd.ExcelFile函数,一个是to_excel函数
(1)######
fpath="xx.xlsx"
pvuv=pd.read.excel(fpath);

(2)######
import pandas as pd
#使用pandas读取excel文件
xls_file=pd.ExcelFile('./data/workbook.xls')
xls_file.sheet_names#显示出读入excel文件中的表名字
table1=xls_file.parse('first_sheet')
table2=xls_file.parse('second_sheet')

xlsx_file=pd.ExcelFile("./demo.xlsx")
x1=xlsx_file.parse(0)
x2=xlsx_file.parse(1)

#excel文件的写出
#data.to_excel("abc.xlsx",sheet_name="abc",index=False,header=True)  #该条语句会运行失败，原因在于写入的对象是np数组而不是DataFrame对象,只有DataFrame对象才能使用to_excel方法。

DataFrame(data).to_excel("abc.xlsx",sheet_name="123",index=False,header=True)







例3: 读取mysql
import pymysql
conn=pymysql.connect(
	host='127.0.0.1',
	user='root',
	password="123456",
	database='test',
	charset='utf8'
)

mysql_page=pd.read_sql('select * from tableName', con=conn)
mysql_page







2. pandas的数据结构: 
DataFrame 二维数据，整个表格，多行多列;
Series 一维数据，一行或一列；

竖着为 df.columns;
横着为 df.index;

(1) Series例子
例1: a=pd.Series([1,2,3,4,5]); 默认三个参数 data,index默认是从0开始的编号,dtype
a
# 0    1
# 1    2
# 2    3
# 3    4
# 4    5
# dtype: int64

加更多参数
a=pd.Series([1,2,3,4,5], index=['a','b','c','d','e'], dtype=float);
a
# a    1.0
# b    2.0
# c    3.0
# d    4.0
# e    5.0
# dtype: float64



例2: 也可以使用numpy作为输入
import numpy as np;
a=np.arange(5);
pd.Series(a)
结果同例1。


例3: 传入字典
dic={'name':'Lee', 'gender':'M', 'age':18}
pd.Series(dic) #key变索引，value变data; 如果这里再次设置index则会覆盖字典的key
# name      Lee
# gender      M
# age        18
# dtype: object


例4: 当一个值，却多个索引时
pd.Series(5, [0,1,10])
# 0     5
# 1     5
# 10    5
# dtype: int64

#pd.Series([3,5], [0,1,10,100]) 报错 Length of passed values is 2, index implies 4





(2) DataFrame数据结构，和R的data.frame类似

例1: 创建数据框
a=np.random.randint(0,10,(2,3)) #2行3列
pd.DataFrame(a, index=['a', 'b'], columns=['x','y','z']) #定义index行名，columns列名
#	x	y	z
#a	0	5	1
#b	6	3	2


例2: 传入字典 
population={'beijing':1000, 'shanghai':1200,'guangzhou':999}
a=pd.Series(population)
b=pd.DataFrame(a) ##直接传入字典会报错；
#传入index=population.keys()输出也是不正确的; pd.DataFrame(population, index=population.keys())
print(a)
b
# beijing      1000
# shanghai     1200
# guangzhou     999
# dtype: int64
#
#            0
# beijing	1000
# shanghai	1200
# guangzhou	999

pd.DataFrame(a, columns=['population']) #可以修改列名
# 	   population
# beijing	1000
# shanghai	1200
# guangzhou	999

#如果非要传入字典，也可构建字典形式的参数:
pd.DataFrame( {'data2':population} )
# 	      data2
# beijing	1000
# guangzhou	999
# shanghai	1200

#再补充一个json数据，key要一致，则构建两列数据框：
gdp={'beijing':1, 'shanghai':1.5,'guangzhou':3}
pd.DataFrame( {'population':population, 'gdp':gdp} )
#	population	gdp
#beijing	1000	1.0
#guangzhou	999	3.0
#shanghai	1200	1.5

#还可以添加一个常数列
pd.DataFrame( {'population':population, 'gdp':gdp, 'country':'China'} )
#	   population	gdp	country
# beijing	1000	1.0	China
# guangzhou	999	3.0	China
# shanghai	1200	1.5	China






3. 属性
a=pd.DataFrame( {'population':population, 'gdp':gdp} )
a
#	population	gdp
#beijing	1000	1.0
#guangzhou	999	3.0
#shanghai	1200	1.5

a.values
# array([[1.00e+03, 1.00e+00],
#        [9.99e+02, 3.00e+00],
#        [1.20e+03, 1.50e+00]])

a.index #获取行名
# Index(['beijing', 'guangzhou', 'shanghai'], dtype='object')

a.columns #获取列名
# Index(['population', 'gdp'], dtype='object')

a.shape #(3, 2) 3行2列

a.size #几个元素 6

a.dtypes #每列数据的类型
# population      int64
# gdp           float64
# dtype: object






========================================
|-- 索引、切片、赋值、新增列/行、对行列排序
----------------------------------------
数据接上文
a
# 	   population	gdp
# beijing	1000	1.0
# guangzhou	999	3.0
# shanghai	1200	1.5


1. 如何取一列? 直接使用[]
a['gdp'] #取列名为gdp的一列
# beijing      1.0
# guangzhou    3.0
# shanghai     1.5
# Name: gdp, dtype: float64

或者使用点号
a.gdp #同上




2. 如何取出一行 loc[]
(1)
a.loc['beijing'] #注意是方括号，不是圆括号！
# population    1000.0
# gdp              1.0
# Name: beijing, dtype: float64


#取多行数据
a.loc[ ['beijing', 'guangzhou'] ] #注意输入的是数组形式
#	  population	gdp
# beijing	1000	1.0
# guangzhou	999	3.0

#如果不是数组呢
a.loc[ 'beijing', 'guangzhou' ]
# 报错 'the label [guangzhou] is not in the [index]' 说明第二个参数要是列
a.loc[ 'beijing', 'population' ] #1000 精确返回 beijing行 population列的数据



(2) 切片的方式取出多行，冒号
a.loc[ 'beijing':'guangzhou' ]
# 	  population	gdp
# beijing	1000	1.0
# guangzhou	999	3.0


(3)还可以使用数字编号指定行
a.iloc[0] #第一行
# population    1000.0
# gdp              1.0
# Name: beijing, dtype: float64

a.iloc[1] #第二行
# population    999.0
# gdp             3.0
# Name: guangzhou, dtype: float64

a.iloc[[0,2]] #第1,3行
# 	   population	gdp
# beijing	1000	1.0
# shanghai	1200	1.5




3. 取出一个具体的数值，行列交叉
(1)
a.loc[ 'shanghai', 'gdp' ] #1.5
a.iloc[ 2, 1] #1.5

(2) 按照numpy数组形式取值
print(type(a.values)) #<class 'numpy.ndarray'> 转为numpy类
a.values[2,1] #1.5 
a.values[2][1] #1.5


(3) iloc切片方式
a.iloc[:2, :] #前0,1行，全部列
#	population	gdp
#beijing	1000	1.0
#guangzhou	999	3.0


#切片a:b是一个[a,b)区间
t1=[10,1,2,3,4,5,6,7]
print( t1[0:4])
t1[1:4] # 左闭右开区间



4. 对某一列按条件筛选
a.gdp>1
# beijing      False
# guangzhou     True
# shanghai      True
# Name: gdp, dtype: bool

a[a.gdp>1]
# 	  population	gdp
# guangzhou	999	3.0
# shanghai	1200	1.5

a[a.gdp==1.5]
#	  population	gdp
# shanghai	1200	1.5




5. 赋值
(1)修改某个值，就是使用loc，iloc等定位到元素，然后就可以赋值了
a.iloc[1,1] #3
a.iloc[1,1]=3.2 #赋值

a
#	  population	gdp
# beijing	1000	1.0
# guangzhou	999	3.2 #这里已经修改了
# shanghai	1200	1.5






6. 新增行或列
(1) 新增一列
先新建一个Series，行标题index和原来一样
s=pd.Series([10,20,30], index=['beijing', 'shanghai', 'guangzhou'])
s
# beijing      10
# shanghai     20
# guangzhou    30
# dtype: int64


a['cName']=s; #指定列名
a
# 	  population	gdp	cName
# beijing	1000	1.0	10
# guangzhou	999	3.2	30
# shanghai	1200	1.5	20



(2) 新增一行
a.loc['zhengzhou'] = [1300,0.8,9]
a
# 	  population	gdp	cName
# beijing	1000.0	1.0	10.0
# guangzhou	999.0	3.2	30.0
# shanghai	1200.0	1.5	20.0
# zhengzhou	1300.0	0.8	9.0

(3) 通过合并2个数据框，新增一行或多行
df1=pd.DataFrame([888,0.9,9.5]).T #默认是列向量，变为行向量;
df1.columns = a.columns # 修改df1的column和a的一致
df1.index=['nj'] #修改行名
df1
#   population	gdp	cName
# nj	888.0	0.9	9.5


# 把两个dataframe合并，需要设置 ignore_index=True
#pd.concat([a,df1],ignore_index=True) #ignore_index就会损失掉index
pd.concat([a,df1])
#	  population	gdp	cName
# beijing	1000.0	1.0	10.0
# guangzhou	999.0	3.2	30.0
# shanghai	1200.0	1.5	20.0
# zhengzhou	1300.0	0.8	9.0
# nj	888.0	0.9	9.5





7. 对行列排序 
(1)# 加载数据
print(flights.shape)
flights.head()
##	year	month	passengers
#0	1949	January	112
#1	1949	February	118
#2	1949	March	132


# 交叉表，x=年,y=月，中间数字是乘客人数
df=flights.pivot('month', 'year', 'passengers')
print(df)
# year       1949  1950  1951  1952  1953  1954  1955  1956  1957  1958  1959  \
# month                                                                         
# April       129   135   163   181   235   227   269   313   348   348   396   
# August      148   170   199   242   272   293   347   405   467   505   559 

(2)# 行的顺序不对
df.index
# Index(['April', 'August', 'December', 'February', 'January', 'July', 'June',

# 怎么调整月份顺序
df2=df.reindex(['January','February','March','April','May','June','July',
                'August','September','October','November','December'])
print(df2)
ax2=sns.heatmap(df2)


plt.figure(figsize=(8,5))
sns.heatmap(df2, annot=True, fmt='d') #字体格式d，显示比较正常


(3) # 对列进行倒序
df2.columns
# Int64Index([1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959,

df2.columns[::-1] #Int64Index([1960, 1959, 1958, 1957, 1956, 1955, 1954, 1953, 1952, 1951, 1950,

df3=df2.loc[:, df2.columns[::-1]]
df3

# year	1960	1959	1958	1957	1956	1955	1954	1953	1952	1951	1950	1949
# month												
# January	417	360	340	315	284	242	204	196	171	145	115	112
# February	391	342	318	301	277	233	188	196	180	150	126	118

sns.heatmap(df3, cmap="YlGnBu")






ref:
https://www.bilibili.com/video/BV16E411G7sd?p=5



========================================
|-- 数据查看
----------------------------------------
#先构建数据
dates=pd.date_range(start="2020-1-1", periods=6)
dates
#DatetimeIndex(['2020-01-01', '2020-01-02', '2020-01-03', '2020-01-04',
#               '2020-01-05', '2020-01-06'],
#              dtype='datetime64[ns]', freq='D')

df=pd.DataFrame(np.random.randint(0,10,(6,4)), index=dates, columns=['A','B','C','D'])
df
# 	           A	B	C	D
# 2020-01-01	5	4	7	2
# 2020-01-02	7	6	9	2
# 2020-01-03	0	6	6	8
# 2020-01-04	9	2	5	5
# 2020-01-05	8	2	5	6
# 2020-01-06	8	3	4	9

1. 查看每一列的数据的特征
df.describe() #统计角度
#           A              B          C         D
# count	6.000000	6.000000	6.000000	6.000000
# mean	6.166667	3.833333	6.000000	5.333333
# std	3.311596	1.834848	1.788854	2.943920
# min	0.000000	2.000000	4.000000	2.000000
# 25%	5.500000	2.250000	5.000000	2.750000
# 50%	7.500000	3.500000	5.500000	5.500000
# 75%	8.000000	5.500000	6.750000	7.500000
# max	9.000000	6.000000	9.000000	9.000000


df.info() #对每一类的描述(内存角度)
# <class 'pandas.core.frame.DataFrame'>
# DatetimeIndex: 6 entries, 2020-01-01 to 2020-01-06 #对索引的描述
# Freq: D
# Data columns (total 4 columns): #对每一列的数据表述
# A    6 non-null int64
# B    6 non-null int64
# C    6 non-null int64
# D    6 non-null int64
# dtypes: int64(4)
# memory usage: 240.0 bytes



2. 查看前几行、后几行
df.head() #默认前5行
df.head(2)

df.tail() #末尾5行



3. 转置行和列
df.T


4. 排序
df.sort_index(axis=1, ascending=False) #按照列名排序，倒序
# 	           D	C	B	A
# 2020-01-01	2	7	4	5
# 2020-01-02	2	9	6	7
# 2020-01-03	8	6	6	0
# 2020-01-04	5	5	2	9
# 2020-01-05	6	5	2	8
# 2020-01-06	9	4	3	8

df.sort_index(axis=0, ascending=False) #按照行名排序，倒序
#               A	B	C	D
# 2020-01-06	8	3	4	9
# 2020-01-05	8	2	5	6
# 2020-01-04	9	2	5	5
# 2020-01-03	0	6	6	8
# 2020-01-02	7	6	9	2
# 2020-01-01	5	4	7	2


df.sort_values('C') #按照"C"列排序
#          A	B	C	D
# 2020-01-06	8	3	4	9
# 2020-01-04	9	2	5	5
# 2020-01-05	8	2	5	6
# 2020-01-03	0	6	6	8
# 2020-01-01	5	4	7	2
# 2020-01-02	7	6	9	2



========================================
|-- pandas 的计算、缺失值处理
----------------------------------------

1. 矩阵的运算
(1)和常量的加减法
a=pd.DataFrame([1,2,3])
a #3行1列的列向量
#      0
#0	1
#1	2
#2	3

a+7 #向量每个元素都增加7
# 	0
# 0	8
# 1	9
# 2	10

a.add(b) #结果同上。


(2) 矩阵和矩阵的加减法
b=pd.DataFrame([4,5,6])
a+b #就是对应元素相加
#	0
#0	5
#1	7
#2	9


(3) 矩阵的乘法
c=pd.DataFrame(np.random.randint(10, size=(1,3))) #1行3列
c
#	0	1	2
#0	7	1	3


d=a@c
d
# 	0	1	2
# 0	7	1	3
# 1	14	2	6
# 2	21	3	9
或者 a.dot(c)


(4)再次验证加法add()方法:
# 矩阵相加，如果维度不同，则缺失部分补0；如果直接使用+，则维度不同的地方直接NaN
a+d
#  	0	1	2
# 0	8	NaN	NaN
# 1	16	NaN	NaN
# 2	24	NaN	NaN

a.add(d, fill_value=0)
#      0	1	2
# 0	8	1.0	3.0
# 1	16	2.0	6.0
# 2	24	3.0	9.0







2. 缺失值的处理
创建一个有缺失值的矩阵
# pd.DataFrame( np.arange(9).reshape([3,3]) )
d.iloc[:2,2]=np.nan
d
#	 0	1	2
#0	7	1	NaN
#1	14	2	NaN
#2	21	3	9.0

(1) 直接丢掉含缺失值的行
d.dropna()
#	0	1	2
#2	21	3	9.0

(2) 直接丢掉含缺失值的列
d.dropna(axis=1)
#	0	1
# 0	7	1
# 1	14	2
# 2	21	3


(3) 如果只丢掉全部都是NaN的列呢？有一个NaN还可以接受
d.dropna(axis=1, how="all") #any默认, all
则返回值和原矩阵一行，因为没有全是NaN的列。


(4) 如果想挽救缺失值呢，NaN都填充为0
d.fillna(0)
#	0	1	2
# 0	7	1	0.0
# 1	14	2	0.0
# 2	21	3	9.0
注意: 原始的矩阵d并没有被改变！


(5) 查找缺失值
houseprice.isnull() #元素级别的判断，把对应的所有元素的位置都列出来，元素为空或者NA就显示True，否则就是False
houseprice.isnull().any() #列级别的判断，只要该列有为空或者NA的元素，就为True，否则False
missing=houseprice.columns[houseprice.isnull().any()].tolist() #将为空或者NA的列找出来
houseprice[missing].isnull().sum()　#将列中为空或者NA的个数统计出来

houseprice[['LotFrontage','Alley']][houseprice['Alley'].isnull()==True]  #从LotFrontage 和Alley 列中进行选择行，选择Alley中数据为空的行。主要用来看两个列的关联程度，是不是大多同时为空。

houseprice['Fireplaces'][houseprice['FireplaceQu'].isnull()==True].describe()   #对筛选出来的数据做一个描述，比如一共多少行，均值、方差、最小值、最大值等等。




ref:
https://www.cnblogs.com/gczr/p/6761613.html




========================================
|-- 合并(concat)和对齐(merge)
----------------------------------------
1. concat就是简单合并
a=pd.DataFrame(np.zeros([3,4]), columns=['a', 'b', 'c', 'd']);
b=pd.DataFrame(np.ones([3,4]), columns=['a', 'b', 'c', 'd']);
print(a)
b
#      a    b    c    d
# 0  0.0  0.0  0.0  0.0
# 1  0.0  0.0  0.0  0.0
# 2  0.0  0.0  0.0  0.0
# 
# 	 a	b	c	d
# 0	1.0	1.0	1.0	1.0
# 1	1.0	1.0	1.0	1.0
# 2	1.0	1.0	1.0	1.0


(1) 垂直合并
pd.concat([a,b])
#	a	b	c	d
#0	0.0	0.0	0.0	0.0
#1	0.0	0.0	0.0	0.0
#2	0.0	0.0	0.0	0.0
#0	1.0	1.0	1.0	1.0
#1	1.0	1.0	1.0	1.0
#2	1.0	1.0	1.0	1.0


#如果不想要行标题，设置ignore_index参数，行标题变成递增的编号
pd.concat([a,b], ignore_index=True)


(2) 水平合并
pd.concat([a,b], axis=1)
#	a	b	c	d	a	b	c	d
# 0	0.0	0.0	0.0	0.0	1.0	1.0	1.0	1.0
# 1	0.0	0.0	0.0	0.0	1.0	1.0	1.0	1.0
# 2	0.0	0.0	0.0	0.0	1.0	1.0	1.0	1.0



(3) 如果待合并的矩阵的行名和列名不一致，怎么合并？
a2=pd.DataFrame(np.zeros([3,4]),index=[0,1,2], columns=['a', 'b', 'c', 'd']);
b2=pd.DataFrame(np.ones([3,4]),index=[1,2,3], columns=['c', 'd','E','F']);
print(a2)
b2
#     a    b    c    d
#0  0.0  0.0  0.0  0.0
#1  0.0  0.0  0.0  0.0
#2  0.0  0.0  0.0  0.0
#
#	c	d	E	F
#1	1.0	1.0	1.0	1.0
#2	1.0	1.0	1.0	1.0
#3	1.0	1.0	1.0	1.0

pd.concat([a2,b2], axis=1) #水平合并(水平不做调整)
# 	a	b	c	d	c	d	E	F #可见，列名重复了，列名仅仅是简单平凑一起。
# 0	0.0	0.0	0.0	0.0	NaN	NaN	NaN	NaN
# 1	0.0	0.0	0.0	0.0	1.0	1.0	1.0	1.0
# 2	0.0	0.0	0.0	0.0	1.0	1.0	1.0	1.0
# 3	NaN	NaN	NaN	NaN	1.0	1.0	1.0	1.0
#行名做了整合，相同的行名只出现一次，没有数据的填充NaN;



(4) 
c=pd.Series([1,2,3,4], index=['a', 'b', 'c', 'd'])
c
# a    1
# b    2
# c    3
# d    4
# dtype: int64

a2.append(c, ignore_index=True) #底部新增一行
# 	a	b	c	d
# 0	0.0	0.0	0.0	0.0
# 1	0.0	0.0	0.0	0.0
# 2	0.0	0.0	0.0	0.0
# 3	1.0	2.0	3.0	4.0
#注意 a2 本身没有被改变







2. merge的用法:按照某一列合并
(1)
a3=pd.DataFrame([[2,0],[3,1]], columns=['A','B'])
a3
#	A	B
#0	2	0
#1	3	1

b3=pd.DataFrame([[20,0],[30,1]], columns=['C','B'])
b3
#	C	B
#0	20	0
#1	30	1

pd.merge(a3,b3) #相当于中间列B是一个桥梁中介，类似于sql中的where a.id=b.uid;
#	A	B	C
#0	2	0	20
#1	3	1	30







========================================
|-- 分组(groupby)、数据透视表(stack/pivot)
----------------------------------------
1. 分组查看
df=pd.DataFrame({'key':list('ABCCBA'),
	'data1':range(6),
	'data2':range(20,26)
})
df.iloc[0,1]=4 #修改一个值
df

# 	key	data1	data2
# 0	A	4	20
# 1	B	1	21
# 2	C	2	22
# 3	C	3	23
# 4	B	4	24
# 5	A	5	25

(1) 
df.groupby('key') #<pandas.core.groupby.groupby.DataFrameGroupBy object at 0x7faac8f64fd0>
df.groupby('key').sum()
#	data1	data2
#key		
#A	9	45
#B	5	45
#C	5	45

df.groupby('key').mean()
# 	data1	data2
# key		
# A	4.5	22.5
# B	2.5	22.5
# C	2.5	22.5

df.groupby('key')['data1'].mean() #某一列的均值
#      key
# A    4.5
# B    2.5
# C    2.5
# Name: data1, dtype: float64


df.groupby('key')[['data1']].mean() #返回数据框的形式
# 	data1
# key	
# A	4.5
# B	2.5
# C	2.5



(2) 自定义统计函数
def func1(x):
	x['data1'] /= x['data1'].sum();
	return x;
df.groupby('key').apply(func1)
# 	key	data1	data2
# 0	A	0.444444	20
# 1	B	0.200000	21
# 2	C	0.400000	22
# 3	C	0.600000	23
# 4	B	0.800000	24
# 5	A	0.555556	25
#确实已经做了改变;







2. 数据透视表: stack/pivot

(1) 数据的格式

长格式: mysql方便存储，方便新增一行；不适合直接画图;
sample gene expression
1 1 10
1 2 200
1 3 99
2 1 20
2 2 9
2 3 106


宽格式: 人容易读懂，很容易画二维图
	  sample1 sample2
gene1   10      20
gene2   200      9
gene3   99      106

本文目的: 为了方便作图，如何把mysql中的长格式变为宽的二维交叉格式呢？
这个过程叫重塑或者透视。


melt 融化成长的;
cast 重塑成宽的。常用函数为 stack得到二维数据，pivot得到透视表。



(1)导入数据集
import seaborn as sns;

#titannic=sns.lead_dataset('titanic'); #报错，不起作用

#这是git clone到服务器上的文件
titanic = pd.read_csv("http://y.biomooc.com/wangjl/docs/seaborn-data/titanic.csv")
print(titanic.shape) #(891, 15)
titanic.head()
# survived  pclass	sex	age	sibsp	parch	fare  embarked	class	who adult_male deck	embark_town	alive	alone
# 0	0	3	male	22.0	1	0	7.2500	S	Third	man	True	NaN	Southampton	no	False
# 1	1	1	female	38.0	1	0	71.2833	C	First	woman	False	C	Cherbourg	yes	False
# 2	1	3	female	26.0	0	0	7.9250	S	Third	woman	False	NaN	Southampton	yes	True
# 3	1	1	female	35.0	1	0	53.1000	S	First	woman	False	C	Southampton	yes	False
# 4	0	3	male	35.0	0	0	8.0500	S	Third	man	True	NaN	Southampton	no	True


(2) 查看不同等级仓，不同性别 乘客的生存情况
titanic.pivot_table('survived', index='sex', columns='class')
# class    First	  Second	Third
# sex			
# female  0.968085	0.921053	0.500000
# male    0.368852	0.157407	0.135447

发现女性存活率高于男性，且随着仓位升高而升高。












========================================
******** Python可视化包 ********
----------------------------------------
https://www.jianshu.com/nb/30715100

seaborn，matplotlib，pychart包都可以。




========================================
matplotlib 可视化简介
----------------------------------------

1.使用Matplotlib，它是用Python写的类似Matlab的库，能实现Matlab的功能，而且画图的质量很高，可用于做论文发表。
(1) 教程
源代码：https://github.com/matplotlib/matplotlib
官网：https://matplotlib.org/

图片库：https://matplotlib.org/gallery/index.html
教程: https://matplotlib.org/tutorials/index.html#introductory

视频教程 https://www.bilibili.com/video/BV1Jx411L7LU?p=3
艺术家教程: https://www.jianshu.com/p/aeb1cdf269ea



(2).一般流程
定义分析目标，数据采集及预处理，数据分析挖掘，数据可视化。

(3)四个可视化目标：
分布：柱状图、散点图、概率密度曲线图
相关：散点图with相关系数、拟合曲线
构成：柱状图with不同颜色、饼图
比较：柱状图、分面





2.数据分析案例
(1)电影放映时间和入座率的时间序列模型；
(2)导航软件；
  全球飞机航线图；
(3)超市物品摆放；
  啤酒尿布案例。
  人口年龄的性别分布；
(4) 常见的可视化形式和工具
柱状图、折线图: 比较高低
分布散点图: 看趋势

(5) 常用的工具
分析工具: pandas, SciPy, numpy, sklearn;
绘图工具: matplotlib, Pychart, reportlab;
平台工具: Jupyter notebook, PyCharm;

Matplotlib 是Python的绘图库。
可以和 NumPy 一起使用，提供了一种有效的Matlab开源替代方案。
也可以和图形工具包一起使用，如PyQt和wxPython。




3. 安装
(1)安装 anaconda: Python环境和包管理工具，能切换Python版本。类似Java的Maven。
(2)安装 Jupyter Notebook: 基于网页的交互计算应用程序。可被用于全过程计算：开发、文档编写、运行代码和展示结果。
(3) 安装 matplotlib包。是Python的2D会图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版级别的图形。


我是使用的 pip安装的包。
Matplotlib需要配合numpy,scipy才能使用，使用pip安装。
$ pip install --user matplotlib




4. Hello world 绘图 
(1)黑窗口输入 jupyter notebook ，打开网页，新建py3文件；
(2)输入画图代码
import matplotlib.pyplot as plt
print('==load plt==', plt)

x=[1,2]
y=[3,4]
plt.bar(x,y)
plt.show() ## 画基本柱状图


(3) 画线条，点组成线
import matplotlib.pyplot as plt

import numpy as np;
x=np.linspace(-1,1,50)#[-1,1]均匀的取50个点，效果看，取5个点也一样
y=2*x+1;

plt.plot(x,y)
plt.show()


## 二次曲线
x=np.linspace(-1,1,50)#[-1,1]均匀的取50个点
y=x**2-0.2*x+1;

#
plt.plot(x,y)
plt.show()




5. 基本配置：如果不配置，可能中文不正常显示。
官网搜索 rcParams 参数，可见到详细参数意义。
常用设置：
(1)输出中文 
import matplotlib.pyplot as plt

import matplotlib as mpl
mpl.rcParams['font.sans-serif']=['SimHei'] #为了正常显示中文

x=[1,2]
y=[3,14]
plt.title("柱状图")
plt.bar(x,y)
plt.show()



(2) 正常输入坐标轴上的负数
import matplotlib.pyplot as plt

import matplotlib as mpl
mpl.rcParams['font.sans-serif']=['SimHei'] #为了正常显示中文
mpl.rcParams['axes.unicode_minus']=False #正常输入坐标轴上的负数

x=[1,2]
y=[-3,14]
plt.title("柱状图")
plt.bar(x,y)
plt.show()

(3) 修改线条宽度和类型
import matplotlib.pyplot as plt
%matplotlib inline
#
import matplotlib as mpl
mpl.rcParams['font.sans-serif']=['SimHei'] #为了正常显示中文
mpl.rcParams['axes.unicode_minus']=False #正常输入坐标轴上的负数
#
mpl.rcParams['lines.linewidth']=10 #修改线条宽度
mpl.rcParams['lines.linestyle']='--' #线条类型改为虚线

x=[1,2,3]
y=[-3,14,-9]
plt.title("折线图")
plt.plot(x,y)
plt.show()






6.快速入门教程
(1)Figure和Subplot
	figure相当于一个大绘图窗口; 调用一次plt.figure(num=1, )

(2)颜色、标记和线型
	color="red"
	linestyle="--" #虚线
	

(3)刻度、标签和图例
	设置标题、轴标签、刻度以及刻度标签
		plt.title("hist plot") #标题
		
	添加图例（legend）、注解以及在Subplot上绘图
		plt.text()

(4)将图表保存到文件
plt.savefig('filepath.png')
plt.savefig('filepath.png', dpi=400,bbox_inches='tight')

Figure.savefig参数
	fname：路径，包含设置文件格式（如.pdf等）
	dpi：图像分辨率，默认100
	facecolor、edgecolor：图像背景色，默认为’w’（白色）
	format：显示设置文件格式
	bbox_inches：图像需要保存的部分。‘tight’，将尝试剪除图像周围的空白部分

####






========================================
|-- 颜色(color, colormap/cmap)、标记、线型
----------------------------------------
1.简写例子
import matplotlib.pyplot as plt
import numpy as np

X=np.random.randn(30).cumsum()

plt.figure()
plt.plot(X, color='k')

plt.figure()
plt.plot(X, color='k', linestyle='dashed') #设置线型（linestyle）

plt.figure()
plt.plot(X, color='k', linestyle='dashed',marker='o') #设置标记(marker)



(1)
ax.plot(x, y, 'r–')
等价于 ax.plot(x, y, linestyle='–', color='r')

(2)
axes[0].plot(np.random.randint(0, 100, 50), 'ro--')
# 等价
axes[1].plot(np.random.randint(0, 100, 50), color='r', linestyle='dashed', marker='o')







2. 简写设置
(1)颜色（color 简写为 c）：
蓝色： 'b' (blue)
绿色： 'g' (green)
红色： 'r' (red)
蓝绿色(墨绿色)： 'c' (cyan) 青色
红紫色(洋红)： 'm' (magenta) 品红
黄色： 'y' (yellow)
黑色： 'k' (black)
白色： 'w' (white)


https://stackoverflow.com/questions/22408237/named-colors-in-matplotlib
1)## 所有可用的颜色的十六进制 
import matplotlib
i=0
for name, hex in matplotlib.colors.cnames.items():
    i+=1
    print(i, name, hex)
# 1 aliceblue #F0F8FF
# 2 antiquewhite #FAEBD7
# 3 aqua #00FFFF
#

plt支持的全部颜色(另一种显示方式): https://matplotlib.org/examples/color/named_colors.html



2)装了seaborn扩展的话，在字典seaborn.xkcd_rgb中包含所有的xkcd crowdsourced color names。如下：
plt.plot([1,2], lw=4, c=seaborn.xkcd_rgb['baby poop green'])


fig, ax = plt.subplots(figsize=(9.2, 5))
ax.set_xlim(0, 10)

i=-1
for cName,cHex in seaborn.xkcd_rgb.items():
    i+=1
    #print(cName, cHex) #怎么能把所有颜色和其hex值画出来呢？
#



3)把python和seaborn中支持的颜色都画出来，左边颜色块，右边颜色名字和16进制。
代码及效果图: http://www.biomooc.com/Python3/Python3-color.html





(2)点型（标记marker）：
. point
, pixel 像素
o circle 圆形
v 下三角形
^ 上三角形
< 左三角形
> 右三角

方形： 's'
加号： '+' 
叉形： 'x'
棱形： 'D'
细棱形： 'd'
三脚架朝下： '1'（像'丫'）
三脚架朝上： '2'
三脚架朝左： '3'
三脚架朝右： '4'
六角形： 'h'
旋转六角形： 'H'
五角形： 'p'
垂直线： '|'
水平线： '_'




(3)linestyle 简写为 ls
- or solid 实线
-- or dashed 虚线
-. or dashdot 虚点先
: or dotted 点线

'None' draw nothing
' ' or '' 什么也不绘画


ref:
https://blog.csdn.net/qq_40981268/article/details/89150614




========================================
|-- figure 和 一页多图(子图subplot)、图中图
----------------------------------------
1.plt.figure(num=3, figsize=(6,6)) 开始一个图形
其中2个可选参数 
num 图形编号
figsize 图像长宽


import matplotlib.pyplot as plt

import numpy as np;
x=np.linspace(-1,1,50)#[-1,1]均匀的取50个点

y1=2*x+1;
y2=x**2+1;

plt.figure() #一个图开始
plt.plot(x,y1)
plt.show()


plt.figure(num=3, figsize=(6,6)) #另一个图开始
plt.plot(x,y2,linewidth=3)
plt.plot(x,y1, color="red",linewidth=1, linestyle='--') #红色线,宽度3，虚线
plt.show()






2. 有多种画子图的方法

(1) subplot(nrow, ncol, num)
subplot前面俩参数指定的是一个画板被分割成的行和列，后面一个参数则指的是当前正在绘制的编号！
行优先开始数。2行2列就是先填充第1行(图1，图2)，再填充第二行(图3，图4)；
直接指定划分方式和位置，接着画图填充该位置。

下图是第一行2个图，第二行一个大图。
x=np.arange(0,2,0.1);
y=np.sin(x*np.pi);

plt.subplot(2,2,1)#2行2列，第一个图
plt.plot(x,y,'b--') #blue 虚线
plt.ylabel('y1')

plt.subplot(2,2,2)#2行2列，第二个图
plt.plot(x,y,'r--') #red 虚线
plt.ylabel('y2')

plt.subplot(2,1,2) #2行1列，第2个
plt.plot(x,y, 'm--')
plt.ylabel('y3')

plt.show()




(2)subplots(nrow,ncol) 缺点: 不那么灵活，无法自由组合跨行跨列。
这个方法更直接。事先先把画板分隔好。

x=np.arange(0,2,0.1)
y=np.sin(x*np.pi)

figure,ax=plt.subplots(2,2) #事先先把画板分隔好
ax[0][0].plot(x,y,'r*')
ax[0,1].plot(x,y,'b--')
ax[1,0].plot(x,4*y,'m--') 
#第四个区域没有，就空着了
#figure


## 然后可以接着指定
ax[1,1].plot(x,4*y,'k--') 
figure





(3) 这个貌似可以任意占位
例子的结构:
1 1 1
2 2 3
4 5 3

X=np.arange(0,1,0.1)
Y=np.sin(X*2*np.pi)

plt.figure()
ax1=plt.subplot2grid( (3,3),(0,0), rowspan=1, colspan=3) #3行3列，从0 0开始，跨1行3列
ax1.plot([0,1], [0,1])
ax1.set_title('Title1')
#
ax2=plt.subplot2grid( (3,3),(1,0), rowspan=1, colspan=2); #从1行0列开始，跨1行2列
ax2.plot([0,1], [1,10], 'r--')
#
ax3=plt.subplot2grid( (3,3),(1,2), rowspan=2, colspan=1); #从1行2列开始，跨2行1列
ax3.plot(X,Y, 'g--')
#
ax4=plt.subplot2grid( (3,3),(2,0)); #从2行0列开始，默认跨1行1列
ax4.plot(X,Y, 'b--')
#
ax5=plt.subplot2grid( (3,3),(2,1)); #从2行0列开始，默认跨1行1列
ax5.plot(X,Y, 'k--') #black


(4) 任意占位， 效果同上
import matplotlib.gridspec as gridspec

plt.figure()
gs=gridspec.GridSpec(3,3) #3行3列

ax1=plt.subplot(gs[0,:]) #第0行，所有列
ax2=plt.subplot(gs[1,:2]) #第1行，第0,1列
ax3=plt.subplot(gs[1:,2]) #第1行之后(就是1,2行)，第2列
ax4=plt.subplot(gs[2,0]) #第2行，第0列
ax5=plt.subplot(gs[2,1]) #第2行，第1列






3. 图中图

# 大图中嵌入小图: 左上角、右下角各加入一个小图
fig=plt.figure()
X=np.linspace(0,10,10)
Y=np.random.normal(0,1, 10)

# 定位
left,bottom,width,height=0.1,0.1,0.8,0.8 #都是百分比
ax1=fig.add_axes([left,bottom,width,height]) #主图的位置
# 画图
ax1.plot(X,Y, 'r')
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_title('title1')

###
# 定位
left,bottom,width,height=0.15,0.6,0.25,0.25
ax2=fig.add_axes([left,bottom,width,height]) #主图的位置
# 画图
ax2.plot(Y, X, 'b--')
ax2.set_axis_off() #不要坐标轴
ax2.set_title('title2(inside)')

### 换一种加图的写法
left,bottom,width,height=0.6,0.2,0.25,0.25
plt.axes([left,bottom,width,height]) #主图的位置
# 画图
plt.plot(X, Y[::-1], 'g--') #Y逆序一下

plt.xlabel('')
plt.ylabel('y2')
plt.title('title3(inside)')

plt.show()



ref:
https://www.jianshu.com/p/de223a79217a




========================================
|-- 坐标轴与刻度、主次坐标轴
----------------------------------------

1.设置轴显示区域、轴标签、刻度以及刻度标签、隐藏top-right边界、移动坐标轴位置
(1)
轴标签
	plt.xlabel('x label')
	plt.ylabel('y label')

自定义x轴刻度
	plt.xticks(new_ticks) 
	#自定义y轴刻度显示内容
	plt.yticks([原始刻度值], [要显示的刻度值])

坐标轴显示区域
	plt.xlim(-1,3) 
#



##### 完整代码
plt.figure()
plt.plot(x,y2)
plt.plot(x,y1, 'r--', linewidth=1)

plt.xlim(-1,3) #坐标轴显示区域
plt.ylim(-2,8)

plt.xlabel('I am x label') #坐标轴标签
plt.ylabel('This is y label')

plt.title("probability of distance") #图片标题

new_ticks=np.linspace(-1,3,5) 
print(new_ticks)
plt.xticks(new_ticks) #自定义x轴刻度
#自定义y轴刻度显示内容
plt.yticks(
    [0,3,6,9], #可以自定义刻度
    [ 'bad', 'normal', 'good', 'very good']
)

plt.show()






(2)显示成更好看的字体，把字符前后加$符，同时空格要转义;
plt.yticks(
    [0,3,6,9],
    [ r'$bad$', r'$normal\ \alpha$', r'$good$', r'$very\ good$']
)




(3) 获取当前坐标轴，并移动其位置
# gca=get current axis
ax=plt.gca();

# 获得图片的4个边框
ax.spines['right'].set_color('none') #右边的框消失掉了
ax.spines['top'].set_color('none') #上边的框消失掉了

ax.xaxis.set_ticks_position('bottom') #设置x轴为底边
ax.yaxis.set_ticks_position('left') #y轴为左边

#移动坐标轴
ax.spines['bottom'].set_position(('data', -1))
ax.spines['left'].set_position(('data', 0))




### 完整实例
x=np.linspace(-3,3,50)
y1=2*x+1
y2=x**2-2*x+1

plt.figure()
plt.plot(x,y2)
plt.plot(x,y1, 'r--', linewidth=1)

plt.xlim(-1,3) #坐标轴显示区域
plt.ylim(-0.5,5)

# gca=get current axis
ax=plt.gca();
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none') #上边的框消失掉了

ax.xaxis.set_ticks_position('bottom') #设置x轴为底边
ax.yaxis.set_ticks_position('left') #y轴为左边

#移动坐标轴; 除了'data'，还可以填'outward'(todo?),'axes'(按百分比)
ax.spines['bottom'].set_position(('data', 0)) #x轴移动到y=0位置
ax.spines['left'].set_position(('data', 0)) #y轴移动到x=0位置

plt.show()






2. 设置tick的能见度 
#如果图盖住了坐标轴刻度，想让刻度可见
#1.plt.plot()中设置zorder=1；2.后面for循环汇总设置label.set_zorder(2)
#zorder相当于重叠程度，上面的遮挡着下面的;

x=np.linspace(-3,3,50)
y1=0.5*x
y2=x**2-2*x+1

plt.figure()
plt.plot(x,y2, label='up',zorder=1) #标上zorder=1
plt.plot(x,y1, 'r--', linewidth=10, label='down',zorder=1)

plt.xlim(-1,3)
plt.ylim(-1,5)


#移动坐标轴
ax=plt.gca();
ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none') #上边的框消失掉了

ax.xaxis.set_ticks_position('bottom') #设置x轴为底边
ax.yaxis.set_ticks_position('left') #y轴为左边

#移动坐标轴; 除了'data'，还可以填'outward'(todo?),'axes'(按百分比)
ax.spines['bottom'].set_position(('data', 0)) #x轴移动到y=0位置
ax.spines['left'].set_position(('data', 0)) #y轴移动到x=0位置


#调整坐标轴标签的不透明度
for label in ax.get_xticklabels()+ax.get_yticklabels():
    label.set_fontsize(12)
    #alpha=1不透明，0全透明
    label.set_bbox(dict(facecolor="white", edgecolor="None", alpha=0.7))
    label.set_zorder(2)

plt.show()







3. 主次坐标轴 
x=np.arange(0,10,0.1)
y1=0.05*x**2
y2=-y1;

fig,ax1=plt.subplots()
ax2=ax1.twinx() #相当于复制了一个x轴？Create a twin Axes sharing the xaxis.

ax1.plot(x, y1, 'g-')
ax2.plot(x, y2, 'b--')

ax1.set_xlabel('X_data')
ax1.set_ylabel("Y1", color='g')

ax2.set_ylabel('Y2', color='b')


plt.show()






========================================
|-- 标签和图例、标注/注解、标题
----------------------------------------
2.添加图例（legend）、注解以及在Subplot上绘图
(1) 默认图例
x=np.linspace(-3,3,50)
y1=2*x+1
y2=x**2-2*x+1

plt.figure()
plt.plot(x,y2, label='up') #标上label
plt.plot(x,y1, 'r--', linewidth=1, label='down')

plt.legend() #默认的参数

plt.show()


(2)调整图例的位置
plt.legend(loc="lower right") #位置参数loc默认为'best'，自动找一个图少的角落



2) bbox_to_anchor控制图例的位置
plt.legend(ncol=2,
           bbox_to_anchor=(1.04,0.5), #图形百分比(0,0)左下角， (1,1)右上方
           loc='center left', #边界盒子（bounding box）里面的方位
           markerscale =4, #图例点的放大倍数
           fontsize='small' ) 
#
#
legend 是放置在我们的坐标边界里面的一个东西，可以在plt.legend 里面使用 loc 这个参数。
e.g. loc="upper right", 就放置在我们的边界盒子（bounding box）里面的右上方 ，默认的设置就是坐标轴边界的设置 （0,0）（1,1）

注解边界的默认设置就是（x0,y0,width,height）=(0,0,1,1). 
为了把这个legend 放置在我们的坐标轴边界的外部，我们需要借助一个特殊的元组（x0,y0）,比如说放置在坐标轴边界的左下部。

plt.legend(loc=(1.04,0))

还有一些更加通用的方法来手动的设置legend box 放置的地方，就是bbox_to_anchor参数，在这里我们可以只提供bbox 的一个参数来作为限制就是提供 （x0,y0）,它所处的方向就有loc 这个参数来提供

plt.legend(bbox_to_anchor=(1.04,1), loc="upper left")


l1 = plt.legend(bbox_to_anchor=(1.04,1), borderaxespad=0) #右侧，上
l2 = plt.legend(bbox_to_anchor=(1.04,0), loc="lower left", borderaxespad=0) #右侧，下
l3 = plt.legend(bbox_to_anchor=(1.04,0.5), loc="center left", borderaxespad=0) #右侧，中

l4 = plt.legend(bbox_to_anchor=(0,1.02,1,0.2), loc="lower left",
                mode="expand", borderaxespad=0, ncol=3) #上部，左
l5 = plt.legend(bbox_to_anchor=(1,0), loc="lower right",  #右测，底
                bbox_transform=fig.transFigure, ncol=3)
l6 = plt.legend(bbox_to_anchor=(0.4,0.8), loc="upper right") #图片中，竖中线，顶




ref: 
Matplotlib 放置legend(bbox_to_anchor) https://blog.csdn.net/chichoxian/article/details/101058046





(3) 重命名标签
x=np.linspace(-3,3,50)
y1=2*x+1
y2=x**2-2*x+1

plt.figure()
l1,=plt.plot(x,y2, label='up') #标上label; 返回值后加逗号,有返回值加label就无效了
l2,=plt.plot(x,y1, 'r--', linewidth=1)

plt.legend(handles=[l1,l2], labels=['up22', 'down33'], loc="lower right") #位置参数loc默认为'best'，自动找一个图少的角落

plt.show()








3. 标注/注解
x=np.linspace(-3,3,50)
y1=2*x+1
y2=x**2-2*x+1

plt.figure()
plt.plot(x,y2, label='up') #标上label
plt.plot(x,y1, 'r--', linewidth=1, label='down')

plt.xlim(-1,3)
plt.ylim(-1,5)


####### 添加注释
x0=1
y0=2*x0+1
plt.plot([x0,x0], [0,y0], 'k--', linewidth=2.5) #竖虚线
plt.scatter(x0,y0, s=150, color='r') #size=150，红色

##method1
plt.annotate(r'$2x+1=%s$' % y0, 
             xy=(x0,y0), #打印位置
             xycoords='data', #位置基准
             
             xytext=(+30,-30),
             textcoords='offset points',
             
             fontsize=16,
             arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=0.2")
            )
##method2
plt.text(-0.8, 4, r'$This\ is\ some\ text\ \alpha\ \sigma$', 
         fontdict={'fontsize':16, 'color':'blue'})

plt.show()









========================================
|-- matplotlib使用plt.savefig()保存图片文件
----------------------------------------
1.实例1：曲线图
#import numpy as np
import matplotlib.pyplot as plt
#import matplotlib

# 定义数据
x = np.arange(0, 10, 0.1)
y = 0.05 * x ** 2

#绘制图像
plt.plot(x, y)

# 设置坐标轴
plt.xlabel('x data')
plt.ylabel('y data')

# 默认保存为png格式
plt.savefig('/home/wangjl/data/apa/190610APA/pdf/test.png')
#plt.show()




2. 实例二： 获取当前 figure 的引用，然后调用 figure 对象的 savefig() 方法。
import numpy as np
import matplotlib.pyplot as plt
 
x = np.linspace(1, 100, 100)
y1 = np.random.randint(20, 60, size=100)
y2 = np.random.randint(30, 70, size=100)
y3 = np.random.randint(50, 90, size=100)
 
fig = plt.figure(num="111", figsize=(6, 4), facecolor="pink", edgecolor="green")
plt.plot(x, y1, c="red", label="y1_low")
plt.plot(x, y2, c="blue", label="y2_middle")
plt.plot(x, y3, c="yellow", label="y3_high")
plt.legend(loc="best")
# plt.show()
re = fig.savefig("a")




3.命令行运行时报错：RuntimeError: Invalid DISPLAY variable
https://blog.csdn.net/gdkyxy2013/article/details/79585922

原因：matplotlib的默认backend是TkAgg，而FltAgg、GTK、GTKCairo、TkAgg、Wx和WxAgg这几个backend都要求有GUI图形界面，所以在ssh操作的时候会报错。

解决办法：在导入matplotlib的时候指定不需要GUI的backend（Agg、Cairo、PS、PDF和SVG）。例如：
import matplotlib.pyplot as plt
plt.switch_backend('agg')




注意：
1. 在 plt.show() 之前调用 plt.savefig()，否则可能是空白图片；
　　import matplotlib.pyplot as plt
　　""" 一些画图代码 """
　　plt.savefig("filename.png")
　　plt.show()
#
2. 画图的时候获取当前图像（这一点非常类似于 Matlab 的句柄的概念）：
 　 # gcf: Get Current Figure
　　fig = plt.gcf()
　　plt.show()
　　fig1.savefig('test.png', dpi=100)

3.文件格式
savefig(fname, dpi=None, facecolor='w', edgecolor='w',
        orientation='portrait', papertype=None, format=None,
        transparent=False, bbox_inches=None, pad_inches=0.1,
        frameon=None)

参数：
fname : str 或者 file 对象，如果是 str 格式，文件的输出格式是根据 str 中的后缀决定的。如果字符串中没有后缀指定文件格式，则由 rc 参数 savefig.format 决定。
format ： str，文件格式，一般支持 png、pdf、ps、eps 和 svg。





https://blog.csdn.net/tz_zs/article/details/81365576 
https://matplotlib.org/api/_as_gen/matplotlib.pyplot.savefig.html






========================================
|-- matplotlib-venn包绘制韦恩图 
----------------------------------------


使用
matplotlib-venn 包提供了四个主要的函数：venn2、venn2-circles、venn3 和 venn3-circles。
venn2和venn2_circles接受一个3元素（Ab，aB，AB）构成的 tuple 作为各个子集所包含元素的个数（不是具体的元素）：

Ab：包含A，但不包含B，即A中非B的部分，A∩¬BA∩¬B
aB：包含B，但不包含A，即B中非A，B∩¬AB∩¬A
AB：既包含A，又包含B，即A与B的交集，A∩B




核心代码：
from matplotlib_venn import venn2, venn2_circles
venn2(subsets=(3, 2, 1), set_labels=('A', 'B'))
venn2([set(['A', 'B', 'C', 'D']), set(['D', 'E', 'F'])])


实例: 
1.需要安装包
pip install --user matplotlib_venn

2.求两个集合的交集、差集的大小
n1=0
n2=0
for p in pasAll:
    if p in pasDB3:
        n1+=1
    else:
        n2+=1
print(n1, n2) #5576 128391

#
c1=0
c2=0
for p in pasDB3:
    if p in pasAll:
        c1+=1
    else:
        c2+=1
print(c1, c2) #5576 284593

3.绘图
#有标题
from matplotlib import pyplot as plt
from matplotlib_venn import venn2, venn2_circles
plt.figure(figsize=(6,6))
venn2(subsets=(n2,c2, c1), set_labels=('pA-Seq', 'PolyA_DB3'))
plt.title("(cid=all)M_gt5_No4A)")


#没有标题
from matplotlib_venn import venn2, venn2_circles
venn2(subsets=(n2,c2, c1), set_labels=('pA-Seq', 'PolyA_DB3'))








refer:
https://www.jianshu.com/p/25b0dc441247
https://pypi.org/project/matplotlib-venn/




========================================
|-- plt.pie 饼图
----------------------------------------
1. 饼图 plt.pie(data)
饼图常用于显示一个数据系列中各项的大小与各项总和的比例。

#饼图
import matplotlib.pyplot as plt

labels=['Clothes', 'Food', 'Housing', 'Travel', 'Others']
data=[0.1, 1.45, 0.3, 0.1, 0.05] #可以不是百分比，直接放原始数据，自动计算百分比

# plt.pie(data, labels=labels) #没有显示百分比
plt.pie(data, labels=labels, autopct="%1.1f%%") #加2个百分号就能正常显示百分号了
plt.show()




2.例2
import matplotlib as mpl
import matplotlib.pyplot as plt

# 生成数据
labels = ['M', '1S', '2S', 'Other']
share = [0.49, 0.24, 0.2, 1-0.49-0.24-0.2] #41%, 24%, 20%

#颜色
colors=['lightgreen','gold','lightskyblue','lightcoral',"lightred"]
# 设置分裂属性
explode = [0, 0, 0, 0]

# 分裂饼图
plt.pie(share, explode = explode,
        labels = labels, autopct = '%3.1f%%',
        startangle = 0, #shadow = True,
        colors =colors )
plt.title('Mapping End by Cigar of c12_ROW03') # 标题
plt.axis('equal') #正圆
plt.show()





========================================
|-- matplotlib 直方图hist、条形图bar、折线图plot
----------------------------------------
1. 直方图 需要2个参数(原始数据，区间)
每个柱子的高度等于该区间内数据的个数。

import matplotlib.pyplot as plt
#%matplotlib inline

height=[168,155,182,170,173,161,155,173,181,166,172,170]
bins=range(150, 191, 5) #步长为5

plt.title("hist plot")
plt.hist(height, bins=bins)
plt.show()




2. 条形图 plt.bar(X,Y) 第一个参数表示x轴位置，第二个参数表示y轴高度。
使用宽度相同的条形的高度或长度来表示数据的数值。
更直观的显示图形关系。

import matplotlib.pyplot as plt

classes=['Class 1', 'Class 2', 'Class 3']
scores=[70,80,90]

plt.title("bar plot")
plt.bar(classes, scores)
plt.show()


(2) 两个条形图，一个朝上一个朝下
#
n=12
X=np.arange(n)
Y1=(1-X/float(n))*np.random.uniform(0.5,1,n) #uniform 均匀分布
Y2=(1-X/float(n))*np.random.uniform(0.5,1,n) #uniform 均匀分布

plt.xlim(-0.5, n)
plt.ylim(-1.25, 1.25)

plt.xticks(()) #不要坐标轴刻度
plt.yticks(())

plt.bar(X, +Y1, facecolor='#9999ff',edgecolor="white" )
plt.bar(X, -Y2, facecolor='#ff9999',edgecolor="white" )

#添加文字
for x,y in zip(X,Y1):
    # ha: horizontal alignment;
    # va: vertical alignment;
    plt.text(x,y, '%.2f' % y, ha='center', va="bottom")

for x,y in zip(X,-Y2): #注意负号
    # ha: horizontal alignment;
    # va: vertical alignment;
    #'%.2f'保留2位有效数字
    plt.text(x,y-0.05, '%.2f' % y, ha='center', va="top")

plt.show()




(3) 画一个条形图，水平方向的，归一化到100%，并在图上标上每部分的百分比
import numpy as np
import matplotlib.pyplot as plt

#准备数据
category_names = ['Strongly disagree', 'Disagree',
                  'Neither agree nor disagree', 'Agree', 'Strongly agree']
results = {
    'Question 1': [10, 15, 17, 32, 26],
    'Question 2': [26, 22, 29, 10, 13],
    'Question 3': [35, 37, 7, 2, 19],
    'Question 4': [32, 11, 9, 15, 33],
    'Question 5': [21, 29, 5, 5, 40],
    'Question 6': [8, 19, 5, 30, 38]
}

#归一化到100%
for key in results:
    #print(key,  results[key])
    for i in range(len(results[key])):
        results[key][i]=100*results[key][i]/ sum(results[key])
results

def survey(results, category_names):
    """
    Parameters
    ----------
    results : dict
        A mapping from question labels to a list of answers per category.
        It is assumed all lists contain the same number of entries and that
        it matches the length of *category_names*.
    category_names : list of str
        The category labels.
    """
    labels = list(results.keys()) #标签['Question 1', 'Question 2', 'Question 3', 'Question 4', 'Question 5', 'Question 6']
    data = np.array(list(results.values())) #数据；np格式，则可以向量加减法
    data_cum = data.cumsum(axis=1) #数据累加，按行
    category_colors = plt.get_cmap('RdYlGn')( #获取颜色
        np.linspace(0.15, 0.85, data.shape[1])) #data有几列，产生几个颜色
    
    #创建图片
    fig, ax = plt.subplots(figsize=(9.2, 5))
    ax.invert_yaxis() #倒置y轴
    ax.xaxis.set_visible(False) #隐藏x轴
    ax.set_xlim(0, np.sum(data, axis=1).max()) #x轴范围0，到 np.sum(data, axis=1).max() np按照行求和，行和最大的

    # zip函数，从数组对中返回一对值；
    # enumerate(iterable) 返回一系列(0, seq[0]), (1, seq[1]), (2, seq[2]), ...
    for i, (colname, color) in enumerate(zip(category_names, category_colors)):
        widths = data[:, i] # 一次画一列
        starts = data_cum[:, i] - widths #宽度就是当前位置的累加和 - 当前宽度
        ax.barh(labels, widths, left=starts, height=0.5, #水平bar图，参数1是y位置，参数2是x长度，left是左边起点位置，height高度，
                label=colname, color=color)  #label是列名，color是颜色
        
        #中点坐标，放文字
        xcenters = starts + widths / 2 
        
        # 字体颜色，根据背景颜色调整
        r, g, b, _ = color
        text_color = 'white' if r * g * b < 0.5 else 'darkgrey'
        #添加文字
        for y, (x, c) in enumerate(zip(xcenters, widths)):
            ax.text(x, y, str(int(c)), ha='center', va='center', #文字，x,y坐标, 宽度是写上去的文字，水平对齐，垂直对齐
                    color=text_color) #颜色是根据背景定的
    # 图例
    ax.legend(ncol=len(category_names), 
              bbox_to_anchor=(0,1), #百分比(0,0)左下角， (1,1)
              loc='lower left', #边界盒子（bounding box）里面的左上方
              fontsize='small')
    return fig, ax

survey(results, category_names)
plt.show()







3. 折线图 plt.plot(X,Y)
体现两个数据的关系，是否相关？是否正相关？能大致拟合为什么函数？

import matplotlib.pyplot as plt

classes=['Class 1', 'Class 2', 'Class 3']
scores=[70,80,90]

year=range(2017,2021) #区间是[)的，所以是2017-2020年的共4年
height=[157,170,176,180]

plt.plot(year, height)
plt.show()






========================================
|-- matplotlib 散点图和箱线图
----------------------------------------
1. 散点图 方便观察二维数据之间的关系

#######
# 散点图
import matplotlib.pyplot as plt

(1) 例1
data=[[64,181], [50,120], [70,150], [55,100]]

weight=[item[0] for item in data]
height=[item[1] for item in data]
print(weight,height)

plt.scatter(weight, height)

# 添加坐标轴标签
plt.xlabel('Weight(kg)')
plt.ylabel('Height(cm)')

plt.title('Scatter')

#在固定的位置插入文字
plt.text(60,140, 'low | high')



(2)例2 正态分布的散点图
n=1024
X=np.random.normal(0,1,n) #正态分布随机数
Y=np.random.normal(0,1,n)

T=np.arctan2(Y,X) #好看的颜色

plt.scatter(X,Y,s=75,c=T, alpha=0.5) #散点图

plt.xlim(-1.5, 1.5) #坐标轴范围
plt.ylim(-1.5, 1.5)

plt.xticks(()) #隐藏坐标轴刻度
plt.yticks(())

plt.show()





2.箱线图 又叫盒子图 plt.boxplot(X)









refer:
https://matplotlib.org/contents.html
https://github.com/matplotlib/matplotlib

http://lib.csdn.net/article/python/43397
https://blog.csdn.net/qq_34337272/article/details/79555544





========================================
|-- 等高线图、3D图、动画
----------------------------------------
1.实例：绘制等高线图
# -*- coding: utf-8 -*-
"""
绘制等高线图
"""
import matplotlib.pyplot as plt
import numpy as np

# 定义等高线高度函数
def f(x, y):
    return (1 - x / 2 + x ** 5 + y ** 3) * np.exp(- x ** 2 - y ** 2)

# 数据数目
n = 256
# 定义x, y
x = np.linspace(-3, 3, n)
y = np.linspace(-3, 3, n)

# 生成网格数据
X, Y = np.meshgrid(x, y)

# 填充等高线的颜色, 8是等高线分为几部分
plt.contourf(X, Y, f(X, Y), 8, alpha = 0.75, cmap = plt.cm.hot)
# 绘制等高线
C = plt.contour(X, Y, f(X, Y), 8, colors = 'black', linewidth = 0.5)
# 绘制等高线数据
plt.clabel(C, inline = True, fontsize = 10)

# 去除坐标轴
plt.xticks(())
plt.yticks(())
plt.show()




2. 绘制3D图

from mpl_toolkits.mplot3d import Axes3D

fig=plt.figure()
ax=Axes3D(fig)

X=np.arange(-4, 4, 0.25)
Y=np.arange(-4, 4, 0.25)
X,Y=np.meshgrid(X,Y)
R=np.sqrt(X**2 + Y**2)

Z=np.sin(R)

# 3D图
ax.plot_surface(X,Y,Z, rstride=1, cstride=1, cmap=plt.get_cmap('rainbow'))

#rstride: row stride 步长;
#cstride: column stride 步长;

# 等高线图
ax.contourf(X,Y,Z, zdir='z', offset=-2, cmap='rainbow') #等高线图放到z=-2位置
ax.set_zlim(-2,2)

ax.contourf(X,Y,Z, zdir='x', offset=-5, cmap='rainbow') #再向x压下去一个等高线图

plt.show()









3.动画 //todo

jupyter和pycharm中没动起来，vscode中可以动。


from matplotlib import animation

fig, ax=plt.subplots()

x=np.arange(0,2*np.pi, 0.01)
line,=ax.plot(x,np.sin(x))

def animate(i):
    line.set_ydata(np.sin(x+i/100))
    return line;

def init():
    line.set_ydata(np.sin(x))
    return line;

ani=animation.FuncAnimation(fig=fig, #图像
                            func=animate, #更新时使用的函数
                            frames=100,  #帧频率
                            init_func=init, #第一帧
                            interval=20, #更新时间
                            blit=False #更新全图还是只更新变化部分
                           )

plt.show()






========================================
|-- 矩阵可视化 / 热图
----------------------------------------
1.热图 Image
cmap 是啥？

最简单的一句话 plt.imshow(weights_1_2)



实例：绘制heatmap
# -*- coding: utf-8 -*-
"""
绘制Image 
"""
import matplotlib.pyplot as plt
import numpy as np

# 定义图像数据
a = np.linspace(0, 1, 25).reshape(5, 5)
a[0,3]=0.9
print(a)

# 显示图像数据
plt.imshow(a, interpolation = 'nearest', cmap = 'bone', origin = 'upper')
# interpolation 插值方式

# 添加颜色条
# plt.colorbar() 
plt.colorbar(shrink=0.8) #压缩到原来高度的80%，默认是100%

# 去掉坐标轴
plt.xticks(())
plt.yticks(())
plt.show()







2. 缺点： 无法控制图片大小
这是一个绘制矩阵的函数。原文：“plot a matrix or an array as an image"

用matshow绘制矩阵的例子：

import matplotlib.pyplot as plt
import numpy as np
 
 
def samplemat(dims):
    """Make a matrix with all zeros and increasing elements on the diagonal"""
    aa = np.zeros(dims)
    for i in range(min(dims)):
        aa[i, i] = i
    return aa
 
 
# Display matrix
plt.matshow(samplemat((15, 15)))
 






========================================
|-- 绘制贝塞尔曲线
----------------------------------------
1.#二次贝塞尔曲线
np.random.seed(1)
x=np.random.random(3)*10+10
y=np.random.random(3)*10+20


def bezie2(p0, p1, p2):
    x=[]
    y=[]
    def b2(t, c0,c1,c2):
        return ((1-t)**2)*c0 + 2*t*(1-t)*c1 + (t**2)*c2
    for i in range(1000):
        t=i/999
        x.append( b2(t, p0[0], p1[0], p2[0]) )
        y.append( b2(t, p0[1], p1[1], p2[1]) )
    return (x,y)
#
rs=bezie2( [x[0], y[0]], [x[1], y[1]]  , [x[2], y[2]])

#
plt.scatter(rs[0], rs[1], color='red', s=1)
plt.scatter(x,y, color='black')
print(x,y)



2.#三次贝塞尔曲线
#np.random.seed(1)
x=np.random.random(4)*10+10
y=np.random.random(4)*10+20

def bezie3(p0, p1, p2, p3):
    x=[]
    y=[]
    def b3(t, c0,c1,c2,c3):
        return (1-t)**3*c0 + t*(1-t)**2*3*c1 + t**2*(1-t)*3*c2 + t**3*c3
    for i in range(1000):
        t=i/999
        x.append( b3(t, p0[0], p1[0], p2[0], p3[0]) )
        y.append( b3(t, p0[1], p1[1], p2[1], p3[1]) )
    return (x,y)
#
rs=bezie3( [x[0], y[0]], [x[1], y[1]]  , [x[2], y[2]] , [x[3], y[3]])

#
plt.scatter(rs[0], rs[1], color='red', s=1)
plt.scatter(x,y, color='#cccccc')
print(x,y)






ref:
https://www.jb51.net/article/177375.htm




========================================
Seaborn 包: 对matplotlib的封装
----------------------------------------
1. 简介

seaborn的数据来自github: https://github.com/mwaskom/seaborn-data

(1) 示例和教程(中文)
seaborn 的图表很漂亮: https://blog.csdn.net/weixin_44766179/article/details/89133526
https://blog.csdn.net/weixin_44766179/article/details/89095211
https://blog.csdn.net/Julialove102123/article/details/89063166
https://www.cnblogs.com/gczr/p/6767175.html


distplot/kdeplot/pairplot/strip-swarmplot/boxplot/jointplot/violinplot/pointplot/bar/
https://blog.csdn.net/weixin_41988628/article/details/83038332



(2) 官方教程(英文)
官网 http://seaborn.pydata.org/introduction.html
http://seaborn.pydata.org/tutorial/color_palettes.html

官方API：http://seaborn.pydata.org/index.html
案例库：http://seaborn.pydata.org/examples/

https://www.datacamp.com/community/tutorials/seaborn-python-tutorial


(3) 视频 
https://www.bilibili.com/video/BV1CE411P79j?p=8




2. 安装
(1)pip install seaborn;


(2)使用seaborn加载数据时，
df_iris=sns.load_dataset('iris')
df_iris.head()
总是报错:
ConnectionRefusedError: [Errno 111] Connection refused
URLError: <urlopen error [Errno 111] Connection refused>


==>方案1:https://blog.csdn.net/m0_37842667/article/details/83243722
添加:
import ssl
ssl._create_default_https_context = ssl._create_unverified_context
还是报错;

==>方案2: https://blog.csdn.net/qq_41477675/article/details/103543268
添加 iris=sns.load_dataset("iris",engine='python')
还是报错;

==>方案3:https://www.pythonheidong.com/blog/article/184505/
在主目录创建SSL证书
$ mkdir certs
$ cd certs
$ sudo openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem

告诉Jupyter在哪里找到它。
查看jupyter_notebook_config.py是否有一个（或使用生成一个jupyter notebook --generate-config）。
确保您具有以下行：
c.NotebookApp.certfile = u'/home/ubuntu/certs/mycert.pem' #location of your certificate file
还是不行


==> 解决方案:
把数据从github克隆到本地web文件夹中:
git clone https://github.com/mwaskom/seaborn-data.git
然后可以直接访问:
tips = pd.read_csv("http://y.biomooc.com/wangjl/docs/seaborn-data/tips.csv")





其他功能貌似正常。






3.开始绘图

import numpy as np
import pandas as pd

import matplotlib.pyplot as plt  
import seaborn as sns
print('==end==')









========================================
|-- 整体布局风格设置
----------------------------------------

1. 一共5种预定义风格
help(sns.set) 
#context must be in paper, notebook, talk, poster
#style must be one of white, dark, whitegrid, darkgrid, ticks 

help(sns.set_style) 


(1)实例 
def sinplot(flip=1):
    x=np.linspace(0,14, 100)
    for i in range(1,7):
        y=np.sin(x+i*0.5) *(7-i)*flip
        plt.plot(x, y)
sinplot()

sns.set(style='whitegrid')
sinplot()


(2) 去掉上、右边框
sns.set_style("white")
sinplot() 
sns.despine() # 默认无参数状态，就是删除上方和右方的边框

(3) 加大图到坐标轴的距离
sinplot()
sns.despine(offset=20)


(4)# 一页多图，每个风格不同，使用with结构
with sns.axes_style('darkgrid'):
    plt.subplot(211)
    sinplot()
with sns.axes_style('whitegrid'):
    plt.subplot(212)
    sinplot(-1)
#





2. 布局设置。4种上下文环境: paper, notebook, talk, poster

(1)
sns.set_style("whitegrid")

sns.set_context('paper')
plt.figure(figsize=(8,6))
sinplot()


(2)设置字体大小、线宽
sns.set_context('paper', font_scale=5, #字体放大
                rc={"lines.linewidth":2}) #线条粗细
sns.set_style("whitegrid")

plt.figure(figsize=(8,6))
sinplot()






========================================
|-- 颜色：调色板、xkcd颜色
----------------------------------------
离散型
连续型


1. 调色板的使用


目测颜色的方法：
plt.hlines(y=3,xmin=0,xmax=2,color="#FF0000", linewidth=10)

sns.palplot(np.array([ [1,0,0], [0,1,0],  [0,0,1]  ]) )



(1) 10个默认颜色循环主题
current_palette=sns.color_palette()
sns.palplot(current_palette)
current_palette



(2)圆形画板：对色环平均分成n份
sns.palplot( sns.color_palette('hls', 8) )

1) 上条语句中的hls是颜色命名空间，如何知道还有哪些命名空间呢？
尝试输错一次，看看报错即可：
sns.palplot( sns.color_palette('hls00', 8) )
ValueError: Colormap hls00 is not recognized. Possible values are: Accent, Accent_r, Blues, Blues_r, BrBG, BrBG_r, BuGn, BuGn_r, BuPu, BuPu_r, CMRmap, CMRmap_r, Dark2, Dark2_r, GnBu, GnBu_r, Greens, Greens_r, Greys, Greys_r, OrRd, OrRd_r, Oranges, Oranges_r, PRGn, PRGn_r, Paired, Paired_r, Pastel1, Pastel1_r, Pastel2, Pastel2_r, PiYG, PiYG_r, PuBu, PuBuGn, PuBuGn_r, PuBu_r, PuOr, PuOr_r, PuRd, PuRd_r, Purples, Purples_r, RdBu, RdBu_r, RdGy, RdGy_r, RdPu, RdPu_r, RdYlBu, RdYlBu_r, RdYlGn, RdYlGn_r, Reds, Reds_r, Set1, Set1_r, Set2, Set2_r, Set3, Set3_r, Spectral, Spectral_r, Wistia, Wistia_r, YlGn, YlGnBu, YlGnBu_r, YlGn_r, YlOrBr, YlOrBr_r, YlOrRd, YlOrRd_r, afmhot, afmhot_r, autumn, autumn_r, binary, binary_r, bone, bone_r, brg, brg_r, bwr, bwr_r, cividis, cividis_r, cool, cool_r, coolwarm, coolwarm_r, copper, copper_r, cubehelix, cubehelix_r, flag, flag_r, gist_earth, gist_earth_r, gist_gray, gist_gray_r, gist_heat, gist_heat_r, gist_ncar, gist_ncar_r, gist_rainbow, gist_rainbow_r, gist_stern, gist_stern_r, gist_yarg, gist_yarg_r, gnuplot, gnuplot2, gnuplot2_r, gnuplot_r, gray, gray_r, hot, hot_r, hsv, hsv_r, icefire, icefire_r, inferno, inferno_r, jet, jet_r, magma, magma_r, mako, mako_r, nipy_spectral, nipy_spectral_r, ocean, ocean_r, pink, pink_r, plasma, plasma_r, prism, prism_r, rainbow, rainbow_r, rocket, rocket_r, seismic, seismic_r, spring, spring_r, summer, summer_r, tab10, tab10_r, tab20, tab20_r, tab20b, tab20b_r, tab20c, tab20c_r, terrain, terrain_r, viridis, viridis_r, vlag, vlag_r, winter, winter_r

# 尝试几个颜色画板
sns.palplot( sns.color_palette('Dark2', 8) )
sns.palplot( sns.color_palette('terrain', 12) )

sns.palplot( sns.color_palette("Paired", 12) ) #成对数据



2)#怎么使用这些颜色呢？
np.random.seed(1)
data=np.random.normal(size=(20,8)) + np.arange(8) /2
#
sns.set(style="ticks")
sns.boxplot(data=data, palette=sns.color_palette('Accent', 8))



3) 颜色格式的互换
import matplotlib.pyplot as plt
from matplotlib import colors as mcolors
import seaborn as sns

c3=['red','orange','brown', '#A8FF00','lime', '#12e193','green','blue','#0d75f8','cyan','#FF00FF','purple']
sns.palplot( c3 )
plt.show()

for i,color in enumerate(c3):
    rgb=mcolors.to_rgba(color)[:3] #变为rgba。第一步
    #
    hexC=mcolors.rgb2hex(rgb); #rgb变16进制
    hsv=mcolors.rgb_to_hsv(rgb) #rgb变hsv
    print("%d InputColor=%s, hex=%s, rgb=%s, hsv=%s" % (i,str(color),str(hexC), str(rgb), str(hsv) ) )
    #
    # 目测颜色
    sns.palplot(rgb)
    plt.show()
#



(3) 指定亮度和饱和度
sns.palplot( sns.hls_palette(8, l=0.3, s=0.8) )
sns.palplot( sns.hls_palette(8, l=0.5, s=0.8) ) #提高亮度
sns.palplot( sns.hls_palette(8, l=0.7, s=1) ) # #继续提高亮度

HLS色调空间：hls_palette([n_colors, h, l, s])
HUSL色调空间：husl_palette([n_colors, h, l, s])







2. 调色板颜色设置：使用 xkcd 颜色来命名颜色
xkcd包含了一套众包努力的针对随机RGB色的命名。产生了954个可以随时通过 xdcd_rgb 字典中调用的命名颜色。
可视化查看: http://www.biomooc.com/Python3/seabornColors.html

plt.plot([0,1], [0,1], sns.xkcd_rgb['pale red'], lw=3)
plt.plot([0,1.5], [0,1], sns.xkcd_rgb['medium green'], lw=3)








3. 连续色板
色彩随着数据变换。
(1)
sns.palplot(sns.color_palette("Blues")) #浅到深
# 想翻转，就在末尾加上_r
sns.palplot(sns.color_palette("Blues_r")) #深到浅

好像和上文一样，只是少了个整数参数。

怎么用呢？


(2) cubehelix_palette()  #色调线性变换。在三维空间选择颜色。
cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8, light=0.85, dark=0.15, reverse=False, as_cmap=False)
    Make a sequential palette from the cubehelix system.
# 参数取值范围
# start : float, 0 <= start <= 3
# hue : float, 0 <= hue <= 1

sns.palplot(sns.color_palette('cubehelix', 8)) 

sns.palplot(sns.cubehelix_palette(8, start=0.5, rot=-0.75))
sns.palplot(sns.cubehelix_palette(8, start=0.75, rot=-0.15))


(3) 调用定制连续调色板：指定颜色，生成几个渐变色
sns.palplot(sns.light_palette('green')) #浅绿 --> 绿 
sns.palplot(sns.dark_palette('green')) #墨绿 -> 绿

sns.palplot(sns.light_palette('green', reverse=True)) # 绿 -> 浅绿


实例：
np.random.seed(1)
x,y=np.random.multivariate_normal([0,0], [[1,-5], [-5,1]], size=300).T

pal=sns.dark_palette('green', as_cmap=True)
sns.kdeplot(x,y,cmap=pal)


(4) 设置颜色空间，输入该空间的颜色参数，来获得渐变色
sns.palplot(sns.light_palette((210, 90, 60), input="husl"))
# help(sns.light_palette)
# input : {'rgb', 'hls', 'husl', xkcd'}



(5) 交互式挑选一系列颜色 Select a palette from the ColorBrewer set.
choose_colorbrewer_palette(data_type, as_cmap=False)
help(sns.choose_colorbrewer_palette)
# data_type : {'sequential', 'diverging', 'qualitative'}


sns.choose_colorbrewer_palette('qualitative', as_cmap=False)





========================================
|-- 如果需要30种颜色，要求能尽量可分辨，该怎么生成？
----------------------------------------
最舒服的色彩搭配RGB值配色: https://blog.csdn.net/chelen_jak/article/details/95475247

颜色太多时，不要太依靠机器，还是要人眼分辨一下试试的。


1. 策略1: 从已有列表手工挑选( 比如 python和 seaborn 颜色库，6列，每列挑选几个)
http://www.biomooc.com/Python3/matplotlibColors.html
http://www.biomooc.com/Python3/seabornColors.html

c4=[ ['red', 'orange', 'yellow', '#A8FF00',  # 青柠色
          '#00FF24',
          'green', 'blue', 'purple', 'black'],
      [
      #red
    '#970000','#FE7F7F',
      #brown
    '#B17301','#FF9000',
      #orange
      '#FFCE74','#fdde6c',
     # lime     
    '#B0B000',
    '#D2FF00', 
    
     '#9EFF9E', #'black',
    '#000083','#0d75f8',
    '#009D9D', 'cyan',
    '#FF00FF',  '#FF8EFF',
      '#484848','#B7B6B6'
      ]
    ]

sns.palplot(c4[0])
sns.palplot(c4[1])

print(len(c4[0]), len(c4[1])) #26种颜色
rs004=sortAndSee(c4[0]+c4[1]) #策略2定义的函数。
# ['#000000', '#484848', '#b7b6b6', '#fe7f7f', '#970000', '#ff0000', '#ff9000', '#ffa500', '#ffce74', '#b17301', '#fdde6c', '#b0b000', '#ffff00', '#d2ff00', '#a8ff00', '#9eff9e', '#008000', '#00ff24', '#009d9d', '#00ffff', '#0d75f8', '#000083', '#0000ff', '#ff8eff', '#800080', '#ff00ff']



2. 策略2: 选择基础颜色，通过生成加深和变浅，生成一系列颜色，然后手工剔除不容易区分的颜色。

# 44个颜色
c0= ['#ff9999', '#ff4c4c', '#a52a2a', '#6c1717', '#b50b0b', '#ff0000', '#ffdb99', '#b5790b', '#6c4e17', '#ffa500', '#ffc04c', '#4f6c17', '#7bb50b', '#a8ff00', '#dcff99', '#99d599', '#99ff99', '#4caa4c', '#0b610b', '#0bb50b', '#008000', '#00ff00', '#a0f4d4', '#17a16d', '#12e193', '#99ffff', '#0bb5b5', '#00ffff', '#0d75f8', '#559efa', '#9999ff', '#4c4cff', '#0b0bb5', '#0000ff', '#730bb5', '#9c00ff', '#ba4cff', '#d599d5', '#ff99ff', '#aa4caa', '#ff4cff', '#b50bb5', '#800080', '#ff00ff']
sns.palplot(c0)



3. 从别人的文章中用picpick提取颜色。





========================================
|-- 单变量分析绘图：直方图
----------------------------------------
1. 记数图
sns.countplot(x='time', data=tips)




2. 直方图

sns.set(style="white")
np.random.seed(1)
x=np.random.normal(size=100)
sns.distplot(x, kde=False)

# 切分的更细
sns.distplot(x,bins=20, kde=False)

# 显示数据分布，加上概率密度曲线
from scipy import stats
sns.distplot(x,bins=20, kde=False, fit=stats.gamma)






========================================
|-- 观察2个变量之间的关系，需要用到散点图
----------------------------------------
1.
(1)## 根据均值和协方差生成数据
np.random.seed(1)

mean, cov=[0,1], [(1,0.5), (0.5,1)]
data=np.random.multivariate_normal(mean, cov, 200)
df=pd.DataFrame(data, columns=["x","y"])

print(df.shape)
df.head()

#(200, 2)
#        x	      y
#0	-1.100846	-0.712603
#1	0.993894	0.920926
#2	0.401304	-0.900234
#3	-1.130448	-0.891655
#4	-0.151611	0.599019


(2)## 画图，主体是散点图，边缘是直方图
sns.jointplot(x="x", y="y", data=df)


# 在图中显示相关系数和p值
from scipy import stats
g = sns.jointplot(x='total_bill', y='tip',
                  data=tips, kind="reg", 
                  stat_func=stats.pearsonr, 
                  color=None, height=6, ratio=5, 
                  space=.2, dropna=True)
#sns.plt.show()


(3)## 计算相关系数和p值
from scipy.stats import pearsonr
rs=pearsonr(df['x'],df['y'])
rho=rs[0]
p=rs[1]
print(rho, p)


(4)## 散点密度图，但是使用六边形填充区域，防止重叠过多看不清楚。数据量大时使用。
np.random.seed(2)
x,y=np.random.multivariate_normal(mean, cov, 1000).T
sns.jointplot(x, y, kind="hex", color='r')




2. 两两之间画散点图、主对角线是直方图

(1) 载入iris数据集
iris=pd.read_csv('http://y.biomooc.com/wangjl/docs/seaborn-data/iris.csv')
print(iris.shape) #(150, 5)
iris.head()

(2)# 两两之间画散点图
sns.pairplot(iris)


# 指定某几个属性之间，指定颜色为类别
sns.pairplot(iris, vars=["sepal_width", "sepal_length"], hue='species',palette="husl") 




========================================
|-- 回归分析绘图
----------------------------------------
1.
(1) 导入数据tips
tips=pd.read_csv('http://y.biomooc.com/wangjl/docs/seaborn-data/tips.csv')
print(tips.shape) #(244, 7)
tips.head()

#	total_bill	tip	sex	smoker	day	time	size
#0	16.99	1.01	Female	No	Sun	Dinner	2
#1	10.34	1.66	Male	No	Sun	Dinner	3
#2	21.01	3.50	Male	No	Sun	Dinner	3
#3	23.68	3.31	Male	No	Sun	Dinner	2
#4	24.59	3.61	Female	No	Sun	Dinner	4
# 总金额，小费，性别，是否抽烟，星期几，早中晚饭，几个人吃的


(2)# regplot()和lmplot()都可以绘制回归关系，推荐前者。
sns.regplot(x="total_bill", y="tip", data=tips)

# or 
sns.lmplot(x="total_bill", y="tip", data=tips)
# 有更多可设置指标，支持更高级功能。


#为不同性别添加不同的回归线
sns.lmplot(x="total_bill", y="tip", hue='sex', data=tips) 

# 也可以添加分面，分别制定row和col即可。
sns.lmplot(x="total_bill", y="tip", hue='sex', col='day', row='smoker',  data=tips) 


sns.regplot(x="size", y="tip", data=tips)
# 看上图，size太固定，不利于做回归(?why?)。可以加入少量抖动
sns.regplot(x="size", y="tip", data=tips, x_jitter=0.05)




(3) 怎么得到回归方程及其p值呢？

//todo









========================================
|-- 多变量分析绘图 - 分类属性绘图
----------------------------------------
1. 类别图，就是x坐标是分类变量(比如，AB组，早中晚饭)，y坐标是连续分布的指标。
(1)使用stripplot
sns.stripplot(x='day', y='total_bill', data=tips)
sns.stripplot(x='day', y='total_bill', data=tips, jitter=False) #默认jitter=True

(2)更夸张的分类图swarmplot
sns.swarmplot(x='day', y="total_bill", data=tips)

sns.swarmplot(x='day', y="total_bill", hue="sex", data=tips) #区分性别

sns.swarmplot(y='day', x="total_bill", hue="sex", data=tips) #交换x和y轴，横着放


(3)箱线图 / 盒图
IQR 即统计学概念四分位距，1/4和3/4之间的距离。
N=1.5IQR 如果一个值>Q3+N 或者 <Q1-N,则为离群点。

plt.figure(figsize=(6,5))
sns.boxplot(x='day', y='total_bill', hue='sex',data=tips)


# 横着放：交换x和y
sns.boxplot(y='day', x='total_bill', hue='time',data=tips)


(4) 小提琴图
sns.violinplot(x='day', y="total_bill", hue='time', data=tips)

sns.violinplot(x='day', y="total_bill", hue='sex', data=tips, split=True) #把分组分别画到小提琴的2测


(5) 两张图合并到一起: inner 属性
sns.violinplot(x='day', y='total_bill', data=tips, inner=None)
sns.swarmplot(x='day', y='total_bill', data=tips, color='w', alpha=0.5)


(6) 条形图
sns.barplot('sex', 'survived', hue='class', data=titanic)

# 控制条形图图例的排布顺序
sns.barplot('sex', 'survived', hue='class', data=titanic, hue_order=['First', 'Second', 'Third'])


(7) 点图 pointplot(折线图), 更能看出来差异
sns.pointplot('sex', 'survived', hue='class', data=titanic, hue_order=['First', 'Second', 'Third'])

# 对颜色、线性、关键点形状的更多设置
sns.pointplot('class', 'survived', hue='sex', data=titanic, 
              palette={'male':'g', 'female':'m'}, #颜色
              markers=['^', 'o'],  #点的形状
			  linestyles=['-','--'] ) #线型
#

(8) 多层面板分类图(原来的factorplot改名为catplot)
sns.catplot(x='day', y='total_bill', hue='smoker', hue_order=["Yes","No"],
            order=["Thur",'Fri',"Sat","Sun"],
            data=tips, kind='point')
#
#指定为条形图
sns.catplot(x='day', y='total_bill', hue='smoker', hue_order=["Yes","No"],
            order=["Thur",'Fri',"Sat","Sun"],
            data=tips, kind='bar')

#
# swarm图：添加col分成2列
sns.catplot(x='day', y='total_bill', hue='smoker', hue_order=["Yes","No"],
            order=["Thur",'Fri',"Sat","Sun"],
            col="time",
            data=tips, kind='swarm')
#
# box图：指定高度、长宽比
sns.catplot(x='day', y='total_bill', hue='smoker', hue_order=["Yes","No"],
            order=["Thur",'Fri',"Sat","Sun"],
            col="day", col_order=["Thur",'Fri',"Sat","Sun"], #指定分列，并给定顺序
            height=6, #高度
            aspect=0.5, #长宽比
            data=tips, kind='box')
#







========================================
|-- 点、线混合绘图 relplot (和ggplot2画散点图的使用和效果很接近)
----------------------------------------
1.
散点图: replot(kind="scatter") 默认。
线图: replot(kind="line")


(1) 指定点的大小
sns.relplot(x='total_bill',y='tip', data=tips, 
            col='time', #分列
            hue="smoker",  # 颜色
            style='smoker', #点的形状
            size='size' #就餐人数
           )
#

(2) 线图
sns.relplot(x='total_bill',y='tip', data=tips, 
            kind="line",
            col='time', #分列
            hue="smoker",  # 颜色
            style='smoker', #点的形状
            size='size' #就餐人数
           )
#






========================================
|-- FacetGrid 分面展示函数，PairGrid 绘制矩阵散点图
----------------------------------------

1. 分面的使用
(1) 简单实例
g=sns.FacetGrid(tips, col='time') #实例化出坐标系
g.map(plt.hist, 'tip') #map函数中指定绘图函数和参数

map第一个参数是函数名，接着是该函数的参数。


(2) 
g=sns.FacetGrid(tips, col='time')
g.map(sns.boxplot, 'sex', 'tip', order=['Male', 'Female']) #map函数中指定更多参数


(3) 图分列，每图2个颜色
g=sns.FacetGrid(tips, col='sex', hue='smoker')
g.map(plt.scatter, 'total_bill', 'tip', alpha=0.7)
g.add_legend()



(4) 回归分析
g=sns.FacetGrid(tips, col='sex', hue='smoker')
g.map(sns.regplot, 'total_bill', 'tip', fit_reg=True) 
g.add_legend()


(5) barplot 设定长宽
g=sns.FacetGrid(tips, col='day', height=4, aspect=0.4, col_order=["Thur",'Fri','Sat','Sun'])
g.map(sns.barplot, 'sex', 'total_bill', order=['Male', 'Female']) 
g.add_legend()







2. 更精细的控制

(1) 给点加上描边
pal=dict(Lunch="seagreen", Dinner="red") #用字典的形式传入颜色
g=sns.FacetGrid(tips, hue='time', palette=pal, height=5)
g.map(plt.scatter, 'total_bill', 'tip', 
      s=60, #点的大小
      alpha=0.7, #不透明度
      linewidth=2, #点的描边的粗细
      edgecolor='gray' #点的描边的颜色
     )
g.add_legend()



(2) marker 设置点的形状
g=sns.FacetGrid(tips, hue='time', palette="Set1", height=5, hue_kws={'marker':["^", "v"]})
g.map(plt.scatter, 'total_bill', 'tip', 
      s=100, alpha=0.7, linewidth=0.5, edgecolor='white' )
g.add_legend()



(3)
# 一页多图时，调整图形之间的距离
# 指定坐标轴名称、刻度
with sns.axes_style('ticks'):
    g=sns.FacetGrid(tips, row='sex', col='smoker', margin_titles=True, height=2.5)
g.map(plt.scatter, "total_bill", "tip", color="#334488", edgecolor="white", lw=0.5)
g.set_axis_labels("Total bill (US Dollars)", "Tip") #坐标轴名称
g.set(xticks=[10,30,50], yticks=[2,6,10]) #坐标轴刻度
g.fig.subplots_adjust(wspace=0.05, hspace=0.02) #wspace 水平间距， hspace竖直间距

g.fig.subplots_adjust(left=0.125, right=0.9, bottom=0.1, top=0.9, wspace=0.2, hspace=0.02) #整体的四个边距







3. 两两作图，矩阵散点图

(1) 现指定两两绘图大框架，然后再使用散点图填充
sns.set(style="ticks")
g=sns.PairGrid(iris)
g.map(plt.scatter)


(2) 更进一步的，指定对角线和非对角线上怎么画
sns.set(style="ticks")
g=sns.PairGrid(iris)
g.map_diag(plt.hist)
g.map_offdiag(plt.scatter)


(3) 添加颜色分类
g=sns.PairGrid(iris, hue="species")
g.map_diag(plt.hist, histtype ="barstacked") # 有问题，不会堆叠 
g.map_offdiag(plt.scatter)
g.add_legend()


(4)#vars参数：只想取一部分特征呢
g=sns.PairGrid(iris, vars=['sepal_length','sepal_width'], hue="species")
g.map(plt.scatter)


(5)# 指定调色板
g=sns.PairGrid(tips,hue="size", palette="GnBu_d")
g.map(plt.scatter, s=50, edgecolor="white")
g.add_legend()











========================================
|-- 热图 heatmap
----------------------------------------
1.
(1) 示意
np.random.seed(1)
uniform_data=np.random.rand(3,3) #3行3列，[0,1)随机数
print(uniform_data)

heatmap=sns.heatmap(uniform_data)



(2) 控制color bar的最大、最小值
hp2=sns.heatmap(uniform_data, vmin=0.2, vmax=0.5)


(3) 改变color bar的中心位置数值
hp3=sns.heatmap(uniform_data, center=0.45) #指定color bar 的中心



(4) 修改行列
# 加载数据
print(flights.shape)
flights.head()
# 	year	month	passengers
# 0	1949	January	112
# 1	1949	February	118
# 2	1949	March	132


# 交叉表，x=年,y=月，中间数字是乘客人数
df=flights.pivot('month', 'year', 'passengers')
print(df)

ax=sns.heatmap(df)


# 怎么调整月份顺序
df2=df.reindex(['January','February','March','April','May','June','July',
                'August','September','October','November','December'])
print(df2)
ax2=sns.heatmap(df2)

# 航班人数随着时间，越来越多。
# 月份中，78月最高。



(5) 把数值写到热图上
plt.figure(figsize=(8,5))
sns.heatmap(df2, annot=True, fmt='d') #字体格式d，显示比较正常
# 默认是科学计数法，有重叠，不好。



(6) 指定格子之间的间距
sns.heatmap(df2, linewidths=0.5)


(7)# 自定义配色
sns.heatmap(df2, cmap="YlGnBu")


(8)# 隐藏color bar, 最好还是显示出来。
sns.heatmap(df2, cmap="YlGnBu", cbar=False)


(9)计算特征之间的相关程度，然后画热图
iris_cor=iris.corr() #计算列之间的相关系数
iris_cor


sns.heatmap(iris_cor, cmap="YlGnBu")





========================================
ggplot2 和 Bokeh.js(可交互式、基于js) 
----------------------------------------
1. ggplot2
基于R的一个作图库ggplot2，同时利用了源于《图像语法》（The Grammar of Graphics）中的概念，允许叠加不同的图层来完成一幅图，并不适用于制作非常个性化的图像，为操作的简洁度而牺牲了图像的复杂度。

http://ggplot.yhathq.com/docs/index.html


2. Bokeh
跟ggplot一样，Bokeh也基于《图形语法》的概念。与ggplot不同之处为它完全基于Python而不是从R处引用。长处在于能用于制作可交互、可直接用于网络的图表。图表可以输出为JSON对象、HTML文档或者可交互的网络应用。

https://docs.bokeh.org/en/latest/

https://hub.gke.mybinder.org/user/bokeh-bokeh-notebooks-sfsu50bf/notebooks/tutorial/00%20-%20Introduction%20and%20Setup.ipynb

Bokeh 的目标是使用 D3.js 样式提供优雅，简洁新颖的图形化风格，同时提供大型数据集的高性能交互功能。Boken 可以快速的创建交互式的绘图，仪表盘和数据应用。






========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------

