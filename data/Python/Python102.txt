Python3基础详解

There should be one—--and preferably only one –--obvious way to do it.
----摘自The Zen of Python, by Time Peters




========================================
web based tutorials
----------------------------------------
http://rosalind.info/problems/locations/
user:dawnEve/bi789789/pos***9@163.com



========================================
Python中的装饰器(decorator)
----------------------------------------
http://www.cnblogs.com/Jerry-Chou/archive/2012/05/23/python-decorator-explain.html
想理解Python的decorator首先要知道在Python中函数也是一个对象，所以你可以
	将函数复制给变量
	将函数当做参数
	返回一个函数

函数在Python中给变量的用法一样也是一等公民，也就是高阶函数(High Order Function)。所有的魔法都是由此而来。


1，起源
我们想在函数login中输出调试信息，我们可以这样做

def login():
    print('in login')
 
def printdebug(func):
    print('enter the login')
    func()
    print('exit the login')
 
printdebug(login)

这个方法讨厌的是每次调用login是，都通过printdebug来调用，但毕竟这是可行的。


2，让代码变得优美一点
既然函数可以作为返回值，可以赋值给变量，我们可以让代码优美一点。

def login():
    print('in login')
 
def printdebug(func):
    def __decorator():
        print('enter the login')
        func()
        print('exit the login')
    return __decorator  #function as return value
 
debug_login = printdebug(login)  #function assign to variable
 
debug_login()  #execute the returned function

这样我们每次只要调用debug_login就可以了，这个名字更符合直觉。我们将原先的两个函数printdebug和login绑定到一起，成为debug_login。这种耦合叫内聚:-)。


3，让代码再优美一点
printdebug和login是通过debug_login = printdebug(login)这一句来结合的，这一句似乎也是多余的，能不能在定义login是加个标注，从而将printdebug和login结合起来？

上面的代码从语句组织的角度来讲很难再优美了，Python的解决方案是提供一个语法糖(Syntax Sugar)，用一个@符号来结合它们。

def printdebug(func):
    def __decorator():
        print('enter the login')
        func()
        print('exit the login')
    return __decorator  
 
@printdebug  #combine the printdebug and login
def login():
    print('in login')
 
login()  #make the calling point more intuitive

可以看出decorator就是一个：使用函数作参数并且返回函数的函数。通过改进我们可以得到：
	更简短的代码，将结合点放在函数定义时
	不改变原函数的函数名
在Python解释器发现login调用时，他会将login转换为printdebug(login)()。也就是说真正执行的是__decorator这个函数。

更高级的应用：
http://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators-in-python/1594484#1594484
如带参数，给装饰器加上装饰器。




1.
[Python入门及进阶笔记]Python-decorator装饰器小结 【深入浅出】
http://blog.csdn.net/wklken/article/details/8118942

2.
decorator注意事项
https://my.oschina.net/laugh2last/blog/493393
	python2.4及其以上版本有此功能
	装饰器使代码执行的效率变低了
	一旦一个函数已经被装饰好了，就定下来了，不能变了
	装饰器decorator在函数之间包装起来了，比较难debug
python自己也提供了几个装饰器，property，staticmethod等。Django用装饰器来管理缓存和视图权限，能够把python的decorator玩透，将会帮你解决很多事情。

3.
http://thecodeship.com/patterns/guide-to-python-function-decorators/
http://blog.csdn.net/azhao_dn/article/details/7638882
http://www.cnblogs.com/vamei/archive/2013/02/16/2820212.html

========================================
第九天 I/O - 文件读写 
----------------------------------------


如果文件很小，read()一次性读取最方便；
如果不能确定文件大小，反复调用read(size)比较保险；
如果是配置文件，调用readlines()最方便：

for line in f.readlines():
    print(line.strip()) # 把末尾的'\n'删掉
	
# 默认读写方式是GBK，打开显示是ansi。也可以指定encoding='utf-8'
with open("C:\\Tools\\test.txt", 'r', encoding='GBK') as f:
    print(f.read())


文件打开方式：
 - r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
 - rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。
 - r+ 打开一个文件用于读写。文件指针将会放在文件的开头。
 - rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。
 - w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
 - wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
 - w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
 - wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。
 - a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
 - ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
 - a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
 - ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。


小结

在Python中，文件读写是通过open()函数打开的文件对象完成的。使用with语句操作文件IO是个好习惯。


========================================
第九天：os - path目录
----------------------------------------
Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 25 2016, 22:01:18) [MSC v.1900 32 bit (Intel)] on win32

python在安装的时候，就自带了很多模块，我们把这些模块称之为标准库，其中，有一个是使用频率比较高的，就是 os 。这个库中方法和属性众多，有兴趣的看官可以参考

官方文档：https://docs.python.org/3.5/library/os.html，或者在交互模式中，用dir(os)看一看。
Source code: Lib/os.py

代码如下:
>>> import os   #这个动作很重要，不能缺少 
>>> dir(os) 
['F_OK', 'MutableMapping', 'O_APPEND', 'O_BINARY', 'O_CREAT', 'O_EXCL', 'O_NOINHERIT', 'O_RANDOM', 'O_RDONLY', 'O_RDWR', 'O_SEQUENTIAL', 'O_SHORT_LIVED', 'O_TEMPORARY', 'O_TEXT', 'O_TRUNC', 'O_WRONLY', 'P_DETACH', 'P_NOWAIT', 'P_NOWAITO', 'P_OVERLAY', 'P_WAIT', 'R_OK', 'SEEK_CUR', 'SEEK_END', 'SEEK_SET', 'TMP_MAX', 'W_OK', 'X_OK', '_DummyDirEntry', '_Environ', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__','_dummy_scandir', '_execvpe', '_exists', '_exit', '_get_exports_list', '_putenv', '_unsetenv', '_wrap_close', 'abort', 'access', 'altsep', 'chdir', 'chmod', 'close', 'closerange', 'cpu_count', 'curdir', 'defpath', 'device_encoding', 'devnull', 'dup', 'dup2', 'environ', 'errno', 'error', 'execl', 'execle', 'execlp', 'execlpe', 'execv', 'execve', 'execvp', 'execvpe', 'extsep', 'fdopen', 'fsdecode','fsencode', 'fstat', 'fsync', 'ftruncate', 'get_exec_path', 'get_handle_inheritable', 'get_inheritable', 'get_terminal_size', 'getcwd', 'getcwdb', 'getenv', 'getlogin', 'getpid', 'getppid', 'isatty', 'kill', 'linesep', 'link', 'listdir', 'lseek', 'lstat', 'makedirs', 'mkdir', 'name', 'open', 'pardir', 'path', 'pathsep', 'pipe', 'popen', 'putenv', 'read', 'readlink', 'remove', 'removedirs', 'rename', 'renames', 'replace', 'rmdir', 'scandir', 'sep', 'set_handle_inheritable', 'set_inheritable', 'spawnl', 'spawnle', 'spawnv', 'spawnve', 'st', 'startfile', 'stat', 'stat_float_times', 'stat_result', 'statvfs_result', 'strerror', 'supports_bytes_environ', 'supports_dir_fd', 'supports_effective_ids', 'supports_fd', 'supports_follow_symlinks', 'symlink', 'sys', 'system', 'terminal_size', 'times', 'times_result', 'truncate', 'umask', 'uname_result', 'unlink', 'urandom', 'utime', 'waitpid', 'walk', 'write']

在这么多的东西中，本讲只关注os.path，真所谓“弱水三千，只取一瓢”，为什么这么偏爱它呢？因为它和前面已经讲过的文件操作进行配合，就能够随心所欲操作各个地方的文件了。
关于os.path的属性也不少，依然可以用dir(os.path)查看：
代码如下:


>>> dir(os.path) 
['__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_get_bothseps', '_getfinalpathname', '_getfullpathname', '_getvolumepathname', 'abspath', 'altsep', 'basename', 'commonpath', 'commonprefix', 'curdir', 'defpath', 'devnull', 'dirname', 'exists', 'expanduser', 'expandvars', 'extsep', 'genericpath', 'getatime', 'getctime', 'getmtime', 'getsize', 'isabs', 'isdir', 'isfile', 'islink', 'ismount', 'join', 'lexists', 'normcase', 'normpath', 'os', 'pardir', 'pathsep', 'realpath', 'relpath', 'samefile', 'sameopenfile', 'samestat', 'sep', 'split', 'splitdrive', 'splitext', 'splitunc', 'stat', 'supports_unicode_filenames', 'sys']

这么多属性，看官可以用help()逐个查看有关信息，并了解其使用方法。下面列出常见的几个使用方法，为看官减轻一点阅读英文的障碍，不过，如果看官英语足够好，请直接看原文档。就像这样：
代码如下:

>>> help(os.path.split)
Help on function split in module ntpath:

split(p)
    Split a pathname.

    Return tuple (head, tail) where tail is everything after the final slash.
    Either part may be empty.

以下将一些典型举例说明：

特别说明，下面的所有操作，均是进入到如下的目录（C:\python_data）中进行的。
代码如下:
>>> import os.path
>>> os.path.abspath('1.py')
'C:\\python_data\\1.py'

文件 1.py 是否真实存在上述路径中，都能得到该文件的相对该文件夹的绝对路径。
这里不妨理解为，如果要建立这个文件，它即将被放在那个位置。


但是，如何区别文件是否存在于这个目录中？
>>> os.path.isfile('1.py')
True
>>> os.path.isfile('100.py') #不存在的文件
False



分开目录和文件名
>>> pt=os.path.abspath('1.py')
>>> pt
'C:\\python_data\\1.py'
>>> os.path.split(pt)
('C:\\python_data', '1.py')

>>> path,filename=os.path.split(pt)
>>> path
'C:\\python_data'
>>> filename
'1.py'



os.paht.split(),参数是目录加文件名，就可以将路径和文件名分开。其实，我看这个功能不是很智能，你看
>>> os.path.split('/home/wjl')
('/home', 'wjl')
>>> os.path.split('/home/wjl/')
('/home/wjl', '')
它就是将最后一组认为是文件名了，即最后一个/后面的就是文件名，所以第二个实验中，文件名是空了。是不是有点傻呢？

同样，参数中的文件或者目录，不一定是你的电脑中真实存在的，请看：
>>> os.path.split('/home/wjl/a.gif')
('/home/wjl', 'a.gif')
只要符合目录书写结构，就可以分解了。该命令不关心这个文件或者路径是否真实存在。




有另外两个属性，是os.path.split()的分别执行，即可以分别获得路径和文件名，这样让操作更简单了。
>>> os.path.dirname('/home/wjl/a.gif')
'/home/wjl'
>>> os.path.basename('/home/wjl/a.gif')
'a.gif'


判断 - 路径是否存在
前面稍微提到了os.path.isfile()可以用来判断一个文件是否存在，那么判断目录路径是否存在，可否？可：
>>> os.path.exists('d:/R_code')
True
>>> os.path.exists('d:/R_code2')
False


组合路径
将两个或多个对象组合起来，是常见的事情，那么如何将多个路径组合呢？如下：
>>> os.path.join("/home/python","/BasicsPython","226.md")
'/BasicsPython\\226.md'
>>> os.path.join("/home/python","./BasicsPython","226.md")
'/home/python\\./BasicsPython\\226.md'
不同对象之间的分隔符是按照操作系统选择的。
特别提醒，第一个例子中属性的返回值，将第一个绝对路径忽略。




========================================
Python yield 使用浅析
----------------------------------------
带有 yield 的函数在 Python 中被称之为 generator（生成器），何谓 generator ？
我们先抛开 generator，以一个常见的编程题目来展示 yield 的概念。

仅仅把 print b 改为了 yield b。




yield什么用？http://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/
关于Python中的yield：迭代器和生成器：http://www.cnblogs.com/tqsummer/archive/2010/12/27/1917927.html




========================================
命令行启动py脚本时的参数传入
----------------------------------------
1.基础版本
(1)脚本内容 sayID.py
#!/usr/bin/env python3

import sys
print(sys.argv)
#print(sys.argv[-1])

def test():
        args=sys.argv
        print("From function test()")

if __name__=='__main__':
        test()

(2)测试结果
1)直接传递参数
$ ./sayID.py abc.txt
['./sayID.py', 'abc.txt']
From function test()

2)传入文本中的参数
$ cat > id.txt
c1-1
c2-2
c2-3
c3-1
^C

$ cat id.txt | ./sayID.py
['./sayID.py']
From function test()

$ cat id.txt | xargs ./sayID.py
['./sayID.py', 'c1-1', 'c2-2', 'c2-3', 'c3-1']
From function test()

还是只传入一个参数好了。
然后通过Linux循环，提交后台运行。




2. 改进版本1:从命令行传入cellID，然后后续使用该变量
(1)代码
#!/usr/bin/env python3

import sys

cellId=""
if __name__=='__main__':
        args=sys.argv
        assert len(args)>=2, 'please input the Cell ID'
        print(args[1])
        cellId=args[1]


print("The cell file is : ",cellId+".bed") #这里依旧可以使用

(2)测试结果
$ ./sayID.py c12-01
c12-01
The cell file is :  c12-01.bed

$ ./sayID.py c12-03
c12-03
The cell file is :  c12-03.bed

符合预期





========================================
python数组、列表、字典、集合等的操作
----------------------------------------
1.列表
https://blog.csdn.net/litao_243/article/details/80484082

sm = ['cat','dog','bat','spider']
sm.append('fox') #结尾添加元素
sm.insert(2，'fox') #在位置2插入元素




2.集合的添加。集合能保证唯一性。
a=set() #新建空集合
a.add(3)
a

sm = {'cat','dog','bat','spider'}
sm.add('fox')


========================================
Python的lambda, filter, reduce 和 map
----------------------------------------
https://www.cnblogs.com/reanote/p/python_lambda.html

Lambda操作或者lambda函数是一种创建小型匿名函数的方式，即：函数都没有函数名。这些函数都是投掷(throw-away)函数，即：它们只会在我们需要的地方创建，Lambda函数大部分时间都是与filter(), map() 和 reduce()函数混合使用。Lambda特性被添加到Python是因为Lisp 程序员的强烈要求。



1.Lambda函数通常的语法是十分简单的：
lambda argument_list: expression

参数列表(argument_list)是由逗号分隔的参数列表组成，而上面这个表达式（expression）是一个可以使用这些参数的算术表达式。你能通过把这个函数赋给一个变量来给这个lambda函数一个名字。

下面这个lambda函数的例子返回的是这两个参数的和：
f=lambda x,y:x+y
f(1,2) #3





2.map() 函数
当与map函数混合使用的时候，lambda操作的优势就能体现出来了。

map()是一个带有两个参数的函数：
r = map(func, seq)
第一个参数func是一个函数名，第二个seq是一个序列（如：list)。map()将会这个函数应用在序列seq的每一个元素上，然后返回一个被这个函数func改变后的元素的列表
def add(T):
    return 1+T
temp = (1, 50, 35,9)
rs=map(add, temp)

#打印结果，简写: list(rs)
for i in temp:
    print(next(rs))
#2
#51
#36
#10

使用lambda则可以避免先定义函数：
rs2=map(lambda x:1+x, temp)

map()能够应用多个列表，但这些列表必须有相同的长度。
对列表的下标为0的同时传入，然后下标为1的同时传入，直到n。
a = [1,2,3,4]
b = [17,12,11,10]
c = [-1,-4,5,9]
rs3=map(lambda x,y:x+y, a,b)

list(rs3)
#[18, 102, 113, 14]





3. Filtering 
filter(func, list) 函数提供了一种优雅的方式去把函数func返回值为True的元素过滤出来。

filter(f, l) 需要一个函数f作为它的第一个参数。f返回一个布尔型的值，如：True或者False。这个函数将会应用在列表l的每一个元素上。只有当f返回True的时候，这个列表中的元素才会包含在结果列表中。
a=[1,2,3,4,5]
rs=filter(lambda x:x%2, a) #只要奇数。
list(rs) #[1, 3, 5]
list(filter(lambda x:x%2==0, a)) #只要偶数 [2, 4] 





4.Reducing a List
函数reduce(func, seq)持续的应用函数func在序列上。它将会返回一个值。

一个序列 seq = [ s1, s2, s3, ... , sn ], 调用reduce(func, seq)的工作像这样：
func(s1,s2)
func(func(s1, s2),s3)
..
直到只剩下一个元素，然后作为reduce的结果返回这个元素

#累加求和
from functools import reduce
reduce(lambda x,y: x+y, [47,11,42,13]) #113
#累加求和2
print( list(range(3)) ) #[0, 1, 2]
reduce(lambda x,y:x+y, range(101)) #5050

#使用reduce来查找一列数字中的最大值
f = lambda a,b: a if (a > b) else b
reduce(f, [47,11,42,102,13]) #102





========================================
Python列表生成式(List Comprehensions)
----------------------------------------
https://www.cnblogs.com/reanote/p/python_list_comprehension.html

列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。

对于函数map(), filter(), 和reduce()，递推式构造列表（List comprehension）是一个完整的lambda替代者。对于大部分人们，递推式构造列表（List comprehension）的语法更容易被人们掌握。 



#1. 生成1到10.
list(range(1, 11)) #[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

#2. 如果生成1^2,2^2,3^2,...10^2等。可以用循环
L=[]
for i in range(11):
    L.append(i*i)
print(L)
#也可以用列表生成式
[x*x for x in range(11)]
#[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]



#3. 获取华氏温度
#可以用map和lambda函数
D= [39.2, 36.5, 37.3, 37.8]
F=map(lambda x:(float(9)/5)*x + 32, D)
list(F)
#也可以用列表生成式
[ ((float(9)/5)*x + 32) for x in D ]
#[102.56, 97.7, 99.14, 100.03999999999999]



#4.(if的使用)用递推式构造列表（list comprehension）创建了毕达哥拉斯三元组：
[(x,y,z) for x in range(1,30) for y in range(x,30) for z in range(y,30) if x**2 + y**2 == z**2]
#[(3, 4, 5), (5, 12, 13), (6, 8, 10), (7, 24, 25), (8, 15, 17), (9, 12, 15), (10, 24, 26), (12, 16, 20), (15, 20, 25), (20, 21, 29)]


### 把list中所有的字符串变成小写：
#字符串时
L = ['Hello', 'World', 'IBM', 'Apple']
[x.lower() for x in L]
# 有非字符串元素时，由于非字符串没有lower()方法，会报错，所以需要用if过滤出字符串。
L1 = ['Hello', 'World', 18, 'Apple', None]
[s.lower() for s in L1 if isinstance(s, str)] #['hello', 'world', 'apple']








#5.两个集合的交叉乘积
colours = [ "red", "green"]
things = [ "house", "car", "tree" ]
coloured_things = [ (x,y) for x in colours for y in things ]
coloured_things
#[('red', 'house'),  ('red', 'car'),('red', 'tree'), ('green', 'house'), ('green', 'car'), ('green', 'tree')]

#或者字符串全排列
[m + n for m in 'ABC' for n in 'XYZ']
# ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']




#6.递推式构造生成器(Generator Comprehension)
x=(x **2 for x in range(20))
print(x) #<generator object <genexpr> at 0x7fd9ec94a938>
list(x)



################
#更高级的例子
################
1.列出当前目录下的所有文件和目录名，可以通过一行代码实现：
import os
print(os.getcwd()) #当前工作目录
[d for d in os.listdir('.')] # os.listdir可以列出文件和目录



2.同时迭代出字典的key和value
d = {'x': 'A', 'y': 'B', 'z': 'C' }
#常规是用循环
for k, v in d.items():
	print(k, '=', v)
#x = A
#y = B
#z = C

#也可以用列表生成式
[x+"="+y for x,y in d.items()]
#['x=A', 'y=B', 'z=C']



3.利用埃拉托斯特尼筛法(Sieve of Eratosthenes)计算1到100的质数：
import math
n=100
noprimers = [j for i in range( 2, int(math.sqrt(n))+1 ) for j in range(i*2, n, i)]
print(noprimers)
primers=[x for x in range(2,n) if x not in noprimers]
print(primers)
##[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]

使用[]在noprimers中会有很多重复，使用set可以解决这个问题。
noprimers = {j for i in range( 2, int(math.sqrt(n))+1 ) for j in range(i*2, n, i)}
其他代码不变。



========================================
python web编程：使用socket包
----------------------------------------
建议直接用命令行窗口运行py的server脚本，不要用jupyter，否则端口无法释放。

1.error:[Errno 98] Address already in use的解决
当你该端口被其他进程占用时，那就需要你修改为一个未使用的端口号重新运行。

如果是运行程序没有通过<Ctrl> C正常结束， 而是直接关闭Terminal或者其他非正常途径退出的时候： 
通过lsof -i:(port)，查看占用该端口号的进程，一般就是刚未正常退出的进程。例如
$ lsof -i :8000 # 这个命令针对我用的port 8000
##COMMAND   PID   USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
##python3 16633 wangjl   56u  IPv4 38335892      0t0  TCP *:8000 (LISTEN)

然后kill掉该PID的进程，重新运行。
$ sudo kill -9 16633


如果是查看本机所有的进行的进程： 
ps aux　 #　用ps -A查看所有进程



2.



========================================
python web编程：使用flask包写接口
----------------------------------------
WARNING: Do not use the development server in a production environment.
Use a production WSGI server instead.

Python实现简单的API接口
https://blog.csdn.net/u013040887/article/details/78895323/

教程：http://docs.jinkan.org/docs/flask/quickstart.html#static-files



1.基本例子
$ cat dFlask.py 
from flask import Flask
app = Flask(__name__)
@app.route('/')  
def hello_world():
    return "hello world"
if __name__=='__main__':
    app.run(host="192.168.2.120",port=8000)

运行该脚本后，就可以用浏览器访问了 192.168.2.120:8000





2.简单的get和post
$ cat dFlask2.py 
# -*- coding: utf-8 -*-
# Flask hello world
from flask import Flask, redirect, request
from flask import render_template
app = Flask(__name__)

@app.route('/send_msg', methods=['GET','POST'])
def Messaging():
    if request.method =='POST':
        return('post1')
    elif request.method =='GET':
        return('get1')
    else:
        pass

@app.route('/send_msg2', methods=['POST'])
def do_send():
    return('post2')

@app.route('/send_msg2', methods=['GET'])
def show_form():
    return('get2')


@app.route('/')
def hello():
    return render_template('forms.html')


if __name__ == '__main__':
    ####默认监听127.0.0.1:5000   关闭调试模式
    app.run(host='192.168.2.120',port=8000,debug=True)
-
访问 
http://y.biomooc.com:8000/send_msg
http://y.biomooc.com:8000/send_msg2



3.怎么接收js的参数，处理后的数据再以json传递给js？








========================================
python如何使用base64、base32、base16编码解码
----------------------------------------
1.Base64编码转换 简介
https://www.qqxiuzi.cn/bianma/base64.htm



2.ZG9uZ3dlaW1pbmdAZG91YmFuLmNvbQ== 代表一个邮箱？
#base32解码
import base64
print base64.b32decode("输入要解密的密文")

#base64解码
import base64
print(base64.b64decode("ZG9uZ3dlaW1pbmdAZG91YmFuLmNvbQ==") )
## b'dongweiming@douban.com'



3.base64编码
>>> print(base64.b64encode(b'I love you'))
## b'SSBsb3ZlIHlvdQ=='


4.其他就是把64换成32或16即可。


refer:
https://blog.csdn.net/pdsu161530247/article/details/74840422
https://blog.csdn.net/just_h/article/details/72795088



========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


