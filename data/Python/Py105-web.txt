Python105-web

(2019.3.4)目前主要是flask 1.0.2和jinja2。
Django 框架



========================================
web based tutorials
----------------------------------------
python3的Django 写的博客系统：
https://tendcode.com/article/python-shell/ 


flask写用户登录功能 https://qinqianshan.com/web/flask/



========================================
|-- python web包的比较: Django、tornado、flask、webpy
----------------------------------------

在Python的web开发框架中，目前使用量最高的有Django、Flask和Tornado， 经常会有人拿这几个对比，相信大家的初步印象应该是 Django大而全、Flask小而精、Tornado性能高。


Django是Python 中最全能的 web 开发框架，走大而全的方向。它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。不过Django提供的方便，也意味着Django内置的ORM跟框架内的其他模块耦合程度高，深度绑定了该框架，应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于其ORM的优秀特性。

Tornado全称Tornado Web Server，是一个用Python语言写成的Web服务器兼Web应用框架。Tornado走的是少而精的方向，注重的是性能优越，它最出名的是异步非阻塞的服务器方式。(Tornado框架和服务器一起组成一个WSGI的全栈替代品。单独在WSGI容器中使用tornado web框架或者tornaod http服务器，有一定的局限性，为了最大化的利用tornado的性能，推荐同时使用tornaod的web框架和HTTP服务器。)

Flask是一个使用 Python 编写的轻量级 Web 应用框架，也被称为 “microframework”，语法简单，部署很方便，整个框架自带了路径映射、模板引擎（Jinja2）、简单的数据库访问等web框架组件，支持WSGI协议（采用 Werkzeug）。Flask使用 BSD 授权。 Flask使用简单的核心，用 extension 增加其他功能，虽然没有默认使用的数据库、窗体验证工具，然而Flask保留了扩增的弹性，可以用Flask-extension加入ORM、窗体验证工具、文件上传、各种开放式身份验证技术这些功能。



从性能上看Tornado 比Django、Flask等主流 Web 服务器框架相比有着明显的区别：它是非阻塞式服务器，速度相当快。然而 Tornado 相比 Django 和Flask属于较为原始的框架，插件少，许多内容需要自己去处理。而Flask插件多，文档非常专业，有专门的公司团队维护，对于快速开发很有效率。由于WSGI协议的存在，可以结合 Tornado 的服务器异步特性、并发处理能力和Flask的文档和扩展能力为一体。虽然像Django，Flask框架都有自己实现的简单的WSGI服务器，但一般用于服务器调试，生产环境下建议用其他WSGI服务器，比如Nginx+uwsgi+Django方式。


Tornado关于使用平台的说明：
Tornado should run on any Unix-like platform, although for the best performance and scalability only Linux (with epoll) and BSD (with kqueue) are recommended for production deployment (even though Mac OS X is derived from BSD and supports kqueue, its networking performance is generally poor so it is recommended only for development use). Tornado will also run on Windows, although this configuration is not officially supported and is recommended only for development use.
Tornado应该运行在类Unix平台，在线上部署时为了最佳的性能和扩展性，仅推荐Linux和BSD（因为充分利用Linux的epoll工具和BSD的kqueue工具，是Tornado不依靠多进程/多线程而达到高性能的原因）。对于Mac OS X，虽然也是衍生自BSD并且支持kqueue，但是其网络性能通常不太给力，因此仅推荐用于开发。对于Windows，Tornado官方没有提供配置支持，但是也可以运行起来，不过仅推荐在开发中使用。







========================================
|-- python web编程：使用socket包
----------------------------------------
建议直接用命令行窗口运行py的server脚本，不要用jupyter，否则端口无法释放。

1.error:[Errno 98] Address already in use的解决
当你该端口被其他进程占用时，那就需要你修改为一个未使用的端口号重新运行。

如果是运行程序没有通过<Ctrl> C正常结束， 而是直接关闭Terminal或者其他非正常途径退出的时候： 
通过lsof -i:(port)，查看占用该端口号的进程，一般就是刚未正常退出的进程。例如
$ lsof -i :8000 # 这个命令针对我用的port 8000
##COMMAND   PID   USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
##python3 16633 wangjl   56u  IPv4 38335892      0t0  TCP *:8000 (LISTEN)

然后kill掉该PID的进程，重新运行。
$ sudo kill -9 16633


如果是查看本机所有的进行的进程： 
ps aux　 #　用ps -A查看所有进程



2.



========================================
flask简介
----------------------------------------
flask: https://palletsprojects.com/p/flask/
文档： https://flask.palletsprojects.com/en/1.1.x/



《Flask Web开发：基于Python的Web应用开发实战》
http://blog.sina.com.cn/s/blog_c3b6050b0102x0l0.html

第一部分 Flask简介 
第1章 安装  
第2章 程序的基本结构 
第3章 模板  
第4章 web表单  
第5章 数据库 
第6章 电子邮件 
第7章 大型程序的结构 

第二部分 实例：社会化博客程序 
第8章 用户认证 
第9章 用户角色 
第10章 用户资料 
第11章 博客文章 
第12章 关注者 
第13章 用户评论 
第14章 程序编程接口 

第三部分 成功在望 
第15章 测试 
第16章 性能 
第17章 部署 
第18章 其他资源



Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions. And before you ask: It's BSD licensed!


1.安装
pip install flask

2. 老版1.0例子
文件hello.py
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"

if __name__ == '__main__':
    app.run()

运行
>python hello.py

然后浏览器输入 http://127.0.0.1:5000/




###
3. 新版1.1例子
文件a2.py 
from flask import Flask, escape, request

app = Flask(__name__)

@app.route('/')
def hello():
    name = request.args.get("name", "World")
    return f'Hello, {escape(name)}!'
#
运行：
env FLASK_APP=hello.py flask run

访问浏览器 http://127.0.0.1:5000/?name=Flask~~
Hello, Flask~~!









========================================
|-- flask URL生成: url_for()函数
----------------------------------------

1.url_for() 函数。按照函数名，生成其对应的报时器中的url。

本质是根据函数名反向生成url，使用函数 url_for() 来针对一个特定的函数构建一个 URL。它能够接受函数名作为第一参数，以及一些关键字参数， 每一个关键字参数对应于 URL 规则的变量部分。

未知变量部分被插入到 URL 中作为查询参数。

url_for(方法的名) =app.route参数名
而url_for() 本身和app.route的参数是没关系的，只和方法的参数名相关。


@app.route('/')
def index():
	url=url_for('hello') #第一个参数是函数名，不是路由
	return '<meta http-equiv="refresh" content="0;url='+url+'">'
#

@app.route('/index.py')
def hello():
	pass();
#



2.例2

from flask import Flask,url_for
app = Flask(__name__)


@app.route('/')       #定义一个路由
def hello_world():    #定义一个视图函数
    return "<a href="+url_for('index',keyword="Main", id="1_2" ) +">goto</a>"
#<a href=/html/Main/1_2>goto</a>


@app.route('/html/<keyword>/<id>')
def index(keyword,id):
    return 'Hello kw=%s, id=%s!\n'%(keyword, id);

if __name__ == '__main__':
    app.run()



========================================
|-- flask 的调试，输出到控制台
----------------------------------------
1. 输出到网页
@app.route('/wjl')
def ixx():
	a=getConf("style",'txt');

	#txtStyle = cf.get(section, item)
	return a;
#


2. 输出到控制台 
with app.test_request_context():
	a=getConf("style",'txt');
	print(a) 
#




========================================
|-- python web编程：使用flask包写接口(路由、参数传递、获取) get post header 获取参数
----------------------------------------
WARNING: Do not use the development server in a production environment.
Use a production WSGI server instead.

Python实现简单的API接口
https://blog.csdn.net/u013040887/article/details/78895323/

教程：http://docs.jinkan.org/docs/flask/quickstart.html#static-files


1.基本例子
$ cat dFlask.py 
from flask import Flask
app = Flask(__name__)
@app.route('/')  
def hello_world():
    return "hello world"
if __name__=='__main__':
    app.run(host="192.168.2.120",port=8000)

运行该脚本后，就可以用浏览器访问了 192.168.2.120:8000





2.简单的get和post
(1)请求简介
1).get请求：
　　使用场景：
　　　　说白了就是从服务器获取数据，比如查询百度的时候就是这样的。
　　传参方式：
　　　　放在url中并且是通过 "  ?  " 的形式来指定Key和 Value的。
2).post请求：
　　使用场景：
　　　　对服务期产生影响，比如说登入的时候提交密码。
　　传参方式：
　　　　不通过url传参，通过"  foem_data  "的形式将信息发送至服务器。

(2)获取两种请求的参数
1.get请求：
　　flask.request.args获取，返回的是字典。
2.post请求;
　　flask.request.form获取，返回字典。
	注意：
		默认的视图函数只能发送get请求。如果要发送post请求时要再参数中写清楚。
		例如：@app.route('/login/',methods=['POST'])
3.从header获取信息：获取http的head信息，比如一些auth信息或者referer，useragent的信息等。
	request.headers.get("User-Agent")
#


例
$ cat dFlask2.py 
# -*- coding: utf-8 -*-
# Flask hello world
from flask import Flask, redirect, request
from flask import render_template
app = Flask(__name__)

@app.route('/send_msg', methods=['GET','POST']) #默认只接受get参数
def Messaging():
    if request.method =='POST':
        username = request.form.get('username', '默认值');
        return('post: username='+username);
    elif request.method =='GET':
        usr=request.args.get('username','默认值');
        return('get: usr = '+ usr)
    else:
        pass

@app.route('/send_msg2', methods=['POST'])
def do_send():
    return('post2')

@app.route('/send_msg2', methods=['GET'])
def show_form():
    return('get2')


@app.route('/')
def hello():
    return render_template('forms.html')


if __name__ == '__main__':
    ####默认监听127.0.0.1:5000   关闭调试模式
    app.run(host='192.168.2.120',port=8000,debug=True)
-
访问 
http://y.biomooc.com:8000/send_msg
http://y.biomooc.com:8000/send_msg2










3.路由解析：通过url动态传递参数
(1)#加不加最后的斜杠不一样
@app.route('/projects/')
def projects():
    return 'The project page' #访问时不带最后斜杠，会自动补齐斜杠

@app.route('/about')
def about():
    return 'The about page' #访问的时候加了斜杠，就会报错404
#



(2)从url传入的5类参数
#传入参数
@app.route('/user/<username>')
def show_user_profile(username):
    # show the user profile for that user
    return 'User %s' % escape(username)
#http://blog2.163.com:8000/user/wjl
#User wjl


@app.route('/post/<int:post_id>')
def show_post(post_id):
    # show the post with the given id, the id is an integer
    return 'Post %d' % post_id
# http://blog2.163.com:8000/post/123456
# Post 123456


@app.route('/path/<path:subpath>')
def show_subpath(subpath):
    # show the subpath after /path/
    return 'Subpath %s' % escape(subpath)
# http://blog2.163.com:8000/path/c/usr/bin/python3
# Subpath c/usr/bin/python3


Converter types:
	string:(default) accepts any text without a slash
	int:accepts positive integers
	float:accepts positive floating point values
	path:like string but also accepts slashes
	uuid:accepts UUID strings
#


(3) 从url获取get参数
@app.route('/hello2')
def hello2():
    name = request.args.get("name", "World2")
    return f'Hello, {escape(name)}!'
# http://blog2.163.com:8000/hello2?name=python3
# Hello, python3!

#






4.使用url_for函数构建URL
from flask import Flask, escape, url_for
app = Flask(__name__)

@app.route('/')
def index():
    return 'index'

@app.route('/login')
def login():
    return 'login'

@app.route('/user/<username>')
def profile(username):
    return '{}\'s profile'.format(escape(username))
# http://blog2.163.com:8000/user/百度
# 百度's profile

with app.test_request_context():
    print(url_for('index')) #第一个参数是函数名，不是路由。必须定义过，否则报错。
    print(url_for('login'))
    print(url_for('login', next='/'))
    print(url_for('profile', username='John Doe'))
#/
#/login
#/login?next=%2F
#/user/John%20Doe #输出的路径是按照路由构建的，与函数名无关。

if __name__ == '__main__':
    app.run(host="blog2.163.com",port=8000)
#







3.怎么接收js的参数，处理后的数据再以json传递给js？





========================================
|-- flask中的g、add_url_rule、send_from_directory、static_url_path、static_folder的用法
----------------------------------------
https://www.cnblogs.com/shengulong/p/7106166.html








========================================
|-- 加载非static/下的图片
----------------------------------------
# 添加新静态文件的路径，这样就允许data/下的图片加载了
@app.route("/data/<path:filename>")
def downloader(filename):
    return send_from_directory("data",filename,as_attachment=False)
#



========================================
|-- flask配合表达实现文件上传，下载(todo)
----------------------------------------
#version1: 基本功能
#
import flask, os,sys,time
from flask import request, send_from_directory

interface_path = os.path.dirname(__file__)
sys.path.insert(0, interface_path)  #将当前文件的父目录加入临时系统变量

server = flask.Flask(__name__)

htmlForm="""
<meta http-equiv="content-type" content="text/html;charset=utf-8">
upload a file<br>
<form action="/upload" method="post" enctype="multipart/form-data">
	<input type="file" name="file" />
	<input type="submit" value="上传文件" />
</form>
"""

htmlBtn="""
<style>
a.btn{
    border: 1px solid red;
    padding: 2px 5px;
    text-decoration: none;
	margin:5px;
	
	background:white;
	color:red;
}
a.btn:hover{
    color: white;
	background: red;
}
</style>
<a class=btn target="_blank" href='/upload'>Upload File</a> 
<a class=btn target="_blank" href='http://y.biomooc.com/wangjl/docs/'>File List(Download File)</a> 
<br>
1. Files stay more than 2 days may be deleted! Please backup in time;<br>
2. Now you cannot delete the file yourself; If you want to delete a file, please ask the administrator for help.<br>
3. 
"""

@server.route('/')
def index():
    return htmlBtn;

# post方法：上传文件的
@server.route('/upload', methods=['POST','GET'])
def upload():
    if request.method=='GET':
        return(htmlForm);

    fname = request.files.get('file')  #获取上传的文件
    if fname:
        t = time.strftime('%Y%m%d%H%M%S')
        new_fname = r'./' +t+"_" + fname.filename #文件名加时间前缀，防止覆盖同名文件
        fname.save(new_fname)  #保存文件到指定路径
        #status= '{"code": "ok"}'
        return '<meta http-equiv="refresh" content="2;url=/">Upload success!';
    else:
        return '{"msg": "no file"}';

server.run(host="192.168.2.120",port=8000, debug=True)

使用方法：
$ python upload.py
访问浏览器 http://192.168.2.120:8000
即可看到2个按钮，点上传到/upload页面，选择文件，点上传即可完成上传。



refer:
https://www.cnblogs.com/jessicaxu/p/7891372.html





========================================
|-- 404页面
----------------------------------------

@app.errorhandler(404)
def page_not_found(error):
    return render_template('page_not_found.html')
#

需要在 templates 下新建page_not_found.html。内容自定义。




========================================
|-- 使用flask的jsonify返回json数据
----------------------------------------
1.py文件

from flask import Flask
from flask import jsonify 

app = Flask(__name__)

#json Controler
@app.route('/api/content/<date>')
def content(date):
    status=True
    
    #从Mysql获取当天数据
    content="some content from Mysql-"+date
    
    if content=="":
        status=False;
    #返回json
    return jsonify({'status':status,'date':date, 'content':content})

#启动程序
if __name__ == '__main__':
    print("==> pls browse http://127.0.0.1:5000/api/content/2019")
    app.run()

2.运行
python hello2.py 

在浏览器输入 http://127.0.0.1:5000/api/content/2019
即可看到json个数的数据：
{"content":"some content from Mysql-2019","date":"2019","status":true}




3.用jQuery获取json数据
(1)py文件
from flask import Flask,request
from flask import jsonify
from flask.templating import render_template

app = Flask(__name__)

#首页Controler
@app.route('/', methods=['GET'])
def home():
    return render_template("jQ_index.html");


#计算并返回
@app.route('/add', methods=['GET'])
def add_numbers():
    a=request.args.get('a',0,type=int) #获取表单参数
    b=request.args.get('b',0,type=int)
    return jsonify({'result': a+b});


#run app
if __name__ == '__main__':
    print("==> pls browse http://10.21.127.192:5000/")
    app.run(host="0.0.0.0", debug=True)


(2)jQ_index.html文件放在py同级的templates文件夹下
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Flask JQuery</title>

<!-- 插入jquery -->
<script src="{{url_for('static', filename='jquery-1.8.0.js')}}"></script>

<script type=text/javascript>
var $SCRIPT_ROOT = {{request.script_root|tojson|safe}};//这是？
</script>

<script type=text/javascript>
$(function() {
    function submit_form(e) {
        $.getJSON($SCRIPT_ROOT + '/add', 
		{
            a: $('input[name="a"]').val(),
            b: $('input[name="b"]').val(),
            now: new Date().getTime()
        },
        function(data,status) { /*status 参数可以省略*/
			console.log("status =",status)
            $('#result').text(data.result);
        });
    };
    // 绑定click事件
    $('#calculate').bind('click', submit_form);
});
</script>
</head>
<body>
<p>
    <input type=text size=5 name=a> +
    <input type=text size=5 name=b> =
    <span id=result>?</span>
</p>
<p><input type="button" id="calculate" value="计算"></p>
</body>
</html>

(3)jquery-1.8.0.js文件放到py同级的static文件夹下
(4)访问 http://10.21.127.192:5000/ 即可。



========================================
|-- python mysql 转义方法
----------------------------------------

python抓取的一些是数据放到mysql里去，但是有个问题，因为从外面抓取的数据有带'等其他的不规则的数据，如果你直接调用插入数据的方法会提示报错，这个时候就需要用到 python mysql 转义了。

通过help方法和dir的方法终于找到了，原来是：escape_string

如果你要用mysql转义字符串，那就可以看看下面的使用方法了：
content = MySQLdb.escape_string(content)


========================================
|-- 从url获取参数，从mysql获取数据，以json格式返回
----------------------------------------
1.hello3.py 
from flask import Flask
from flask import jsonify
import pymysql

app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World! PLS browse: http://127.0.0.1:5000/about/32"

def getItem(id):
	#mysql 获取数据
	# 打开数据库连接
	#db = pymysql.connect(host='y.biomooc.com',port=7070,user='yanpd', password='789789', database='english')
	db = pymysql.connect(host='localhost',port=3306,user='root', password='', database='think')
	# 使用cursor()方法获取操作游标 
	cursor = db.cursor()
	# 执行sql语句
	sql = "select * from think_weibo where id="+id
	cursor.execute(sql)
	values = cursor.fetchall()
	# 关闭数据库连接
	db.close()
	#返回结果
	return values

#从url获取参数 http://127.0.0.1:5000/about/30
@app.route("/about/<id>")
def about(id):
	return jsonify(getItem(id));

if __name__ == '__main__':
    app.run()



2.运行该应用:
python hello3.py 

在浏览器输入 http://127.0.0.1:5000/about/30
即可看到json格式的、从mysql返回的数据。




========================================
|-- flask 允许跨域请求 cors ：用make_response 设置 'Access-Control-Allow-Origin' header
----------------------------------------
1. 实例1：跨域请求文本文件，相当于py是一个静态文件服务器

推荐方式
#CORS (Cross-Origin Resource Sharing)
def cors(arrOrStr):
    res=jsonify(arrOrStr)
    res.headers.add('Access-Control-Allow-Origin', '*')
    res.headers.add('Backend', 'wjl_dawnDict_server/0.3')
    res.headers.add('Email', 'jimmymall at 163 dot com')
    return res;
#


使用：需要提供跨域访问的地方，把返回值包裹一下即可：
return cors(arrayOrDict);




(1)py代码
# https://gist.github.com/LtGlahn/f0cad0530b4b4298fa8c
# https://www.pythonanywhere.com/forums/topic/2192/

#
#设置变量
import sys
env=sys.platform #"win32"测试环境;  "linux"生产环境
#print('env=',env)
if env=='linux':
    rootPath="/home/wangjl/web/docs/" #ubuntu
elif env=='win32':
    rootPath="F://Temp/" #windows

##############
# 支持跨域访问
# version: 0.2
##############
#路径名字不能是/static/,因为它是内部定义过的静态文件路径
@server.route('/file/<path:filePath>', methods=['get'])
def audio(filePath):
    #fpath = request.values.get('path', '') #获取文件路径
    #fname = request.values.get('filename', '')  #获取文件名
    fpathT = os.path.join(rootPath, filePath) #真实路径
    print(fpathT)
    if filePath.strip():
        if os.path.isfile(fpathT):
            blob=''
            try:
                with open( fpathT, 'rb') as file:
                    blob = file.read()
            except Exception as e:
                print(e)
                pass
            #
            res = make_response(blob) #重点：自定义响应
            res.mimetype='application/octet-stream'
            res.headers['Access-Control-Allow-Origin'] = '*' #允许跨域请求
            return res;
        else:
            return '{"msg2":"参数不正确"}path=%s, filename=%s;' %(fpathT, fname);
    else:
        return '{"msg1":"请输入参数"}'
#ajax test OK: http://127.0.0.1:8005/file/tmp.R


(2)测试：
<html>
<head>
<!--
  <script type="text/javascript" src="/html5/jquery-1.9.1.min.js"></script>
-->
<script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
<style>
#show{border:1px solid red;}
</style>
<script type="text/javascript">
$(document).ready(function(){
  $("button").click(function(){
    $.get('http://127.0.0.1:8005/file/tmp.R',function(res){
      $('#show').html( res );
    })
  });
});
</script>
</head>

<body>
  <button>click</button>
  <pre id="show">xx</pre>
</body>

</html>



2. 实例2： 返回json数据
(1)app1.py
from flask import jsonify,make_response

#json Controler 不能跨域请求
import time
@app.route('/api/content/<date>')
def content(date):
    status=True
    #time.sleep(2)
    #从Mysql获取当天数据
    content="<h1>some content from Mysql-Docker "+date+'</h1>'
    
    if content=="":
        status=False
    #返回json
    return jsonify({'status':status,'date':date, 'content':content})

#json Controler 允许跨域请求
import time
@app.route('/api/content2/<date>')
def content2(date):
    status=True
    #time.sleep(2)
    #从Mysql获取当天数据
    content="<h1>some content2 from Mysql-Docker "+date+'</h1>'
    
    if content=="":
        status=False
    #构建自定义响应
    json_data=jsonify({'status':status,'date':date, 'content':content})
    res=make_response(json_data)
    #允许跨域
    res.headers['Access-Control-Allow-Origin']='*'
    #返回json
    return res


#启动程序
if __name__ == '__main__':
    print("==> pls browse http://127.0.0.1:5000/api/content/2019")
    app.run(debug=True)

(2)测试 ajax2.html
<html>
<head>
<script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
<style>
#show{border:1px solid red;}
</style>
<script type="text/javascript">
$(document).ready(function(){
  $("#btn1").click(function(){
      $.get('http://127.0.0.1:5000/api/content/2019', function(res){
      $('#show').html( res );
    })
  });

  $("#btn2").click(function(){
    $.get('http://127.0.0.1:5000/api/content2/2019', function(res){
      console.log(res)
    })
  })
});
</script>
</head>

<body>
  <button id='btn1'>btn1</button>
  <button id='btn2'>btn2</button>
</body>
</html>

效果
点击btn1，控制台：
Access to XMLHttpRequest at 'http://127.0.0.1:5000/api/content/2019' from origin 'http://127.0.0.1' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
jquery.min.js:4 Cross-Origin Read Blocking (CORB) blocked cross-origin response http://127.0.0.1:5000/api/content/2019 with MIME type application/json. See https://www.chromestatus.com/feature/5629709824032768 for more details.


点击btn2，控制台：
{content: "<h1>some content2 from Mysql-Docker 2019</h1>", date: "2019", status: true}




3. 实例3：简化的返回json的方法
@app.route('/your/route/<params>', methods=['GET'])
def yourMethod(params):
    response = jsonify({'some': 'data'})
    response.headers.add('Access-Control-Allow-Origin', '*')
    return response
#测试也能通过





========================================
|-- blueprint 技术：能降低入口文件(app/__init__.py) 的长度
----------------------------------------
1.蓝图就是把一部分功能打包成一个python包。
# * 特别适合重复使用的模块，比如用户、权限等的打包。
# * 或者同一个系统内，使用两种不同的url策略。这样不同的url，加载同一个蓝图，节省了一个模块的开发。

文件结构
app.py 
static/
templates/
blueprints/ 里面放很多蓝图，相当于独立的包
  |-maintain/ 这是一个叫做maintain的蓝图
    |-static/
    |-templates/
	|-__init__.py

(1) 现在 blueprints/maintain/__init__.py 中添加代码
#
from flask import Blueprint

bp=Blueprint('maintain', __name__,
             template_folder='templates',
             static_folder='static')

@bp.route('/ping')
def ping():
    return "pong"





(2) 然后在入口文件 app.py 中引入该文件

from flask import Flask
from flask import request
app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return '<h1>Home 4</h1>'

# 导入蓝图。具体实现（控制器、模板等文件）可以在其他文件夹中。
from blueprints import maintain

#2选1，url_prefix 是可选参数，默认是空
app.register_blueprint(maintain.bp) #访问： xx:5000/ping
app.register_blueprint(maintain.bp, url_prefix="/maintain") #访问： xx:5000/maintain/ping

app.logger.info('Load blueprints/maintain')

if __name__ == '__main__':
    app.run(debug=True)

#

(3) 运行入口文件 app.py即可访问浏览器
xx:5000/ping 查看是否返回pong



refer:
https://www.bilibili.com/video/BV1j64y1M7sd

https://dormousehole.readthedocs.io/en/latest/
https://dormousehole.readthedocs.io/en/latest/tutorial/views.html








========================================
|-- 获得访问者IP地址
----------------------------------------
1.代码
(1) demo.py
from flask import Flask, render_template, request

# Initialize the Flask application
app = Flask(__name__)
# Default route, print user's IP
@app.route('/')
def index():
    ip = request.remote_addr
    return render_template('getIP.html', user_ip=ip)
if __name__ == '__main__':
    app.run(
        host="0.0.0.0",
        port=int("81")
    )


(2) 模板
$ cat getIP.html 
<p>You IP address is: {{user_ip}}</p>
<h3 class="text-muted">Code to retrieve the IP</h3>

(3) 测试
http://10.21.9.239:81/  You IP address is: 10.21.9.239
http://192.168.19.1:81/  You IP address is: 192.168.19.1








========================================
flask-SQLAlchemy 及 flask 常见模型类: 模型这个术语表示程序使用的持久化实体
----------------------------------------

flask-sqlalchemy 致力于简化在 Flask 中 SQLAlchemy 的使用，提供了有用的默认值和额外的助手来更简单地完成常见任务。



1. flask中的模型

## example1
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///./test.db'
db = SQLAlchemy(app)

class User(db.Model):
    id = db.Column(db.Integer,primary_key=True)
    username = db.Column(db.String(80),unique = True)
    email = db.Column(db.String(120),unique=True)

    def __init__(self,username,email):
        self.username = username
        self.email = email

    def __repr__(self):
        return '<User %r>' % self.username

 db.create_all()
#
# 解释：
(1) 模型需要继承自db.Model,然后需要映射到表中的属性,必须写成db.Column的数据类型
(2)
db.Integer代表整型
db.String代表varchar
db.Text 代表text

(3)
其他参数
primary_key 代表将这个字段设置为主键
autoincrement 代表这个主键为自增长的
nullable 代表这个字段是否为空,默认可以为空

最后用db.creat_all() 将模型真正创建到数据库中

admin = User('admin','admin@example.com')
guest = User('guest','guest@example.com')

db.session.add(admin)
db.session.add(guest)
db.session.commit()

ref: 
https://blog.csdn.net/Co_zy/article/details/77905568










2.
(1)一对多
class Role(db.Model):
    """角色表"""
    __tablename__ = 'roles'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    users = db.relationship('User', backref='role', lazy='dynamic')

class User(db.Model):
    """用户表"""
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True, index=True)


(2)多对多
tb_student_course = db.Table('tb_student_course',
                             db.Column('student_id', db.Integer, db.ForeignKey('students.id')),
                             db.Column('course_id', db.Integer, db.ForeignKey('courses.id'))
                             )

class Student(db.Model):
    __tablename__ = "students"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)

    courses = db.relationship('Course', secondary=tb_student_course,
                              backref=db.backref('students', lazy='dynamic'),
                              lazy='dynamic')

class Course(db.Model):
    __tablename__ = "courses"
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)


(3)自关联 一对多
class Comment(db.Model):
    """评论"""
    __tablename__ = "comments"

    id = db.Column(db.Integer, primary_key=True)
    # 评论内容
    content = db.Column(db.Text, nullable=False)
    # 父评论id
    parent_id = db.Column(db.Integer, db.ForeignKey("comments.id"))
    # 父评论(也是评论模型)
    parent = db.relationship("Comment", remote_side=[id],
                             backref=db.backref('childs', lazy='dynamic'))

# 测试代码
if __name__ == '__main__':
    db.drop_all()
    db.create_all()

    com1 = Comment(content='我是主评论1')
    com2 = Comment(content='我是主评论2')
    com11 = Comment(content='我是回复主评论1的子评论1')
    com11.parent = com1
    com12 = Comment(content='我是回复主评论1的子评论2')
    com12.parent = com1

    db.session.add_all([com1, com2, com11, com12])
    db.session.commit()
    app.run(debug=True)


(4)自关联多对多
tb_user_follows = db.Table(
    "tb_user_follows",
    db.Column('follower_id', db.Integer, db.ForeignKey('info_user.id'), primary_key=True),  # 粉丝id
    db.Column('followed_id', db.Integer, db.ForeignKey('info_user.id'), primary_key=True)  # 被关注人的id
)

class User(db.Model):
    """用户表"""
    __tablename__ = "info_user"

    id = db.Column(db.Integer, primary_key=True)  
    name = db.Column(db.String(32), unique=True, nullable=False)

    # 用户所有的粉丝，添加了反向引用followed，代表用户都关注了哪些人
    followers = db.relationship('User',
                                secondary=tb_user_follows,
                                primaryjoin=id == tb_user_follows.c.followed_id,
                                secondaryjoin=id == tb_user_follows.c.follower_id,
                                backref=db.backref('followed', lazy='dynamic'),
                                lazy='dynamic')
##







ref:
https://blog.csdn.net/fanlei5458/article/details/80464633

Flask从入门到精通之模型定义: https://www.cnblogs.com/senlinyang/p/8378632.html
	https://www.jianshu.com/p/19eb89b1d6b3

模型关系 https://www.cnblogs.com/senlinyang/p/8379436.html



========================================
flask 安全：cookie, session 和用户登录、退出
----------------------------------------
1.理论基础

(1)cookie(保存在客户端的浏览器上)：
在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。

(2)session(保存在服务器上):
session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，存一些session信息还是绰绰有余的。

(3)cookie和session结合使用：
web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：

1)存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。

2)将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式，但是也可以替换成其他形式。





2.flask中使用cookie和session
(1)cookies：
在Flask中操作cookie，是通过response对象来操作，可以在response返回之前，通过response.set_cookie来设置，这个方法有以下几个参数需要注意：

key：设置的cookie的key。
value：key对应的value。
max_age：改cookie的过期时间，如果不设置，则浏览器关闭后就会自动过期。
expires：过期时间，应该是一个datetime类型。
domain：该cookie在哪个域名中有效。一般设置子域名，比如cms.example.com。
path：该cookie在哪个路径下有效。

使用：
  获取：request.cookies.get(key, '默认值')
  设置：resp.set_cookie(key, value, max_age=整数)
  删除：resp.delete_cookie(key)
#

##参考代码 not run;
from flask import Flask,Blueprint,request,make_response

app = Flask(__name__)

#创建实例
cookie=Blueprint('cookie', __name__)

#获取cookie
@cookie.route('/get/')
def get():
    return request.cookies.get('name','I am cookie001')

#设置cookie
@cookie.route('/set/')
def set():
    res=make_response('cookie 已设置')
    #设置cookie，顺便指定有效期，默认为none，浏览器关闭就失效
    #max_age: 一个整数，单位为s，即多少秒后过期
    # expires: datetime类型，即指定日期后过期
    res.set_cookie('name','I am another cookie002', max_age=30)
    return res

#删除cookie
@cookie.route('/del/')
def delete():
    res=make_response('cookie 已删除')
    res.delete_cookie('name')
    return res

#
#启动后端程序
if __name__ == '__main__':
    app.run(debug=True, port=10001) 
#





(2)session：
Flask中的session是通过from flask import session。然后添加值key和value进去即可。

client side session：Flask中的session机制是将session信息加密，然后存储在cookie中。专业术语叫做client side session。
server side session：存储在服务器，客户端保存的时session_id（通过cookie完成）

使用：
  获取：session.get(key, '默认值')
设置：
    session.permanent = True
    session[key] = value  
删除：
指定删除：session.pop(key, None)
清空所有：session.clear()


设置session过期时间
如果没有指定session的过期时间，默认是浏览器关闭后就自动结束
设置了session的permanent属性为True，那么过期时间是31天（session.permanent = True）

可以通过给app.config设置PERMANENT_SESSION_LIFETIME来更改过期时间，这个值的数据类型是datetime.timedelay类型。
"""config.py"""
from datetime import timedelta
import os

SECRET_KEY = os.urandom(24)         #生成一串随机24位的字符
PERMANENT_SESSION_LIFETIME = timedelta(days=7)  #设置session7天有效
#


#
##参考代码 not run;
from flask import Blueprint,session

sess=Blueprint('sess',__name__)

#设置
@sess.rout('/set/')
def set():
    #设置是否永久有效（必须放在请求上下文中），默认False，浏览器关闭失效
    #设置为True，有效期由 app.config['PERMANENT_SESSION_LIFETIME']决定
    #app.config[PERMANENT_SESSION_LIFETIME]默认为31天
    session.permanent=True
    session['name']='who are you'
    return "session was set"

#获取session
@sess.route('/get/')
def get():
    return session.get('name','who are you?(default)')

#删除
@sess.route("/del/")
def delete():
    #删除指定的session，第二个参数设置为None，即使删除不存在的键也不报错
    #session.pop('name',None)
    #清空所有的session
    session.clear()
    return "session is deleted"
#








(3) manage.py 可运行的代码
from flask import Flask, session,jsonify,make_response,request
import os

app=Flask(__name__)
#app.config['SECRET_KEY']='123456' ## 一串随机字符串作为session的加密盐值
app.config['SECRET_KEY']='1'
app.config['PERMANENT_SESSION_LIFETIME']=20 #20s有效期 10天有效期，可以设置 10*24*365

#操作session方法与操作字典相同

@app.route('/')
def index():
    #设置是否永久有效（必须放在请求上下文中），默认False，浏览器关闭失效
    #设置为True，有效期由 app.config['PERMANENT_SESSION_LIFETIME']决定
    #app.config[PERMANENT_SESSION_LIFETIME]默认为31天
    session.permanent=True
    session['username']='Jim'
    session['psw']='123456'

    #for cookie:
    res=make_response('hello, session test ~ cookie 已设置')
    #设置cookie，顺便指定有效期，默认为none，浏览器关闭就失效
    #max_age: 一个整数，单位为s，即多少秒后过期
    # expires: datetime类型，即指定日期后过期
    res.set_cookie('name','I am another cookie002', max_age=30)
    res.set_cookie('book','js the good part', max_age=30)

    return res
#
# 读取session
@app.route('/get')
def get():
    #session['username']    # 方法一，如果内容不存在，将会报异常
    username=session.get('username','')     # 方法二，如果内容不存在，将返回None。推荐使用
    #return session.get('username','no session username')

    #for cookie:
    cookie=request.cookies.get('name','no cookie00_')
    book=request.cookies.get('book','no book')

    return jsonify({
        'session':[username,session.get('psw', 'nothing') ], 
        #'session':[username,session['psw'] ], 
        'cookie':[cookie,book]
    })
#
#删除 session
@app.route('/delete/')
def delete():
    session.pop('username') #字典pop方法删除session指定键
    #session.clear() #删除session所有值

    #for cookie 
    res=make_response('deleted!')
    res.delete_cookie('book')

    return res


#启动后端程序
if __name__ == '__main__':
    app.run(debug=True, port=10001) 

#
# http://127.0.0.1:10001/  #设置session
# http://127.0.0.1:10001/get 超过20s不访问，paw session就会失效。
#   - 一直刷新，30s后cookie就自动到期销毁了 
# 





========================================
|-- flask RBAC (Role-Based Access Control): 基于角色的权限控制
----------------------------------------

1. RBAC几乎无关语言、框架，主要是数据库结构上面设计；通常来讲需要5张表：
1)、 auth_user // 用户表
2)、 auth_node // 可授权节点表
3)、 auth_role // 角色表

4)、 auth_user_role // 用户《=》角色关系对应表，因为用户和角色是many-to-many的关系（or ones-to-one，看实际情况）
5)、 authenticated // 角色授权表 同样是many-to-many的关系

用户可对应N个角色（不一定非一成不变），每个角色可授权N个节点，节点权限验证的时候，使用用户的所有角色去取得已授权的节点列表，然后判断，就这么简单。开发中可能会根据实际情况有一些变动，灵活处理即可。

另外说一句，Flask有RBAC的实现方案，不过没用过，github上面关注度也不高，给传送门吧 https://github.com/shonenada/flask-rbac







2.Flask实现基于角色的访问控制(RBAC)
https://blog.51cto.com/kevinhao/1900391

Flask的核心在于”Micro”，因此它不像Django拥有很多功能，尤其是认证系统。因此使用Flask要自己写一个认证系统。下面就给大家分享一下简单的Flask实现RBAC。下面都是在models.py文件的代码

1、权限常量

class Permission:
    COMMENT = 0x02
	ADMINISTER = 0x80

2、角色表
class Role(db.Model):
    __tablename__ = 'roles'
    id =db.Column(db.Integer,primary_key=True)
	name =db.Column(db.String(255),unique=True)
	default = db.Column(db.Boolean,default=False,index=True)
	permissions = db.Column(db.Integer)
	users = db.relationship('User',backref='role',lazy='dynamic')
	
def __repr__(self):
	return '<Role%r>' %self.name

将角色手动添加到数据库中，即耗时又容易出错，最便捷的又不容易出错的方法就是写一个静态方法。

class Role(db.Model):
……
  @staticmethod
      def insert_roles():
          roles = {
              'User': (Permission.COMMENT,True),
              'Administrator': (0xff,False)
          }
          for ro in roles:
              role= Role.query.filter_by(name=ro).first()
              ifrole is None:
                  role = Role(name=ro)
              role.permissions = roles[ro][0]
              role.default = roles[ro][1]
              db.session.add(role)
          db.session.commit()

3、用户表
class User(UserMixin,db.Model):
    __tablename__ = 'users'
    id =db.Column(db.Integer,primary_key=True)
    username =db.Column(db.String(255),unique=True,index=True)
    passwd =db.Column(db.String(255))
    email =db.Column(db.String(255),unique=True,index=True)
    role_id = db.Column(db.Integer,db.ForeignKey('roles.id'))
 

    def __repr__(self):
         '<User %r>'%self.username

4、赋予角色
用户在注册时，会赋予适当的角色。用户注册时赋予的角色都是普通用户，这是默认角色。但管理员就比较列外了。管理员由设置的变量CMDB_ADMIN来识别，当注册的邮箱和设置的该变量的值一样就会自动设置为管理员。

Class User(UseMin,db.Model):

……

    def__init__(self,**kwargs):
       super(User,self).__init__(**kwargs)
        if self.role is None:
            if self.email ==current_app.config['CMDB_ADMIN']:
                self.role =Role.query.filter_by(permissions=0xff).first()
            if self.role ==None:
                self.role =Role.query.filter_by(default=True).first()
    def __repr__(self):
         '<User %r>'%self.username
#




3.flask通用rbac权限框架
https://blog.csdn.net/weixin_39352048/article/details/80363326







========================================
|-- casbin: 权限控制
----------------------------------------

https://casbin.org/

现在新推出了一个权限框架，叫PyCasbin（https://github.com/casbin/pyc...）。PyCasbin采用了元模型的设计思想，支持多种经典的访问控制方案，如ACL、RBAC、ABAC，还支持对RESTful API的控制。现在已经支持Django、Flask等Web框架了。需要中文文档的话，可以在百度搜索：PyCasbin: https://github.com/casbin/pycasbin








========================================
flask 踩坑
----------------------------------------

========================================
|-- 手动更新数据表，但是flask显示并没有更新
----------------------------------------

1.
查询前先 `db.session.commit()` 将当前 session 对象里的缓存提交（清空缓存），查询时就直接从数据库中查询最新数据。
https://www.cnblogs.com/huchong/p/9258458.html
https://www.jianshu.com/p/c0a8275cce99

https://www.v2ex.com/t/198981



2.



========================================
|-- FLASK在其他文件中添加路由
----------------------------------------
应用文件为：app.py
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"

if __name__ == '__main__':
    app.run()

如果不想在这个文件中添加新路由，怎么办？


1.有个直观的办法, 新建test.py
def  add_new_routes(app):
    @app.route("/test")
    def test():
        return 'test'
#

然后在app.py中添加调用，
from test import add_new_routes
add_new_routes(app)

前面的办法缩进有点多啊！



2. 换个方法，将test.py的代码改为：

def hello():
    return 'hello world'

def add_new_routes(app):
    app.add_url_rule('/hello', view_func=hello)

同理，在Blueprint中，也可以这么干。


个人认为：方法2更好，适合很多函数的场景，代码改动很少。

https://www.cnblogs.com/lyg-blog/p/9499227.html




========================================
jinja2 模板技术简介
----------------------------------------
jinja2: http://jinja.pocoo.org/
jinja2: https://palletsprojects.com/p/jinja/ 





========================================
Vue项目开发与规范--RESTful API 设计篇
----------------------------------------
1.协议
API与用户的通信协议，总是使用HTTPs协议。

2.域名
应该尽量将API部署在专用域名之下。
https://api.example.com

如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。
https://example.org/api/


3.版本（Versioning）
应该将API的版本号放入URL。
https://api.example.com/v1/

另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。


4.路径（Endpoint）
路径又称"终点"（endpoint），表示API的具体网址。
在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的"集合"（collection），所以API中的名词也应该使用复数。

举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。
https://api.example.com/v1/zoos
https://api.example.com/v1/animals
https://api.example.com/v1/employees



5.HTTP动词
对于资源的具体操作类型，由HTTP动词表示。

常用的HTTP动词有下面五个（括号里是对应的SQL命令）。
GET（SELECT）：从服务器取出资源（一项或多项）。
POST（CREATE）：在服务器新建一个资源。
PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。
PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。
DELETE（DELETE）：从服务器删除资源。
还有两个不常用的HTTP动词。
HEAD：获取资源的元数据。
OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。

下面是一些例子。
GET /zoos：列出所有动物园
POST /zoos：新建一个动物园
GET /zoos/ID：获取某个指定动物园的信息
PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
DELETE /zoos/ID：删除某个动物园
GET /zoos/ID/animals：列出某个指定动物园的所有动物
DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物



6.过滤信息（Filtering）
如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。

下面是一些常见的参数。
?limit=10：指定返回记录的数量
?offset=10：指定返回记录的开始位置。
?page=2&per_page=100：指定第几页，以及每页的记录数。
?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
?animal_type_id=1：指定筛选条件

参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。



7.状态码（Status Codes）
服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。

HTTP 状态码就是一个三位数，分成五个类别。
1xx：相关信息
2xx：操作成功
3xx：重定向
4xx：客户端错误
5xx：服务器错误
# API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。


200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。
201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
204 NO CONTENT - [DELETE]：用户删除数据成功。

400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。
404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。

500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。



8.错误处理（Error handling）
如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。

{
    error: "Invalid API key"
}


9.返回结果
针对不同操作，服务器向用户返回的结果应该符合以下规范。

GET /collection：返回资源对象的列表（数组）
GET /collection/resource：返回单个资源对象
POST /collection：返回新生成的资源对象
PUT /collection/resource：返回完整的资源对象
PATCH /collection/resource：返回完整的资源对象
DELETE /collection/resource：返回一个空文档


10.Hypermedia API
RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。
比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。

{"link": {
  "rel":   "collection https://www.example.com/zoos",
  "href":  "https://api.example.com/zoos",
  "title": "List of zoos",
  "type":  "application/vnd.yourformat+json"
}}

上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。
Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。

{
  "current_user_url": "https://api.github.com/user",
  "authorizations_url": "https://api.github.com/authorizations",
  // ...
}

从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。

{
  "message": "Requires authentication",
  "documentation_url": "https://developer.github.com/v3"
}
上面代码表示，服务器给出了提示信息，以及文档的网址。



11.其他
服务器返回的数据格式，应该尽量使用JSON，避免使用XML。



12.安全 
做一个网站，前端用vue写的，后端准备 ASP/Python/PHP mvc做API

(1)返回状态码是用http状态代码，然后再json中说明错误信息,
还是直接http返回200然后在json中返回错误码和错误信息?

A:
status code表示http状态，2xx系列都能表示各种成功返回。

status code 肯定是跟回http的标准，简单明了。404就是not found，500就是server error，不用额外说明。如果你所有status都返回200，一些ajax的success和fail的callback不能直接用。





(2) 我看有人说登陆状态不要用session 和cookie而要自定义一个token 在请求中带上，
个人感觉不是用session 不是简单么？为啥一定要自定义token ？

A: 
做restful必然是stateless， session天然带有state属性，不符合涉及习惯，而token满足stateless中的验证要求。

token是无状态的，在登陆的时候领取到token，在请求资源的时候带上token，token有效期内均视为已登录。

不要使用session，session需要server端存储，有多种风险。前端页面ajax请求的话用COOKIE，因为浏览器会自动发送COOKIE，比较方便。非页面的模块发请求用token，因为没有浏览器帮忙发cookie了，手动拼的话拼url更方便。


RESTful并不是专门为浏览器设计的，它是为普通的客户端api设计的，客户端不方便使用session，反而是token更简单。



google best api design books，然后先看他三本再说




refer:
https://www.jianshu.com/p/704f318a74f2
http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html



========================================
Vue项目开发与规范--RESTful API 实现篇
----------------------------------------
使用 Python 和 Flask 设计 RESTful API http://www.pythondoc.com/flask-restful/first.html


1. 实例 Ensembl REST API Endpoints http://rest.ensembl.org/
访问 http://rest.ensembl.org/archive/id/ENSG00000157764?content-type=application/json
返回 {"release":"97","possible_replacement":[],"latest":"ENSG00000157764.13","assembly":"GRCh38","peptide":null,"version":13,"is_current":"1","type":"Gene","id":"ENSG00000157764"}

Python3访问
import requests, sys
 
server = "http://rest.ensembl.org"
ext = "/archive/id/ENSG00000157764?"
 
r = requests.get(server+ext, headers={ "Content-Type" : "application/json"})
 
if not r.ok:
  r.raise_for_status()
  sys.exit()
 
decoded = r.json()
print(repr(decoded))


(2)
中间放一层php呢？






2. 完整示例
我的测试代码: https://github.com/DawnEve/learngit/tree/dev/Python3/pythonCodeGit/day15-web-sql dev分支



from flask import Flask,request,jsonify

#http://www.pythondoc.com/flask-restful/first.html
# HTTP methods like GET, POST, PUT, DELETE.

app = Flask(__name__)

tasks = [
    {
        'id': 1,
        'title': u'Buy groceries',
        'description': u'Milk, Cheese, Pizza, Fruit, Tylenol',
        'done': False
    },
    {
        'id': 2,
        'title': u'Learn Python',
        'description': u'Need to find a good Python tutorial on the web',
        'done': False
    }
]

@app.route('/todo/api/v1.0/tasks', methods=['GET'])
def get_tasks():
    return jsonify({'tasks': tasks})

#通过执行 app.py，启动 web service。

#1. 浏览器查看
# http://127.0.0.1:5000/todo/api/v1.0/tasks

#2. 打开一个新的控制台窗口，运行以下命令:
# curl -i http://localhost:5000/todo/api/v1.0/tasks
# 使用curl能更灵活的使用4个请求方法
#  一个 GET 请求表示客户端获取一个用户的信息。
#  一个 POST 请求表示客户端新增一个用户信息。
#  一个 PUT 请求表示更新用户信息，比如可能是更新邮箱地址。
#  一个 DELETE 请求表示删除用户账号。




##############
# 使用get方法
##############
from flask import abort

@app.route('/todo/api/v1.0/tasks/<int:task_id>', methods=['GET'])
def get_task(task_id):
    task0 = filter(lambda t: t['id'] == task_id, tasks)
    task = list(task0)
    if len(task) == 0:
        abort(404) #报错不是jason格式的，不理想
    return jsonify({'task': task[0]}) #用 jsonify 打包成 JSON 格式并将其发送作为响应
# http://localhost:5000/todo/api/v1.0/tasks/2
# curl -i http://localhost:5000/todo/api/v1.0/tasks/2



##############
# json格式的报错
##############
from flask import make_response

@app.errorhandler(404)
def not_found(error):
    return make_response(jsonify({'error': 'Not found'}), 404)
#




##############
# post方式
##############
from flask import request

@app.route('/todo/api/v1.0/tasks', methods=['POST'])
def create_task():
    if not request.json or not 'title' in request.json:
        abort(400)
    task = {
        'id': tasks[-1]['id'] + 1,
        'title': request.json['title'],
        'description': request.json.get('description', ""),
        'done': False
    }
    tasks.append(task)
    return jsonify({'task': task}), 201
#使用如下的 curl 命令来测试这个新的函数:
# $ curl -i -H "Content-Type: application/json" -X POST -d '{"title":"Read a book"}' http://localhost:5000/todo/api/v1.0/tasks
# 查看效果
# curl -i http://localhost:5000/todo/api/v1.0/tasks





##############
# put 方式
##############
@app.route('/todo/api/v1.0/tasks/<int:task_id>', methods=['PUT'])
def update_task(task_id):
    task0 = filter(lambda t: t['id'] == task_id, tasks)
    task=list(task0)
    if len(task) == 0:
        abort(404)
    if not request.json:
        abort(400)
    if 'title' in request.json and type(request.json['title']) != unicode:
        abort(400)
    if 'description' in request.json and type(request.json['description']) is not unicode:
        abort(400)
    if 'done' in request.json and type(request.json['done']) is not bool:
        abort(400)
    task[0]['title'] = request.json.get('title', task[0]['title'])
    task[0]['description'] = request.json.get('description', task[0]['description'])
    task[0]['done'] = request.json.get('done', task[0]['done'])
    return jsonify({'task': task[0]})
#
# curl -i -H "Content-Type: application/json" -X PUT -d '{"done":true}' http://localhost:5000/todo/api/v1.0/tasks/2
# 查看效果
# curl -i http://localhost:5000/todo/api/v1.0/tasks







##############
# delete 方式
##############
@app.route('/todo/api/v1.0/tasks/<int:task_id>', methods=['DELETE'])
def delete_task(task_id):
    task0 = filter(lambda t: t['id'] == task_id, tasks)
    task=list(task0)
    if len(task) == 0:
        abort(404)
    tasks.remove(task[0])
    return jsonify({'result': True})
# 删除一条
# curl -i -H "Content-Type: application/json" -X DELETE http://localhost:5000/todo/api/v1.0/tasks/2
# 查看效果
# curl -i http://localhost:5000/todo/api/v1.0/tasks





##############
# 优化 web service 接口: 输出的id改为URI
##############

# 一个小的辅助函数生成一个 “公共” 版本任务发送到客户端:
from flask import url_for
def make_public_task(task):
    new_task = {}
    for field in task:
        if field == 'id':
            new_task['uri'] = url_for('get_task', task_id=task['id'], _external=True)
        else:
            new_task[field] = task[field]
    return new_task
# 我们将会把上述的方式应用到其它所有的函数上以确保客户端一直看到 URIs 而不是 ids。

@app.route('/todo/api/v2.0/tasks', methods=['GET'])
def get_tasks2():
    return jsonify({'tasks': list( map(make_public_task, tasks)) })
# curl -i http://localhost:5000/todo/api/v2.0/tasks






##############
# 加强 RESTful web service 的安全性
##############
# 确保我们的 web service 安全服务的最简单的方法是要求客户端提供一个用户名和密码。
# 在常规的 web 应用程序会提供一个登录的表单用来认证，并且服务器会创建一个会话为登录的用户以后的操作使用，
#  会话的 id 以 cookie 形式存储在客户端浏览器中。

# 然而 REST 的规则之一就是 “无状态”， 因此我们必须要求客户端在每一次请求中提供认证的信息。

# HTTP 协议提供了两种认证机制: Basic 和 Digest。
# $ flask/bin/pip install flask-httpauth

#from flask.ext.httpauth import HTTPBasicAuth
#error: https://blog.csdn.net/i_spirit/article/details/94642832
#出现该问题主要原因是新版的flask抛弃了flask.ext这种引入扩展的方法，更改为 flask_扩展名
#例如：
#以前：from flask.ext.script import Manager
#现在：from flask_script import Manager
from flask_httpauth import HTTPBasicAuth

auth = HTTPBasicAuth()


#get_password 函数是一个回调函数，Flask-HTTPAuth 使用它来获取给定用户的密码。
#在一个更复杂的系统中，这个函数是需要检查一个用户数据库，但是在我们的例子中只有单一的用户因此没有必要。
@auth.get_password
def get_password(username):
    if username == 'lang':
        return 'python'
    return None
#error_handler 回调函数是用于给客户端发送未授权错误代码。像我们处理其它的错误代码，
#这里我们定制一个包含 JSON 数据格式而不是 HTML 的响应。
@auth.error_handler
def unauthorized():
    #return make_response(jsonify({'error': 'Unauthorized access'}), 401)
    #让人不舒服的是当请求收到一个 401 的错误，网页浏览都会跳出一个丑陋的登录框
    return make_response(jsonify({'error': 'Unauthorized access'}), 403)


# 随着认证系统的建立，所剩下的就是把需要认证的函数添加 @auth.login_required 装饰器
@app.route('/todo/api/v3.0/tasks', methods=['GET'])
@auth.login_required
def get_tasks3():
    return jsonify({'tasks': tasks})
# http://localhost:5000/todo/api/v3.0/tasks
# 未授权  curl -i http://localhost:5000/todo/api/v3.0/tasks
# 授权后  curl -u lang:python -i http://localhost:5000/todo/api/v3.0/tasks

# 认证扩展给予我们很大的自由选择哪些函数需要保护，哪些函数需要公开。






##############
# 可能的改进
##############
#一个真正的 web service 需要一个真实的数据库进行支撑。我们现在使用的内存数据结构会有很多限制不应该被用于真正的应用。

#另外一个可以提高的领域就是处理多用户。如果系统支持多用户的话，不同的客户端可以发送不同的认证凭证获取相应用户的任务列表。








if __name__ == '__main__':
    app.run(debug=True)








========================================
Django 框架 课程概述
----------------------------------------
https://www.djangoproject.com/
Django makes it easier to build better Web apps more quickly and with less code.

Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It’s free and open source.



1. 入门课程: 
三小时带你入门Django框架 https://www.imooc.com/learn/1110
django入门与实践: https://www.imooc.com/learn/790


专题课程:
全面掌握Django ORM: https://www.imooc.com/learn/1087
Django的一个强大的功能是它的对象关系映射Object-Relational Mapping（ORM），它允许你就像使用 SQL一样去和你的数据库交互，本课程将以Django官方文档为依据，通过开发讲师、课程、学生、助教四个模型类，给大家完整透彻的讲解Django ORM知识体系，为更高级的开发打下坚实基础。

课程源码：https://github.com/liaogx/imooc


## 用户评价：
- Tornado使用高并发。Django中异步需要使用Celery。
- 零零散散花了7小时42分，学习完了，感觉非常不错，特别是对 Models API的系统讲解。



(1) 安装
pip3 install django
python3 -m django --version ## 3.1.2

This tutorial is written for Django 3.1, which supports Python 3.6 and later.
https://docs.djangoproject.com/en/3.1/intro/tutorial01/


(2) Creating a project
cd到一个目录
$ django-admin startproject mysite

目录结构
wangjl@sustc-HG:~/web/Django$ tree
.
└── mysite          项目文件夹
    ├── manage.py
    └── mysite
        ├── asgi.py
        ├── __init__.py
        ├── settings.py
        ├── urls.py
        └── wsgi.py
#

(3) The development server
$ python3 manage.py runserver
浏览器打开能看到小火箭，http://127.0.0.1:8000/
只能在本地桌面看页面了。则会使admin页面。



(4) Creating the Polls app
$ python3 manage.py startapp polls

wangjl@sustc-HG:~/web/Django/mysite$ tree
mysite/
...
└── polls
    ├── admin.py
    ├── apps.py
    ├── __init__.py
    ├── migrations
    │   └── __init__.py
    ├── models.py
    ├── tests.py
    └── views.py
# 这就是调查问卷的框架结构

(5)Write your first view
i)添加视图文件
$ vim polls/views.py
from django.http import HttpResponse

def index(request):
    return HttpResponse("Hello, world. You're at the polls index.")


ii)还需要配置url
$ vim polls/urls.py
from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
]

# path()可以接收4个参数  route and view, and two optional: kwargs, and name. 




iii)接着，还需要把根url指向 polls.urls 模块。插入一行：
$ vim mysite/urls.py
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('polls/', include('polls.urls')),  #指向自定义模块
    path('admin/', admin.site.urls),
]

# 在 include()函数中允许指向其他URL设置。当Django遇到include()时，就切开URL匹配部分，把剩余字符串发送到该包含的url模块做进一步的处理。


要么用 include()，要么用 admin.site.urls:
You should always use include() when you include other URL patterns. admin.site.urls is the only exception to this.




(6) 运行新模块
$ python3 manage.py runserver
http://localhost:8000/polls/

可以看到输出 Hello, world. You're at the polls index.








2. Django的优势
最早接触Django，在我心中的形象是：Web框架界的变形金刚
Django的MVT架构、自带ORM、强大的Admin后台管理、自带数据库、还自带开发测试用的服务器、不得不说服务周到。
如此大而全，重量级的Django给开发者提供了超高的开发效率。
淌着Python血液
MVT三大轮子 连接浏览器 数据库开跑
一身装备 可变形 可扩展
多领域 跨平台 协调作战
自我测试 自我管理 自我保护
友好 开放 国际化
装备很多：用户认证 缓存 日志 邮件 组织 分页 消息 序列化 会话 网站地图 静态文件处理 数据验证
Django支持第三方扩展：比如 富文本编辑器  缓存 全文检索  celery等
Django项目布署 用nginx做静态资源代理、负载均衡 可以提高高并发能力。

一些Web项目开发 无论用户量、服务群体、上来总谈高并发。没用户 天天愁高并发问题 还没解决也许项目已经黄了。
项目有了、业务有了、用户有了、性能优化、高并发顺势解决嘛。
当然一些大型网站，在高性能的要求下，框架的各个部分往往都需要自己定制，这样用Django也就没有太大优势。













========================================
Tornado 非阻塞式服务器
----------------------------------------
1. 简介
http://www.tornadoweb.org/en/stable/

Tornado is a Python web framework and asynchronous networking library, originally developed at FriendFeed. By using non-blocking network I/O, Tornado can scale to tens of thousands of open connections, making it ideal for long polling, WebSockets, and other applications that require a long-lived connection to each user.

python写的异步web框架，起源于FriendFeed公司。使用非阻塞的网络IO， Tornado可以扩展到数以万计的开放连接，特别适用于long polling, WebSockets 等需要长时间和每个用户连接的情况。




2. Here is a simple “Hello, world” example web app for Tornado:
手动pip安装包: $ pip install tornado

$ vim tornado_demo.py
import tornado.ioloop
import tornado.web

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello, world")

def make_app():
    return tornado.web.Application([
        (r"/", MainHandler),
    ])

if __name__ == "__main__":
    app = make_app()
    app.listen(8000)
    tornado.ioloop.IOLoop.current().start()

$ python tornado_demo.py

什么也没显示，不过用浏览器访问该端口 http://y.biomooc.com:8000/，能看到 Hello, world，在F12能看到响应的服务器名字 Server: TornadoServer/5.1





========================================
如何写复杂业务代码
----------------------------------------
https://www.jianshu.com/p/05f395780da1







========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------





========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------



========================================
----------------------------------------

========================================
----------------------------------------





