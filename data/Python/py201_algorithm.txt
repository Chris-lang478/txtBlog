数据结构与算法

这里主要是python版本的
还有一个c版本的: C/数据结构与算法




推荐: 《数据结构与算法之美》的学习笔记和python代码实现
https://github.com/xiao-xiaoming/DataStructure-BeautyOfAlgorithm


算法图解(py2.7 -> 我改为了 py3.7): 
	www.manning.com/books/grokking-algorithms
	https://github.com/egonschiele/grokking_algorithms

  * 1 算法简介: 二分查找，大O表示法
  * 2 选择排序
  * 3 递归
  * 4 快速排序
  * 5 散列表
  * 6 广度优先搜索: 图简介，最短路径，队列
  * 7 迪克斯特拉算法
  * 8 贪婪算法
  * 9 动态规划 
  * 10 K最近邻算法
  * 11 接下来如何做: 10种算法
	树
	反向索引
	傅里叶变换
	并行算法
	MapReduce
	布隆过滤器和 HyperLogLog 
	SHA 算法 
	据不敏感的散列算法
	Diffie-Hellman 密钥交换
	线性规划



https://www.khanacademy.org/  更多算法。



========================================
常用的算法
----------------------------------------

1. 数据结构
数组
链表
栈
跳表
图
Trie树



2. 排序
二分查找
搜索
哈希算法
贪心算法
分治算法
回溯算法
动态规划
字符串匹配算法

递归





========================================
二分查找，递归，大O表示法
----------------------------------------
1. 二分查找
必须是有序元素列表，如果要查找的元素存在，则返回其下标序号，如果不存在，则返回 null.

使用二分查找，每次排除一半数字。
所以1-100的数字，二分查找总能够在_步以内找到答案？ 答案是7步。

对于包含n个元素的列表，
	简单查找最多需要 n 步；大O表示就是 O(n) ，称作线性时间。
	而二分查找最多需要 log2(n) 步；大O表示就是 O(log n)，称作对数时间。

大O表示法的log是指的 log2.



(2) py算法
随机生成一个1-100的数字，用户猜测后给出大了、小了、对三种回复。正确则回复下标，错误则回复-1.

函数接收一列排序后的数字，和一个数字。

# 二分法查找
import math

def binary_search(sorted_arr, num, debug=False):
    low=0
    high=len(sorted_arr)-1
    mid= math.floor( (low+high)/2 )
    #
    while low<=high:
        mid= math.floor( (low+high)/2 )
        guess=sorted_arr[mid]
        if debug:
            print(low, mid, high)
        if guess==num:
            return mid;
        elif guess>num:
            high=mid-1
        else:
            low=mid+1
    return -1

arr1=[1,3,5,6,7]
print(binary_search(arr1, 50))
print(binary_search(arr1, 0))
print(binary_search(arr1, 7))
print(binary_search(arr1, 6, 0))
#print(binary_search(arr1, 6, True))






2. 大O表示法 算法的时间增速

(1)
大O表示法让你能够比较操作数，它指出了算法运行时间的增速。

大O 表示法指出了最糟情况下的运行时间

   算法的速度指的并非时间，而是操作数的增速。
   谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
   算法的运行时间用大O表示法表示。
   O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。



(2) 一些常见的大O 运行时间
下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。
 O(log n)，也叫对数时间，这样的算法包括二分查找。
 O(n)，也叫线性时间，这样的算法包括简单查找。
 O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。
 O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。
 O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。





3. 旅行商 问题 O(n!)

某人要去5个城市，同时要确保旅程最短。
需要穷举各种前往的顺序，计算每次的总路程，从而挑选最短路程的方案。
5个城市，需要穷举 5! =120 个方案。
6个城市，6!=720 个方案。
7个城市，7!=5040 个方案。






小结
 二分查找的速度比简单查找快得多。
 O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
 算法运行时间并不以秒为单位。
 算法运行时间是从其增速的角度度量的。
 算法运行时间用大O表示法表示。



========================================
选择排序：数组和链表
----------------------------------------

排序后才能进行二分查找。
选择排序时下一节的 快速排序 的基石，而 快速排序 又是一种重要的算法。


1. 内存

内存可以看做很多抽屉，你有钥匙(地址)，就可以在对应的抽屉放东西。

fe0ffeeb是一个内存单元的地址。

存一个时，请求一个地址。
存多个时，可以使用 数组和链表。



2. 数组和链表

数组占用连续的空间。
	知道第一个元素的地址，可以算出来任何一个元素的地址。这就是说的数组支持随机访问。

链表占用空间不要求必须连续。
	链表必须同时保存数据和下一个元素的地址。就像一个寻宝游戏。
	链表不能直接读取最后一个元素，只能一个一个找到最后一个的地址，然后读取其中的元素。
	如果需要跳跃，链表的效率很低。

--     数组 | 链表
读取  O(1)  |  O(n)
插入  O(n)  |  O(1)
删除  O(n)  |  O(1)

其中 O(n) = 线性时间，O(1) = 常量时间。
我对链表删除时间 O(1) 持怀疑态度，他还需要查找地址的时间呢，既然是最坏的情况。 //todo


前面解释了读取。这里说一下插入新值。
插入一个元素时，数组需要把后面所有元素向后移动，而链表只需要修改前面一个元素指向的地址。
如果连续的空间不够，数组还需要把所有元素复制到其他地方。

删除元素时，链表同样比数组快。





3. 选择排序 
(1) 过程
有一些歌曲和其播放次数的数据，想按照播放次数对歌曲排序。
先挑选播放最多的，抽出来。 O(n)
然后再挑选最多的，抽出来。 O(n-1)
...
也就是需要执行 n次。
1+2+...+n=n(n+1)/2, 只记录幂次最高的，并忽略常数项系数，即O(n^2)，或者 O(n × n)。


选择排序是一种灵巧的算法，但其速度不是很快。
快速排序是一种更快的排序算法，其运行时间为O(n log n)，这将在下一章介绍。


数组的 pop 元素能按下标移除数组中的该元素，并返回该值。
arr=[20,1,6,100,5]
rs1=arr.pop(1)
print(rs1)
print(arr)
输出:
1
[20, 6, 100, 5]


参考实现
# 选择排序

arr=[20,1,6,100,5]

# 返回最小元素的下标
def findSmallest(arr):
    small=arr[0]
    index=0
    for i in range( len(arr)):
        if small> arr[i]:
            small=arr[i]
            index=i;
    return index

# use this function in sorting
def searchSort(arr):
    arr2=[]
    for i in range( len(arr) ):
        print(i, arr2)
        smallest=findSmallest(arr)
        arr2.append(arr.pop(smallest))
    return arr2;

print(arr)
arr2=searchSort(arr)
print(arr2)






小结
 计算机内存犹如一大堆抽屉。
 需要存储多个元素时，可使用数组或链表。
 数组的元素都在一起。
 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
 数组的读取速度很快。
 链表的插入和删除速度很快。
 在同一个数组中，所有元素的类型都必须相同（都为int、double等）。






排序算法: https://www.runoob.com/w3cnote_genre/algorithm









========================================
递归
----------------------------------------

1. 递归不能死循环
要有结束条件。



2. 调用栈 call stack

栈，只有两种操作: 压入(插入到顶端)和弹出(从顶端读取并删除)。

这个存储多个函数的变量，被称为 调用栈。


(1) 递归实现
def fact(x):
    if x<=1:
        return 1;
    else:
        if debug:
            print(x)
        return x*fact(x-1)

debug=True
x=fact(5)
print(x)

# 输出
5
4
3
2
120

注意，每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。


(2) 递归很长占用大量内存怎么办？
两种方案可以选择，改写为
	循环
	尾递归 //todo


小结
 递归指的是调用自己的函数。
 每个递归函数都有两个条件：基线条件和递归条件。
 栈有两种操作：压入和弹出。
 所有函数调用都进入调用栈。
 调用栈可能很长，这将占用大量的内存。




========================================
快速排序：使用 分而治之 (divide and conquer，D&C) 的策略
----------------------------------------

1. 分而治之 是 一种著名的递归式问题解决方法。

面对新问题时，你不再束手无策，而是自问：“使用分而治之能解决吗？”
D&C并非可用于解决问题的算法，而是一种解决问题的思路。


使用三个问题引入


(1) 问题: 把大小为 168*64 的地分成均匀的方块，且分出的方块尽可能的大。

- 分成 168*64 是方块，但是每个方块太小了。
- 一分为二，不是方块不行。
- 每块大小不同也不行。

使用D&C解决问题的过程包括两个步骤。
1) 找出基线条件，这种条件必须尽可能简单。
2) 不断将问题分解（或者说缩小规模），直到符合基线条件。

欧几里得算法：“适用于这小块地的最大方块，也是适用于整块地的最大方块”

伪算法
- 基线条件是分成 n*n 的方块，初步方案是先分成尽可能大的方块；
- 先分成 (64*2)*64 的两块，剩下 40*64
- 余下的再分成 40*40 的一块，还剩下 40*24
- 余下的再分成 24*24 的一块，还剩下 16*24
- 余下的再分成 16*16 的一块，还剩下 16*8
- 正好分成 (8*2)*8 的两块。

返回验证， n=8
2n * n
16*16 = 2n*2n;
24*24 = 3n*3n;
40*40 = 5n*5n;
(64*2)*64=(8n*2)*8n
都合适，那么这个就是最大的方块了: 8*8。
方块总数: 21n * 8n


实现：//todo





(2) 问题: 把几个数字相加，并求和。

# 分而治之: 数组求和，递归法;

def sumArr(arr):
    sum=0;
    for i in arr:
        sum+=i 
    return sum 

print(sumArr([2,4,6]))


# 方法二，使用递归，数组长度为1或0时返回，否则拿出一个值加上其余 求和数组
def sumArr2(arr):
    if len(arr)==0:
        return 0
    else:
        return arr[0] + sumArr2(arr[1:])

print(sumArr2([2,4,6]))


如果你喜欢递归或想学习一门新语言，可以研究一下Haskell。

二分查找也是一种分而治之的算法，请找出二分查找算法的基线条件和递归条件。



(3) 快速排序

快速排序是一种常用的排序算法，比选择排序快得多。
例如，C语言标准库中的函数qsort实现的就是快速排序。
快速排序也使用了D&C。

归纳证明: 像数学归纳法，证明一个，然后证明可以化简，然后就可以了。
	我能站到第一个梯子横板上，我能从一个横板爬到上一个横板，然后我就能爬到梯子最顶端。



算法实现：
# 快速排序，使用递归，是一种分而治之的策略。

def quickSort(arr):
    if len(arr)<2:
        return arr;
    else:
        pivot=arr[0]; #第一个数做参考，其余部分，分割成比它小的，比它大的
        less = [i for i in arr[1:] if i<=pivot]
        greater =[i for i in arr[1:] if i>pivot]
        
        # 然后分别排序，拍好后放出来
        return quickSort(less)+[pivot] + quickSort(greater)

print(quickSort([10,2,30,-100,5]))
# [-100, 2, 5, 10, 30]





(4) 合并排序（merge sort）

还有一种名为合并排序（merge sort）的排序算法，其运行时间为O(n log n)，比选择排序快得多！
快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n^2)。

与选择排序一样慢！但这是最糟情况。在平均情况下，快速排序的运行时间为O(n log n)。你可能会有如下疑问。
- 这里说的最糟情况和平均情况是什么意思呢？
- 若快速排序在平均情况下的运行时间为O(n log n)，而合并排序的运行时间总是O(n log n)，为何不使用合并排序？它不是更快吗？



(5) 最佳情况/最糟情况/平均情况
二分查找，如果是从低到高的1-8。
每次使用第一个元素作为参考，则需要8次，每次第一个数组都是空数组。
如果每次都使用中间值，则只需要 log2(8)次。

但是两种情况，每次都需要和参考值比较n次。


在这个示例中，层数为O(log n)（用技术术语说，调用栈的高度为O(log n)），而每层需要的时间为O(n)。
因此整个算法需要的时间为O(n) * O(log n) = O(n log n)。这就是最佳情况。

在最糟情况下，有O(n)层，因此该算法的运行时间为O(n) * O(n) = O(n2)。

知道吗？这里要告诉你的是，最佳情况也是平均情况。
只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为O(n logn)。
快速排序是最快的排序算法之一，也是D&C典范。






小结
 D&C将问题逐步分解。使用D&C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。
 实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。
 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。
 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n)快得多。









========================================
散列表(hash table)：实现、冲突、散列函数
----------------------------------------

学习散列表的内部机制：实现、冲突和散列函数。这将帮助你理解如何分析散列表的性能。

缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中！

1.散列表适合用于：
 模拟映射关系；
 防止重复；
 缓存/记住数据，以免服务器再通过处理来生成它们。


2. 冲突

哈希函数冲突怎么办？比如 返回首字母，返回字符串长度等这些hash函数就有这些问题。
最简单的办法，如果两个键映射到了同一个位置，就在这个位置存储一个链表。

如果需要保存的数据都在某一个位置后面的链表中，则hash结构和链表一样慢。

经验教训：
	hash 函数很重要。
	冲突时同一位置的链表不能太长！



3. 性能

(1) 填装因子 

填装因子度量的是散列表中有多少位置是非空的 = 填充的条目/位置总数。

比如: _ 1 _ 的填装因子是 1/3.
如果只有 50个位置，但是塞了100个条目呢？填装因子是 100/50=2.


(2) 良好的散列函数

良好的散列函数让数组中的值呈均匀分布。
糟糕的散列函数让值扎堆，导致大量的冲突。

如果你好奇，可研究一下SHA函数。


散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。
最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。




4. 小结 
你几乎根本不用自己去实现散列表，因为你使用的编程语言提供了散列表实现。你可使用 Python提供的散列表，并假定能够获得平均情况下的性能：常量时间。

散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型。

你可能很快会发现自己经常在使用它。
 你可以结合散列函数和数组来创建散列表。
 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。
 散列表的查找、插入和删除速度都非常快。
 散列表适合用于模拟映射关系。
 一旦填装因子超过0.7，就该调整散列表的长度。
 散列表可用于缓存数据（例如，在Web服务器上）。
 散列表非常适合用于防止重复。










========================================
广度优先搜索 (breadth-first search, BFS)
----------------------------------------

1. 广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多！
使用广度优先搜索可以：
 编写国际跳棋AI，计算最少走多少步就可获胜；
 编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将READED改为READER需要编辑一个地方；
 根据你的人际关系网络找到关系最近的医生


在我所知道的算法中，图算法应该是最有用的。




2. 查找A到B的最少换乘方案

- 先找一步能到的地方
- 如果无法到达B，则继续找2步能到的点；
- 如果还无法到B，则继续找3步能到的点；
...

这种问题被称为最短路径问题（shorterst-path problem）。


(1)  你经常要找出最短路径

这可能是前往朋友家的最短路径，也可能是国际象棋中把对方将死的最少步数。
解决最短路径问题的算法被称为广度优先搜索。

(2) 要确定如何从双子峰前往金门大桥，需要两个步骤。
- 使用图来建立问题模型。
- 使用广度优先搜索解决问题。



3. 什么是图
(1)图是节点和边组成。
边可以有方向 和 权重。

(2)
有方向：有向图 directed graph，有箭头。
无方向的：无向图 undirected graph，没有箭头。

(3)
有权重：权重图。
带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。


(4)
一个节点可能与众多节点直接相连，这些节点被称为邻居。







4. 广度优先搜索

(1) 解决的问题
第一类问题：从节点A出发，有前往节点B的路径吗？
第二类问题：从节点A出发，前往节点B的哪条路径最短？


第一个问题：我是种芒果的，我的朋友有芒果经销商吗？
从社交网络开始，比如Facebook为例:
先从朋友查找，如果有结束。
再遍历朋友，逐个加朋友的朋友，是经销商吗？是则结束。
...


再说一次，广度优先搜索可回答两类问题。
- 第一类问题：从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？）
- 第二类问题：从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？）


(2) 一度关系在二度关系之前加入查找名单。

你按顺序依次检查名单中的每个人，看看他是否是芒果销售商。这将先在一度关系中查找，再在二度关系中查找，因此找到的是关系最近的芒果销售商。

广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径。


你需要按添加顺序进行检查。有一个可实现这种目的的数据结构，那就是队列（queue）。




5. 队列
队列只支持两种操作：入队和出队。

队列是一种先进先出（First In First Out，FIFO）的数据结构，
而栈是一种后进先出（Last In First Out，LIFO）的数据结构。




6. 实现图
图就是点之间的对应关系。A->B 
正好，散列表可以实现键值对映射： key -> value.

(1)
比如，表示你和你的直接邻居：
graph = {}
graph["you"] = ["alice", "bob", "claire"]

注意，“你”被映射到了一个数组，因此graph["you"]是一个数组，其中包含了“你”的所有邻居。



(2) 更复杂的图的Python代码如下

graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []

散列表是无序的，因此添加键—值对的顺序无关紧要。





7. 实现广度优先算法

(1) 伪代码
创建队列，保存直接邻居
从对首遍历：
	是要找的，返回，结束查找。
	不是要找的
		弹出这个人
		并把这个人的邻居添加到队伍末尾。
如果队伍为空，则说明这个人的直接和间接邻居都没有要找的目标。


(2) py实现: 简陋实现
# 广度优先算法:
# 维护一个队列，先加入一度节点；
# 遍历，如果找到了就停止；没找到，就弹出，并把其好友添加到队列末尾。
# 直到返回，或者找不到。

# 创建图
graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []


# 在Python中，可使用函数deque来创建一个双端队列。
from collections import deque
search_queue = deque()
search_queue += graph["you"]

# 判断这个人是不是芒果经销商，最后一个字母是m 的停止
def person_is_seller(name):
    return name[-1] == 'm'

# 开始搜索
def bfs(search_queue):
    i=0
    while search_queue:
        person = search_queue.popleft() #左侧弹出一个元素
        
        i+=1
        print(f"[{i}] Cur:", person);
        
        if person_is_seller(person):
            print(person + " is a mango seller!")
            return True
        else:
            search_queue += graph[person]
    return False

bfs(search_queue);
print("==End==")


这个粗糙的实现有个问题，就是有人(peggy) 被查询了2次。
首先同一个元素检查2次是在浪费时间，其次这有可能陷入死循环，如果两个人互为好友。
应该使用一个表格，记录检查过的元素。



(3) 广度优先算法 标准实现
# 维护一个队列，先加入一度节点；
# 遍历，如果找到了就停止；没找到，就弹出，并把其好友添加到队列末尾。
# 直到返回，或者找不到。
from re import search

#
# v2: 为了避免死循环，要记录搜寻过的元素，并跳过它。
# 另一个更新，是把函数封装的更好：传入图和要查找的起始点。

# 创建图
graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []

# 在Python中，可使用函数deque来创建一个双端队列。
from collections import deque

# 判断这个人是不是芒果经销商，最后一个字母是m 的停止
def person_is_seller(name):
    return name[-1] == 'm'

# 开始搜索
def bfs2(graph, name="you", debug=True):
    search_queue = deque()
    search_queue += graph[name]

    searched=[]
    i=0
    while search_queue:
        i+=1
        person = search_queue.popleft() #左侧弹出一个元素
        if person in searched:
            print(f"[{i}]==>Jump:", person)
            continue;
        else:
            searched.append(person);
        
        if debug:
            print(f"[{i}] Cur:", person);
            print("\t>>>queue:", search_queue);
        
        if person_is_seller(person):
            print(person + " is a mango seller!")
            return True
        else:
            search_queue += graph[person]
    return False

bfs2(graph, "you");
print("==End==")





(4) 算法的时间复杂性

检查每条边 O(边数)
使用队列，检查每个人，将一个人添加到队尾的时间是固定的 O(1)，则总时间为 O(人数).
所以，广义优先搜索的运行时间为 O(人数 + 边数)，通常写作 O(V+E)
V 顶点 Vertice
E 边数 Edge



(5) 拓扑排序
从某种程度上说，这种列表是有序的。如果任务A依赖于任务B，在列表中任务A就必须在任
务B后面。这被称为拓扑排序，使用它可根据图创建一个有序列表


家谱结构的方向不能颠倒，这种图被称为树。树是一种特殊的图，其中没有往后指的边






8. 小结
 广度优先搜索指出是否有从A到B的路径。
 如果有，广度优先搜索将找出最短路径。
 面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题。
 有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama→adit表示rama欠adit钱。
 无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约会，而rachel也与ross约会”。
 队列是先进先出（FIFO）的。
 栈是后进先出（LIFO）的。
 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。
 对于检查过的人，务必不要再去检查，否则可能导致无限循环。









========================================
狄克斯特拉算法（Dijkstra’s algorithm）：加权图的最短距离
----------------------------------------

1. 狄克斯特拉算法包含4个步骤。
(1) 找出“最便宜”的节点，即可在最短时间内到达的节点。
(2) 更新该节点的邻居的开销，其含义将稍后介绍。
(3) 重复这个过程，直到对图中的每个节点都这样做了。
(4) 计算最终路径。



2.使用范围
狄克斯特拉算法只适用于有向无环图（directed acyclic graph，DAG）。


































========================================
==> cur: P53 (113/197)
----------------------------------------




















========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------
