数据结构与算法

这里主要是python版本的
还有一个c版本的: C/数据结构与算法




推荐: 《数据结构与算法之美》的学习笔记和python代码实现
https://github.com/xiao-xiaoming/DataStructure-BeautyOfAlgorithm


算法图解(py2.7 -> 我改为了 py3.7): 
	www.manning.com/books/grokking-algorithms
	https://github.com/egonschiele/grokking_algorithms

  * 1 算法简介: 二分查找，大O表示法
  * 2 选择排序
  * 3 递归
  * 4 快速排序
  * 5 散列表
  * 6 广度优先搜索: 图简介，最短路径，队列
  * 7 迪克斯特拉算法
  * 8 贪婪算法
  * 9 动态规划 
  * 10 K最近邻算法
  * 11 接下来如何做: 10种算法
	树
	反向索引
	傅里叶变换
	并行算法
	MapReduce
	布隆过滤器和 HyperLogLog 
	SHA 算法 
	据不敏感的散列算法
	Diffie-Hellman 密钥交换
	线性规划



https://www.khanacademy.org/  更多算法。



========================================
常用的算法
----------------------------------------

1. 数据结构
数组
链表
栈
跳表
图
Trie树



2. 排序
二分查找
搜索
哈希算法
贪心算法
分治算法
回溯算法
动态规划
字符串匹配算法

递归





========================================
二分查找，递归，大O表示法
----------------------------------------
1. 二分查找
必须是有序元素列表，如果要查找的元素存在，则返回其下标序号，如果不存在，则返回 null.

使用二分查找，每次排除一半数字。
所以1-100的数字，二分查找总能够在_步以内找到答案？ 答案是7步。

对于包含n个元素的列表，
	简单查找最多需要 n 步；大O表示就是 O(n) ，称作线性时间。
	而二分查找最多需要 log2(n) 步；大O表示就是 O(log n)，称作对数时间。

大O表示法的log是指的 log2.



(2) py算法
随机生成一个1-100的数字，用户猜测后给出大了、小了、对三种回复。正确则回复下标，错误则回复-1.

函数接收一列排序后的数字，和一个数字。

# 二分法查找
import math

def binary_search(sorted_arr, num, debug=False):
    low=0
    high=len(sorted_arr)-1
    mid= math.floor( (low+high)/2 )
    #
    while low<=high:
        mid= math.floor( (low+high)/2 )
        guess=sorted_arr[mid]
        if debug:
            print(low, mid, high)
        if guess==num:
            return mid;
        elif guess>num:
            high=mid-1
        else:
            low=mid+1
    return -1

arr1=[1,3,5,6,7]
print(binary_search(arr1, 50))
print(binary_search(arr1, 0))
print(binary_search(arr1, 7))
print(binary_search(arr1, 6, 0))
#print(binary_search(arr1, 6, True))






2. 大O表示法 算法的时间增速

(1)
大O表示法让你能够比较操作数，它指出了算法运行时间的增速。

大O 表示法指出了最糟情况下的运行时间

   算法的速度指的并非时间，而是操作数的增速。
   谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
   算法的运行时间用大O表示法表示。
   O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。



(2) 一些常见的大O 运行时间
下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。
 O(log n)，也叫对数时间，这样的算法包括二分查找。
 O(n)，也叫线性时间，这样的算法包括简单查找。
 O(n * log n)，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。
 O(n2)，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。
 O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。





3. 旅行商 问题 O(n!)

某人要去5个城市，同时要确保旅程最短。
需要穷举各种前往的顺序，计算每次的总路程，从而挑选最短路程的方案。
5个城市，需要穷举 5! =120 个方案。
6个城市，6!=720 个方案。
7个城市，7!=5040 个方案。






小结
 二分查找的速度比简单查找快得多。
 O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
 算法运行时间并不以秒为单位。
 算法运行时间是从其增速的角度度量的。
 算法运行时间用大O表示法表示。



========================================
选择排序：数组和链表
----------------------------------------

排序后才能进行二分查找。
选择排序时下一节的 快速排序 的基石，而 快速排序 又是一种重要的算法。


1. 内存

内存可以看做很多抽屉，你有钥匙(地址)，就可以在对应的抽屉放东西。

fe0ffeeb是一个内存单元的地址。

存一个时，请求一个地址。
存多个时，可以使用 数组和链表。



2. 数组和链表

数组占用连续的空间。
	知道第一个元素的地址，可以算出来任何一个元素的地址。这就是说的数组支持随机访问。

链表占用空间不要求必须连续。
	链表必须同时保存数据和下一个元素的地址。就像一个寻宝游戏。
	链表不能直接读取最后一个元素，只能一个一个找到最后一个的地址，然后读取其中的元素。
	如果需要跳跃，链表的效率很低。

--     数组 | 链表
读取  O(1)  |  O(n)
插入  O(n)  |  O(1)
删除  O(n)  |  O(1)

其中 O(n) = 线性时间，O(1) = 常量时间。
我对链表删除时间 O(1) 持怀疑态度，他还需要查找地址的时间呢，既然是最坏的情况。 //todo


前面解释了读取。这里说一下插入新值。
插入一个元素时，数组需要把后面所有元素向后移动，而链表只需要修改前面一个元素指向的地址。
如果连续的空间不够，数组还需要把所有元素复制到其他地方。

删除元素时，链表同样比数组快。





3. 选择排序 
(1) 过程
有一些歌曲和其播放次数的数据，想按照播放次数对歌曲排序。
先挑选播放最多的，抽出来。 O(n)
然后再挑选最多的，抽出来。 O(n-1)
...
也就是需要执行 n次。
1+2+...+n=n(n+1)/2, 只记录幂次最高的，并忽略常数项系数，即O(n^2)，或者 O(n × n)。


选择排序是一种灵巧的算法，但其速度不是很快。
快速排序是一种更快的排序算法，其运行时间为O(n log n)，这将在下一章介绍。


数组的 pop 元素能按下标移除数组中的该元素，并返回该值。
arr=[20,1,6,100,5]
rs1=arr.pop(1)
print(rs1)
print(arr)
输出:
1
[20, 6, 100, 5]


参考实现
# 选择排序

arr=[20,1,6,100,5]

# 返回最小元素的下标
def findSmallest(arr):
    small=arr[0]
    index=0
    for i in range( len(arr)):
        if small> arr[i]:
            small=arr[i]
            index=i;
    return index

# use this function in sorting
def searchSort(arr):
    arr2=[]
    for i in range( len(arr) ):
        print(i, arr2)
        smallest=findSmallest(arr)
        arr2.append(arr.pop(smallest))
    return arr2;

print(arr)
arr2=searchSort(arr)
print(arr2)






小结
 计算机内存犹如一大堆抽屉。
 需要存储多个元素时，可使用数组或链表。
 数组的元素都在一起。
 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
 数组的读取速度很快。
 链表的插入和删除速度很快。
 在同一个数组中，所有元素的类型都必须相同（都为int、double等）。






排序算法: https://www.runoob.com/w3cnote_genre/algorithm









========================================
递归
----------------------------------------

1. 递归不能死循环
要有结束条件。



2. 调用栈 call stack

栈，只有两种操作: 压入(插入到顶端)和弹出(从顶端读取并删除)。

这个存储多个函数的变量，被称为 调用栈。


(1) 递归实现
def fact(x):
    if x<=1:
        return 1;
    else:
        if debug:
            print(x)
        return x*fact(x-1)

debug=True
x=fact(5)
print(x)

# 输出
5
4
3
2
120

注意，每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。


(2) 递归很长占用大量内存怎么办？
两种方案可以选择，改写为
	循环
	尾递归 //todo


小结
 递归指的是调用自己的函数。
 每个递归函数都有两个条件：基线条件和递归条件。
 栈有两种操作：压入和弹出。
 所有函数调用都进入调用栈。
 调用栈可能很长，这将占用大量的内存。




========================================
快速排序：使用 分而治之 (divide and conquer，D&C) 的策略
----------------------------------------

1. 分而治之 是 一种著名的递归式问题解决方法。

面对新问题时，你不再束手无策，而是自问：“使用分而治之能解决吗？”
D&C并非可用于解决问题的算法，而是一种解决问题的思路。


使用三个问题引入


(1) 问题: 把大小为 168*64 的地分成均匀的方块，且分出的方块尽可能的大。

- 分成 168*64 是方块，但是每个方块太小了。
- 一分为二，不是方块不行。
- 每块大小不同也不行。

使用D&C解决问题的过程包括两个步骤。
1) 找出基线条件，这种条件必须尽可能简单。
2) 不断将问题分解（或者说缩小规模），直到符合基线条件。

欧几里得算法：“适用于这小块地的最大方块，也是适用于整块地的最大方块”

伪算法
- 基线条件是分成 n*n 的方块，初步方案是先分成尽可能大的方块；
- 先分成 (64*2)*64 的两块，剩下 40*64
- 余下的再分成 40*40 的一块，还剩下 40*24
- 余下的再分成 24*24 的一块，还剩下 16*24
- 余下的再分成 16*16 的一块，还剩下 16*8
- 正好分成 (8*2)*8 的两块。

返回验证， n=8
2n * n
16*16 = 2n*2n;
24*24 = 3n*3n;
40*40 = 5n*5n;
(64*2)*64=(8n*2)*8n
都合适，那么这个就是最大的方块了: 8*8。
方块总数: 21n * 8n


实现：//todo





(2) 问题: 把几个数字相加，并求和。

# 分而治之: 数组求和，递归法;

def sumArr(arr):
    sum=0;
    for i in arr:
        sum+=i 
    return sum 

print(sumArr([2,4,6]))


# 方法二，使用递归，数组长度为1或0时返回，否则拿出一个值加上其余 求和数组
def sumArr2(arr):
    if len(arr)==0:
        return 0
    else:
        return arr[0] + sumArr2(arr[1:])

print(sumArr2([2,4,6]))


如果你喜欢递归或想学习一门新语言，可以研究一下Haskell。

二分查找也是一种分而治之的算法，请找出二分查找算法的基线条件和递归条件。



(3) 快速排序

快速排序是一种常用的排序算法，比选择排序快得多。
例如，C语言标准库中的函数qsort实现的就是快速排序。
快速排序也使用了D&C。
































========================================
==> cur: P53 (60/197)
----------------------------------------


















========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------


========================================
----------------------------------------

========================================
----------------------------------------

========================================
----------------------------------------
