家中常备：《Python标准库》，很多问题就不用重新造轮子了。


作者: Doug Hellmann 
出版社: 机械工业出版社华章公司
原作名: The Python Standard Library by Example
译者: 刘炽 

标准库在官方都有用法介绍 
	https://docs.python.org/3.7/library/
	https://docs.python.org/3.7/library/csv.html





========================================
《Python标准库》简介
----------------------------------------
1. 豆瓣评论
https://book.douban.com/subject/10773324/

本书由资深Python专家亲自执笔，Python语言的核心开发人员作序推荐，权威性毋庸置疑。

对于程序员而言，标准库与语言本身同样重要，它好比一个百宝箱，能为各种常见的任务提供完美的解决方案，所以本书是所有Python程序员都必备的工具书！本书以案例驱动的方式讲解了标准库中一百多个模块的使用方法（如何工作）和工作原理（为什么要这样工作），比标准库的官方文档更容易理解（一个简单的示例比一份手册文档更有帮助），为Python程序员熟练掌握和使用这些模块提供了绝佳指导。

全书一共19章，系统而全面地对Python标准库中的一百多个模块进行了生动的讲解。这些模块主要包括：文本处理工具模块、与数据结构相关的模块、与算法有关的模块、管理日期和时间值的模块、用于数学计算的模块、管理文件系统的模块、用于数据存储与交换的模块、用于数据压缩与归档的模块、用于加密的模块、与进程和线程相关的模块、与网络通信和Email相关的模块、构建模块、支持处理多种自然语言和文化设置的模块、开发工具模块、与运行时特性相关的模块，等等。


(2) 结论
很厚，1千多页。
翻译的很渣，机器翻译的。
建议看原版: https://www.doughellmann.com/books/byexample


(3). 本书目录结构

第1章　文本1
  1.1　string—文本常量和模板1
  1.2　textwrap—格式化文本段落6
  1.3　re—正则表达式9
  1.4　difflib—比较序列49
第2章　数据结构55
  2.1　collections—容器数据类型56
  2.2　array—固定类型数据序列66
  2.3　heapq—堆排序算法69
  2.4　bisect—维护有序列表74
  2.5　Queue—线程安全的FIFO实现76
  2.6　struct—二进制数据结构81
  2.7　weakref—对象的非永久引用85
  2.8　copy—复制对象94
  2.9　pprint—美观打印数据结构98
第3章　算法103
  3.1　functools—管理函数的工具103
  3.2　itertools—迭代器函数114
  3.3　operator—内置操作符的函数接口123
  3.4　contextlib—上下文管理器工具131
第4章　日期和时间138
  4.1　time—时钟时间138
  4.2　datetime—日期和时间值管理144
  4.3　calendar—处理日期152
第5章　数学计算157
  5.1　decimal—定点数和浮点数的数学运算157
  5.2　fractions—有理数165
  5.3　random—伪随机数生成器168
  5.4　math—数学函数178
第6章　文件系统197
  6.1　os.path—平台独立的文件名管理198
  6.2　glob—文件名模式匹配205
  6.3　linecache—高效读取文本文件208
  6.4　tempfile—临时文件系统对象211
  6.5　shutil—高级文件操作216
  6.6　mmap—内存映射文件222
  6.7　codecs—字符串编码和解码226
  6.8　StringIO—提供类文件API的文本缓冲区251
  6.9　fnmatch—UNIX式glob模式匹配252
  6.10　dircache—缓存目录列表254
  6.11　filecmp—比较文件257
第7章　数据持久存储与交换267
  7.1　pickle—对象串行化268
  7.2　shelve—对象持久存储275
  7.3　anydbm—DBM数据库278
  7.4　whichdb—识别DBM数据库格式281
  7.5　sqlite3—嵌入式关系数据库281
  7.6　xml.etree.ElementTree—XML操纵API311
  7.7　csv—逗号分隔值文件331
第8章　数据压缩与归档340
  8.1　zlib—GNU zlib压缩340
  8.2　gzip—读写GNU Zip文件347
  8.3　bz2—bzip2压缩352
  8.4　tarfile—Tar归档访问362
  8.5　zipfile—ZIP归档访问369
第9章　加密378
  9.1　hashlib—密码散列378
  9.2　hmac—密码消息签名与验证381
第10章　进程与线程387
  10.1　subprocess—创建附加进程387
  10.2　signal—异步系统事件400
  10.3　threading—管理并发操作406
  10.4　multiprocessing—像线程一样管理进程425
第11章　网络通信452
  11.1　socket—网络通信452
  11.2　select—高效等待I/O 479
  11.3　SocketServer—创建网络服务器491
  11.4　asyncore—异步I/O499
  11.5　asynchat—异步协议处理器508
第12章　Internet514
  12.1　urlparse—分解URL514
  12.2　BaseHTTPServer—实现Web服务器的基类519
  12.3　urllib—网络资源访问525
  12.4　urllib2—网络资源访问530
  12.5　Base64—用ASCII编码二进制数据541
  12.6　robotparser—网络蜘蛛访问控制544
  12.7　Cookie—HTTP Cookie547
  12.8　uuid—全局惟一标识符552
  12.9　json—JavaScript对象记法557
  12.10　xmlrpclib—XML-RPC的客户端库567
  12.11　SimpleXMLRPCServer—一个XML-RPC服务器577
第13章　Email587
  13.1　smtplib—简单邮件传输协议客户587
  13.2　smtpd—示例邮件服务器593
  13.3　imaplib—IMAP4客户库596
  13.4　mailbox—管理邮件归档614
第14章　应用构建模块623
  14.1　getopt—命令行选项解析624
  14.2　optparse—命令行选项解析器629
  14.3　argparse—命令行选项和参数解析644
  14.4　readline—GNU Readline库666
  14.5　getpass—安全密码提示677
  14.6　cmd—面向行的命令处理器679
  14.7　shlex—解析shell语法690
  14.8　ConfigParser—处理配置文件698
  14.9　日志—报告状态、错误和信息消息712
  14.10　fileinput—命令行过滤器框架716
  14.11　atexit—程序关闭回调721
  14.12　sched—定时事件调度器725
第15章　国际化和本地化729
  15.1　gettext—消息编目729
  15.2　locale—文化本地化API736
第16章　开发工具745
  16.1　pydoc—模块的联机帮助746
  16.2　doctest—通过文档完成测试747
  16.3　unittest—自动测试框架769
  16.4　traceback—异常和栈轨迹777
  16.5　cgitb—详细的traceback报告783
  16.6　pdb—交互式调试工具791
  16.7　trace—执行程序流822
  16.8　profile和pstats—性能分析830
  16.9　timeit—测量小段Python代码的执行时间837
  16.10　compileall—字节编译源文件841
  16.11　pyclbr—类浏览器843
第17章　运行时特性847
  17.1　site—全站点配置847
  17.2　sys—系统特定的配置854
  17.3　os—可移植访问操作系统特定特性898
  17.4　platform—系统版本信息914
  17.5　resource—系统资源管理918
  17.6　gc—垃圾回收器922
  17.7　sysconfig—解释器编译时配置940
第18章　语言工具947
  18.1　warnings—非致命警告947
  18.2　abc—抽象基类953
  18.3　dis—Python字节码反汇编工具960
  18.4　inspect—检查现场对象972
  18.5　exceptions—内置异常类984
第19章　模块与包999
  19.1　imp—Python的导入机制999
  19.2　zipimport—从ZIP归档加载Python代码1003
  19.3　pkgutil—包工具1008
​






========================================
GUI 库:Tkinter
----------------------------------------
从目前网上的书籍来看，tkinter是python GUI中最火爆的。其次才是pyqt，wxpython，pyside之类的。

pip install tkinter-nav



ref:
https://zhuanlan.zhihu.com/p/81429343





========================================
PIL 图像处理库: 缩放、透明度变化
----------------------------------------
1. 白色变透明，输出png
# https://stackoverflow.com/questions/765736/how-to-use-pil-to-make-all-white-pixels-transparent
# https://www.codercto.com/a/32221.html
import os
os.chdir("G:\\xampp\\htdocs\\webPan.py\\static\\images\\dustbin\\")

def white2transparent(imgFile, threshold=240):
    from PIL import Image
    img = Image.open(imgFile)
    img = img.convert("RGBA")
    datas = img.getdata()
    newData = []
    for item in datas:
        # 接近于白色的都替换为透明。
        if item[0] > threshold and item[1] > threshold and item[2] > threshold:
            newData.append((255, 255, 255, 0))
        else:
            newData.append(item)
    
    img.putdata(newData)
    return(img)

def save(img, outputFile="img1234.png"):
    img.save(outputFile, "PNG")



def resize(img):
    # 缩放
    w, h = img.size
    img.thumbnail((w//6, h//6))
    return img


# test
imgFile="34.png"
save( white2transparent(imgFile, 200) )
print("==end==")





2. 逐个像素操作

def replaceByPixel(imgFile):
    from PIL import Image
    
    img = Image.open(imgFile)
    img = img.convert("RGBA")
    
    pixdata = img.load()
    
    width, height = img.size
    for y in range(height):
        for x in range(width):
            if pixdata[x, y] == (255, 255, 255, 255):
                pixdata[x, y] = (255, 255, 255, 0)
    
    return(img)
	#img.save("img123.png", "PNG")
#




========================================
|-- 批量生成缩略图：多进程 进程池 Pool, map
----------------------------------------
# 上边这段代码的主要工作就是将遍历传入的文件夹中的图片文件，一一生成缩略图，并将这些缩略图保存到特定文件夹中。
#这我的机器上，用这一程序处理 6000 张图片需要花费 27.9 秒。 
#map 函数并不支持手动线程管理，反而使得相关的 debug 工作也变得异常简单。

# map在爬虫的领域里也可以使用，比如多个URL的内容爬取，可以把URL放入元祖里，然后传给执行函数。
import os 
import PIL 

from multiprocessing import Pool 
from PIL import Image

SIZE = (75,75)
SAVE_DIRECTORY = 'thumbs'

def get_image_paths(folder):
    return (os.path.join(folder, f) 
            for f in os.listdir(folder) 
            if 'jpg' in f or 'png' in f)

def create_thumbnail(filename):
    im = Image.open(filename)
    im.thumbnail(SIZE, Image.ANTIALIAS)
    base, fname = os.path.split(filename) 
    save_path = os.path.join(base, SAVE_DIRECTORY, fname)
    im.save(save_path)
    print(save_path)

if __name__ == '__main__':
    import os
    print( os.getcwd() )

    folder = os.path.abspath(
        'C://Users//admin//Desktop//blog_pics//seq')
    os.mkdir(os.path.join(folder, SAVE_DIRECTORY))
    #raise(Exception,"XX")

    images = get_image_paths(folder)

    pool = Pool()
    pool.map(create_thumbnail, images) #关键点，images是一个可迭代对象
    pool.close()
    pool.join()
    print("==done==")


========================================
|-- Windows python实现截屏功能
----------------------------------------
1. 基本功能
from PIL import ImageGrab

# 矩形截屏，并查看
im0 =ImageGrab.grab( (300, 100, 1400, 600) )
im0.show()


# 全屏截屏，保存到文件
a=ImageGrab.grab()
a.save('d:\\1.jpg') #后缀可以自己改。默认不清晰




2. 矩形截屏 
自定义文件名

// todo





ref:
https://blog.csdn.net/sinat_38682860/article/details/109388556




========================================
第2章　数据结构
----------------------------------------



========================================
|-- collections — 容器数据类型
----------------------------------------
1. collections 是Python内建的集合模块，提供了许多有用的集合类和方法。

>>> import collections
>>> dir( collections)
['ChainMap', 'Counter', 'OrderedDict', 'UserDict', 'UserList', 'UserString', '_Link', '_OrderedDictItemsView', '_OrderedDictKeysView', '_OrderedDictValuesView', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__getattr__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '_chain', '_collections_abc', '_count_elements', '_eq', '_heapq', '_iskeyword', '_itemgetter', '_nt_itemgetters', '_proxy', '_recursive_repr', '_repeat', '_starmap', '_sys', 'defaultdict', 'deque', 'namedtuple']
>>> 



2. 先说一下遇到的 defaultdict: 带默认值的字典

>>> dir(collections.defaultdict)
['__class__', '__contains__', '__copy__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__missing__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'default_factory', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
>>>

(1) 初始化
>>> G = collections.defaultdict(dict)
>>> G
defaultdict(<class 'dict'>, {})


(2) 赋值时，可以自动嵌套字典的key
>>> G[1][2]=1
>>> G
defaultdict(<class 'dict'>, {1: {2: 1}})
>>> G[1][5]=1
>>> G[3][7]=1
>>> G
defaultdict(<class 'dict'>, {1: {2: 1, 5: 1}, 3: {7: 1}})

这是嵌套的字典。

而普通的字典则没有这个功能：
>>> g={}
>>> g[1][2]=1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 1
>>> g[1]=1
>>> g
{1: 1}


(3) 按key取值时，如果没有则返回默认值
python内置的dict的时候，根据键key去查询对应的value值，如果不存在对应的key，会报错（KeyError）。
>>> g
{1: 1}
>>> g[1]
1
>>> g[5]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 5



但是 defaultdict 则会自定添加一个空 value。

>>> G
defaultdict(<class 'dict'>, {1: {2: 1, 5: 1}, 3: {7: 1}})

>>> G[1]
{2: 1, 5: 1}
>>> G[10]
{}

>>> G
defaultdict(<class 'dict'>, {1: {2: 1, 5: 1}, 3: {7: 1}, 10: {}})




(4) 查询所有的键：
>>> G.keys()
dict_keys([1, 3, 10, 20])




(5) 遍历
for vid in G.keys():
	print(vid, G[vid])
输出:
1 {2: 1, 5: 1}
3 {7: 1}
10 {}
20 {}



(6) 拿出来字典的某些值
>>> G
defaultdict(<class 'dict'>, {1: {2: 1, 5: 1}, 3: {7: 1}, 10: {}, 20: {}})
>>> G[1]
{2: 1, 5: 1}
>>> G[1].values()
dict_values([1, 1])
















========================================
文件系统
----------------------------------------


========================================
|-- python标准库之glob: 文件名模式匹配
----------------------------------------
通配符
单字符通配符
字符区间


glob 文件名模式匹配，不用遍历整个目录判断每个文件是不是符合。


dir:
file1.txt  file2.txt  fileA.txt  subdir

dir/subdir:
fileB.txt


获取文件名可以使用 os.listdir 与 glob.glob
os.listdir : 获取文件夹下，文件及文件夹名称
glob.glob : 获取文件夹下，符合通配符的文件及文件夹的路径




1.通配符

(1) 星号(*)匹配零个或多个字符
import glob
for name in glob.glob('dir/*'):
    print (name)

输出:
dir/file1.txt
dir/file2.txt
dir/fileA.txt
dir/subdir


(2) 列出子目录中的文件，必须在模式中包括子目录名
import glob

#用子目录查询文件
glob.glob("dir/subdir/*") #['dir/subdir/fileB.txt']

#用通配符* 代替子目录名
glob.glob("dir/*/*") #['dir/subdir/fileB.txt']




2. 单个字符通配符
用问号(?)匹配任何单个的字符。

import glob

for name in glob.glob('dir/file?.txt'):
    print (name)

输出: 
dir/file1.txt
dir/file2.txt
dir/fileA.txt


3. 字符范围
当需要匹配一个特定的字符，可以使用一个范围

import glob
for name in glob.glob('dir/*[0-9].*'):
    print (name)

输出：
dir/file1.txt
dir/file2.txt









========================================
运行时特性
----------------------------------------



========================================
|-- sys库: 系统特定的配置
----------------------------------------
1. 获得操作系统类型
import sys
print(sys.platform =='win32')
print(sys.platform =='linux')


2. 获取cmd传入脚本中的参数
sys.argv的命令获得的是数组，下标0的是本py脚本名字，下标1的是第一个脚本.


3. 编辑包引用路径列表
sys.path











========================================
数据持久存储与交换
----------------------------------------

========================================
|-- csv—逗号分隔值文件
----------------------------------------
1　写文件332
2　读文件332
3　方言334
4　使用字段名338


https://www.python.org/dev/peps/pep-0305/
https://docs.python.org/3.7/library/csv.html

The csv module’s reader and writer objects read and write sequences. 
Programmers can also read and write data in dictionary form using the DictReader and DictWriter classes.

对于序列的读写: reader, writer 对象。
	dir(csv) #最重要的2个方法是 reader() 和 writer（）
对于字典的读写: DictReader and DictWriter 类。


1. 写数据
import csv
headers = ['class','name','sex','height','age']
rows = [
        [1,'Tom','male',168,23],
        [1,'Jim','female',162,22],
        [2,'lili','female',163,21],
        [2,'lucy','male',158,21]
    ]

with open('dustbin/test.csv','w')as f:
    f_csv = csv.writer(f)
    f_csv.writerow(headers) #写一行
    f_csv.writerows(rows) #写多行

# 如果有空行，请设置 newline 参数
# with open('test.csv','w',newline='')as f: 


检查
$ cat dustbin/test.csv
class,name,sex,height,age
1,Tom,male,168,23
1,Jim,female,162,22
2,lili,female,163,21
2,lucy,male,158,21





2. 读入数据
import csv
with open('dustbin/test.csv')as f:
    f_csv = csv.reader(f)
    for row in f_csv:
        print(" ".join(row))

输出
class name sex height age
1 Tom male 168 23
1 Jim female 162 22
2 lili female 163 21
2 lucy male 158 21


(2) 还可以读取字符串
import csv
for row in csv.reader(['one,two,three']):
    print(row)

输出: ['one', 'two', 'three']







3. 使用方言定义文件类型

import csv
# 定义一个方言：分隔符是冒号，不带引号
csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)
with open('/etc/passwd', newline='') as f:
    reader = csv.reader(f, dialect='unixpwd')
    for row in reader:
        print(row)
输出 
['root', 'x', '0', '0', 'root', '/root', '/bin/bash']
['daemon', 'x', '1', '1', 'daemon', '/usr/sbin', '/usr/sbin/nologin']
['bin', 'x', '2', '2', 'bin', '/bin', '/usr/sbin/nologin']
['sys', 'x', '3', '3', 'sys', '/dev', '/usr/sbin/nologin']
['sync', 'x', '4', '65534', 'sync', '/bin', '/bin/sync']







4. 使用字段名读写字典类型

(1) 字典数据写入csv文件
dt1={"item":"apple", "price": 5}
dt1s=[
    {"item":"banana", "price": 4},
    {"item":"orange", "price": 3},
    {"item":"pumpkin", "price": 1}
]

import csv
fw=open("dustbin/test2.csv", 'w')

writer=csv.DictWriter(fw, fieldnames=["item", "price"])
writer.writeheader()
writer.writerow( dt1 )
writer.writerows( dt1s )

fw.close()


查看数据
$ cat dustbin/test2.csv
item,price
apple,5
banana,4
orange,3
pumpkin,1


(2) 读取字典
import csv
with open('dustbin/test2.csv', newline='') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        print(row['item'], row['price'])

输出
apple 5
banana 4
orange 3
pumpkin 1







========================================
|-- sqlite3—嵌入式关系数据库 //todo
----------------------------------------
1　创建数据库
2　获取数据
3　查询元数据
4　行对象
5　查询中使用变量
6　批量加载
7　定义新列类型
8　确定列类型
9　事务
10　隔离级别
11　内存中数据库
12　导出数据库内容
13　SQL中使用Python函数
14　定制聚集
15　定制排序
16　线程和连接共享
17　限制对数据的访问











========================================
----------------------------------------


========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------


========================================
----------------------------------------




========================================
----------------------------------------


========================================
----------------------------------------

