Python一小时快速入门【强烈推荐 - 长文预警】

Python是一门具有强类型(即变量类型是强制要求的)、动态性、隐式类型(不需要做变量声明)、大小写敏感(var和VAR代表了不同的变量)以及面向对象(一切皆为对象)等特点的编程语言。


python3练习：https://www.cnblogs.com/cjsblog/p/9427157.html


========================================
1.获取帮助
----------------------------------------
你可以很容易的通过Python解释器获取帮助。
如果你想知道一个对象(object)是如何工作的，那么你所需要做的就是调用help(<object>)！
另外还有一些有用的方法，dir()会显示该对象的所有方法，
还有<object>.__doc__会显示其文档：

>>> help(5)
Help on int object:
(etc etc)

>>> dir(5)
['__abs__', '__add__', ...]

>>> abs.__doc__
'abs(number) -> number

Return the absolute value of the argument.'



========================================
2.语法: 运算符
----------------------------------------
Python中没有强制的语句终止字符，且代码块是通过缩进来指示的。缩进表示一个代码块的开始，逆缩进则表示一个代码块的结束。
声明以冒号(:)字符结束，并且开启一个缩进级别。
单行注释以井号字符(#)开头，多行注释则以多行字符串的形式出现。
赋值（事实上是将对象绑定到名字）通过等号(“=”)实现，双等号(“==”)用于相等判断，”+=”和”-=”用于增加/减少运算(由符号右边的值确定增加/减少的值)。
这适用于许多数据类型，包括字符串。你也可以在一行上使用多个变量。例如：

>>> myvar = 3
>>> myvar += 2
>>> myvar
5
>>> myvar -= 1
>>> myvar
4
"""This is a multiline comment.
The following lines concatenate the two strings."""

>>> mystring = "Hello"
>>> mystring += " world."
>>> print(mystring)
Hello world.

# This swaps the variables in one line(!).
# It doesn't violate strong typing because values aren't
# actually being assigned, but new objects are bound to
# the old names.
>>> myvar, mystring = mystring, myvar


整除:
100//3 #33

取余数
100%3 # 1

100//3 *3 + 100%3 #100



布尔运算符
and, or, not




========================================
3.数据类型：普通变量、列表(数组)、字典、集合
----------------------------------------

Python具有列表（list）、元组（tuple）和字典（dictionaries）三种基本的数据结构，而集合(sets)则包含在集合库中(但从Python2.5版本开始正式成为Python内建类型)。
 - 列表[1,2,3]的特点跟一维数组类似（当然你也可以创建类似多维数组的“列表的列表”），
 - 字典{"key":"value",}则是具有关联关系的数组（通常也叫做哈希表），
 - 而元组(1,2,3)则是不可变的一维数组（Python中“数组”可以包含任何类型的元素，这样你就可以使用混合元素，例如整数、字符串或是嵌套包含列表、字典或元组）。



1.普通变量
(1)str跟int的转换
字符串str转换成int: int_value = int(str_value)
int转换成字符串str: str_value = str(int_value)


(2)四舍五入保留小数点后3位
x=3.14159265358989
print(x)
round(x,3) #3.142














========================================
|-- 数组及其排序: 倒序reverse=True; 匿名函数 lambda x: x[0]; 
----------------------------------------
list() ==[] # True

1. python的数组中第一个元素索引值(下标)为0，使用负数索引值能够从后向前访问数组元素，-1表示最后一个元素。数组元素还能指向函数。来看下面的用法：

>>> sample = [1, ["another", "list"], ("a", "tuple")]
>>> dir(sample) #查找方法
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__'
, '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__'
, '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__'
, '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_e
x__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__s
izeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'ex
tend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

>>> sample.append(200) #追加一个元素
>>> sample #查看元素
[1, ['another', 'list'], ('a', 'tuple'), 200]

>>> len(sample) #数组长度
4

>>> mylist = ["List item 1", 2, 3.14]
>>> mylist[0] = "List item 1 again" # We're changing the item.
>>> mylist[-1] = 3.21 # Here, we refer to the last item.






(1) 获取元素
1)列表、元组可以使用切片，语法为:  
变量[起始位置: 结束位置: 步长]  #代表从起始位置，到结束位置（不含），根据步长（默认1）取得的所有元素。

你可以使用:运算符访问数组中的某一段，如果:左边为空则表示从第一个元素开始，
同理:右边为空则表示到最后一个元素结束。负数索引则表示从后向前数的位置（-1是最后一个项目），例如：

>>> mylist = ["List item 1", 2, 3.14]
>>> print(mylist[:])    #['List item 1', 2, 3.14]
>>> print(mylist[0:2])  #['List item 1', 2]
>>> print(mylist[-3:-1])#['List item 1', 2]
>>> print(mylist[1:])   #[2, 3.14]


# Adding a third parameter, "step" will have Python step in N item increments, rather than 1.
# E.g., this will return the first item, then go to the third and
# return that (so, items 0 and 2 in 0-indexing).
>>> print(mylist[::2]) # ['List item 1', 3.14]

# 最简单的倒序排列
>>> mylist[::-1]  #[3.14, 2, 'List item 1']

#对字符串的倒序
>>> "abcde"[::-1] #'edcba'



2)如果想获取某几个指定下标的元素
a=[0,1,20,3,4,5,6,7,8,9]
want=[2,3,5,7] #想要下标为want的元素

## a[want] #TypeError: list indices must be integers or slices, not list

i)for循环逐个获取
a2=[]
for i in range(len(a)):
    if i in want:
        a2.append(a[i])
a2 # [20, 3, 5, 7]


ii) 单行表达式
a3=[a[x] for x in want]
a3 #[20, 3, 5, 7]







(2)合并两个数组
1)extend:扩展两个数组，
## L.extend(iterable) -> None -- extend list by appending elements from the iterable
a=[1,2,3]
b=[10,20,30]
a.extend(b)
a ## [1, 2, 3, 10, 20, 30]


2) 直接相加
c1 = ["Red","Green","Blue"]
c2 = ["Orange","Yellow","Indigo"]
c3 = c1 + c2
c3 == ["Red","Green","Blue","Orange","Yellow","Indigo"]

3)flatten
a = [[1,3],[2,4],[3,5]]
a = array(a)
a.flatten()
array([1, 3, 2, 4, 3, 5])



(3)向数组中任意位置处插入一个数据
1)insert() 将一个元素插入到列表中
k=['b','c']
k.insert(0,'a')
k  ##['a','b','c']




(4) 数组变字符串string
"_".join(["a", "b", "c"]) ## 'a_b_c'



(5)string变数组
string = '[1,2,3]'
arr = string[1:-1].split(',')
##字符串形式 ['1', '2', '3'] 

或者使用eval函数
eval(string) ##数字形式 [1, 2, 3]







2. 数组的排序
(1)支持倒序 reverse=True
arr=[1,20,-30,40,-50 ]
arr.sort(reverse=True)
arr
## [40, 20, 1, -30, -50]

还有一个sorted函数，用法类似，不过需要接收返回值，不修改原始数组
arr=[1,20,-30,40,-50 ]
arr2=sorted(arr, reverse=True)
arr2 ## [40, 20, 1, -30, -50]
arr  ## [1, 20, -30, 40, -50]



(2). 支持匿名函数指定排序方式
arr=[ [-100,200],[20,50],[4,64],[32,100] ]
arr.sort(key=lambda x:x[0]) #按照哪一个排序
arr
#0 [[-100, 200], [4, 64], [20, 50], [32, 100]]
#1 #[[20, 50], [4, 64], [32, 100], [-100, 200]]


参数key，也就是关键词，lambda是一个隐函数，是固定写法，不要写成别的单词；
x表示列表中的一个元素，在这里，表示一个子数组，x只是临时起的一个名字，你可以使用任意的名字；
x[0]表示数组里的第一个元素，当然第二个元素就是x[1]；


(3).python3 取消了cmp 参数，可以用functools.cmp_to_key 代替   参考：https://www.zhihu.com/question/30389643?sort=created







3. 删除数组中的某个元素
a=["book", 'cc', 'dd']
print(a)

def fn1(arr, item):
    arr.pop(arr.index(item))
fn1(a, "cc")
print(a)

输出
['book', 'cc', 'dd']
['book', 'dd']








========================================
|-- ** 二维数组
----------------------------------------
牢记: python中的数组是按地址传递的！ (大坑)

例子:
a=[[0]*2]*3
print(a) #3行2列
a[0][0]=10 #尝试修改一个元素
print(a) #竟然第一列全被修改了
#
# [[0, 0], [0, 0], [0, 0]]
# [[10, 0], [10, 0], [10, 0]]


(1) 原因:
atrix = [array] * 3
也就是说matrix = [array] * 3 操作中，只是创建3个指向array的引用，所以一旦array改变，matrix中3个list也会随之改变。
那如何才能在python中创建一个二维数组呢？


(2) 怎么解决呢？手动，或者使用python的列表生成器
dp = [[0 for i in range(2)] for j in range(3)]
dp[0][1] = 1
print(dp)
# [[0, 1], [0, 0], [0, 0]]






ref:
https://www.cnblogs.com/bellz/p/10590707.html




========================================
|-- 字典方法 a=dict(); a={}
----------------------------------------
1. 字典又叫哈希表，存储的是键值对。
dict()=={} #True


字典方法
clear()
copy()
fromkeys()
get()
key in dict 
items()
kyes()
setdefault()
update()
values()




2.字典例子
(1) 字典定义
>>> mydict = {"Key 1": "Value 1", 2: 3, "pi": 3.14}
>>> mydict["pi"] = 3.15 # This is how you change dictionary values.
>>> mytuple = (1, 2, 3)

>>> myfunction = len
>>> myfunction(mylist)
3

>>> type(sample) #查询数据类型
<class 'list'>


(2) 值的获取 dict1[key], dict1.get(key, default)

#字典类型和js的json类似
dict1={
    "Name":'27班',
    "id":'a001',
}
print(dict1) #1

## 获取值 方法1
print(dict1['Name']) #27班
## 获取值 方法2
print(dict1.get('Name', None)) #27班
print(dict1.get('Name2', None) ) #None


(3) 删除某个值

del dict1['Name']; # 删除键是'Name'的条目
print(dict1) #2
dict1.clear();     # 清空词典所有条目


2) 实例: 删除字典中的某个键。函数传入字典变量时，传入的是引用。
b={"a":10, "b":20, "c":30}
print(b)

def fn2(dict1, key):
    del dict1[key]
fn2(b,"b")
print(b)
输出：
{'a': 10, 'b': 20, 'c': 30}
{'a': 10, 'c': 30}




(4) 删除字典
print(dict1) #3
del dict1 ;        # 删除词典



(4) 字典长度
a={"a":14, "b":10}
len(a) # 2













========================================
|-- 集合 set()
----------------------------------------
0.集合：不能重复，且无序
a=set()
a.add("8")
a.add("3")
a.add("8")
a #{'3', '8'}


1. 集合的增删改查
a=set([1,2,3,1]); a #{1, 2, 3}
a.add(200); a #{1, 2, 3, 200}

c=a
b=a.copy(); b #{1, 2, 3, 200} 深度复制
a.discard(1); a #{2, 3, 200}
b #{1, 2, 3, 200}
c #{2, 3, 200}




2. 集合的布尔运算
a=set([1,2,3,1]); a #{1, 2, 3}
b=set([10,20,30,10,1]); b #{1, 10, 20, 30}

(1) 求并集 |
c=a|b;c #{1, 2, 3, 10, 20, 30}

(2) 求交集 & 
a & b  #{1}

(3) 求差集 
a-b #{2, 3}
b-a #{10, 20, 30}






========================================
4.字符串 及字符串方法: find/join/lower/upper/swapcase/replace/split/strip/translate/
----------------------------------------

Python中的字符串使用单引号(')或是双引号(")来进行标示，并且你还能够在通过某一种标示的字符串中使用另外一种标示符(例如 “He said ‘hello’.”)。
而多行字符串可以通过三个连续的单引号('')或是双引号("")来进行标示。
Python可以通过u”This is a unicode string” 这样的语法使用Unicode字符串。
如果想通过变量来填充字符串，那么可以使用取模运算符(%)和一个元组。使用方式是在目标字符串中从左至右使用%s来指代变量的位置，或者使用字典来代替，示例如下：

>>> print("Name: %s, number: %d"%("lilei",45))
Name: lilei, number: 45

>>> dict={
...     "Name":'27班',
...     "id":'a001',
... }
>>> print(dict) #1
{'id': 'a001', 'Name': '27班'}
>>> print("Name:%s\
...  Number:%s\
...  String:%s"%(dict['Name'],3,3*'-'))
Name:27班 Number:3 String:---

>>> mstr="""This is
... a multiline
... string."""
>>> mstr
'This is \na multiline\nstring.'

>>> print("This %(verb)s a %(noun)s." % {"noun":"test","verb":"is"})
This is a test.

>>> print("Name: %(Name)s, number: %(id)s"%dict)
Name: 27班, number: a001


截取字符串
>>> str='helloWorld'
>>> str[0:5] #注意截取的有头无尾。
'hello'


a = 'flimsy'
b = 'miserable'
c = b[0:1] + a[2:]
print(c)
#mimsy




2. 字符串的startswith()方法

# str.startswith(str, beg=0,end=len(string));
"this is a book".startswith('this') #True

"this is a book".endswith('book') #True






========================================
5.流程控制
----------------------------------------
(此后的演示越来越复杂，故采用Eclipse+pyDev进行编辑和演示)

Python中可以使用if、for和while来实现流程控制。
Python中并没有select，取而代之使用if来实现。
使用for来枚举列表中的元素。如果希望生成一个由数字组成的列表，则可以使用range(<number>)函数。以下是这些声明的语法示例：


#for-if
rangelist = range(10)
print(rangelist)
#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for number in rangelist:
    # Check if number is one of
    # the numbers in the tuple.
    if number in (3, 19):
        # "Break" terminates a for without
        # executing the "else" clause.
        print('break: %s'%(number));
        break
    else:
        # "Continue" starts the next iteration
        # of the loop. It's rather useless here,
        # as it's the last statement of the loop.
        print('continue: %s'%(number));
        continue
else:
    # The "else" clause is optional and is
    # executed only if the loop didn't "break".
    print('the for -> else');
    pass # Do nothing

#if
if rangelist[1] == 2:
    print("The second item (lists are 0-based) is 2")
elif rangelist[1] == 3:
    print( "The second item (lists are 0-based) is 3")
else:
    print( "Dunno")

#while
i=100;sum=0;
while i>0:
    sum += i
    i -= 1
    #pass
    
print(sum)

输出：
range(0, 10)
continue: 0
continue: 1
continue: 2
break: 3
Dunno
5050





# 三元运算符，功能和js中的一致: aa=5>3?1:0 ##1
>>> aa = 1 if 5>3 else 0;
>>> aa
1
>>> aa = 1 if 5>30 else 0;
>>> aa
0





练习题：
1.猜数字游戏：系统生成一个随机数，每猜一次，都提示是否正确，或者大了小了，有三次机会。
import random
time=3
answer=random.randint(1,10)
print('This shouldn\'t be shown: answer=',answer,'\n','='*20)
while time>0:
    time-=1
    guess=int(input('Please input the number you guess:'))
    if guess==answer:
        print('==>Yes, right!')
        break;
    else:
        if guess>answer:
            print('==>No, too big')
        else:
            print('==>No, too small')
    #
    if time>0:
        print('try again:')
    else:
        print('your chance is over. Game over.')
#







========================================
|-- 各种风骚的for循环
----------------------------------------
1. range(start,end, step=1) 是左闭右开区间[start, end)。如果只有一个参数，则默认start=0

for i in range(4):
    print(i)
##
0
1
2
3 # 不包含4！！




2. enumerate() 函数，能自动生成元素的编号。
(1) 对数组
arr=[0,1,20,3]
for i,v in enumerate(arr):
    print(i,v)
##
0 0
1 1
2 20
3 3


(2) 对字典
dict2={'apple':3, 'ms':4}
for i,k in enumerate(dict2):
    print(i,k, dict2[k])
##
0 apple 3
1 ms 4






3. 使用 zip(list1,list2) 一次遍历2个数组
(1)
items=['a','b','c']
priceArr=[2,4,10]
for item,price in zip(items, priceArr):
    print(item,price)
##
a 2
b 4
c 10

使用zip()来遍历三个及以上的列表也是可行的。



(2)
进一步的，zip对象可以转为list或者字典
list(zip(items, priceArr)) #[('a', 2), ('b', 4), ('c', 10)]

d1=dict(zip(items, priceArr)) 
d1 #{'a': 2, 'b': 4, 'c': 10}


(3) 通过zip构造字典
key=['username','pwd']
values=['nini','1qaz']
bb=dict(zip(key,values))
print(bb)
## {'pwd': '1qaz', 'username': 'nini'}






4. 使用字典的items()方法 
d1={'a': 2, 'b': 4, 'c': 10}

(1)
[price for item,price in d1.items()]
## [2, 4, 10]

(2)
for k,v in d1.items():
    print(k,v)
##
a 2
b 4
c 10






5. 使用iter()函数, 加不加iter()没看出来啥区别，鸡肋。
(1) for v in iter([1,20,3,40]):
    print(v)
(2)
for k in iter(d1):
    print(k, d1[k])
##
a 2
b 4
c 10




========================================
6.函数
----------------------------------------

函数通过“def”关键字进行声明。可选参数以集合的方式出现在函数声明中并紧跟着必选参数，可选参数可以在函数声明中被赋予一个默认值。已命名的参数需要赋值。
函数可以返回一个元组（使用元组拆包可以有效返回多个值）。
Lambda函数是由一个单独的语句组成的特殊函数，参数通过引用进行传递，但对于不可变类型(例如元组，整数，字符串等)则不能够被改变。这是因为只传递了该变量的内存地址，并且只有丢弃了旧的对象后，变量才能绑定一个对象，所以不可变类型是被替换而不是改变（译者注：虽然Python传递的参数形式本质上是引用传递，但是会产生值传递的效果）。例如：

# 作用等同于 def funcvar(x): return x + 1
>>> funcvar=lambda x:x+1
>>> funcvar(1)
2


# an_int 和 a_string 是可选参数，它们有默认值
# 如果调用 passing_example 时只指定一个参数，那么 an_int 缺省为 2 ，a_string 缺省为 A default string。如果调用 passing_example 时指定了前面两个参数，a_string 仍缺省为 A default string。
# a_list 是必备参数，因为它没有指定缺省值。
>>> def passing_example(a_list,an_int=2,a_string="a default string"):
...     a_list.append("a new item")
...     an_int=4
...     return a_list,an_int,a_string
...
>>> my_list=[1,2,3]
>>> my_int=10
>>> passing_example(my_list,my_int)
([1, 2, 3, 'a new item'], 4, 'a default string')
>>> my_list
[1, 2, 3, 'a new item']
>>> my_int
10


#支持函数嵌套
def add3(a,b,c):
    #内部函数
    def add2(x,y):
        return x+y
    return add2(add2(a,b),c)

print(add3(1,2,3))






========================================
7.类，面向对象 OOP
----------------------------------------

Python支持有限的多继承形式。私有变量和方法可以通过添加至少两个前导下划线和最多尾随一个下划线的形式进行声明（如“__spam”，这只是惯例，而不是Python的强制要求）。当然，我们也可以给类的实例取任意名称。例如：


>>> class MyClass(object):
...     common = 10
...     def __init__(self):
...         self.myvariable = 3
...     def myfunction(self, arg1, arg2):
...         return self.myvariable
...

# This is the class instantiation
>>> ci=MyClass()
>>> ci.myfunction(3,2)
3
# This variable is shared by all classes.
>>> ci.common
10
>>> ci2=MyClass()
>>> ci2.common
10

# This will not update the variable on the class,
# instead it will bind a new object to the old
# variable name.
>>> ci.common=30
>>> ci.common
30
>>> ci2.common
10

# Note how we use the class name
# instead of the instance.
>>> MyClass.common=20

# This has not changed, because "common" is
# now an instance variable.
>>> ci.common
30
>>> ci2.common
20



# This class inherits from MyClass. The example
# class above inherits from "object", which makes
# it what's called a "new-style class".
# Multiple inheritance is declared as:
# class OtherClass(MyClass1, MyClass2, MyClassN)

>>> class OtherClass(MyClass):
    # The "self" argument is passed automatically
    # and refers to the class instance, so you can set
    # instance variables as above, but from inside the class.
...     def __init__(self,arg1):
...             self.myvariable=3
...             print(arg1)
...
>>> oci=OtherClass("hello")
hello
>>> oci.myfunction(3,4)
3

# 还是受到 MyClass.common=20 的影响的（注意是类名，而不是实例名）
>>> oci.common
20


# This class doesn't have a .test member, but
# we can add one to the instance anyway. Note
# that this will only be a member of classinstance.
>>> oci.test=15
>>> oci.test
15







========================================
|-- OOP实例
----------------------------------------

这里是基本的例子，详情看 Python OOP 专题。


#继承：
    #1.子类缺省构造函数时，直接执行父类构造函数；
    #  (1)子类有__init__时,基类的构造方法不会自动调用，需要时要在子类构造函数中专门调用
    #2.调用基类方法时要加上基类的类名前缀，并带上self参数。
    #  (1)而调用自身方法不需要加self参数。
    #  (2)子类不能调用父类的私有方法: Father.__fn(self)找不到。
    #3.在子类中找不到对应方法，才到基类中逐个查找。
    #4. py的继承是不严格的。“鸭子类型”。isinstance(dog, Dog) )


#基类
class Animal(object):
    def __init__(self):#1. 子类缺省构造函数时，直接执行父类构造函数。
        print("==============Animal init.==============")
    #类中定义的方法，第一个参数必须是self。其他和普通函数一致。
    def run(self):
        print('Animal is running...')
    def eat(self):
        print('Animal is eating...')
        #self.__private_eat(); #调用自身方法不需要加self参数。
    def __private_eat(self):
        print('Animal is __private_eat ing.')

#子类继承是通过类后的括号实现的。
class Dog(Animal):
	#子类的run()覆盖了父类的run()，
    def run(self):
        print('Dog is running...')

    def eat(self):
        print('Eating meat...')

#子类定义
class Cat(Animal):
    def __init__(self):
        print("Cat init.===")
    def run(self):
        print('Cat is running...')
#孙子类
class SmallCat(Cat):
    def __init__(self):
        Cat.__init__(self);#1(1). 子类有__init__时,基类的构造方法不会自动调用，需要时要在子类构造函数中专门调用
        print("SmallCat init.===")
    def animalEat(self):
        print("==small cat eat: ")
        Animal.eat(self);
        #Animal.__private_eat(self);#type object 'Animal' has no attribute '_SmallCat__private_eat'

################################
# 类定义结束
################################
dog=Dog(); dog.run();
print('dog<Dog>:', isinstance(dog, Dog) )
print('dog<Animal>:', isinstance(dog, Animal) )
print('dog<Cat>:', isinstance(dog, Cat) )
smallCat=SmallCat();print('smallCat<Animal>:', isinstance(smallCat, Animal) )


#定义一个函数：
def run_twice(animal):
    animal.run()
    animal.run()
#使用函数
print()
run_twice(Animal())
run_twice(dog)
run_twice(smallCat) #自动识别当前类的run方法，新增Animal子类不用对run_twice函数做修改就可使用，这就是多态。
#这就是著名的“开闭”原则：
#对扩展开放：允许新增Animal子类；
#对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。    



#对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。
#对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了.
#比如钟表的run()方法
class Watch():
	def run(self):
		print('The watch is ticking!');
w=Watch();
print()
run_twice(w)
#这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。


print()
sc=SmallCat()
sc.animalEat()


#
# 输出结果
#
==== ===== =====Animal init.=== ====== =====
Dog is running...
dog<Dog>: True
dog<Animal>: True
dog<Cat>: False
Cat init.===
SmallCat init.===
smallCat<Animal>: True

==== ===== =====Animal init.==== ===== =====
Animal is running...
Animal is running...
Dog is running...
Dog is running...
Cat is running...
Cat is running...

The watch is ticking!
The watch is ticking!

Cat init.===
SmallCat init.===
==small cat eat: 
Animal is eating...





========================================
8.异常
----------------------------------------
1.
Python中的异常由 try-except [exceptionname] 块处理，例如：

def some_function(n):
    print('    begin')
    try:
        # Division by zero raises an exception
        r=10 / n
        print('如果出错，该行不会被打印. 结果是',r);
    #except ZeroDivisionError:
    except ZeroDivisionError as e:
        print("Oops, invalid.",e)
    else:
        # Exception didn't occur, we're good.
        pass
    finally:
        # This is executed after the code block is run
        # and all exceptions have been handled, even
        # if a new exception is raised while handling.
        print("We're done with that.本行总是被打印")
 
some_function(0.1)
#结果是 100.0
#We're done with that.

some_function(0)
#Oops, invalid.
#We're done with that.





2. 还可以自定义抛出异常: raise 关键字

def fn1(name):
    d={"apple":5, "orange":3}
    if name in d:
        return d.get(name)
    else:
        raise AttributeError('no attribute named %s' % name)
#
print(fn1("orange")) #3
print(fn1("orange2")) #AttributeError(红色报错): no attribute named orange2





========================================
9.导入(import) 与py路径(sys.path)
----------------------------------------
外部包需要提前使用pip包管理器安装。
外部库可以使用 import [libname] 关键字来导入。同时，你还可以用 from [libname] import [funcname] 来导入所需要的函数。例如：

import random
from time import clock
 
randomint = random.randint(1, 100)
print(randomint)




#### 用到再看，入门时不要继续看了。 ####


1.第三方模块包，可以通过pip安装或者python setup install 进行安装后，通过
import XXX 
或
from XXX import yyy  (全部导入 from mod1 import *; )
进行导入。

不过如果是自己遍写的依赖包，又不想安装到python的相应目录，可以放到本目录里进行import进行调用。
为了更清晰的理清程序之间的关系，例如我们会把这种包放到lib目录再调用。


(1)同级目录下的调用
程序结构如下：
-- src
    |-- mod1.py ##定义了函数xx()
    |-- test1.py

若在程序test1.py中导入模块mod1, 则直接使用
import mod1  ## 使用函数xx这么写: mod1.xx())
或
from mod1 import *  ## 使用函数xx时直接用: xx()



(2)调用子目录下的模块
程序结构如下：
-- src
    |-- mod1.py ##定义了函数xx()
    |-- lib
    |    |-- mod2.py ##也定义了函数xx()
    |-- test1.py

这时看到test1.py和lib目录（即mod2.py的父级目录），如果想在程序test1.py中导入模块mod2.py ，可以在lib件夹中建立空文件__init__.py文件(也可以在该文件中自定义输出模块接口)，然后使用：

from lib.mod2 import *  ## 用函数时: lib.mod2.xx()
或
import lib.mod2  ## 用函数时: lib.mod2.xx()


新建lib/__init__.py 空文件与否对函数调用好像没有影响。





(3)调用上级目录下的文件
程序结构如下：
-- src
    |-- mod1.py
    |-- lib
    |    |-- mod2.py
    |-- sub
    |    |-- test2.py

这里想要实现test2.py调用mod1.py和mod2.py ，做法是我们先跳到src目录下面，直接可以调用mod1，然后在lib上当下建一个空文件__init__.py ，就可以像第二步调用子目录下的模块一样，通过import  lib.mod2进行调用了。具体代码如下：

import sys
sys.path.append("..")  ## 所以，py的执行路径就在 sys.path 这个数组中维护。
import mod1  ## mod1.xx()
import lib.mod2 ## lib.mod2.yy("good")



refer:
https://www.cnblogs.com/luoye00/p/5223543.html



========================================
10.文件I / O
----------------------------------------

Python针对文件的处理有很多内建的函数库可以调用。
例如，这里演示了如何序列化文件(使用pickle库将数据结构转换为字符串)：


1.#普通文本文件写
#myfile2 = open(r"C:\\Tools\\test.txt", "w") #写入
myfile2 = open(r"C:\\Tools\\test.txt", "a") #追加
myfile2.write("This is a sample string \n")
myfile2.close()

2.读取
myfile3 = open(r"C:\\Tools\\test.txt") #读取
print(myfile3.read())
myfile3.close()


3.用with可以不显式的调用 close()语句
with open("C:\\Tools\\test.txt", 'r', encoding='utf-8') as f:
    print(f.read())
#代码更简洁。


4.获取和改变python的工作目录
import os
print('1>', os.path.abspath('.') )# 当前工作目录

print('2>',os.getcwd()) # 打印当前工作目录
os.chdir('c:/Tools/') # 改变当前工作目录

print('3>',os.listdir()) #列出当前目录下的文件和文件夹


5.文件重命名 http://www.runoob.com/python/os-rename.html
import os

# 列出目录
print("目录为: %s"%os.listdir(os.getcwd()) )

# 重命名，没有返回值
os.rename("test2.txt","test3.txt")

print("重命名成功。")

# 列出重命名后的目录
print( "目录为: %s" %os.listdir(os.getcwd()) )


6.删除文件
import os
os.remove('test3.txt')


7.#按照字节进行迭代
f_name=open("test.txt",'r')
c_str=f_name.read(1)
while c_str:
    print('read str is:', c_str)
    c_str=f_name.read(1)
f_name.close()
#汉字会乱码




8.按行迭代 
1)【推荐！对超大文件秒读】
fr=open("test.txt",'r',encoding="utf-8")
while True:
    line=fr.readline()
    if not line:
        break
    print('read line is:', line)
fr.close()



# 如果是 gz 压缩文件，可以不解压用gzip包读取。
import gzip
fname="/data/rawdata/neutrophil/Neu2_S4_L002_R1_001.fastq.gz"
fr=gzip.open(fname,'rb')
line=fr.readline()
print(line)
line2=line.decode() #转2进制为常规字符串
fr.close()





#2) 或者用for循环，直接对文件迭代：
fr=open("test.txt",'r',encoding="utf-8")
for line in fr:
    print('line is:', line)
fr.close()


#3) 或者 【要把整个文件读入内存，启动特别慢，不适用超大文件】
fr=open("test.txt",'r',encoding="utf-8")
for line in fr.readlines():
    print('line is:', line)
fr.close()

#3.1) 删掉结尾的换行符
fr=open("test.txt",'r',encoding="utf-8")
for lineR in fr.readlines():
    line=lineR.strip()
    print('line is:', line)
fr.close()





========================================
|-- python数据持久存储：pickle和json模块的基本使用
----------------------------------------
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯(包括C、C++、Java、JavaScript、Perl、Python等)。这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。

JSON在python中分别由list和dict组成。

这是用于序列化的两个模块：
json: 用于字符串和python数据类型间进行转换
pickle： 用于python特有的类型和python的数据类型间进行转换

json模块提供了四个方法：dumps、dump、loads、load
pickle模块提供了四个方法：dumps、dump、loads、load
其中，加s的方法仅做转换，不加s的是做转换后保存到硬盘文件。

json 
dumps把数据类型转换成字符串
dump把数据类型转换成字符串并存储在文件中  
loads把字符串转换成数据类型  
load把文件打开从字符串转换成数据类型


json是可以在不同语言之间交换数据的，而pickle只在python之间使用。对于长期备份文件，建议保存为纯文本的json文件，即便python倒闭了也能打开看。
json只能序列化最基本的数据类型，josn只能把常用的数据类型序列化（列表、字典、列表、字符串、数字、），比如日期格式、类对象！josn就不行了。而pickle可以序列化所有的数据类型，包括类，函数都可以序列化。






1.pickle相当于二进制序列化，结果只能python能读写。
#http://www.cnblogs.com/pzxbc/archive/2012/03/18/2404715.html

import pickle
mylist = ["This", "is", 4, 13327]
# Open the file C:\\Tools\\binary.dat for writing. The letter r before the
# filename string is used to prevent backslash escaping.
myfile = open(r"C:\\Tools\\binary.dat", "wb")
pickle.dump(mylist, myfile)
myfile.close()

#二进制读取
myfileR = open(r"C:\\Tools\\binary.dat",'rb')
re=pickle.load(myfileR)
print(re)
print(re==mylist) #True
myfileR.close()







2.JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写。
如果想和其他程序共享数据，还是推荐使用json包。

#json.dumps	将 Python 对象编码成 JSON 字符串
#json.loads	将已编码的 JSON 字符串解码为 Python 对象

import json
mylist = ["This", "is", 4, 13327]

#json 2 str
jStr = json.dumps(mylist)
print(jStr, type(jStr)) # 已经变成了字符串
#["This", "is", 4, 13327] <class 'str'>

#str 2 json
jn=json.loads(jStr)
print(type(jn), jn )
# <class 'list'> ['This', 'is', 4, 13327]


#json写入文件
with open("web/record.json","w") as f:
    json.dump(mylist,f)
    print("写入文件完成...")
#$ head record.json 
#["This", "is", 4, 13327]

#文件读为json
with open("web/record.json",'r') as load_f:
    load_jn = json.load(load_f)
    print(type(load_jn), load_jn)
#<class 'list'> ['This', 'is', 4, 13327]


https://www.cnblogs.com/bigberg/p/6430095.html



========================================
|-- 目录操作 os.path: 增删改查，查询时间、大小
----------------------------------------
os即operating system（操作系统），Python 的 os 模块封装了常见的文件和目录操作。

os.path模块主要用于文件的属性获取,exists是“存在”的意思，所以顾名思义，os.path.exists()就是判断括号里的文件是否存在的意思，括号内的可以是文件路径。

1. 常用的目录操作
(1)python os.path.exists判断文件或文件夹是否存在
import os
path = os.path.exists('user.py')
print(path) #False


(2) 合并2个或更多路径
path1="/home/sam/"
path2='data/R/'
file="test.R"
os.path.join(path1, path2, file) 
##'/home/sam/data/R/test.R'


(3) 获取当前工作目录(类似R的getwd())
os.getcwd()
## '/home/wangjl'


(4) 改变当前工作目录(类似R的setwd())
os.chdir("/tmp/")
os.getcwd()
## '/tmp'


(5) 获取某路径内的文件列表(相当于shell的ls)
os.listdir("/home/wangjl/web/docs")
## ['vueJS.html',
##  'docs',
##  'PPT',
##  'outfile.pdf',
##  'pic']



(6)创建目录
#如果没有则建立文件路径
path1='pic201909';
if not os.path.exists(path1):
	os.mkdir(path1) 
#

#可以使用os.makedirs() 函数创建多级目录。
os.makedirs('pic201910/png/') 



(7) os.rename(Olddir,Newdir) 重命名
os.rename('pic201910','201910')




(8) 获取文件名和后缀名
os.path.splitext("MarkDown3.css")# [0]是文件名; [1]扩展名
# ('MarkDown3', '.css')


os.path.splitext("/home/wangjl/web/docs/MarkDown3.css")
# ('/home/wangjl/web/docs/MarkDown3', '.css')




(9)python 中使用 shutil 实现文件或目录的复制、删除、移动
https://blog.csdn.net/qq_38640439/article/details/81410116

import shutil 
# source_file:源路径, target_ir:目标路径
shutil.copy(source_file,target_ir) #复制

shutil.move(src, dst) #移动


例子:
import shutil
shutil.copy("vueJS.docx","pdf/") #把x移动到pdf/目录下。





(10)相对路径转绝对路径，绝对路径转相对路径
1)绝对路径转相对路径
print os.path.relpath("d:/MyProj/MyFile.txt")
#..\MyProj\MyFile.txt

2)相对路径转绝对路径
注意用os.chdir(dir)改变当前比较路径
path = "..\MyProj\MyFile.txt"
print os.path.abspath(path)
#D:\MyProj\MyFile.txt

用于两个目录比较时，先都转换为绝对路径，再比较路径字符串即可。







2.实例
(1). 查询文件/文件夹大小

# !/usr/bin/python3
# -*- coding: utf-8 -*-
# https://www.cnblogs.com/TTyb/p/6140867.html
import os

# 字节bytes转化kb\m\g
def formatSize(bytes):
    try:
        bytes = float(bytes)
        kb = bytes / 1024
    except:
        print("传入的字节格式不对")
        return "Error"

    if kb >= 1024:
        M = kb / 1024
        if M >= 1024:
            G = M / 1024
            return "%fG" % (G)
        else:
            return "%fM" % (M)
    else:
        return "%fkb" % (kb)


# 获取文件大小
def getDocSize(path):
    try:
        size = os.path.getsize(path)
        return formatSize(size)
    except Exception as err:
        print(err)
#


# 获取文件夹大小，递归法，返回的是bytes，需要在最终返回值做k/m/g换算
# by: Lin Yanling v0.1 2019.9.4
# v0.2 改为os.path.join
def dirSize(path):
    content = os.listdir(path)
    size = 0
    for v in content:
        if os.path.isfile('/'.join([path,v])):
            size += os.path.getsize(os.path.join(path, v)); #'/'.join([path,v])
        else:
            size += dirSize(os.path.join(path, v)) #'/'.join([path,v])
    return size
#


# 获取文件夹大小，不能嵌套文件夹//walk是什么意思？
def getFileSize(path):
    sumsize = 0
    try:
        filename = os.walk(path)
        for root, dirs, files in filename:
            for fle in files:
                size = os.path.getsize(path + fle)
                sumsize += size
        return formatSize(sumsize)
    except Exception as err:
        print(err)


if __name__ == "__main__":
    print(getDocSize("../index.py"))
    # 2.018555kb
    print(getFileSize("../data/R/")) #缺陷：不能嵌套文件夹
    # 7.980469kb
#






(2). 遍历文件并获得文件的修改时间
# -*- coding: utf-8 -*-
import os
import sys
import time

reload(sys)
sys.setdefaultencoding('utf8')

path = u"../"
for root, dir, files in os.walk(path):
    for file in files:
        full_path = os.path.join(root, file)
        #print(full_path)
        #print(file)
        mtime = os.stat(full_path).st_mtime
        file_modify_time = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(mtime))
        print("{0} 修改时间是: {1}".format(full_path,file_modify_time))
#


(3) 批量修改文件名
import os
path = ('/home/wangjl/web/docs/')
filelist = os.listdir(path)  # 该文件夹下所有的文件（包括文件夹）
for files in filelist:  #遍历所有文件
    Olddir=os.path.join(path,files) #原来的文件路径
    # 新的路径
    filename=os.path.splitext(files)[0]  #文件名
    filetype = os.path.splitext(files)[1];  #文件扩展名
    # filetype='.jpg'
    #对 filename 进行加工 #(str(name1[i])+'--计算机学院a')
    #filename="A_"+filename; #加前缀A_
    filename=re.sub("^A_",'',filename) # 去掉前缀A_
    Newdir=os.path.join(path, filename+filetype) #新的文件路径
    # 改名字
    os.rename(Olddir,Newdir) #重命名
#





========================================
11.其它杂项
----------------------------------------
数值判断可以连续使用，例如 1<a<3 能够判断变量 a 是否在1和3之间。
可以使用 del 删除变量或删除数组中的元素。

列表推导式(List Comprehension)提供了一个创建和操作列表的有力工具。列表推导式由一个表达式以及紧跟着这个表达式的for语句构成，for语句还可以跟0个或多个if或for语句，来看下面的例子：


>>> list1=[1,2,3]
>>> list2=[4,5,6]
>>> print([x*y for x in list1 for y in list2])
[4, 5, 6, 8, 10, 12, 12, 15, 18]

>>> print(x for x in list1 if 1<x<4) #不懂：生成器
<generator object <genexpr> at 0x006FC870>

>>> print([x for x in list1 if 1 < x < 4]) #需要加入[]符号
[2, 3]

# Check if an item has a specific property.
# "any" returns true if any item in the list is true.
>>> any([i % 3==0 for i in [4, 4]])
False
>>> any([i % 3==0 for i in [4, 42]])
True

# This is because 6 % 5 = 1, and 1 is true, so any()
# returns True.
>>> any([i%5==1 for i in [2,3]])
False
>>> any([i%5==1 for i in [2,6]])
True
>>> any([i%5 for i in [2,6]])
True
>>> any([i%5 for i in [2,3]]) #bug?为什么是True
True


>>> list1
[1, 2, 3]
>>> del list1[0]
>>> list1
[2, 3]
>>> del list1
>>> list1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'list1' is not defined





全局变量在函数之外声明，并且可以不需要任何特殊的声明即能读取，但如果你想要修改全局变量的值，就必须在函数开始之处用global关键字进行声明，否则Python会将此变量按照新的局部变量处理（请注意，如果不注意很容易被坑）。例如：


c=0
print('outer1',c);

def fn1():
	#不要和全局变量重名，可以直接使用全局变量；
	print('fn1 inner:',c) 
	
def fn2():
	#如果接下来定义全局变量同名变量，则此处无法提前读取全局变量，提示本地变量定义之前使用
	#UnboundLocalError: local variable 'c' referenced before assignment
	#要么不要和全局变量重名，可以直接使用全局变量,如fn1
	#要么和全局变量重名，定义完本地后再使用该变量,如fn2
	#print('fn2-1:',c) 
	c=2
	print('fn2-2:',c)

def fn10():
	global c #加了global就读写全局变量了
	c=5+4
	print('inner:', c)

fn1()
print('outer after fn1:',c);

fn2()
print('outer after fn2:',c);

fn10()
print('outer after fn10:',c);







========================================
12. py快速web服务器
----------------------------------------
$ python -m http.server --bind x.biomooc.com 8890

可以直接绑定IP和端口号，然后就可以以当前目录为web根目录，在浏览器查看文件。常规的txt、pdf可以直接在浏览器中打开。




1.在cmd中输入(Python3) python -m http.server 8888
 -此时你所在的文件路径，就是之后你访问的文件路径； 
 -8888是定义的端口名称，你可以随便改成其他你喜欢的端口。

 据说 Python2 是 Python -m SimpleHTTPServer

2.windows的IP地址可以通过 ipconfig 获得。
3. 可以用url访问了资源了，能快速局域网传输大文件了。

https://www.cnblogs.com/asis/p/6842996.html


========================================
13. 正则表达式 regExp
----------------------------------------
测试正则表达式的网站 https://regexr.com/


1.正则分割
import re 

# 从字符串中获取cellID
def getCellID(t1):
    t2=re.split(r'[.\/]', t1)
    t3=re.split(r'_Log',t2[3])
    return(t3[0])
#usage
str1="==> ../c12_A1_Log.final.out <==" 
print( getCellID(str1) ) #输出c12_A1



import re
re.split(r'[^A-Za-z]+',"book/cat/n") #['book', 'cat', 'n']




2.正则匹配，以及分割、替换
import re 
line='gene_id "ENSG00000000003.14_2"; gene_type "protein_coding"; gene_name "TSPAN6"; level 2; havana_gene "OTTHUMG00000022002.1_2"'
arr=re.split(r"; ",line) #正则分割成数组
if re.match("gene_name ",arr[2]):
	gname=arr[2]
else:
	gname=arr[3]
print(gname) #'gene_name "TSPAN6"'
gname=re.sub("gene_name ","", gname) #替换 gene_name 为空，相当于删除
gname=re.sub('"', "",gname) #去掉引号
print(gname) #TSPAN6


(2) 去掉html标签，只保留文本 
ref:https://zhuanlan.zhihu.com/p/29490804
p = re.compile('<[^>]+>')
print( p.sub("", html) ) #过滤html标签



3. 正则匹配多个，且返回位置信息
import re
a='ATGCTAGCTATCAGCTAGCTAGCTACGTAGCATCGATGCATGATCGATCGATCGTACGCATCATCGATGC'
print('1> ',re.findall('ATGC', a)) #能找到多个，但是不能返回位置

#
b=re.search('ATGC', a) #只能找到一个，有位置
print('2> ', b)

#
cs=re.finditer('ATGC',a) #找到多个，返回位置
for c in cs:
    print(c, " | ", c.span(), c.group(0) )
#
#
# 输出结果:
1>  ['ATGC', 'ATGC', 'ATGC']
2>  <_sre.SRE_Match object; span=(0, 4), match='ATGC'>
<_sre.SRE_Match object; span=(0, 4), match='ATGC'>  |  (0, 4) ATGC
<_sre.SRE_Match object; span=(35, 39), match='ATGC'>  |  (35, 39) ATGC
<_sre.SRE_Match object; span=(66, 70), match='ATGC'>  |  (66, 70) ATGC






========================================
14. 操作mysql(Ubuntu1804)
----------------------------------------
后面有封装的类。

1.安装包

(1)http://www.runoob.com/python/python-mysql.html
import MySQLdb
$ pip install MySQLdb 安装失败
## MySQL-python (1.2.5)  - Python interface to MySQL
$ pip install MySQL-python 安装失败


(2)廖雪峰推荐的
https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014320107391860b39da6901ed41a296e574ed37104752000

由于MySQL服务器以独立的进程运行，并通过网络对外服务，所以，需要支持Python的MySQL驱动来连接到MySQL服务器。
MySQL官方提供了mysql-connector-python驱动，但是安装的时候需要给pip命令加上参数--allow-external：
$ pip install mysql-connector-python --allow-external mysql-connector-python
mysql-connector-python (8.0.13) - MySQL driver written in Python
报错 no such option: --allow-external
$ pip install --user mysql-connector-python  #加--user后安装成功


如果上面的命令安装失败，可以试试另一个驱动：
$ pip install mysql-connector
mysql-connector (2.1.6)   - MySQL driver written in Python

(3)《Python3.5从零开始学》刘宇宙 中是用的
$ pip install --user  pymysql

并且提到Python DB-API规定了Python所有数据库的接口，为不同数据库提供了一致的结构，因此不同数据库之间移植代码成为一件很轻松的事情。
DB-API规范包括全局变量、异常、链接、游标和类型等基本概念。






2. DP-API

技巧：
## pymysql.connect中加上 charset='utf8' ，使用cmd黑窗口，就能得到正常中文，不乱码


实例：https://www.cnblogs.com/ddjl/p/8670545.html




(1)实例1: 查询
#!/usr/bin/python
# -*- coding: UTF-8 -*-
import pymysql

#mysql 获取数据

# 打开数据库连接
db = pymysql.connect(host='y.biomooc.com',port=7070,user='yanpd', password='789789', database='english')

# 使用cursor()方法获取操作游标 
cursor = db.cursor()

# SQL 插入语句
sql = "select * from EMPLOYEE"
# 执行sql语句
cursor.execute(sql)
values = cursor.fetchall()

print(values)

# 关闭数据库连接
db.close()
# (('Mac', 'Mohan', 20, 'M', 2000.0),)





(2)实例2：mysql事务
#!/usr/bin/python
# -*- coding: UTF-8 -*-

##事务

import mysql.connector

# 打开数据库连接
db = mysql.connector.connect(host='y.biomooc.com',port=7070,user='root', password='123', database='wang')
#("y.biomooc.com:7070", "root", "123", "wang", charset='utf8' )

# 使用cursor()方法获取操作游标 
cursor = db.cursor()

# SQL 插入语句
sql = "INSERT INTO EMPLOYEE(FIRST_NAME,LAST_NAME, AGE, SEX, INCOME) \
       VALUES ('%s', '%s', '%d', '%c', '%d' )" % \
       ('Mac', 'Mohan', 20, 'M', 2000)
try:
    # 执行sql语句
    cursor.execute(sql)
    # 提交到数据库执行
    db.commit()
    print("commit")
except:
    # 发生错误时回滚
    db.rollback()
    print("rollback")

# 关闭数据库连接
db.close()





(3)实例3
#mysql和python

#1. 导入MySQL驱动:
import mysql.connector
#2. 获取连接，注意把password设为你的root口令:
conn = mysql.connector.connect(host='y.biomooc.com',port=7070,user='root', password='123', database='wang')



#3.使用cursor()方法获取操作游标 
cursor = conn.cursor()

#4. 使用execute方法执行SQL语句
#创建user表: 
cursor.execute('create table user (id varchar(20) primary key, name varchar(20))')
#插入一行记录，注意MySQL的占位符是%s:
cursor.execute('insert into user (id, name) values (%s, %s)', ['1', 'Michael'])
cursor.rowcount
#提交事务:
conn.commit()
cursor.close()
# 执行INSERT等操作后要调用commit()提交事务；
# MySQL的SQL占位符是%s。



#5. 运行查询:
cursor = conn.cursor()
cursor.execute('select * from user where id = %s', ('1',))
values = cursor.fetchall()
values
#[('1', 'Michael')]


##6. 新建表格 EMPLOYEE
# 使用cursor()方法获取操作游标 
cursor = conn.cursor()

# 如果数据表已经存在使用 execute() 方法删除表。
cursor.execute("DROP TABLE IF EXISTS EMPLOYEE")

# 创建数据表SQL语句
sql = """CREATE TABLE EMPLOYEE (
         FIRST_NAME  CHAR(20) NOT NULL,
         LAST_NAME  CHAR(20),
         AGE INT,  
         SEX CHAR(1),
         INCOME FLOAT )"""

cursor.execute(sql)



#8. 关闭Cursor和Connection:
cursor.close()
True
conn.close()










========================================
|-- 封装的mysql操作对象 class DBUtil()
----------------------------------------
DBUtil.py 

#v1.0
#v1.1 改错，添加新方法db()

import pymysql
# 单例模式 https://blog.csdn.net/qq_32539403/article/details/83343581
# 方法很好 https://blog.csdn.net/qy20115549/article/details/82972993
# 更多方法 https://www.cnblogs.com/ddjl/p/8670545.html
class DBUtil():
    _db=None;
    #在这里配置自己的SQL服务器
    _config = {
        'host':"y.biomooc.com",
        'port':7070,
        'username':"root",
        'password':'123456',
        'database':"wang",
        'charset':"utf8"
    }
    #单例模式
    def __connect(self):
        if(self._db == None):
            try:
                self._db = pymysql.connect(
                    host = self._config['host'],
                    port = self._config['port'],
                    user = self._config['username'],
                    passwd = self._config['password'],
                    db = self._config['database'],
                    charset = self._config['charset']
                );
                self._cur=self._db.cursor();
            except Exception as e:
                print(e);
                raise BaseException("DataBase connect error,please check the db config.");
    #初始化
    def __init__(self):
        self.__connect();
    #获取数据库方法，便于转义 content=mydb.db().escape_string(xxStr);
    def db(self):
        return self._db
    #结束销毁连接
    def close(self):
        '''结束查询和关闭连接'''
        if self._cur is not None:
            self._cur.close();
        if self._db is not None:
            self._db.close();
    #创建表
    def create_table(self,sql_str):
        '''创建数据表'''
        try:
            self._cur.execute(sql_str)
        except Exception as e:
            print(e)
    #
    def query(self,sql_str):
        '''查询数据并返回 tuple
             cursor 为连接光标
             sql_str为查询语句
        '''
        try:
            self._cur.execute(sql_str)
            rows = self._cur.fetchall()
            return rows
        except:
            return False
    #
    def execute(self,sql):
        '''
        插入或更新记录 成功返回最后的id
        '''
        try:
            rs=self._cur.execute(sql) #成功了总是1
            rs= self._cur.lastrowid  # 最新插入行的主键id
            self._db.commit()
        except Exception as e:
            rs=self._db.rollback()
            print(e);
        return rs;
#



#测试实例
from DBUtil import DBUtil
#测试库

mydb=DBUtil();
#创建表
rs1=mydb.create_table("DROP TABLE IF EXISTS cell_c1"); #删除
print('rs1=', rs1)

sql = """
create table cell_c1(
id int(4) not null primary key auto_increment,
cid char(20) not null,
readCounts int);
"""
rs2=mydb.create_table(sql); #创建
print('rs2=', rs2)


#assert 0, 'should stop before insert';
#插入数据
import re,time
fr=open('data/225.cellID','r') #从文件读取

i=0
for lineR in fr.readlines():
    i+=1;
    if i>2:
        #break;
        pass;
    line=lineR.strip();
    #arr=re.split('\t', line)
    #print(line)
    #构建sql语句，并执行
    sql='insert into cell_c1(cid) values("'+line+'");'
    rs2=mydb.execute(sql)
    print(line, rs2)
fr.close()
#







========================================
|-- SQLAlchemy创建模型与表的映射(ORM, Object-Relational Mapping 对象关系映射)
----------------------------------------
ORM: 把关系数据库的表结构映射到对象

关系db:
[
    ('1', 'Michael'),
    ('2', 'Bob'),
    ('3', 'Adam')
]


对象object:
class User(object):
    def __init__(self, id, name):
        self.id = id
        self.name = name

[
    User('1', 'Michael'),
    User('2', 'Bob'),
    User('3', 'Adam')
]





1. 准备

(1)官网： https://www.sqlalchemy.org/
The Python SQL Toolkit and Object Relational Mapper

It provides a full suite of well known enterprise-level persistence patterns, designed for efficient and high-performing database access, adapted into a simple and Pythonic domain language.
提供了一套企业级的持久化模式，为高可用和高性能数据访问而设计，提供一种简单的Python风格的语言。



(2)设计哲学
The main goal of SQLAlchemy is to change the way you think about databases and SQL!
主要目标是，改变你思考和使用数据库和SQL的方式。


SQLAlchemy considers the database to be a relational algebra engine, not just a collection of tables.
更像关系代数，而不是表格的集合。

SQLAlchemy is most famous for its object-relational mapper (ORM), an optional component that provides the data mapper pattern, where classes can be mapped to the database in open ended, multiple ways - allowing the object model and database schema to develop in a cleanly decoupled way from the beginning.
因ORM出名。

类似把C盘深层次文件或文件夹拉到桌面，本质也是映射磁盘位置信息，其实也与快捷方式图标启动应用程序也有异曲同工之妙。ORM就是用面向对象的方式操作mysql数据库。



(3)架构图： http://aosabook.org/en/sqlalchemy.html
ORM:
Core: Schema/ SQL expression language/ Engine /{ Connection Pooling / Dialect}
Python  core: DBAPI
DB: database



(4)ORM作用
1）隐藏了数据访问细节，“封闭”的通用数据库交互，ORM的核心。他使得我们的通用数据库交互变得简单易行，并且完全不用考虑该死的SQL语句。快速开发，由此而来。
2）ORM使我们构造固化数据结构变得简单易行。


(5)ORM缺点
1）无可避免的，自动化意味着映射和关联管理，代价是牺牲性能
2）现在的各种ORM框架都在尝试使用各种方法来减轻这块（LazyLoad，Cache），效果还是很显著的。





2. 使用
(1)安装方法
pip install SQLAlchemy

教程:
The SQLAlchemy Reference Documentation: https://docs.sqlalchemy.org/en/13/
廖雪峰教程 https://www.liaoxuefeng.com/wiki/1016959663602400/1017803857459008
音频: https://talkpython.fm/episodes/show/5/sqlalchemy-and-data-access-in-python


(2)
提前建表
MariaDB [test]> select * from user;
+----+----------+
| id | name     |
+----+----------+
|  1 | Lilei    |
|  2 | jim      |
|  3 | Michael  |
|  4 | Bob      |
|  5 | Adam     |
|  6 | Robinson |
+----+----------+
6 rows in set (0.09 sec)



(3) DB_test1.py
# 导入:
from sqlalchemy import Column, String, create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# 创建对象的基类:
Base = declarative_base()

# 定义User对象:
class User(Base):
    # 表的名字:
    __tablename__ = 'user'

    # 表的结构:
    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    
    def __repr__(self): # 可选，仅仅为美化输出
        return "<User(id='%s', name='%s')>" % ( self.id, self.name)

# 初始化数据库连接:
#engine = create_engine('mysql+mysqlconnector://root:password@localhost:3306/test')
engine = create_engine('mysql+mysqlconnector://root:@localhost:3306/test')
# 创建DBSession类型:
DBSession = sessionmaker(bind=engine)


解释：
1)以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如School：

class School(Base):
    __tablename__ = 'school'
    id = ...
    name = ...

2)create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：

'数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名'
你只需要根据需要替换掉用户名、口令等信息即可。

## engine = create_engine("mysql+mysqldb://john:123456@127.0.0.1:3306/s15", max_overflow=5)
		max_overflow是最大连接数




3)如何从数据库表中查询数据呢？有了ORM，查询出来的可以不再是tuple，而是User对象。SQLAlchemy提供的查询接口如下：

# 创建Session:
session = DBSession()
# 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:
user = session.query(User).filter(User.id=='1').one()
# 打印类型和对象的name属性:
print('type:', type(user))
print('name:', user.name)
# 关闭Session:
session.close()

输出:
$ python DB_test1.py
type: <class '__main__.User'>
name: Lilei



4) 下面，我们看看如何向数据库表中添加一行记录。
由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个User对象：

# 创建session对象:
session = DBSession()
# 创建新User对象:
new_user = User(id='7', name='Bob02')
# 添加到session:
session.add(new_user)
# 提交即保存到数据库:
session.commit()
# 关闭session:
session.close()

可见，关键是获取session，然后把对象添加到session，最后提交并关闭。DBSession对象可视为当前数据库连接。
可见，ORM就是把数据库表的行与相应的对象建立关联，互相转换。



(5) 由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。

例如，如果一个User拥有多个Book，就可以定义一对多关系如下：

class User(Base):
    __tablename__ = 'user'

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # 一对多:
    books = relationship('Book')

class Book(Base):
    __tablename__ = 'book'

    id = Column(String(20), primary_key=True)
    name = Column(String(20))
    # “多”的一方的book表是通过外键关联到user表的:
    user_id = Column(String(20), ForeignKey('user.id'))

当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。



小结
ORM框架的作用就是把数据库表的一行记录与一个对象互相做自动转换。

正确使用ORM的前提是了解关系数据库的原理。







3. 更详细用法
https://docs.sqlalchemy.org/en/13/
分为ORM和Core两大部分:
https://docs.sqlalchemy.org/en/13/orm/tutorial.html


(1) 过滤器	说明
filter()	把过滤器添加到原查询上,返回一个新查询
filter_by()	把等值过滤器添加到原查询上,返回一个新查询
limit()	使用指定的值限制原查询返回的结果数量,返回一个新查询
offset()	偏移原查询返回的结果,返回一个新查询
order_by()	根据指定条件对原查询结果进行排序,返回一个新查询
group_by()	根据指定条件对原查询结果进行分组,返回一个新查询


(2)在查询上应用指定的过滤器后,通过调用 all() 执行查询,以列表的形式返回结果。除了 all() 之外,还有其他方法能触发查询执行。

常用查询执行函数
方法	说明
all()	以列表形式返回查询的所有结果
first()	返回查询的第一个结果,如果没有结果,则返回 None
first_or_404()	返回查询的第一个结果,如果没有结果,则终止请求,返回 404 错误响应
get()	返回指定主键对应的行,如果没有对应的行,则返回 None
get_or_404()	返回指定主键对应的行,如果没找到指定的主键,则终止请求,返回 404 错误响应
count()	返回查询结果的数量
paginate()	返回一个 Paginate 对象,它包含指定范围内的结果



session.query.filter(User.name == 'ed')
session.query(User).filter(User.name != ‘tom’)# 不等判断


session.query(User).filter(User.name.like('%tom%'))
session.query.filter(User.name.ilike('%ed%')) # (case-insensitive LIKE)



## 范围条件——in / not in
# IN
session.query.filter(User.name.in_(['ed', 'wendy', 'jack']))
session.query(User).filter(User.id.in_([1,2,3,4]))

session.query(User).filter(User.name.in_([
     session.query(User.name).filter(User.id.in_[1,2,3,4])
]))

# NOT IN
session.query(User).filter(~User.id.in_([1,2,3]))





# 指定排序查询
user_list = session.query(User).order_by(User.id) # 默认顺序
user_list = session.query(User).order_by(-User.id) # 指定倒序
user_list = session.query(User).order_by(-User.id, User.name) # 多个字段



from sqlalchemy import text
for user in session.query(User).\
        filter(text("id<4")).\
        order_by(text("id")).all():
    print(user.name)
#
# 结果
# Lilei
# jim
# Michael



# 指定列查询
user_list = session.query(User, User.name).all()
for u in user_list:
    print(u.id, u.name)

# 切片查询
user_list = session.query(User).all()[1:3]


# 指定列属性别名
对于名称较长的字段属性，可以指定名称在使用时简化操作
user_list = session.query(Usre.name.label(‘n’)).all()

for user in user_list:
    print(user.n)
#



## 指定类型别名
对于类型名称较长的情况，同样可以指定别名进行处理
from sqlalchemy.orm import aliased

user_alias = aliased(User, name=’u_alias’)
user_list = session.query(u_alias, u_alias.name).all()
for u in user_list:
    print(u.u_alias, u.name)
#



## 空值条件——is null / is not null

# IS NULL
session.query(User).filter(User.name == None)
session.query(User).filter(User.name.is_(None)) # pep8

# IS NOT NULL
session.query(User).filter(User.name != None)
session.query(User).filter(User.name.isnot(None)) # pep8


## 并且条件——AND
from sqlalchemy import and_

session.query(User).filter(User.name=’tom’).filter(User.age=12)
session.query(User).filter(User.name=’tom’, User.age=12)
session.query(User).filter(and_(User.name=’tom’, User.age=12))



## 或者条件——OR

from sqlalchemy import or_
session.query(User).filter(or_(User.name=’tom’, User.name=’jerry’))










(2) 直接使用sql语句
## SQL语句查询
某些特殊情况下，我们也可能在自己的程序中直接使用sql语句进行操作

# exaple 1
from sqlalchemy import text
session.query(User).from_statement(
	text('select * from users where name=:name and age=:age')).params(name=’tom’, age=12).all()



# exaple 2
from sqlalchemy import text
users=session.query(User).from_statement(
                     text("SELECT * FROM user where name=:name")).\
                     params(name='Jim').all()
print(users)
##
# 输出 [<User(id='2', name='jim')>]



(3) 查询结果
1) all()函数返回查询列表
session.query(User).all()
[..]

2) filter()函数返回单项数据的列表生成器
session.query(User).filter(..)
<..>

3) one()/one_or_none()/scalar()返回单独的一个数据对象
session.query(User).filter(..).one()/one_or_none()/scalar()
..

usr_info = session.query(user).filter_by(age=12).first()


ref:
https://www.jianshu.com/p/7d4b9f2e32a7
https://www.jianshu.com/p/ce885bf16b99

mysql 与python: https://www.jianshu.com/p/874b100bec69





========================================
|-- Sqlalchemy 实例(中文乱码解决方法)
----------------------------------------
实例2
Sqlalchemy 中文乱码解决方法 https://blog.csdn.net/u014291956/article/details/78771594
中文乱码了，查看一下数据表示什么编码的: show create table xxTable;


################### 1. get engine
from sqlalchemy import create_engine

# https://www.jianshu.com/p/47c1c2618812
from sqlalchemy.ext.declarative import declarative_base 
from sqlalchemy import Column, Integer, String ,DateTime, Boolean

# 连接数据库
#engine = create_engine('mysql://root:password@localhost:3306/test?charset=utf8')
engine = create_engine('mysql+pymysql://root:@localhost:3306/test?charset=utf8') #加这一句，防止中文乱码1/2


## 编码问题
## 获取基类
BaseModel = declarative_base()

class News(BaseModel): # 继承基类
    __tablename__ = 'students1'
    id = Column(Integer, primary_key = True)
    nickname = Column(String(20))
    name = Column(String(20), nullable = False)
    sex = Column(String(10))
    in_time = Column(DateTime)
    is_vaild = Column(Boolean)
    idcard = Column(Integer, unique = True)
	
	#id = Column(Integer, primary_key = True, autoincrement=True)
    #name = Column(String(250),nullable=False,unique = True,comment=u"姓名")
    
    __table_args__ = {
        "mysql_charset": "utf8" #加这一句，防止中文乱码2/2 
    }
#


News.metadata.create_all(engine)   # 创建表格
#向数据库发出CREATE TABLE命令，由此数据库新建名为users的表
#调用时会检查已经存在的表结构，因此可重复调用


################### 2. get session
## 新增数据
from sqlalchemy.orm import sessionmaker
Session = sessionmaker(bind=engine)

class OrmTest(object):
    def __init__(self):
        self.session = Session()

    def add_one(self):
        new_obj = News(
            nickname = '123',
            name = '321',
            sex = '男',
        )
        self.session.add(new_obj)
        self.session.commit()
        return new_obj

    def add_more(self):
        new_obj = News(
            nickname = '123',
            name = '321',
            sex = '男',
        )
        new_obj2 = News(
            nickname = 'wei',
            name = 'lai',
            sex = '女',
        )
        self.session.add_all([new_obj, new_obj2])
        self.session.commit()
        return new_obj

    ## 查询数据        
    def get_one(self, n=1):
        return self.session.query(News).get(n)  # get 是选id为2的

    def get_more(self):
        #return self.session.query(News).filter_by(is_vaild=True)
        return self.session.query(News).filter_by(is_vaild=0)


    ## 修改数据
    ## 将一条当作多条的一种情况
    def update_data(self):
        data_list = self.session.query(News).filter(News.id >= 5)
        for item in data_list:
            if item:
                item.is_vaild = 0
                self.session.add(item)  # 加入
        self.session.commit()  # 提交
    ## filter 与 filter_by 的区别


    ## 删除数据
    def delete_data(self, n=6):
        data = self.session.query(News).get(n)
        if data:
            self.session.delete(data)
            self.session.commit()
        else:
            return False

    def delete_data_more(self, n=5):
        delete_list = self.session.query(News).filter(News.id <= n)
        for item in delete_list:
            if item:
                self.session.delete(item)       
            else:
                return False
        self.session.commit() 


#######
def selLine(model, n=1, more=False): 
    # 2. get one line
    if not more:
        man = model.get_one(n) 
        ## 防止查询失误
        if man:  
            print('ID:{0}, {1} {2}'.format(man.id, man.nickname ,man.sex))
        else:
            print('Not exist')
    
    # get more data
    else:
        data_more = model.get_more()
        print('count =', data_more.count())  # 计数
        for new_obj in data_more:
            print('ID:{0}  {1} {2} {3}'.format(new_obj.id,new_obj.sex,new_obj.name,new_obj.nickname))



    

#增删改查
if __name__ == '__main__':
    model = OrmTest() #0. 创建模型
    #
    # 1. 添加数据, 反复执行，多添加十几条的。
    #model.add_one() #添加一行
    #model.add_more() #添加多行

    # 4. 删除
    #model.delete_data(); print('数据删除成功')
    model.delete_data_more()
    
    # 3. 改
    #model.update_data(); print('数据修改成功')
    
    #selLine(model,n=19);
    selLine(model,more=True);
##














========================================
15. 多进程
----------------------------------------
Python2 中常用的几个并发工具：http://mingxinglai.com/cn/2016/09/python-concurrent/



例：启动2个子进程，并打印子进程和父进程的id。
#!/usr/bin/python3
# -*- coding: utf-8 -*-

from multiprocessing import Process
import os

# 子进程要执行的代码
def run_proc(name):
    print('Run child process %s (%s)...' % (name, os.getpid()))

if __name__=='__main__':
    print('Parent process %s.' % os.getpid())
    # 1.传入一个执行函数和函数的参数
    p = Process(target=run_proc, args=('test1',)) #multiprocessing模块提供了一个Process类来代表一个进程对象
    p2=Process(target=run_proc, args=('test2',)) #注意括号内要有一个逗号
    print('------Child process will start.')
    p.start() #2.用start()方法启动子进程
    p2.start();
    p.join() #3.join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。
    p2.join();
    print('------Child process end.')

print('I am always here:pid =',os.getpid())
print('I am always here:ppid =',os.getppid())

"""
Parent process 11824.
------Child process will start.
I am always here:pid = 17380
I am always here:ppid = 11824
Run child process test1 (17380)...
I am always here:pid = 6204
I am always here:ppid = 11824
Run child process test2 (6204)...
------Child process end.
I am always here:pid = 11824
I am always here:ppid = 24272
[Finished in 0.4s]
"""




2. Python 进程池在面向对象过程中，进程池无法调用实例方法

例1：bad:  https://www.v2ex.com/t/453232
import time
from multiprocessing.pool import Pool

class Test:
    def __init__(self):
        self.pool = Pool(5)

    def func(self):
        time.sleep(0.2)
        print("1")

    def run(self):
        for i in range(10):
            self.pool.apply_async(self.func)  # 这里的 func 为什么不能进入执行？

        time.sleep(3)
        self.pool.close()
        self.pool.join()

if __name__ == '__main__':
    t = Test()
    t.run()
#
####
# 改进后可以正常运行了：#进程池Pool不能放到self上，否则无法进入要并发运行的函数
import time
#from multiprocessing.pool import Pool #这个Pool也行
from multiprocessing import Pool #这个Pool也行
#import multiprocessing

class Test():
    def __init__(self):
        #self.pool = multiprocessing.Pool(5) #进程池不能放到self上，否则无法进入要并发运行的函数
        pass
    def func(self, n):
        time.sleep(0.2)
        print(">>", n)

    def run(self):
        #pool=multiprocessing.Pool(5)
        pool=Pool(5)
        for i in range(10):
            pool.apply_async(self.func, args=(i,))  # 这里的 func 为什么不能进入执行？
        #time.sleep(3)
        pool.close()
        pool.join()
    def runIt(self):
        self.run();

if __name__ == '__main__':
    t = Test()
    t.runIt()
    print('end')

###







例2： ok(https://ask.csdn.net/questions/702827?sort=comments_count)
import multiprocessing
import time

class Test(object):
    def fun(self,n):
        time.sleep(0.2)
        print('----', n) #可以打印

    def run(self):
        p = multiprocessing.Pool(4)
        for i in range(4):
            p.apply_async(self.fun, args=(i,))
        p.close()
        p.join()
        print('end')

if __name__ == '__main__':
    a = Test()
    a.run()
#





3. Python3之无法在进程池中使用队列Queue的解决方案
https://blog.csdn.net/qq_33733970/article/details/77832685
https://blog.csdn.net/zbrj12345/article/details/79766895

self.queue=multiprocessing.Manager().Queue();







========================================
|-- 多进程实例1:并行统计多个bam文件的行数
----------------------------------------
################
# on linux only.
################ 
## 任务：从文件读取一行cell id，作为参数传给处理进程们。
## 一个进程写数据，一个进程池 众多线程读和处理数据。
## 读、写进程之间用queue通信。

#遇到过的问题：
#Q: 为什么不能在子进程中完整保存呢？ A: 因为没有flush文件。
#Q: 为什么把main中的包装成函数，就阻塞了？ A: 没解决 todo
#v0.3 新增日志时间戳


################################
#part 1 定义路径
################################
import os
os.chdir('/home/wangjl/data/apa/190528L/') #定义工作目录，仅对python有效。对linux命令建议都使用绝对路径。
os.getcwd()

################################
#part 2 定义linux命令
################################
import subprocess

#目的：需要平行处理的linux命令。if the function can run on one id, it can run on the batch of ids.
#要点： 使用id拼接linux命令。建议都用绝对路径。
def doLinuxCMD(id):
    #构建命令
    cmd="samtools view /home/wangjl/data/apa/190528L/hg19/"+id+"_Aligned.sortedByCoord.out.bam|wc"
    #执行linux命令
    (status, output)=subprocess.getstatusoutput(cmd)
    #print(output) #查看linux命令输出到屏幕上的文字
    rs=str(status)+" "+output;
    return rs #返回状态码status，0表示命令正常执行，其他表示异常，需要查看output推测具体原因
#test
#doLinuxCMD('c01_ROW07') #3929403 58941045 1511774483


################################
#part 3 并行执行
################################
import time,multiprocessing,os,re #random
from multiprocessing import Queue
from multiprocessing import Process

#=====================
#settings
id_list="/home/wangjl/data/apa/190515/syncHeLa_13.id"
#输入文件名关键词列表，一个id一行，用于在doLinuxCMD命令中构建linux命令。表示本脚本要多线程处理这么多文件。
#一下采用默认值即可
core=13 #使用的CPU逻辑核心数。该数字 x linux命令使用的线程数 要小于硬件CPU逻辑核心数
hint_n=5 #默认给出20个进度提示
log_file_name='logs.txt' #uniq-count-FROM-star.final.207.log
#输出日志的文件名，内容是： id号 运行状态(0表示正常，否则表示异常) 
#=====================
##这个文件名要加上时间戳，防止忘了修改日志文件名而被覆盖掉
timsString=time.strftime("%Y%m%d-%H%M%S", time.localtime()) 
log_file_name=log_file_name + timsString


#读和处理数据，并行
def worker(cb):
    #一个很耗时的计算
    rs=cb+"\t"+str( doLinuxCMD(cb) ) #part2 中定义的
    q.put(rs)   #结果输出到管道

#保存的线程1个
def writer(log_file_name,ID_total,hint_n=20):
    breaks=int(ID_total/hint_n) #显示20次进度提示
    i=0
    with open(log_file_name, 'w') as f: #这里不能是变量名？
        while True:
            i+=1
            if i%breaks==0: #进度条
                print(i," items processed in ", time.time()-start," seconds",sep="")
            rs=q.get() #waite while q is empty
            f.write(rs+"\n") #写入文件
            f.flush() #刷新缓存，一次性输出到文件


#start time
start=time.time()
print('='*10, ">Begin of main process[", os.getpid(), "][child pid by parent ppid]", sep="")

# 主进程
if __name__ == '__main__': 
    q=Queue(core+10) #创建队列
    pool = multiprocessing.Pool(processes = core)# 声明进程池对象

    # 向进程池中提交任务，交给并行的worker()来处理
    fr=open(id_list,'r')#读取id_list文件，分配任务给进程
    i=0
    for lineR in fr.readlines():
        i+=1
        #if i>100:
        #    pass;
            #break; #测试用语句

        line=lineR.strip()
        arr=re.split(' ',line) ##print("start new process", line) #任务是一次发送完的
        pool.apply_async( worker,args=(arr[0],) )
    fr.close() #关闭文件

    #分完任务，开始启动保存进程，由writer()函数来处理
    pOut = Process(target=writer, args=(log_file_name,i,hint_n,)) # args：元组参数，如果参数就一个，记得加逗号’，’
    pOut.start()

    #等待读进程worker()全部结束
    pool.close()
    pool.join()

    #主线程查看队列，决定是否关掉写writer()循环
    ##todo 这里有风险，会不会执行不完就被关掉了呢？虽然目前还没有遇到过
    while not q.empty():
        time.sleep(1)#每一秒检查一次队列是否为空
    pOut.terminate(); #终止死循环

print(time.time()-start,'s <', '='*10, "End of main process[", os.getpid(),']', sep="")
print("#"*40,"\nLog file: "+ os.getcwd()+"/"+log_file_name)




========================================
|-- 多进程实例2: OOP版并行运行Linux命令 ParallelMe.py
----------------------------------------
第1小结是该类的定义。具体使用方法，请参考本文第2小结。


使用方法简单，只需要import引用，定义好
1)单个id可运行的自定义函数，返回需要的结果，或者直接函数内部做IO，返回空字符串或者返回id；建议用绝对路径;
2)id列表文件
3)定义好输出日志，里面记录着id和自定义函数的返回值。

难点：自定义函数的定义。
易错点：自定义函数是否需要临时文件夹？如果需要，还需要继续编码解决该问题，否则还会混乱。



1. 自定义类 ParallelMe.py

# define a class: ParallelMe[Run on Linux only!]
# version: 0.2.1
import subprocess
import time,multiprocessing,os,re,random,datetime

class ParallelMe(object):    
    #初始化属性
    def __init__(self, doLinuxCMD_fn, id_list_file, core=3, hint_n=5,log_file_name='logs.txt',uniqLogName=False):
        """
        待批量处理的函数 doLinuxCMD_fn 仅仅依赖一个id，然后id的list在文件 id_list_file 中提供。
        if hint_n定义几次，就出几次进度提示，默认提示5次,最小是1次;
        uniqLogName==True时，会对log文件加时间戳后缀，默认不加时间戳;
        """
        # 必选值
        self.doLinuxCMD=doLinuxCMD_fn
        self.id_list_file=id_list_file
        #默认值
        self.core=core #使用的CPU逻辑核心数。该数字 x linux命令使用的线程数 要小于硬件CPU逻辑核心数
        self.hint_n=hint_n;
        self.log_file_name=log_file_name; #输出日志的文件名，内容是： id号 运行状态(0表示正常，否则表示异常) 
        #需要处理
        #self.uniqLogName=uniqLogName;#这个文件名要加上时间戳，防止忘了修改日志文件名而被覆盖掉
        if uniqLogName:
            timsString=time.strftime("%Y%m%d-%H%M%S", time.localtime()) 
            self.log_file_name=log_file_name + timsString
        #
        #self.q=Queue(core+5) #创建队列
        self.queue=multiprocessing.Manager().Queue(core+5);
    
    #定义worker: 读和处理数据，并行
    def worker(self, cb):
        #print("worker===> ",cb, os.getpid() );
        #一个很耗时的计算
        rs=str(cb)+"\t"+str( self.doLinuxCMD(cb) ) #part2 中定义的
        self.queue.put(rs)   #结果输出到管道
    
    #保存的线程1个
    def writer(self,log_file_name,ID_total,hint_n=10):
        hit_n=int(hint_n);
        if hint_n<1:
            hint_n=1;
        breaks=int(ID_total/hint_n) #显示hint_n次进度提示
        i=0
        with open(log_file_name, 'w') as f: #这里不能是变量名？
            while True:
                if i%breaks==0 or i==ID_total: #进度条
                    print(i," items processed in ", round(time.time()-self.start, 2)," seconds",sep="")
                # 如果所有条目都保存过了，则退出死循环                
                if(i==ID_total):
                    break;
                i+=1
                rs=self.queue.get() #waite while queue is empty
                f.write(rs+"\n") #写入文件
                f.flush() #刷新缓存，一次性输出到文件
    
    #主进程: 向进程池中提交任务，交给并行的worker()来处理
    def main(self):
        #1. 声明进程池对象
        pool=multiprocessing.Pool(self.core)
        #2. 读取id_list_file文件，分配任务给进程
        fr=open(self.id_list_file,'r')
        lines=fr.readlines();
        ID_total=len(lines);
        for lineR in lines:
            line=lineR.strip()
            arr=re.split(' ',line) ##print("start new process", line) #任务是一次发送完的
            pool.apply_async( self.worker, args=(arr[0],) )
        fr.close() #关闭文件

        #3. 分完任务，开始启动保存进程，由writer()函数来处理
        pOut = multiprocessing.Process(target=self.writer, args=(self.log_file_name,ID_total,self.hint_n,)) # args：元组参数，如果参数就一个，记得加逗号’，’
        pOut.start()

        #4. 等待读进程worker()全部结束
        pool.close()
        pool.join()
        #5. 等待写循环结束
        pOut.join()
    
    #运行
    def run(self):
        #输出运行参数
        self.start=time.time();#启动时的时间
        print("function name:", self.doLinuxCMD);
        print("id list file:", self.id_list_file);
        print('CPU core number:', self.core);
        print('hint number:', self.hint_n);
        print('log_file_name:', self.log_file_name);
        #
        print("#"*40,'\n',datetime.datetime.now(),"\n","#"*40, sep="")
        print('='*10, ">Begin of main process[", os.getpid(), "][child pid by parent ppid]", sep="")
        self.main(); #开启多进程
        print(time.time()-self.start,'s <', '='*10, "End of main process[", os.getpid(),']', sep="")
        print("#"*40,"\nLog file: "+ os.getcwd()+"/"+self.log_file_name,"\n","#"*40, sep="")
# end of class





2. 测试 demo.py
(1) 其他目录，需要添加工作目录，再引入包。
import sys
sys.path.append("/home/wangjl/test/")
from ParallelMe import ParallelMe

#do sth;




(2)当前文件夹内就可以直接引入包
from ParallelMe import ParallelMe
################################
#使用三部曲
################################
import os,subprocess,random

##part 1 定义路径
print('Step1> define path: ',os.getcwd())
os.chdir('/home/wangjl/test') #定义工作目录，仅对python有效。对linux命令建议都使用绝对路径。


#part 2 定义linux命令，返回字符串，会被记录到日志文件中。
print("Step2> define the function to be run parallelly: doLinuxCMD(id)")
#目的：需要平行处理的linux命令。if the function can run on one id, it can run on a list of ids.
#要点： 使用id拼接linux命令。建议都用绝对路径。
def doLinuxCMD(id):
    #构建命令，很复杂的linux命令
    cmd="sleep "+str(random.randint(0,4)); #这个linux命令为休眠一段时间。可以是linux脚本，有输入和输出，建议用绝对路径。
    #执行linux命令
    (status, output)=subprocess.getstatusoutput(cmd)
    #print(output) #查看linux命令输出到屏幕上的文字
    rs=str(status)+"\t"+output# +"\t"+str(os.getpid())+"\t"+str(os.getppid());
    return rs #返回状态码status，0表示命令正常执行，其他表示异常，需要查看output推测具体原因
#test
#doLinuxCMD(1) #status output pid ppid


#part 3 批量运行该linux命令
print("Step3> run the function parallelly");
#doLinuxCMD为函数，要有str返回值
#id_list为id列表文本文件名，一个id一行。建议用绝对路径
#core为并行个数(默认是3)，要小于CPU个数，但是超过id总个数也没有意义;
id_list="/home/wangjl/test/a.txt"
myTasks=ParallelMe(doLinuxCMD, id_list, core=55);
myTasks.run()







3. 运行和输出结果
id list就是一行一个id号即可
$ head /home/wangjl/test/a.txt
1
2
3
或者字符串。


$ python demo.py
Step1> define path:  /home/wangjl/test
Step2> define the function to be run parallelly: doLinuxCMD(id)
Step3> run the function parallelly
function name: <function doLinuxCMD at 0x7ffb11f8b1e0>
id list file: /home/wangjl/test/a.txt
CPU core number: 55
hint number: 5
log_file_name: logs.txt
########################################
2019-09-14 13:14:29.823499
########################################
==========>Begin of main process[381837][child pid by parent ppid]
0 items processed in 0.12 seconds
10 items processed in 1.09 seconds
20 items processed in 2.09 seconds
30 items processed in 2.12 seconds
40 items processed in 3.11 seconds
50 items processed in 4.13 seconds
4.265288829803467s <==========End of main process[381837]
########################################
Log file: /home/wangjl/test/logs.txt
########################################







========================================
16.subprocess: python调用shell命令，并获取返回值
----------------------------------------
https://www.cnblogs.com/huangxm/p/5313560.html


1.是调用的shell命令运行结束后才继续下一步的py语句
# coding: UTF-8
import sys,os,time
import subprocess

cmd = 'sleep 2'#"ls" #在shell中睡2秒

#如下两种都可以运行
#rs1=subprocess.Popen(cmd, shell=True)
print("begin call shell: ")
start = time.time()
rs2=subprocess.call(cmd,shell=True)

#print('rs1=', rs1)
print('rs2=', rs2)
print("==end",time.time()-start)






2.python怎么接收shell的返回数据？
import subprocess,re

(status, output)=subprocess.getstatusoutput('ls') #能拿到shell的返回值:status是0表示正常执行,output是返回的字符串
print('status = ', status)

#分割字符串为文件名
arr=re.split("\n", output)
print("len=", len(arr))
arr










========================================
17. 识别运行环境，设置不同的变量值
----------------------------------------
1.

# v1.0
import re,time
import sys
env=sys.platform #"win32"测试环境;  "linux"生产环境
print('env=',env)

if env=='linux':
    sys.path.append("/home/wangjl/pylib/")
    fname='/home/wangjl/data/ref/hg19/gencode.v30lift37.annotation.GENE.gtf'
elif env=='win32':
    sys.path.append('..')
    fname='../data/hg19.gtf'

#




========================================
小结
----------------------------------------

本教程并未涵盖Python语言的全部内容(甚至连一小部分都称不上)。Python有非常多的库以及很多的功能特点需要学习，所以要想学好Python你必须在此教程之外通过其它方式，例如阅读Dive into Python。我希望这个教程能给你一个很好的入门指导。如果你觉得本文还有什么地方值得改进或添加，或是你希望能够了解Python的哪方面内容，请留言。

本教程适合作一个简短的电子书。电子书后续额外提供的各种Python最佳实践都在一本独立的电子书里，感兴趣的同学可以到 https://leanpub.com/learn-python 购买。购买后可以免费获取更新。








========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------


========================================
----------------------------------------
